
C:\Atollic Projects\3dLaserEngraver\grbl\Debug\grbl.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000d32c  080000c0  080000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000b68  0800d3ec  0800d3ec  0001d3ec  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0800df54  0800df54  0001df54  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  0800df58  0800df58  0001df58  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         0000007c  20000000  0800df5c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000ae4  2000007c  0800dfd8  0002007c  2**2
                  ALLOC
  7 ._user_heap_stack 00000080  20000b60  0800dfd8  00020b60  2**0
                  ALLOC
  8 .ARM.attributes 00000028  00000000  00000000  0002007c  2**0
                  CONTENTS, READONLY
  9 .debug_info   0000c2f5  00000000  00000000  000200a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 000027eb  00000000  00000000  0002c399  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000e90  00000000  00000000  0002eb88  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000d40  00000000  00000000  0002fa18  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00005d76  00000000  00000000  00030758  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00004014  00000000  00000000  000364ce  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .comment      0000007e  00000000  00000000  0003a4e2  2**0
                  CONTENTS, READONLY
 16 .debug_frame  000038f8  00000000  00000000  0003a560  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	2000007c 	.word	0x2000007c
 80000e0:	00000000 	.word	0x00000000
 80000e4:	0800d3d4 	.word	0x0800d3d4

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	20000080 	.word	0x20000080
 8000104:	0800d3d4 	.word	0x0800d3d4

08000108 <__gnu_thumb1_case_uqi>:
 8000108:	b402      	push	{r1}
 800010a:	4671      	mov	r1, lr
 800010c:	0849      	lsrs	r1, r1, #1
 800010e:	0049      	lsls	r1, r1, #1
 8000110:	5c09      	ldrb	r1, [r1, r0]
 8000112:	0049      	lsls	r1, r1, #1
 8000114:	448e      	add	lr, r1
 8000116:	bc02      	pop	{r1}
 8000118:	4770      	bx	lr
 800011a:	46c0      	nop			; (mov r8, r8)

0800011c <__aeabi_uidiv>:
 800011c:	2200      	movs	r2, #0
 800011e:	0843      	lsrs	r3, r0, #1
 8000120:	428b      	cmp	r3, r1
 8000122:	d374      	bcc.n	800020e <__aeabi_uidiv+0xf2>
 8000124:	0903      	lsrs	r3, r0, #4
 8000126:	428b      	cmp	r3, r1
 8000128:	d35f      	bcc.n	80001ea <__aeabi_uidiv+0xce>
 800012a:	0a03      	lsrs	r3, r0, #8
 800012c:	428b      	cmp	r3, r1
 800012e:	d344      	bcc.n	80001ba <__aeabi_uidiv+0x9e>
 8000130:	0b03      	lsrs	r3, r0, #12
 8000132:	428b      	cmp	r3, r1
 8000134:	d328      	bcc.n	8000188 <__aeabi_uidiv+0x6c>
 8000136:	0c03      	lsrs	r3, r0, #16
 8000138:	428b      	cmp	r3, r1
 800013a:	d30d      	bcc.n	8000158 <__aeabi_uidiv+0x3c>
 800013c:	22ff      	movs	r2, #255	; 0xff
 800013e:	0209      	lsls	r1, r1, #8
 8000140:	ba12      	rev	r2, r2
 8000142:	0c03      	lsrs	r3, r0, #16
 8000144:	428b      	cmp	r3, r1
 8000146:	d302      	bcc.n	800014e <__aeabi_uidiv+0x32>
 8000148:	1212      	asrs	r2, r2, #8
 800014a:	0209      	lsls	r1, r1, #8
 800014c:	d065      	beq.n	800021a <__aeabi_uidiv+0xfe>
 800014e:	0b03      	lsrs	r3, r0, #12
 8000150:	428b      	cmp	r3, r1
 8000152:	d319      	bcc.n	8000188 <__aeabi_uidiv+0x6c>
 8000154:	e000      	b.n	8000158 <__aeabi_uidiv+0x3c>
 8000156:	0a09      	lsrs	r1, r1, #8
 8000158:	0bc3      	lsrs	r3, r0, #15
 800015a:	428b      	cmp	r3, r1
 800015c:	d301      	bcc.n	8000162 <__aeabi_uidiv+0x46>
 800015e:	03cb      	lsls	r3, r1, #15
 8000160:	1ac0      	subs	r0, r0, r3
 8000162:	4152      	adcs	r2, r2
 8000164:	0b83      	lsrs	r3, r0, #14
 8000166:	428b      	cmp	r3, r1
 8000168:	d301      	bcc.n	800016e <__aeabi_uidiv+0x52>
 800016a:	038b      	lsls	r3, r1, #14
 800016c:	1ac0      	subs	r0, r0, r3
 800016e:	4152      	adcs	r2, r2
 8000170:	0b43      	lsrs	r3, r0, #13
 8000172:	428b      	cmp	r3, r1
 8000174:	d301      	bcc.n	800017a <__aeabi_uidiv+0x5e>
 8000176:	034b      	lsls	r3, r1, #13
 8000178:	1ac0      	subs	r0, r0, r3
 800017a:	4152      	adcs	r2, r2
 800017c:	0b03      	lsrs	r3, r0, #12
 800017e:	428b      	cmp	r3, r1
 8000180:	d301      	bcc.n	8000186 <__aeabi_uidiv+0x6a>
 8000182:	030b      	lsls	r3, r1, #12
 8000184:	1ac0      	subs	r0, r0, r3
 8000186:	4152      	adcs	r2, r2
 8000188:	0ac3      	lsrs	r3, r0, #11
 800018a:	428b      	cmp	r3, r1
 800018c:	d301      	bcc.n	8000192 <__aeabi_uidiv+0x76>
 800018e:	02cb      	lsls	r3, r1, #11
 8000190:	1ac0      	subs	r0, r0, r3
 8000192:	4152      	adcs	r2, r2
 8000194:	0a83      	lsrs	r3, r0, #10
 8000196:	428b      	cmp	r3, r1
 8000198:	d301      	bcc.n	800019e <__aeabi_uidiv+0x82>
 800019a:	028b      	lsls	r3, r1, #10
 800019c:	1ac0      	subs	r0, r0, r3
 800019e:	4152      	adcs	r2, r2
 80001a0:	0a43      	lsrs	r3, r0, #9
 80001a2:	428b      	cmp	r3, r1
 80001a4:	d301      	bcc.n	80001aa <__aeabi_uidiv+0x8e>
 80001a6:	024b      	lsls	r3, r1, #9
 80001a8:	1ac0      	subs	r0, r0, r3
 80001aa:	4152      	adcs	r2, r2
 80001ac:	0a03      	lsrs	r3, r0, #8
 80001ae:	428b      	cmp	r3, r1
 80001b0:	d301      	bcc.n	80001b6 <__aeabi_uidiv+0x9a>
 80001b2:	020b      	lsls	r3, r1, #8
 80001b4:	1ac0      	subs	r0, r0, r3
 80001b6:	4152      	adcs	r2, r2
 80001b8:	d2cd      	bcs.n	8000156 <__aeabi_uidiv+0x3a>
 80001ba:	09c3      	lsrs	r3, r0, #7
 80001bc:	428b      	cmp	r3, r1
 80001be:	d301      	bcc.n	80001c4 <__aeabi_uidiv+0xa8>
 80001c0:	01cb      	lsls	r3, r1, #7
 80001c2:	1ac0      	subs	r0, r0, r3
 80001c4:	4152      	adcs	r2, r2
 80001c6:	0983      	lsrs	r3, r0, #6
 80001c8:	428b      	cmp	r3, r1
 80001ca:	d301      	bcc.n	80001d0 <__aeabi_uidiv+0xb4>
 80001cc:	018b      	lsls	r3, r1, #6
 80001ce:	1ac0      	subs	r0, r0, r3
 80001d0:	4152      	adcs	r2, r2
 80001d2:	0943      	lsrs	r3, r0, #5
 80001d4:	428b      	cmp	r3, r1
 80001d6:	d301      	bcc.n	80001dc <__aeabi_uidiv+0xc0>
 80001d8:	014b      	lsls	r3, r1, #5
 80001da:	1ac0      	subs	r0, r0, r3
 80001dc:	4152      	adcs	r2, r2
 80001de:	0903      	lsrs	r3, r0, #4
 80001e0:	428b      	cmp	r3, r1
 80001e2:	d301      	bcc.n	80001e8 <__aeabi_uidiv+0xcc>
 80001e4:	010b      	lsls	r3, r1, #4
 80001e6:	1ac0      	subs	r0, r0, r3
 80001e8:	4152      	adcs	r2, r2
 80001ea:	08c3      	lsrs	r3, r0, #3
 80001ec:	428b      	cmp	r3, r1
 80001ee:	d301      	bcc.n	80001f4 <__aeabi_uidiv+0xd8>
 80001f0:	00cb      	lsls	r3, r1, #3
 80001f2:	1ac0      	subs	r0, r0, r3
 80001f4:	4152      	adcs	r2, r2
 80001f6:	0883      	lsrs	r3, r0, #2
 80001f8:	428b      	cmp	r3, r1
 80001fa:	d301      	bcc.n	8000200 <__aeabi_uidiv+0xe4>
 80001fc:	008b      	lsls	r3, r1, #2
 80001fe:	1ac0      	subs	r0, r0, r3
 8000200:	4152      	adcs	r2, r2
 8000202:	0843      	lsrs	r3, r0, #1
 8000204:	428b      	cmp	r3, r1
 8000206:	d301      	bcc.n	800020c <__aeabi_uidiv+0xf0>
 8000208:	004b      	lsls	r3, r1, #1
 800020a:	1ac0      	subs	r0, r0, r3
 800020c:	4152      	adcs	r2, r2
 800020e:	1a41      	subs	r1, r0, r1
 8000210:	d200      	bcs.n	8000214 <__aeabi_uidiv+0xf8>
 8000212:	4601      	mov	r1, r0
 8000214:	4152      	adcs	r2, r2
 8000216:	4610      	mov	r0, r2
 8000218:	4770      	bx	lr
 800021a:	e7ff      	b.n	800021c <__aeabi_uidiv+0x100>
 800021c:	b501      	push	{r0, lr}
 800021e:	2000      	movs	r0, #0
 8000220:	f000 f806 	bl	8000230 <__aeabi_idiv0>
 8000224:	bd02      	pop	{r1, pc}
 8000226:	46c0      	nop			; (mov r8, r8)

08000228 <__aeabi_uidivmod>:
 8000228:	2900      	cmp	r1, #0
 800022a:	d0f7      	beq.n	800021c <__aeabi_uidiv+0x100>
 800022c:	e776      	b.n	800011c <__aeabi_uidiv>
 800022e:	4770      	bx	lr

08000230 <__aeabi_idiv0>:
 8000230:	4770      	bx	lr
 8000232:	46c0      	nop			; (mov r8, r8)

08000234 <__aeabi_cdrcmple>:
 8000234:	4684      	mov	ip, r0
 8000236:	1c10      	adds	r0, r2, #0
 8000238:	4662      	mov	r2, ip
 800023a:	468c      	mov	ip, r1
 800023c:	1c19      	adds	r1, r3, #0
 800023e:	4663      	mov	r3, ip
 8000240:	e000      	b.n	8000244 <__aeabi_cdcmpeq>
 8000242:	46c0      	nop			; (mov r8, r8)

08000244 <__aeabi_cdcmpeq>:
 8000244:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8000246:	f001 fe23 	bl	8001e90 <__ledf2>
 800024a:	2800      	cmp	r0, #0
 800024c:	d401      	bmi.n	8000252 <__aeabi_cdcmpeq+0xe>
 800024e:	2100      	movs	r1, #0
 8000250:	42c8      	cmn	r0, r1
 8000252:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

08000254 <__aeabi_dcmpeq>:
 8000254:	b510      	push	{r4, lr}
 8000256:	f001 fd77 	bl	8001d48 <__eqdf2>
 800025a:	4240      	negs	r0, r0
 800025c:	3001      	adds	r0, #1
 800025e:	bd10      	pop	{r4, pc}

08000260 <__aeabi_dcmplt>:
 8000260:	b510      	push	{r4, lr}
 8000262:	f001 fe15 	bl	8001e90 <__ledf2>
 8000266:	2800      	cmp	r0, #0
 8000268:	db01      	blt.n	800026e <__aeabi_dcmplt+0xe>
 800026a:	2000      	movs	r0, #0
 800026c:	bd10      	pop	{r4, pc}
 800026e:	2001      	movs	r0, #1
 8000270:	bd10      	pop	{r4, pc}
 8000272:	46c0      	nop			; (mov r8, r8)

08000274 <__aeabi_dcmple>:
 8000274:	b510      	push	{r4, lr}
 8000276:	f001 fe0b 	bl	8001e90 <__ledf2>
 800027a:	2800      	cmp	r0, #0
 800027c:	dd01      	ble.n	8000282 <__aeabi_dcmple+0xe>
 800027e:	2000      	movs	r0, #0
 8000280:	bd10      	pop	{r4, pc}
 8000282:	2001      	movs	r0, #1
 8000284:	bd10      	pop	{r4, pc}
 8000286:	46c0      	nop			; (mov r8, r8)

08000288 <__aeabi_dcmpgt>:
 8000288:	b510      	push	{r4, lr}
 800028a:	f001 fd9d 	bl	8001dc8 <__gedf2>
 800028e:	2800      	cmp	r0, #0
 8000290:	dc01      	bgt.n	8000296 <__aeabi_dcmpgt+0xe>
 8000292:	2000      	movs	r0, #0
 8000294:	bd10      	pop	{r4, pc}
 8000296:	2001      	movs	r0, #1
 8000298:	bd10      	pop	{r4, pc}
 800029a:	46c0      	nop			; (mov r8, r8)

0800029c <__aeabi_dcmpge>:
 800029c:	b510      	push	{r4, lr}
 800029e:	f001 fd93 	bl	8001dc8 <__gedf2>
 80002a2:	2800      	cmp	r0, #0
 80002a4:	da01      	bge.n	80002aa <__aeabi_dcmpge+0xe>
 80002a6:	2000      	movs	r0, #0
 80002a8:	bd10      	pop	{r4, pc}
 80002aa:	2001      	movs	r0, #1
 80002ac:	bd10      	pop	{r4, pc}
 80002ae:	46c0      	nop			; (mov r8, r8)

080002b0 <__aeabi_cfrcmple>:
 80002b0:	4684      	mov	ip, r0
 80002b2:	1c08      	adds	r0, r1, #0
 80002b4:	4661      	mov	r1, ip
 80002b6:	e7ff      	b.n	80002b8 <__aeabi_cfcmpeq>

080002b8 <__aeabi_cfcmpeq>:
 80002b8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80002ba:	f000 fb65 	bl	8000988 <__lesf2>
 80002be:	2800      	cmp	r0, #0
 80002c0:	d401      	bmi.n	80002c6 <__aeabi_cfcmpeq+0xe>
 80002c2:	2100      	movs	r1, #0
 80002c4:	42c8      	cmn	r0, r1
 80002c6:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

080002c8 <__aeabi_fcmpeq>:
 80002c8:	b510      	push	{r4, lr}
 80002ca:	f000 faf1 	bl	80008b0 <__eqsf2>
 80002ce:	4240      	negs	r0, r0
 80002d0:	3001      	adds	r0, #1
 80002d2:	bd10      	pop	{r4, pc}

080002d4 <__aeabi_fcmplt>:
 80002d4:	b510      	push	{r4, lr}
 80002d6:	f000 fb57 	bl	8000988 <__lesf2>
 80002da:	2800      	cmp	r0, #0
 80002dc:	db01      	blt.n	80002e2 <__aeabi_fcmplt+0xe>
 80002de:	2000      	movs	r0, #0
 80002e0:	bd10      	pop	{r4, pc}
 80002e2:	2001      	movs	r0, #1
 80002e4:	bd10      	pop	{r4, pc}
 80002e6:	46c0      	nop			; (mov r8, r8)

080002e8 <__aeabi_fcmple>:
 80002e8:	b510      	push	{r4, lr}
 80002ea:	f000 fb4d 	bl	8000988 <__lesf2>
 80002ee:	2800      	cmp	r0, #0
 80002f0:	dd01      	ble.n	80002f6 <__aeabi_fcmple+0xe>
 80002f2:	2000      	movs	r0, #0
 80002f4:	bd10      	pop	{r4, pc}
 80002f6:	2001      	movs	r0, #1
 80002f8:	bd10      	pop	{r4, pc}
 80002fa:	46c0      	nop			; (mov r8, r8)

080002fc <__aeabi_fcmpgt>:
 80002fc:	b510      	push	{r4, lr}
 80002fe:	f000 faff 	bl	8000900 <__gesf2>
 8000302:	2800      	cmp	r0, #0
 8000304:	dc01      	bgt.n	800030a <__aeabi_fcmpgt+0xe>
 8000306:	2000      	movs	r0, #0
 8000308:	bd10      	pop	{r4, pc}
 800030a:	2001      	movs	r0, #1
 800030c:	bd10      	pop	{r4, pc}
 800030e:	46c0      	nop			; (mov r8, r8)

08000310 <__aeabi_fcmpge>:
 8000310:	b510      	push	{r4, lr}
 8000312:	f000 faf5 	bl	8000900 <__gesf2>
 8000316:	2800      	cmp	r0, #0
 8000318:	da01      	bge.n	800031e <__aeabi_fcmpge+0xe>
 800031a:	2000      	movs	r0, #0
 800031c:	bd10      	pop	{r4, pc}
 800031e:	2001      	movs	r0, #1
 8000320:	bd10      	pop	{r4, pc}
 8000322:	46c0      	nop			; (mov r8, r8)

08000324 <__aeabi_f2uiz>:
 8000324:	219e      	movs	r1, #158	; 0x9e
 8000326:	b510      	push	{r4, lr}
 8000328:	05c9      	lsls	r1, r1, #23
 800032a:	1c04      	adds	r4, r0, #0
 800032c:	f7ff fff0 	bl	8000310 <__aeabi_fcmpge>
 8000330:	2800      	cmp	r0, #0
 8000332:	d103      	bne.n	800033c <__aeabi_f2uiz+0x18>
 8000334:	1c20      	adds	r0, r4, #0
 8000336:	f000 fe1d 	bl	8000f74 <__aeabi_f2iz>
 800033a:	bd10      	pop	{r4, pc}
 800033c:	219e      	movs	r1, #158	; 0x9e
 800033e:	1c20      	adds	r0, r4, #0
 8000340:	05c9      	lsls	r1, r1, #23
 8000342:	f000 fc79 	bl	8000c38 <__aeabi_fsub>
 8000346:	f000 fe15 	bl	8000f74 <__aeabi_f2iz>
 800034a:	2380      	movs	r3, #128	; 0x80
 800034c:	061b      	lsls	r3, r3, #24
 800034e:	469c      	mov	ip, r3
 8000350:	4460      	add	r0, ip
 8000352:	e7f2      	b.n	800033a <__aeabi_f2uiz+0x16>

08000354 <__aeabi_d2uiz>:
 8000354:	b570      	push	{r4, r5, r6, lr}
 8000356:	2200      	movs	r2, #0
 8000358:	4b0c      	ldr	r3, [pc, #48]	; (800038c <__aeabi_d2uiz+0x38>)
 800035a:	0004      	movs	r4, r0
 800035c:	000d      	movs	r5, r1
 800035e:	f7ff ff9d 	bl	800029c <__aeabi_dcmpge>
 8000362:	2800      	cmp	r0, #0
 8000364:	d104      	bne.n	8000370 <__aeabi_d2uiz+0x1c>
 8000366:	0020      	movs	r0, r4
 8000368:	0029      	movs	r1, r5
 800036a:	f002 f94f 	bl	800260c <__aeabi_d2iz>
 800036e:	bd70      	pop	{r4, r5, r6, pc}
 8000370:	4b06      	ldr	r3, [pc, #24]	; (800038c <__aeabi_d2uiz+0x38>)
 8000372:	2200      	movs	r2, #0
 8000374:	0020      	movs	r0, r4
 8000376:	0029      	movs	r1, r5
 8000378:	f001 fdf4 	bl	8001f64 <__aeabi_dsub>
 800037c:	f002 f946 	bl	800260c <__aeabi_d2iz>
 8000380:	2380      	movs	r3, #128	; 0x80
 8000382:	061b      	lsls	r3, r3, #24
 8000384:	469c      	mov	ip, r3
 8000386:	4460      	add	r0, ip
 8000388:	e7f1      	b.n	800036e <__aeabi_d2uiz+0x1a>
 800038a:	46c0      	nop			; (mov r8, r8)
 800038c:	41e00000 	.word	0x41e00000

08000390 <__aeabi_fadd>:
 8000390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000392:	024a      	lsls	r2, r1, #9
 8000394:	0243      	lsls	r3, r0, #9
 8000396:	0044      	lsls	r4, r0, #1
 8000398:	004e      	lsls	r6, r1, #1
 800039a:	0fc5      	lsrs	r5, r0, #31
 800039c:	0e24      	lsrs	r4, r4, #24
 800039e:	0028      	movs	r0, r5
 80003a0:	099b      	lsrs	r3, r3, #6
 80003a2:	0e36      	lsrs	r6, r6, #24
 80003a4:	0fc9      	lsrs	r1, r1, #31
 80003a6:	0992      	lsrs	r2, r2, #6
 80003a8:	428d      	cmp	r5, r1
 80003aa:	d059      	beq.n	8000460 <__aeabi_fadd+0xd0>
 80003ac:	1ba0      	subs	r0, r4, r6
 80003ae:	2800      	cmp	r0, #0
 80003b0:	dc00      	bgt.n	80003b4 <__aeabi_fadd+0x24>
 80003b2:	e08d      	b.n	80004d0 <__aeabi_fadd+0x140>
 80003b4:	2e00      	cmp	r6, #0
 80003b6:	d11a      	bne.n	80003ee <__aeabi_fadd+0x5e>
 80003b8:	2a00      	cmp	r2, #0
 80003ba:	d000      	beq.n	80003be <__aeabi_fadd+0x2e>
 80003bc:	e079      	b.n	80004b2 <__aeabi_fadd+0x122>
 80003be:	075a      	lsls	r2, r3, #29
 80003c0:	d004      	beq.n	80003cc <__aeabi_fadd+0x3c>
 80003c2:	220f      	movs	r2, #15
 80003c4:	401a      	ands	r2, r3
 80003c6:	2a04      	cmp	r2, #4
 80003c8:	d000      	beq.n	80003cc <__aeabi_fadd+0x3c>
 80003ca:	3304      	adds	r3, #4
 80003cc:	015a      	lsls	r2, r3, #5
 80003ce:	d538      	bpl.n	8000442 <__aeabi_fadd+0xb2>
 80003d0:	3401      	adds	r4, #1
 80003d2:	2cff      	cmp	r4, #255	; 0xff
 80003d4:	d100      	bne.n	80003d8 <__aeabi_fadd+0x48>
 80003d6:	e089      	b.n	80004ec <__aeabi_fadd+0x15c>
 80003d8:	0028      	movs	r0, r5
 80003da:	019b      	lsls	r3, r3, #6
 80003dc:	0a5b      	lsrs	r3, r3, #9
 80003de:	b2e4      	uxtb	r4, r4
 80003e0:	025b      	lsls	r3, r3, #9
 80003e2:	05e4      	lsls	r4, r4, #23
 80003e4:	0a5b      	lsrs	r3, r3, #9
 80003e6:	4323      	orrs	r3, r4
 80003e8:	07c0      	lsls	r0, r0, #31
 80003ea:	4318      	orrs	r0, r3
 80003ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80003ee:	2cff      	cmp	r4, #255	; 0xff
 80003f0:	d0e5      	beq.n	80003be <__aeabi_fadd+0x2e>
 80003f2:	2180      	movs	r1, #128	; 0x80
 80003f4:	04c9      	lsls	r1, r1, #19
 80003f6:	430a      	orrs	r2, r1
 80003f8:	281b      	cmp	r0, #27
 80003fa:	dd00      	ble.n	80003fe <__aeabi_fadd+0x6e>
 80003fc:	e089      	b.n	8000512 <__aeabi_fadd+0x182>
 80003fe:	0016      	movs	r6, r2
 8000400:	2120      	movs	r1, #32
 8000402:	40c6      	lsrs	r6, r0
 8000404:	1a08      	subs	r0, r1, r0
 8000406:	4082      	lsls	r2, r0
 8000408:	1e51      	subs	r1, r2, #1
 800040a:	418a      	sbcs	r2, r1
 800040c:	4332      	orrs	r2, r6
 800040e:	1a9b      	subs	r3, r3, r2
 8000410:	015a      	lsls	r2, r3, #5
 8000412:	d514      	bpl.n	800043e <__aeabi_fadd+0xae>
 8000414:	019b      	lsls	r3, r3, #6
 8000416:	099e      	lsrs	r6, r3, #6
 8000418:	0030      	movs	r0, r6
 800041a:	f002 fa0d 	bl	8002838 <__clzsi2>
 800041e:	3805      	subs	r0, #5
 8000420:	4086      	lsls	r6, r0
 8000422:	4284      	cmp	r4, r0
 8000424:	dc65      	bgt.n	80004f2 <__aeabi_fadd+0x162>
 8000426:	1b04      	subs	r4, r0, r4
 8000428:	0033      	movs	r3, r6
 800042a:	2020      	movs	r0, #32
 800042c:	3401      	adds	r4, #1
 800042e:	40e3      	lsrs	r3, r4
 8000430:	1b04      	subs	r4, r0, r4
 8000432:	40a6      	lsls	r6, r4
 8000434:	1e72      	subs	r2, r6, #1
 8000436:	4196      	sbcs	r6, r2
 8000438:	2400      	movs	r4, #0
 800043a:	4333      	orrs	r3, r6
 800043c:	e7bf      	b.n	80003be <__aeabi_fadd+0x2e>
 800043e:	075a      	lsls	r2, r3, #29
 8000440:	d1bf      	bne.n	80003c2 <__aeabi_fadd+0x32>
 8000442:	08df      	lsrs	r7, r3, #3
 8000444:	0028      	movs	r0, r5
 8000446:	2cff      	cmp	r4, #255	; 0xff
 8000448:	d12f      	bne.n	80004aa <__aeabi_fadd+0x11a>
 800044a:	2f00      	cmp	r7, #0
 800044c:	d100      	bne.n	8000450 <__aeabi_fadd+0xc0>
 800044e:	e087      	b.n	8000560 <__aeabi_fadd+0x1d0>
 8000450:	2280      	movs	r2, #128	; 0x80
 8000452:	03d2      	lsls	r2, r2, #15
 8000454:	0013      	movs	r3, r2
 8000456:	433b      	orrs	r3, r7
 8000458:	025b      	lsls	r3, r3, #9
 800045a:	0a5b      	lsrs	r3, r3, #9
 800045c:	24ff      	movs	r4, #255	; 0xff
 800045e:	e7bf      	b.n	80003e0 <__aeabi_fadd+0x50>
 8000460:	1ba1      	subs	r1, r4, r6
 8000462:	2900      	cmp	r1, #0
 8000464:	dd49      	ble.n	80004fa <__aeabi_fadd+0x16a>
 8000466:	2e00      	cmp	r6, #0
 8000468:	d029      	beq.n	80004be <__aeabi_fadd+0x12e>
 800046a:	2cff      	cmp	r4, #255	; 0xff
 800046c:	d0a7      	beq.n	80003be <__aeabi_fadd+0x2e>
 800046e:	2680      	movs	r6, #128	; 0x80
 8000470:	04f6      	lsls	r6, r6, #19
 8000472:	4332      	orrs	r2, r6
 8000474:	291b      	cmp	r1, #27
 8000476:	dd00      	ble.n	800047a <__aeabi_fadd+0xea>
 8000478:	e08d      	b.n	8000596 <__aeabi_fadd+0x206>
 800047a:	0017      	movs	r7, r2
 800047c:	2620      	movs	r6, #32
 800047e:	40cf      	lsrs	r7, r1
 8000480:	1a71      	subs	r1, r6, r1
 8000482:	408a      	lsls	r2, r1
 8000484:	1e51      	subs	r1, r2, #1
 8000486:	418a      	sbcs	r2, r1
 8000488:	433a      	orrs	r2, r7
 800048a:	189b      	adds	r3, r3, r2
 800048c:	015a      	lsls	r2, r3, #5
 800048e:	d5d6      	bpl.n	800043e <__aeabi_fadd+0xae>
 8000490:	3401      	adds	r4, #1
 8000492:	2cff      	cmp	r4, #255	; 0xff
 8000494:	d064      	beq.n	8000560 <__aeabi_fadd+0x1d0>
 8000496:	2201      	movs	r2, #1
 8000498:	4976      	ldr	r1, [pc, #472]	; (8000674 <__aeabi_fadd+0x2e4>)
 800049a:	401a      	ands	r2, r3
 800049c:	085b      	lsrs	r3, r3, #1
 800049e:	400b      	ands	r3, r1
 80004a0:	4313      	orrs	r3, r2
 80004a2:	e78c      	b.n	80003be <__aeabi_fadd+0x2e>
 80004a4:	1e03      	subs	r3, r0, #0
 80004a6:	d1ca      	bne.n	800043e <__aeabi_fadd+0xae>
 80004a8:	2000      	movs	r0, #0
 80004aa:	027b      	lsls	r3, r7, #9
 80004ac:	0a5b      	lsrs	r3, r3, #9
 80004ae:	b2e4      	uxtb	r4, r4
 80004b0:	e796      	b.n	80003e0 <__aeabi_fadd+0x50>
 80004b2:	3801      	subs	r0, #1
 80004b4:	2800      	cmp	r0, #0
 80004b6:	d0aa      	beq.n	800040e <__aeabi_fadd+0x7e>
 80004b8:	2cff      	cmp	r4, #255	; 0xff
 80004ba:	d19d      	bne.n	80003f8 <__aeabi_fadd+0x68>
 80004bc:	e77f      	b.n	80003be <__aeabi_fadd+0x2e>
 80004be:	2a00      	cmp	r2, #0
 80004c0:	d100      	bne.n	80004c4 <__aeabi_fadd+0x134>
 80004c2:	e77c      	b.n	80003be <__aeabi_fadd+0x2e>
 80004c4:	3901      	subs	r1, #1
 80004c6:	2900      	cmp	r1, #0
 80004c8:	d0df      	beq.n	800048a <__aeabi_fadd+0xfa>
 80004ca:	2cff      	cmp	r4, #255	; 0xff
 80004cc:	d1d2      	bne.n	8000474 <__aeabi_fadd+0xe4>
 80004ce:	e776      	b.n	80003be <__aeabi_fadd+0x2e>
 80004d0:	2800      	cmp	r0, #0
 80004d2:	d120      	bne.n	8000516 <__aeabi_fadd+0x186>
 80004d4:	1c60      	adds	r0, r4, #1
 80004d6:	b2c0      	uxtb	r0, r0
 80004d8:	2801      	cmp	r0, #1
 80004da:	dd53      	ble.n	8000584 <__aeabi_fadd+0x1f4>
 80004dc:	2780      	movs	r7, #128	; 0x80
 80004de:	1a9e      	subs	r6, r3, r2
 80004e0:	04ff      	lsls	r7, r7, #19
 80004e2:	4037      	ands	r7, r6
 80004e4:	d02f      	beq.n	8000546 <__aeabi_fadd+0x1b6>
 80004e6:	1ad6      	subs	r6, r2, r3
 80004e8:	000d      	movs	r5, r1
 80004ea:	e795      	b.n	8000418 <__aeabi_fadd+0x88>
 80004ec:	0028      	movs	r0, r5
 80004ee:	2300      	movs	r3, #0
 80004f0:	e776      	b.n	80003e0 <__aeabi_fadd+0x50>
 80004f2:	4b61      	ldr	r3, [pc, #388]	; (8000678 <__aeabi_fadd+0x2e8>)
 80004f4:	1a24      	subs	r4, r4, r0
 80004f6:	4033      	ands	r3, r6
 80004f8:	e761      	b.n	80003be <__aeabi_fadd+0x2e>
 80004fa:	2900      	cmp	r1, #0
 80004fc:	d14d      	bne.n	800059a <__aeabi_fadd+0x20a>
 80004fe:	1c61      	adds	r1, r4, #1
 8000500:	b2ce      	uxtb	r6, r1
 8000502:	2e01      	cmp	r6, #1
 8000504:	dd2f      	ble.n	8000566 <__aeabi_fadd+0x1d6>
 8000506:	29ff      	cmp	r1, #255	; 0xff
 8000508:	d02a      	beq.n	8000560 <__aeabi_fadd+0x1d0>
 800050a:	189b      	adds	r3, r3, r2
 800050c:	085b      	lsrs	r3, r3, #1
 800050e:	000c      	movs	r4, r1
 8000510:	e755      	b.n	80003be <__aeabi_fadd+0x2e>
 8000512:	2201      	movs	r2, #1
 8000514:	e77b      	b.n	800040e <__aeabi_fadd+0x7e>
 8000516:	2c00      	cmp	r4, #0
 8000518:	d11b      	bne.n	8000552 <__aeabi_fadd+0x1c2>
 800051a:	2b00      	cmp	r3, #0
 800051c:	d05b      	beq.n	80005d6 <__aeabi_fadd+0x246>
 800051e:	43c0      	mvns	r0, r0
 8000520:	2800      	cmp	r0, #0
 8000522:	d00c      	beq.n	800053e <__aeabi_fadd+0x1ae>
 8000524:	2eff      	cmp	r6, #255	; 0xff
 8000526:	d07e      	beq.n	8000626 <__aeabi_fadd+0x296>
 8000528:	281b      	cmp	r0, #27
 800052a:	dd00      	ble.n	800052e <__aeabi_fadd+0x19e>
 800052c:	e092      	b.n	8000654 <__aeabi_fadd+0x2c4>
 800052e:	001d      	movs	r5, r3
 8000530:	2420      	movs	r4, #32
 8000532:	40c5      	lsrs	r5, r0
 8000534:	1a20      	subs	r0, r4, r0
 8000536:	4083      	lsls	r3, r0
 8000538:	1e58      	subs	r0, r3, #1
 800053a:	4183      	sbcs	r3, r0
 800053c:	432b      	orrs	r3, r5
 800053e:	1ad3      	subs	r3, r2, r3
 8000540:	0034      	movs	r4, r6
 8000542:	000d      	movs	r5, r1
 8000544:	e764      	b.n	8000410 <__aeabi_fadd+0x80>
 8000546:	2e00      	cmp	r6, #0
 8000548:	d000      	beq.n	800054c <__aeabi_fadd+0x1bc>
 800054a:	e765      	b.n	8000418 <__aeabi_fadd+0x88>
 800054c:	2000      	movs	r0, #0
 800054e:	2400      	movs	r4, #0
 8000550:	e7ab      	b.n	80004aa <__aeabi_fadd+0x11a>
 8000552:	2eff      	cmp	r6, #255	; 0xff
 8000554:	d067      	beq.n	8000626 <__aeabi_fadd+0x296>
 8000556:	2480      	movs	r4, #128	; 0x80
 8000558:	04e4      	lsls	r4, r4, #19
 800055a:	4240      	negs	r0, r0
 800055c:	4323      	orrs	r3, r4
 800055e:	e7e3      	b.n	8000528 <__aeabi_fadd+0x198>
 8000560:	24ff      	movs	r4, #255	; 0xff
 8000562:	2300      	movs	r3, #0
 8000564:	e73c      	b.n	80003e0 <__aeabi_fadd+0x50>
 8000566:	2c00      	cmp	r4, #0
 8000568:	d161      	bne.n	800062e <__aeabi_fadd+0x29e>
 800056a:	2b00      	cmp	r3, #0
 800056c:	d07e      	beq.n	800066c <__aeabi_fadd+0x2dc>
 800056e:	2a00      	cmp	r2, #0
 8000570:	d100      	bne.n	8000574 <__aeabi_fadd+0x1e4>
 8000572:	e724      	b.n	80003be <__aeabi_fadd+0x2e>
 8000574:	189b      	adds	r3, r3, r2
 8000576:	015a      	lsls	r2, r3, #5
 8000578:	d400      	bmi.n	800057c <__aeabi_fadd+0x1ec>
 800057a:	e760      	b.n	800043e <__aeabi_fadd+0xae>
 800057c:	4a3e      	ldr	r2, [pc, #248]	; (8000678 <__aeabi_fadd+0x2e8>)
 800057e:	000c      	movs	r4, r1
 8000580:	4013      	ands	r3, r2
 8000582:	e71c      	b.n	80003be <__aeabi_fadd+0x2e>
 8000584:	2c00      	cmp	r4, #0
 8000586:	d11e      	bne.n	80005c6 <__aeabi_fadd+0x236>
 8000588:	2b00      	cmp	r3, #0
 800058a:	d12f      	bne.n	80005ec <__aeabi_fadd+0x25c>
 800058c:	2a00      	cmp	r2, #0
 800058e:	d066      	beq.n	800065e <__aeabi_fadd+0x2ce>
 8000590:	0013      	movs	r3, r2
 8000592:	000d      	movs	r5, r1
 8000594:	e713      	b.n	80003be <__aeabi_fadd+0x2e>
 8000596:	2201      	movs	r2, #1
 8000598:	e777      	b.n	800048a <__aeabi_fadd+0xfa>
 800059a:	2c00      	cmp	r4, #0
 800059c:	d11f      	bne.n	80005de <__aeabi_fadd+0x24e>
 800059e:	2b00      	cmp	r3, #0
 80005a0:	d05a      	beq.n	8000658 <__aeabi_fadd+0x2c8>
 80005a2:	43c9      	mvns	r1, r1
 80005a4:	2900      	cmp	r1, #0
 80005a6:	d00b      	beq.n	80005c0 <__aeabi_fadd+0x230>
 80005a8:	2eff      	cmp	r6, #255	; 0xff
 80005aa:	d050      	beq.n	800064e <__aeabi_fadd+0x2be>
 80005ac:	291b      	cmp	r1, #27
 80005ae:	dc5f      	bgt.n	8000670 <__aeabi_fadd+0x2e0>
 80005b0:	001f      	movs	r7, r3
 80005b2:	2420      	movs	r4, #32
 80005b4:	40cf      	lsrs	r7, r1
 80005b6:	1a61      	subs	r1, r4, r1
 80005b8:	408b      	lsls	r3, r1
 80005ba:	1e59      	subs	r1, r3, #1
 80005bc:	418b      	sbcs	r3, r1
 80005be:	433b      	orrs	r3, r7
 80005c0:	189b      	adds	r3, r3, r2
 80005c2:	0034      	movs	r4, r6
 80005c4:	e762      	b.n	800048c <__aeabi_fadd+0xfc>
 80005c6:	2b00      	cmp	r3, #0
 80005c8:	d11c      	bne.n	8000604 <__aeabi_fadd+0x274>
 80005ca:	2a00      	cmp	r2, #0
 80005cc:	d04a      	beq.n	8000664 <__aeabi_fadd+0x2d4>
 80005ce:	0013      	movs	r3, r2
 80005d0:	000d      	movs	r5, r1
 80005d2:	24ff      	movs	r4, #255	; 0xff
 80005d4:	e6f3      	b.n	80003be <__aeabi_fadd+0x2e>
 80005d6:	0013      	movs	r3, r2
 80005d8:	0034      	movs	r4, r6
 80005da:	000d      	movs	r5, r1
 80005dc:	e6ef      	b.n	80003be <__aeabi_fadd+0x2e>
 80005de:	2eff      	cmp	r6, #255	; 0xff
 80005e0:	d035      	beq.n	800064e <__aeabi_fadd+0x2be>
 80005e2:	2480      	movs	r4, #128	; 0x80
 80005e4:	04e4      	lsls	r4, r4, #19
 80005e6:	4249      	negs	r1, r1
 80005e8:	4323      	orrs	r3, r4
 80005ea:	e7df      	b.n	80005ac <__aeabi_fadd+0x21c>
 80005ec:	2a00      	cmp	r2, #0
 80005ee:	d100      	bne.n	80005f2 <__aeabi_fadd+0x262>
 80005f0:	e6e5      	b.n	80003be <__aeabi_fadd+0x2e>
 80005f2:	2780      	movs	r7, #128	; 0x80
 80005f4:	1a98      	subs	r0, r3, r2
 80005f6:	04ff      	lsls	r7, r7, #19
 80005f8:	4007      	ands	r7, r0
 80005fa:	d100      	bne.n	80005fe <__aeabi_fadd+0x26e>
 80005fc:	e752      	b.n	80004a4 <__aeabi_fadd+0x114>
 80005fe:	1ad3      	subs	r3, r2, r3
 8000600:	000d      	movs	r5, r1
 8000602:	e6dc      	b.n	80003be <__aeabi_fadd+0x2e>
 8000604:	24ff      	movs	r4, #255	; 0xff
 8000606:	2a00      	cmp	r2, #0
 8000608:	d100      	bne.n	800060c <__aeabi_fadd+0x27c>
 800060a:	e6d8      	b.n	80003be <__aeabi_fadd+0x2e>
 800060c:	2080      	movs	r0, #128	; 0x80
 800060e:	08db      	lsrs	r3, r3, #3
 8000610:	03c0      	lsls	r0, r0, #15
 8000612:	4203      	tst	r3, r0
 8000614:	d004      	beq.n	8000620 <__aeabi_fadd+0x290>
 8000616:	08d2      	lsrs	r2, r2, #3
 8000618:	4202      	tst	r2, r0
 800061a:	d101      	bne.n	8000620 <__aeabi_fadd+0x290>
 800061c:	0013      	movs	r3, r2
 800061e:	000d      	movs	r5, r1
 8000620:	00db      	lsls	r3, r3, #3
 8000622:	24ff      	movs	r4, #255	; 0xff
 8000624:	e6cb      	b.n	80003be <__aeabi_fadd+0x2e>
 8000626:	0013      	movs	r3, r2
 8000628:	24ff      	movs	r4, #255	; 0xff
 800062a:	000d      	movs	r5, r1
 800062c:	e6c7      	b.n	80003be <__aeabi_fadd+0x2e>
 800062e:	2b00      	cmp	r3, #0
 8000630:	d00d      	beq.n	800064e <__aeabi_fadd+0x2be>
 8000632:	24ff      	movs	r4, #255	; 0xff
 8000634:	2a00      	cmp	r2, #0
 8000636:	d100      	bne.n	800063a <__aeabi_fadd+0x2aa>
 8000638:	e6c1      	b.n	80003be <__aeabi_fadd+0x2e>
 800063a:	2180      	movs	r1, #128	; 0x80
 800063c:	08db      	lsrs	r3, r3, #3
 800063e:	03c9      	lsls	r1, r1, #15
 8000640:	420b      	tst	r3, r1
 8000642:	d0ed      	beq.n	8000620 <__aeabi_fadd+0x290>
 8000644:	08d2      	lsrs	r2, r2, #3
 8000646:	420a      	tst	r2, r1
 8000648:	d1ea      	bne.n	8000620 <__aeabi_fadd+0x290>
 800064a:	0013      	movs	r3, r2
 800064c:	e7e8      	b.n	8000620 <__aeabi_fadd+0x290>
 800064e:	0013      	movs	r3, r2
 8000650:	24ff      	movs	r4, #255	; 0xff
 8000652:	e6b4      	b.n	80003be <__aeabi_fadd+0x2e>
 8000654:	2301      	movs	r3, #1
 8000656:	e772      	b.n	800053e <__aeabi_fadd+0x1ae>
 8000658:	0013      	movs	r3, r2
 800065a:	0034      	movs	r4, r6
 800065c:	e6af      	b.n	80003be <__aeabi_fadd+0x2e>
 800065e:	2700      	movs	r7, #0
 8000660:	2000      	movs	r0, #0
 8000662:	e722      	b.n	80004aa <__aeabi_fadd+0x11a>
 8000664:	2780      	movs	r7, #128	; 0x80
 8000666:	2000      	movs	r0, #0
 8000668:	03ff      	lsls	r7, r7, #15
 800066a:	e6f1      	b.n	8000450 <__aeabi_fadd+0xc0>
 800066c:	0013      	movs	r3, r2
 800066e:	e6a6      	b.n	80003be <__aeabi_fadd+0x2e>
 8000670:	2301      	movs	r3, #1
 8000672:	e7a5      	b.n	80005c0 <__aeabi_fadd+0x230>
 8000674:	7dffffff 	.word	0x7dffffff
 8000678:	fbffffff 	.word	0xfbffffff

0800067c <__aeabi_fdiv>:
 800067c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800067e:	4656      	mov	r6, sl
 8000680:	4644      	mov	r4, r8
 8000682:	465f      	mov	r7, fp
 8000684:	464d      	mov	r5, r9
 8000686:	b4f0      	push	{r4, r5, r6, r7}
 8000688:	0244      	lsls	r4, r0, #9
 800068a:	0046      	lsls	r6, r0, #1
 800068c:	0fc7      	lsrs	r7, r0, #31
 800068e:	b083      	sub	sp, #12
 8000690:	4688      	mov	r8, r1
 8000692:	0a65      	lsrs	r5, r4, #9
 8000694:	0e36      	lsrs	r6, r6, #24
 8000696:	46ba      	mov	sl, r7
 8000698:	d03d      	beq.n	8000716 <__aeabi_fdiv+0x9a>
 800069a:	2eff      	cmp	r6, #255	; 0xff
 800069c:	d022      	beq.n	80006e4 <__aeabi_fdiv+0x68>
 800069e:	2300      	movs	r3, #0
 80006a0:	00ec      	lsls	r4, r5, #3
 80006a2:	2580      	movs	r5, #128	; 0x80
 80006a4:	4699      	mov	r9, r3
 80006a6:	469b      	mov	fp, r3
 80006a8:	04ed      	lsls	r5, r5, #19
 80006aa:	4325      	orrs	r5, r4
 80006ac:	3e7f      	subs	r6, #127	; 0x7f
 80006ae:	4643      	mov	r3, r8
 80006b0:	025c      	lsls	r4, r3, #9
 80006b2:	0058      	lsls	r0, r3, #1
 80006b4:	0fdb      	lsrs	r3, r3, #31
 80006b6:	0a64      	lsrs	r4, r4, #9
 80006b8:	0e00      	lsrs	r0, r0, #24
 80006ba:	4698      	mov	r8, r3
 80006bc:	d036      	beq.n	800072c <__aeabi_fdiv+0xb0>
 80006be:	28ff      	cmp	r0, #255	; 0xff
 80006c0:	d030      	beq.n	8000724 <__aeabi_fdiv+0xa8>
 80006c2:	2380      	movs	r3, #128	; 0x80
 80006c4:	2100      	movs	r1, #0
 80006c6:	00e4      	lsls	r4, r4, #3
 80006c8:	04db      	lsls	r3, r3, #19
 80006ca:	431c      	orrs	r4, r3
 80006cc:	387f      	subs	r0, #127	; 0x7f
 80006ce:	1a30      	subs	r0, r6, r0
 80006d0:	9001      	str	r0, [sp, #4]
 80006d2:	4648      	mov	r0, r9
 80006d4:	4642      	mov	r2, r8
 80006d6:	4308      	orrs	r0, r1
 80006d8:	4e72      	ldr	r6, [pc, #456]	; (80008a4 <__aeabi_fdiv+0x228>)
 80006da:	0080      	lsls	r0, r0, #2
 80006dc:	5830      	ldr	r0, [r6, r0]
 80006de:	407a      	eors	r2, r7
 80006e0:	0013      	movs	r3, r2
 80006e2:	4687      	mov	pc, r0
 80006e4:	2d00      	cmp	r5, #0
 80006e6:	d144      	bne.n	8000772 <__aeabi_fdiv+0xf6>
 80006e8:	2308      	movs	r3, #8
 80006ea:	4699      	mov	r9, r3
 80006ec:	3b06      	subs	r3, #6
 80006ee:	469b      	mov	fp, r3
 80006f0:	e7dd      	b.n	80006ae <__aeabi_fdiv+0x32>
 80006f2:	2201      	movs	r2, #1
 80006f4:	20ff      	movs	r0, #255	; 0xff
 80006f6:	2400      	movs	r4, #0
 80006f8:	401a      	ands	r2, r3
 80006fa:	0264      	lsls	r4, r4, #9
 80006fc:	05c3      	lsls	r3, r0, #23
 80006fe:	0a64      	lsrs	r4, r4, #9
 8000700:	07d2      	lsls	r2, r2, #31
 8000702:	431c      	orrs	r4, r3
 8000704:	4314      	orrs	r4, r2
 8000706:	0020      	movs	r0, r4
 8000708:	b003      	add	sp, #12
 800070a:	bc3c      	pop	{r2, r3, r4, r5}
 800070c:	4690      	mov	r8, r2
 800070e:	4699      	mov	r9, r3
 8000710:	46a2      	mov	sl, r4
 8000712:	46ab      	mov	fp, r5
 8000714:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000716:	2d00      	cmp	r5, #0
 8000718:	d120      	bne.n	800075c <__aeabi_fdiv+0xe0>
 800071a:	2304      	movs	r3, #4
 800071c:	4699      	mov	r9, r3
 800071e:	3b03      	subs	r3, #3
 8000720:	469b      	mov	fp, r3
 8000722:	e7c4      	b.n	80006ae <__aeabi_fdiv+0x32>
 8000724:	2c00      	cmp	r4, #0
 8000726:	d117      	bne.n	8000758 <__aeabi_fdiv+0xdc>
 8000728:	2102      	movs	r1, #2
 800072a:	e002      	b.n	8000732 <__aeabi_fdiv+0xb6>
 800072c:	2c00      	cmp	r4, #0
 800072e:	d10a      	bne.n	8000746 <__aeabi_fdiv+0xca>
 8000730:	2101      	movs	r1, #1
 8000732:	1a32      	subs	r2, r6, r0
 8000734:	9201      	str	r2, [sp, #4]
 8000736:	464a      	mov	r2, r9
 8000738:	4643      	mov	r3, r8
 800073a:	430a      	orrs	r2, r1
 800073c:	485a      	ldr	r0, [pc, #360]	; (80008a8 <__aeabi_fdiv+0x22c>)
 800073e:	0092      	lsls	r2, r2, #2
 8000740:	5882      	ldr	r2, [r0, r2]
 8000742:	407b      	eors	r3, r7
 8000744:	4697      	mov	pc, r2
 8000746:	0020      	movs	r0, r4
 8000748:	f002 f876 	bl	8002838 <__clzsi2>
 800074c:	1f43      	subs	r3, r0, #5
 800074e:	3076      	adds	r0, #118	; 0x76
 8000750:	409c      	lsls	r4, r3
 8000752:	4240      	negs	r0, r0
 8000754:	2100      	movs	r1, #0
 8000756:	e7ba      	b.n	80006ce <__aeabi_fdiv+0x52>
 8000758:	2103      	movs	r1, #3
 800075a:	e7b8      	b.n	80006ce <__aeabi_fdiv+0x52>
 800075c:	0028      	movs	r0, r5
 800075e:	f002 f86b 	bl	8002838 <__clzsi2>
 8000762:	1f43      	subs	r3, r0, #5
 8000764:	409d      	lsls	r5, r3
 8000766:	2300      	movs	r3, #0
 8000768:	3076      	adds	r0, #118	; 0x76
 800076a:	4246      	negs	r6, r0
 800076c:	4699      	mov	r9, r3
 800076e:	469b      	mov	fp, r3
 8000770:	e79d      	b.n	80006ae <__aeabi_fdiv+0x32>
 8000772:	230c      	movs	r3, #12
 8000774:	4699      	mov	r9, r3
 8000776:	3b09      	subs	r3, #9
 8000778:	469b      	mov	fp, r3
 800077a:	e798      	b.n	80006ae <__aeabi_fdiv+0x32>
 800077c:	2480      	movs	r4, #128	; 0x80
 800077e:	2200      	movs	r2, #0
 8000780:	03e4      	lsls	r4, r4, #15
 8000782:	20ff      	movs	r0, #255	; 0xff
 8000784:	e7b9      	b.n	80006fa <__aeabi_fdiv+0x7e>
 8000786:	2400      	movs	r4, #0
 8000788:	46c2      	mov	sl, r8
 800078a:	468b      	mov	fp, r1
 800078c:	465a      	mov	r2, fp
 800078e:	4653      	mov	r3, sl
 8000790:	2a02      	cmp	r2, #2
 8000792:	d0ae      	beq.n	80006f2 <__aeabi_fdiv+0x76>
 8000794:	2a03      	cmp	r2, #3
 8000796:	d07d      	beq.n	8000894 <__aeabi_fdiv+0x218>
 8000798:	2a01      	cmp	r2, #1
 800079a:	d131      	bne.n	8000800 <__aeabi_fdiv+0x184>
 800079c:	2201      	movs	r2, #1
 800079e:	2000      	movs	r0, #0
 80007a0:	401a      	ands	r2, r3
 80007a2:	2400      	movs	r4, #0
 80007a4:	e7a9      	b.n	80006fa <__aeabi_fdiv+0x7e>
 80007a6:	2201      	movs	r2, #1
 80007a8:	1a10      	subs	r0, r2, r0
 80007aa:	281b      	cmp	r0, #27
 80007ac:	dd56      	ble.n	800085c <__aeabi_fdiv+0x1e0>
 80007ae:	401a      	ands	r2, r3
 80007b0:	2000      	movs	r0, #0
 80007b2:	2400      	movs	r4, #0
 80007b4:	e7a1      	b.n	80006fa <__aeabi_fdiv+0x7e>
 80007b6:	2380      	movs	r3, #128	; 0x80
 80007b8:	03db      	lsls	r3, r3, #15
 80007ba:	421d      	tst	r5, r3
 80007bc:	d14b      	bne.n	8000856 <__aeabi_fdiv+0x1da>
 80007be:	2380      	movs	r3, #128	; 0x80
 80007c0:	03db      	lsls	r3, r3, #15
 80007c2:	432b      	orrs	r3, r5
 80007c4:	025c      	lsls	r4, r3, #9
 80007c6:	0a64      	lsrs	r4, r4, #9
 80007c8:	003a      	movs	r2, r7
 80007ca:	20ff      	movs	r0, #255	; 0xff
 80007cc:	e795      	b.n	80006fa <__aeabi_fdiv+0x7e>
 80007ce:	016d      	lsls	r5, r5, #5
 80007d0:	0160      	lsls	r0, r4, #5
 80007d2:	4285      	cmp	r5, r0
 80007d4:	d230      	bcs.n	8000838 <__aeabi_fdiv+0x1bc>
 80007d6:	9a01      	ldr	r2, [sp, #4]
 80007d8:	2400      	movs	r4, #0
 80007da:	3a01      	subs	r2, #1
 80007dc:	9201      	str	r2, [sp, #4]
 80007de:	221b      	movs	r2, #27
 80007e0:	2701      	movs	r7, #1
 80007e2:	0029      	movs	r1, r5
 80007e4:	0064      	lsls	r4, r4, #1
 80007e6:	006d      	lsls	r5, r5, #1
 80007e8:	2900      	cmp	r1, #0
 80007ea:	db01      	blt.n	80007f0 <__aeabi_fdiv+0x174>
 80007ec:	42a8      	cmp	r0, r5
 80007ee:	d801      	bhi.n	80007f4 <__aeabi_fdiv+0x178>
 80007f0:	1a2d      	subs	r5, r5, r0
 80007f2:	433c      	orrs	r4, r7
 80007f4:	3a01      	subs	r2, #1
 80007f6:	2a00      	cmp	r2, #0
 80007f8:	d1f3      	bne.n	80007e2 <__aeabi_fdiv+0x166>
 80007fa:	1e6a      	subs	r2, r5, #1
 80007fc:	4195      	sbcs	r5, r2
 80007fe:	432c      	orrs	r4, r5
 8000800:	9801      	ldr	r0, [sp, #4]
 8000802:	307f      	adds	r0, #127	; 0x7f
 8000804:	2800      	cmp	r0, #0
 8000806:	ddce      	ble.n	80007a6 <__aeabi_fdiv+0x12a>
 8000808:	0762      	lsls	r2, r4, #29
 800080a:	d004      	beq.n	8000816 <__aeabi_fdiv+0x19a>
 800080c:	220f      	movs	r2, #15
 800080e:	4022      	ands	r2, r4
 8000810:	2a04      	cmp	r2, #4
 8000812:	d000      	beq.n	8000816 <__aeabi_fdiv+0x19a>
 8000814:	3404      	adds	r4, #4
 8000816:	0122      	lsls	r2, r4, #4
 8000818:	d503      	bpl.n	8000822 <__aeabi_fdiv+0x1a6>
 800081a:	4a24      	ldr	r2, [pc, #144]	; (80008ac <__aeabi_fdiv+0x230>)
 800081c:	9801      	ldr	r0, [sp, #4]
 800081e:	4014      	ands	r4, r2
 8000820:	3080      	adds	r0, #128	; 0x80
 8000822:	28fe      	cmp	r0, #254	; 0xfe
 8000824:	dd00      	ble.n	8000828 <__aeabi_fdiv+0x1ac>
 8000826:	e764      	b.n	80006f2 <__aeabi_fdiv+0x76>
 8000828:	2201      	movs	r2, #1
 800082a:	01a4      	lsls	r4, r4, #6
 800082c:	0a64      	lsrs	r4, r4, #9
 800082e:	b2c0      	uxtb	r0, r0
 8000830:	401a      	ands	r2, r3
 8000832:	e762      	b.n	80006fa <__aeabi_fdiv+0x7e>
 8000834:	002c      	movs	r4, r5
 8000836:	e7a9      	b.n	800078c <__aeabi_fdiv+0x110>
 8000838:	1a2d      	subs	r5, r5, r0
 800083a:	221a      	movs	r2, #26
 800083c:	2401      	movs	r4, #1
 800083e:	e7cf      	b.n	80007e0 <__aeabi_fdiv+0x164>
 8000840:	026b      	lsls	r3, r5, #9
 8000842:	d5bc      	bpl.n	80007be <__aeabi_fdiv+0x142>
 8000844:	2400      	movs	r4, #0
 8000846:	2380      	movs	r3, #128	; 0x80
 8000848:	03db      	lsls	r3, r3, #15
 800084a:	431c      	orrs	r4, r3
 800084c:	0264      	lsls	r4, r4, #9
 800084e:	0a64      	lsrs	r4, r4, #9
 8000850:	4642      	mov	r2, r8
 8000852:	20ff      	movs	r0, #255	; 0xff
 8000854:	e751      	b.n	80006fa <__aeabi_fdiv+0x7e>
 8000856:	421c      	tst	r4, r3
 8000858:	d1b3      	bne.n	80007c2 <__aeabi_fdiv+0x146>
 800085a:	e7f4      	b.n	8000846 <__aeabi_fdiv+0x1ca>
 800085c:	0021      	movs	r1, r4
 800085e:	2220      	movs	r2, #32
 8000860:	40c1      	lsrs	r1, r0
 8000862:	1a10      	subs	r0, r2, r0
 8000864:	4084      	lsls	r4, r0
 8000866:	1e62      	subs	r2, r4, #1
 8000868:	4194      	sbcs	r4, r2
 800086a:	430c      	orrs	r4, r1
 800086c:	0762      	lsls	r2, r4, #29
 800086e:	d004      	beq.n	800087a <__aeabi_fdiv+0x1fe>
 8000870:	220f      	movs	r2, #15
 8000872:	4022      	ands	r2, r4
 8000874:	2a04      	cmp	r2, #4
 8000876:	d000      	beq.n	800087a <__aeabi_fdiv+0x1fe>
 8000878:	3404      	adds	r4, #4
 800087a:	0162      	lsls	r2, r4, #5
 800087c:	d504      	bpl.n	8000888 <__aeabi_fdiv+0x20c>
 800087e:	2201      	movs	r2, #1
 8000880:	2001      	movs	r0, #1
 8000882:	401a      	ands	r2, r3
 8000884:	2400      	movs	r4, #0
 8000886:	e738      	b.n	80006fa <__aeabi_fdiv+0x7e>
 8000888:	2201      	movs	r2, #1
 800088a:	01a4      	lsls	r4, r4, #6
 800088c:	0a64      	lsrs	r4, r4, #9
 800088e:	401a      	ands	r2, r3
 8000890:	2000      	movs	r0, #0
 8000892:	e732      	b.n	80006fa <__aeabi_fdiv+0x7e>
 8000894:	2380      	movs	r3, #128	; 0x80
 8000896:	03db      	lsls	r3, r3, #15
 8000898:	431c      	orrs	r4, r3
 800089a:	0264      	lsls	r4, r4, #9
 800089c:	0a64      	lsrs	r4, r4, #9
 800089e:	4652      	mov	r2, sl
 80008a0:	20ff      	movs	r0, #255	; 0xff
 80008a2:	e72a      	b.n	80006fa <__aeabi_fdiv+0x7e>
 80008a4:	0800d60c 	.word	0x0800d60c
 80008a8:	0800d64c 	.word	0x0800d64c
 80008ac:	f7ffffff 	.word	0xf7ffffff

080008b0 <__eqsf2>:
 80008b0:	0243      	lsls	r3, r0, #9
 80008b2:	b570      	push	{r4, r5, r6, lr}
 80008b4:	0042      	lsls	r2, r0, #1
 80008b6:	004c      	lsls	r4, r1, #1
 80008b8:	0a5d      	lsrs	r5, r3, #9
 80008ba:	0fc3      	lsrs	r3, r0, #31
 80008bc:	0248      	lsls	r0, r1, #9
 80008be:	0e12      	lsrs	r2, r2, #24
 80008c0:	0a46      	lsrs	r6, r0, #9
 80008c2:	0e24      	lsrs	r4, r4, #24
 80008c4:	0fc9      	lsrs	r1, r1, #31
 80008c6:	2aff      	cmp	r2, #255	; 0xff
 80008c8:	d00f      	beq.n	80008ea <__eqsf2+0x3a>
 80008ca:	2cff      	cmp	r4, #255	; 0xff
 80008cc:	d011      	beq.n	80008f2 <__eqsf2+0x42>
 80008ce:	2001      	movs	r0, #1
 80008d0:	42a2      	cmp	r2, r4
 80008d2:	d000      	beq.n	80008d6 <__eqsf2+0x26>
 80008d4:	bd70      	pop	{r4, r5, r6, pc}
 80008d6:	42b5      	cmp	r5, r6
 80008d8:	d1fc      	bne.n	80008d4 <__eqsf2+0x24>
 80008da:	428b      	cmp	r3, r1
 80008dc:	d00d      	beq.n	80008fa <__eqsf2+0x4a>
 80008de:	2a00      	cmp	r2, #0
 80008e0:	d1f8      	bne.n	80008d4 <__eqsf2+0x24>
 80008e2:	0028      	movs	r0, r5
 80008e4:	1e43      	subs	r3, r0, #1
 80008e6:	4198      	sbcs	r0, r3
 80008e8:	e7f4      	b.n	80008d4 <__eqsf2+0x24>
 80008ea:	2001      	movs	r0, #1
 80008ec:	2d00      	cmp	r5, #0
 80008ee:	d1f1      	bne.n	80008d4 <__eqsf2+0x24>
 80008f0:	e7eb      	b.n	80008ca <__eqsf2+0x1a>
 80008f2:	2001      	movs	r0, #1
 80008f4:	2e00      	cmp	r6, #0
 80008f6:	d1ed      	bne.n	80008d4 <__eqsf2+0x24>
 80008f8:	e7e9      	b.n	80008ce <__eqsf2+0x1e>
 80008fa:	2000      	movs	r0, #0
 80008fc:	e7ea      	b.n	80008d4 <__eqsf2+0x24>
 80008fe:	46c0      	nop			; (mov r8, r8)

08000900 <__gesf2>:
 8000900:	0243      	lsls	r3, r0, #9
 8000902:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000904:	0042      	lsls	r2, r0, #1
 8000906:	0a5d      	lsrs	r5, r3, #9
 8000908:	0fc3      	lsrs	r3, r0, #31
 800090a:	0248      	lsls	r0, r1, #9
 800090c:	0a44      	lsrs	r4, r0, #9
 800090e:	0048      	lsls	r0, r1, #1
 8000910:	0e12      	lsrs	r2, r2, #24
 8000912:	0e00      	lsrs	r0, r0, #24
 8000914:	0fc9      	lsrs	r1, r1, #31
 8000916:	2aff      	cmp	r2, #255	; 0xff
 8000918:	d01f      	beq.n	800095a <__gesf2+0x5a>
 800091a:	28ff      	cmp	r0, #255	; 0xff
 800091c:	d022      	beq.n	8000964 <__gesf2+0x64>
 800091e:	2a00      	cmp	r2, #0
 8000920:	d109      	bne.n	8000936 <__gesf2+0x36>
 8000922:	426e      	negs	r6, r5
 8000924:	416e      	adcs	r6, r5
 8000926:	2800      	cmp	r0, #0
 8000928:	d10f      	bne.n	800094a <__gesf2+0x4a>
 800092a:	2c00      	cmp	r4, #0
 800092c:	d10d      	bne.n	800094a <__gesf2+0x4a>
 800092e:	2000      	movs	r0, #0
 8000930:	2d00      	cmp	r5, #0
 8000932:	d009      	beq.n	8000948 <__gesf2+0x48>
 8000934:	e005      	b.n	8000942 <__gesf2+0x42>
 8000936:	2800      	cmp	r0, #0
 8000938:	d101      	bne.n	800093e <__gesf2+0x3e>
 800093a:	2c00      	cmp	r4, #0
 800093c:	d001      	beq.n	8000942 <__gesf2+0x42>
 800093e:	428b      	cmp	r3, r1
 8000940:	d013      	beq.n	800096a <__gesf2+0x6a>
 8000942:	4258      	negs	r0, r3
 8000944:	2301      	movs	r3, #1
 8000946:	4318      	orrs	r0, r3
 8000948:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800094a:	2e00      	cmp	r6, #0
 800094c:	d0f7      	beq.n	800093e <__gesf2+0x3e>
 800094e:	4248      	negs	r0, r1
 8000950:	4141      	adcs	r1, r0
 8000952:	2001      	movs	r0, #1
 8000954:	4249      	negs	r1, r1
 8000956:	4308      	orrs	r0, r1
 8000958:	e7f6      	b.n	8000948 <__gesf2+0x48>
 800095a:	2d00      	cmp	r5, #0
 800095c:	d0dd      	beq.n	800091a <__gesf2+0x1a>
 800095e:	2002      	movs	r0, #2
 8000960:	4240      	negs	r0, r0
 8000962:	e7f1      	b.n	8000948 <__gesf2+0x48>
 8000964:	2c00      	cmp	r4, #0
 8000966:	d0da      	beq.n	800091e <__gesf2+0x1e>
 8000968:	e7f9      	b.n	800095e <__gesf2+0x5e>
 800096a:	4282      	cmp	r2, r0
 800096c:	dce9      	bgt.n	8000942 <__gesf2+0x42>
 800096e:	db04      	blt.n	800097a <__gesf2+0x7a>
 8000970:	42a5      	cmp	r5, r4
 8000972:	d8e6      	bhi.n	8000942 <__gesf2+0x42>
 8000974:	2000      	movs	r0, #0
 8000976:	42a5      	cmp	r5, r4
 8000978:	d2e6      	bcs.n	8000948 <__gesf2+0x48>
 800097a:	4258      	negs	r0, r3
 800097c:	4143      	adcs	r3, r0
 800097e:	2001      	movs	r0, #1
 8000980:	425b      	negs	r3, r3
 8000982:	4318      	orrs	r0, r3
 8000984:	e7e0      	b.n	8000948 <__gesf2+0x48>
 8000986:	46c0      	nop			; (mov r8, r8)

08000988 <__lesf2>:
 8000988:	0243      	lsls	r3, r0, #9
 800098a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800098c:	0042      	lsls	r2, r0, #1
 800098e:	004c      	lsls	r4, r1, #1
 8000990:	0a5e      	lsrs	r6, r3, #9
 8000992:	0fc3      	lsrs	r3, r0, #31
 8000994:	0248      	lsls	r0, r1, #9
 8000996:	0e12      	lsrs	r2, r2, #24
 8000998:	0a45      	lsrs	r5, r0, #9
 800099a:	0e24      	lsrs	r4, r4, #24
 800099c:	0fc9      	lsrs	r1, r1, #31
 800099e:	2aff      	cmp	r2, #255	; 0xff
 80009a0:	d017      	beq.n	80009d2 <__lesf2+0x4a>
 80009a2:	2cff      	cmp	r4, #255	; 0xff
 80009a4:	d019      	beq.n	80009da <__lesf2+0x52>
 80009a6:	2a00      	cmp	r2, #0
 80009a8:	d10b      	bne.n	80009c2 <__lesf2+0x3a>
 80009aa:	4270      	negs	r0, r6
 80009ac:	4170      	adcs	r0, r6
 80009ae:	2c00      	cmp	r4, #0
 80009b0:	d017      	beq.n	80009e2 <__lesf2+0x5a>
 80009b2:	2800      	cmp	r0, #0
 80009b4:	d007      	beq.n	80009c6 <__lesf2+0x3e>
 80009b6:	4248      	negs	r0, r1
 80009b8:	4141      	adcs	r1, r0
 80009ba:	2001      	movs	r0, #1
 80009bc:	4249      	negs	r1, r1
 80009be:	4308      	orrs	r0, r1
 80009c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80009c2:	2c00      	cmp	r4, #0
 80009c4:	d013      	beq.n	80009ee <__lesf2+0x66>
 80009c6:	428b      	cmp	r3, r1
 80009c8:	d014      	beq.n	80009f4 <__lesf2+0x6c>
 80009ca:	4258      	negs	r0, r3
 80009cc:	2301      	movs	r3, #1
 80009ce:	4318      	orrs	r0, r3
 80009d0:	e7f6      	b.n	80009c0 <__lesf2+0x38>
 80009d2:	2002      	movs	r0, #2
 80009d4:	2e00      	cmp	r6, #0
 80009d6:	d1f3      	bne.n	80009c0 <__lesf2+0x38>
 80009d8:	e7e3      	b.n	80009a2 <__lesf2+0x1a>
 80009da:	2002      	movs	r0, #2
 80009dc:	2d00      	cmp	r5, #0
 80009de:	d1ef      	bne.n	80009c0 <__lesf2+0x38>
 80009e0:	e7e1      	b.n	80009a6 <__lesf2+0x1e>
 80009e2:	2d00      	cmp	r5, #0
 80009e4:	d1e5      	bne.n	80009b2 <__lesf2+0x2a>
 80009e6:	2000      	movs	r0, #0
 80009e8:	2e00      	cmp	r6, #0
 80009ea:	d0e9      	beq.n	80009c0 <__lesf2+0x38>
 80009ec:	e7ed      	b.n	80009ca <__lesf2+0x42>
 80009ee:	2d00      	cmp	r5, #0
 80009f0:	d1e9      	bne.n	80009c6 <__lesf2+0x3e>
 80009f2:	e7ea      	b.n	80009ca <__lesf2+0x42>
 80009f4:	42a2      	cmp	r2, r4
 80009f6:	dce8      	bgt.n	80009ca <__lesf2+0x42>
 80009f8:	db04      	blt.n	8000a04 <__lesf2+0x7c>
 80009fa:	42ae      	cmp	r6, r5
 80009fc:	d8e5      	bhi.n	80009ca <__lesf2+0x42>
 80009fe:	2000      	movs	r0, #0
 8000a00:	42ae      	cmp	r6, r5
 8000a02:	d2dd      	bcs.n	80009c0 <__lesf2+0x38>
 8000a04:	4258      	negs	r0, r3
 8000a06:	4143      	adcs	r3, r0
 8000a08:	2001      	movs	r0, #1
 8000a0a:	425b      	negs	r3, r3
 8000a0c:	4318      	orrs	r0, r3
 8000a0e:	e7d7      	b.n	80009c0 <__lesf2+0x38>

08000a10 <__aeabi_fmul>:
 8000a10:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a12:	4657      	mov	r7, sl
 8000a14:	464e      	mov	r6, r9
 8000a16:	4645      	mov	r5, r8
 8000a18:	0043      	lsls	r3, r0, #1
 8000a1a:	b4e0      	push	{r5, r6, r7}
 8000a1c:	0246      	lsls	r6, r0, #9
 8000a1e:	4688      	mov	r8, r1
 8000a20:	0a76      	lsrs	r6, r6, #9
 8000a22:	0e1f      	lsrs	r7, r3, #24
 8000a24:	0fc4      	lsrs	r4, r0, #31
 8000a26:	2f00      	cmp	r7, #0
 8000a28:	d047      	beq.n	8000aba <__aeabi_fmul+0xaa>
 8000a2a:	2fff      	cmp	r7, #255	; 0xff
 8000a2c:	d025      	beq.n	8000a7a <__aeabi_fmul+0x6a>
 8000a2e:	2300      	movs	r3, #0
 8000a30:	2580      	movs	r5, #128	; 0x80
 8000a32:	469a      	mov	sl, r3
 8000a34:	4699      	mov	r9, r3
 8000a36:	00f6      	lsls	r6, r6, #3
 8000a38:	04ed      	lsls	r5, r5, #19
 8000a3a:	432e      	orrs	r6, r5
 8000a3c:	3f7f      	subs	r7, #127	; 0x7f
 8000a3e:	4643      	mov	r3, r8
 8000a40:	4642      	mov	r2, r8
 8000a42:	025d      	lsls	r5, r3, #9
 8000a44:	0fd2      	lsrs	r2, r2, #31
 8000a46:	005b      	lsls	r3, r3, #1
 8000a48:	0a6d      	lsrs	r5, r5, #9
 8000a4a:	0e1b      	lsrs	r3, r3, #24
 8000a4c:	4690      	mov	r8, r2
 8000a4e:	d040      	beq.n	8000ad2 <__aeabi_fmul+0xc2>
 8000a50:	2bff      	cmp	r3, #255	; 0xff
 8000a52:	d039      	beq.n	8000ac8 <__aeabi_fmul+0xb8>
 8000a54:	2280      	movs	r2, #128	; 0x80
 8000a56:	2000      	movs	r0, #0
 8000a58:	00ed      	lsls	r5, r5, #3
 8000a5a:	04d2      	lsls	r2, r2, #19
 8000a5c:	4315      	orrs	r5, r2
 8000a5e:	3b7f      	subs	r3, #127	; 0x7f
 8000a60:	18fb      	adds	r3, r7, r3
 8000a62:	4642      	mov	r2, r8
 8000a64:	4657      	mov	r7, sl
 8000a66:	1c59      	adds	r1, r3, #1
 8000a68:	4062      	eors	r2, r4
 8000a6a:	468c      	mov	ip, r1
 8000a6c:	4307      	orrs	r7, r0
 8000a6e:	2f0f      	cmp	r7, #15
 8000a70:	d85c      	bhi.n	8000b2c <__aeabi_fmul+0x11c>
 8000a72:	496f      	ldr	r1, [pc, #444]	; (8000c30 <__aeabi_fmul+0x220>)
 8000a74:	00bf      	lsls	r7, r7, #2
 8000a76:	59c9      	ldr	r1, [r1, r7]
 8000a78:	468f      	mov	pc, r1
 8000a7a:	2e00      	cmp	r6, #0
 8000a7c:	d145      	bne.n	8000b0a <__aeabi_fmul+0xfa>
 8000a7e:	2308      	movs	r3, #8
 8000a80:	469a      	mov	sl, r3
 8000a82:	3b06      	subs	r3, #6
 8000a84:	4699      	mov	r9, r3
 8000a86:	e7da      	b.n	8000a3e <__aeabi_fmul+0x2e>
 8000a88:	4642      	mov	r2, r8
 8000a8a:	2802      	cmp	r0, #2
 8000a8c:	d02d      	beq.n	8000aea <__aeabi_fmul+0xda>
 8000a8e:	2803      	cmp	r0, #3
 8000a90:	d100      	bne.n	8000a94 <__aeabi_fmul+0x84>
 8000a92:	e0c3      	b.n	8000c1c <__aeabi_fmul+0x20c>
 8000a94:	2801      	cmp	r0, #1
 8000a96:	d000      	beq.n	8000a9a <__aeabi_fmul+0x8a>
 8000a98:	e0a2      	b.n	8000be0 <__aeabi_fmul+0x1d0>
 8000a9a:	2500      	movs	r5, #0
 8000a9c:	2600      	movs	r6, #0
 8000a9e:	4002      	ands	r2, r0
 8000aa0:	b2d4      	uxtb	r4, r2
 8000aa2:	0276      	lsls	r6, r6, #9
 8000aa4:	05ed      	lsls	r5, r5, #23
 8000aa6:	0a76      	lsrs	r6, r6, #9
 8000aa8:	432e      	orrs	r6, r5
 8000aaa:	07e4      	lsls	r4, r4, #31
 8000aac:	4326      	orrs	r6, r4
 8000aae:	0030      	movs	r0, r6
 8000ab0:	bc1c      	pop	{r2, r3, r4}
 8000ab2:	4690      	mov	r8, r2
 8000ab4:	4699      	mov	r9, r3
 8000ab6:	46a2      	mov	sl, r4
 8000ab8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000aba:	2e00      	cmp	r6, #0
 8000abc:	d11a      	bne.n	8000af4 <__aeabi_fmul+0xe4>
 8000abe:	2304      	movs	r3, #4
 8000ac0:	469a      	mov	sl, r3
 8000ac2:	3b03      	subs	r3, #3
 8000ac4:	4699      	mov	r9, r3
 8000ac6:	e7ba      	b.n	8000a3e <__aeabi_fmul+0x2e>
 8000ac8:	002a      	movs	r2, r5
 8000aca:	1e51      	subs	r1, r2, #1
 8000acc:	418a      	sbcs	r2, r1
 8000ace:	1c90      	adds	r0, r2, #2
 8000ad0:	e7c6      	b.n	8000a60 <__aeabi_fmul+0x50>
 8000ad2:	2001      	movs	r0, #1
 8000ad4:	2d00      	cmp	r5, #0
 8000ad6:	d0c3      	beq.n	8000a60 <__aeabi_fmul+0x50>
 8000ad8:	0028      	movs	r0, r5
 8000ada:	f001 fead 	bl	8002838 <__clzsi2>
 8000ade:	1f43      	subs	r3, r0, #5
 8000ae0:	3076      	adds	r0, #118	; 0x76
 8000ae2:	409d      	lsls	r5, r3
 8000ae4:	4243      	negs	r3, r0
 8000ae6:	2000      	movs	r0, #0
 8000ae8:	e7ba      	b.n	8000a60 <__aeabi_fmul+0x50>
 8000aea:	2401      	movs	r4, #1
 8000aec:	25ff      	movs	r5, #255	; 0xff
 8000aee:	4014      	ands	r4, r2
 8000af0:	2600      	movs	r6, #0
 8000af2:	e7d6      	b.n	8000aa2 <__aeabi_fmul+0x92>
 8000af4:	0030      	movs	r0, r6
 8000af6:	f001 fe9f 	bl	8002838 <__clzsi2>
 8000afa:	1f43      	subs	r3, r0, #5
 8000afc:	409e      	lsls	r6, r3
 8000afe:	2300      	movs	r3, #0
 8000b00:	3076      	adds	r0, #118	; 0x76
 8000b02:	4247      	negs	r7, r0
 8000b04:	469a      	mov	sl, r3
 8000b06:	4699      	mov	r9, r3
 8000b08:	e799      	b.n	8000a3e <__aeabi_fmul+0x2e>
 8000b0a:	230c      	movs	r3, #12
 8000b0c:	469a      	mov	sl, r3
 8000b0e:	3b09      	subs	r3, #9
 8000b10:	4699      	mov	r9, r3
 8000b12:	e794      	b.n	8000a3e <__aeabi_fmul+0x2e>
 8000b14:	2680      	movs	r6, #128	; 0x80
 8000b16:	2400      	movs	r4, #0
 8000b18:	03f6      	lsls	r6, r6, #15
 8000b1a:	25ff      	movs	r5, #255	; 0xff
 8000b1c:	e7c1      	b.n	8000aa2 <__aeabi_fmul+0x92>
 8000b1e:	0035      	movs	r5, r6
 8000b20:	4648      	mov	r0, r9
 8000b22:	e7b2      	b.n	8000a8a <__aeabi_fmul+0x7a>
 8000b24:	0035      	movs	r5, r6
 8000b26:	0022      	movs	r2, r4
 8000b28:	4648      	mov	r0, r9
 8000b2a:	e7ae      	b.n	8000a8a <__aeabi_fmul+0x7a>
 8000b2c:	0429      	lsls	r1, r5, #16
 8000b2e:	0c09      	lsrs	r1, r1, #16
 8000b30:	0008      	movs	r0, r1
 8000b32:	0c37      	lsrs	r7, r6, #16
 8000b34:	0436      	lsls	r6, r6, #16
 8000b36:	0c36      	lsrs	r6, r6, #16
 8000b38:	0c2c      	lsrs	r4, r5, #16
 8000b3a:	4379      	muls	r1, r7
 8000b3c:	4370      	muls	r0, r6
 8000b3e:	4367      	muls	r7, r4
 8000b40:	4374      	muls	r4, r6
 8000b42:	0c06      	lsrs	r6, r0, #16
 8000b44:	1864      	adds	r4, r4, r1
 8000b46:	1936      	adds	r6, r6, r4
 8000b48:	42b1      	cmp	r1, r6
 8000b4a:	d903      	bls.n	8000b54 <__aeabi_fmul+0x144>
 8000b4c:	2180      	movs	r1, #128	; 0x80
 8000b4e:	0249      	lsls	r1, r1, #9
 8000b50:	4688      	mov	r8, r1
 8000b52:	4447      	add	r7, r8
 8000b54:	0400      	lsls	r0, r0, #16
 8000b56:	0c00      	lsrs	r0, r0, #16
 8000b58:	0431      	lsls	r1, r6, #16
 8000b5a:	1809      	adds	r1, r1, r0
 8000b5c:	018d      	lsls	r5, r1, #6
 8000b5e:	1e68      	subs	r0, r5, #1
 8000b60:	4185      	sbcs	r5, r0
 8000b62:	0e89      	lsrs	r1, r1, #26
 8000b64:	4329      	orrs	r1, r5
 8000b66:	0c35      	lsrs	r5, r6, #16
 8000b68:	19ed      	adds	r5, r5, r7
 8000b6a:	01ad      	lsls	r5, r5, #6
 8000b6c:	430d      	orrs	r5, r1
 8000b6e:	0129      	lsls	r1, r5, #4
 8000b70:	d504      	bpl.n	8000b7c <__aeabi_fmul+0x16c>
 8000b72:	2301      	movs	r3, #1
 8000b74:	0869      	lsrs	r1, r5, #1
 8000b76:	401d      	ands	r5, r3
 8000b78:	4663      	mov	r3, ip
 8000b7a:	430d      	orrs	r5, r1
 8000b7c:	0019      	movs	r1, r3
 8000b7e:	317f      	adds	r1, #127	; 0x7f
 8000b80:	2900      	cmp	r1, #0
 8000b82:	dd25      	ble.n	8000bd0 <__aeabi_fmul+0x1c0>
 8000b84:	0768      	lsls	r0, r5, #29
 8000b86:	d004      	beq.n	8000b92 <__aeabi_fmul+0x182>
 8000b88:	200f      	movs	r0, #15
 8000b8a:	4028      	ands	r0, r5
 8000b8c:	2804      	cmp	r0, #4
 8000b8e:	d000      	beq.n	8000b92 <__aeabi_fmul+0x182>
 8000b90:	3504      	adds	r5, #4
 8000b92:	0128      	lsls	r0, r5, #4
 8000b94:	d503      	bpl.n	8000b9e <__aeabi_fmul+0x18e>
 8000b96:	4927      	ldr	r1, [pc, #156]	; (8000c34 <__aeabi_fmul+0x224>)
 8000b98:	3380      	adds	r3, #128	; 0x80
 8000b9a:	400d      	ands	r5, r1
 8000b9c:	0019      	movs	r1, r3
 8000b9e:	29fe      	cmp	r1, #254	; 0xfe
 8000ba0:	dca3      	bgt.n	8000aea <__aeabi_fmul+0xda>
 8000ba2:	2401      	movs	r4, #1
 8000ba4:	01ad      	lsls	r5, r5, #6
 8000ba6:	0a6e      	lsrs	r6, r5, #9
 8000ba8:	4014      	ands	r4, r2
 8000baa:	b2cd      	uxtb	r5, r1
 8000bac:	e779      	b.n	8000aa2 <__aeabi_fmul+0x92>
 8000bae:	2080      	movs	r0, #128	; 0x80
 8000bb0:	03c0      	lsls	r0, r0, #15
 8000bb2:	4206      	tst	r6, r0
 8000bb4:	d007      	beq.n	8000bc6 <__aeabi_fmul+0x1b6>
 8000bb6:	4205      	tst	r5, r0
 8000bb8:	d105      	bne.n	8000bc6 <__aeabi_fmul+0x1b6>
 8000bba:	4328      	orrs	r0, r5
 8000bbc:	0246      	lsls	r6, r0, #9
 8000bbe:	0a76      	lsrs	r6, r6, #9
 8000bc0:	4644      	mov	r4, r8
 8000bc2:	25ff      	movs	r5, #255	; 0xff
 8000bc4:	e76d      	b.n	8000aa2 <__aeabi_fmul+0x92>
 8000bc6:	4306      	orrs	r6, r0
 8000bc8:	0276      	lsls	r6, r6, #9
 8000bca:	0a76      	lsrs	r6, r6, #9
 8000bcc:	25ff      	movs	r5, #255	; 0xff
 8000bce:	e768      	b.n	8000aa2 <__aeabi_fmul+0x92>
 8000bd0:	2401      	movs	r4, #1
 8000bd2:	1a61      	subs	r1, r4, r1
 8000bd4:	291b      	cmp	r1, #27
 8000bd6:	dd05      	ble.n	8000be4 <__aeabi_fmul+0x1d4>
 8000bd8:	4014      	ands	r4, r2
 8000bda:	2500      	movs	r5, #0
 8000bdc:	2600      	movs	r6, #0
 8000bde:	e760      	b.n	8000aa2 <__aeabi_fmul+0x92>
 8000be0:	4663      	mov	r3, ip
 8000be2:	e7cb      	b.n	8000b7c <__aeabi_fmul+0x16c>
 8000be4:	002e      	movs	r6, r5
 8000be6:	2320      	movs	r3, #32
 8000be8:	40ce      	lsrs	r6, r1
 8000bea:	1a59      	subs	r1, r3, r1
 8000bec:	408d      	lsls	r5, r1
 8000bee:	1e6b      	subs	r3, r5, #1
 8000bf0:	419d      	sbcs	r5, r3
 8000bf2:	432e      	orrs	r6, r5
 8000bf4:	0773      	lsls	r3, r6, #29
 8000bf6:	d004      	beq.n	8000c02 <__aeabi_fmul+0x1f2>
 8000bf8:	230f      	movs	r3, #15
 8000bfa:	4033      	ands	r3, r6
 8000bfc:	2b04      	cmp	r3, #4
 8000bfe:	d000      	beq.n	8000c02 <__aeabi_fmul+0x1f2>
 8000c00:	3604      	adds	r6, #4
 8000c02:	0173      	lsls	r3, r6, #5
 8000c04:	d504      	bpl.n	8000c10 <__aeabi_fmul+0x200>
 8000c06:	2401      	movs	r4, #1
 8000c08:	2501      	movs	r5, #1
 8000c0a:	4014      	ands	r4, r2
 8000c0c:	2600      	movs	r6, #0
 8000c0e:	e748      	b.n	8000aa2 <__aeabi_fmul+0x92>
 8000c10:	2401      	movs	r4, #1
 8000c12:	01b6      	lsls	r6, r6, #6
 8000c14:	0a76      	lsrs	r6, r6, #9
 8000c16:	4014      	ands	r4, r2
 8000c18:	2500      	movs	r5, #0
 8000c1a:	e742      	b.n	8000aa2 <__aeabi_fmul+0x92>
 8000c1c:	2680      	movs	r6, #128	; 0x80
 8000c1e:	2401      	movs	r4, #1
 8000c20:	03f6      	lsls	r6, r6, #15
 8000c22:	432e      	orrs	r6, r5
 8000c24:	0276      	lsls	r6, r6, #9
 8000c26:	0a76      	lsrs	r6, r6, #9
 8000c28:	4014      	ands	r4, r2
 8000c2a:	25ff      	movs	r5, #255	; 0xff
 8000c2c:	e739      	b.n	8000aa2 <__aeabi_fmul+0x92>
 8000c2e:	46c0      	nop			; (mov r8, r8)
 8000c30:	0800d68c 	.word	0x0800d68c
 8000c34:	f7ffffff 	.word	0xf7ffffff

08000c38 <__aeabi_fsub>:
 8000c38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000c3a:	024a      	lsls	r2, r1, #9
 8000c3c:	004e      	lsls	r6, r1, #1
 8000c3e:	0243      	lsls	r3, r0, #9
 8000c40:	0044      	lsls	r4, r0, #1
 8000c42:	0e24      	lsrs	r4, r4, #24
 8000c44:	0fc5      	lsrs	r5, r0, #31
 8000c46:	099b      	lsrs	r3, r3, #6
 8000c48:	0e36      	lsrs	r6, r6, #24
 8000c4a:	0fc9      	lsrs	r1, r1, #31
 8000c4c:	0992      	lsrs	r2, r2, #6
 8000c4e:	2eff      	cmp	r6, #255	; 0xff
 8000c50:	d100      	bne.n	8000c54 <__aeabi_fsub+0x1c>
 8000c52:	e083      	b.n	8000d5c <__aeabi_fsub+0x124>
 8000c54:	2001      	movs	r0, #1
 8000c56:	4041      	eors	r1, r0
 8000c58:	1ba0      	subs	r0, r4, r6
 8000c5a:	42a9      	cmp	r1, r5
 8000c5c:	d05c      	beq.n	8000d18 <__aeabi_fsub+0xe0>
 8000c5e:	2800      	cmp	r0, #0
 8000c60:	dc00      	bgt.n	8000c64 <__aeabi_fsub+0x2c>
 8000c62:	e095      	b.n	8000d90 <__aeabi_fsub+0x158>
 8000c64:	2e00      	cmp	r6, #0
 8000c66:	d11c      	bne.n	8000ca2 <__aeabi_fsub+0x6a>
 8000c68:	2a00      	cmp	r2, #0
 8000c6a:	d000      	beq.n	8000c6e <__aeabi_fsub+0x36>
 8000c6c:	e081      	b.n	8000d72 <__aeabi_fsub+0x13a>
 8000c6e:	075a      	lsls	r2, r3, #29
 8000c70:	d004      	beq.n	8000c7c <__aeabi_fsub+0x44>
 8000c72:	220f      	movs	r2, #15
 8000c74:	401a      	ands	r2, r3
 8000c76:	2a04      	cmp	r2, #4
 8000c78:	d000      	beq.n	8000c7c <__aeabi_fsub+0x44>
 8000c7a:	3304      	adds	r3, #4
 8000c7c:	015a      	lsls	r2, r3, #5
 8000c7e:	d53b      	bpl.n	8000cf8 <__aeabi_fsub+0xc0>
 8000c80:	3401      	adds	r4, #1
 8000c82:	2cff      	cmp	r4, #255	; 0xff
 8000c84:	d100      	bne.n	8000c88 <__aeabi_fsub+0x50>
 8000c86:	e091      	b.n	8000dac <__aeabi_fsub+0x174>
 8000c88:	2001      	movs	r0, #1
 8000c8a:	019b      	lsls	r3, r3, #6
 8000c8c:	0a5b      	lsrs	r3, r3, #9
 8000c8e:	b2e4      	uxtb	r4, r4
 8000c90:	4005      	ands	r5, r0
 8000c92:	025b      	lsls	r3, r3, #9
 8000c94:	05e4      	lsls	r4, r4, #23
 8000c96:	0a5b      	lsrs	r3, r3, #9
 8000c98:	07ed      	lsls	r5, r5, #31
 8000c9a:	4323      	orrs	r3, r4
 8000c9c:	432b      	orrs	r3, r5
 8000c9e:	0018      	movs	r0, r3
 8000ca0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000ca2:	2cff      	cmp	r4, #255	; 0xff
 8000ca4:	d0e3      	beq.n	8000c6e <__aeabi_fsub+0x36>
 8000ca6:	2180      	movs	r1, #128	; 0x80
 8000ca8:	04c9      	lsls	r1, r1, #19
 8000caa:	430a      	orrs	r2, r1
 8000cac:	281b      	cmp	r0, #27
 8000cae:	dd00      	ble.n	8000cb2 <__aeabi_fsub+0x7a>
 8000cb0:	e090      	b.n	8000dd4 <__aeabi_fsub+0x19c>
 8000cb2:	0016      	movs	r6, r2
 8000cb4:	2120      	movs	r1, #32
 8000cb6:	40c6      	lsrs	r6, r0
 8000cb8:	1a08      	subs	r0, r1, r0
 8000cba:	4082      	lsls	r2, r0
 8000cbc:	1e51      	subs	r1, r2, #1
 8000cbe:	418a      	sbcs	r2, r1
 8000cc0:	4332      	orrs	r2, r6
 8000cc2:	1a9b      	subs	r3, r3, r2
 8000cc4:	015a      	lsls	r2, r3, #5
 8000cc6:	d515      	bpl.n	8000cf4 <__aeabi_fsub+0xbc>
 8000cc8:	019b      	lsls	r3, r3, #6
 8000cca:	099e      	lsrs	r6, r3, #6
 8000ccc:	0030      	movs	r0, r6
 8000cce:	f001 fdb3 	bl	8002838 <__clzsi2>
 8000cd2:	3805      	subs	r0, #5
 8000cd4:	4086      	lsls	r6, r0
 8000cd6:	4284      	cmp	r4, r0
 8000cd8:	dc6c      	bgt.n	8000db4 <__aeabi_fsub+0x17c>
 8000cda:	1b04      	subs	r4, r0, r4
 8000cdc:	0033      	movs	r3, r6
 8000cde:	2020      	movs	r0, #32
 8000ce0:	3401      	adds	r4, #1
 8000ce2:	40e3      	lsrs	r3, r4
 8000ce4:	1b04      	subs	r4, r0, r4
 8000ce6:	40a6      	lsls	r6, r4
 8000ce8:	1e72      	subs	r2, r6, #1
 8000cea:	4196      	sbcs	r6, r2
 8000cec:	2400      	movs	r4, #0
 8000cee:	4333      	orrs	r3, r6
 8000cf0:	e7bd      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000cf2:	000d      	movs	r5, r1
 8000cf4:	075a      	lsls	r2, r3, #29
 8000cf6:	d1bc      	bne.n	8000c72 <__aeabi_fsub+0x3a>
 8000cf8:	08df      	lsrs	r7, r3, #3
 8000cfa:	2301      	movs	r3, #1
 8000cfc:	401d      	ands	r5, r3
 8000cfe:	2cff      	cmp	r4, #255	; 0xff
 8000d00:	d133      	bne.n	8000d6a <__aeabi_fsub+0x132>
 8000d02:	2f00      	cmp	r7, #0
 8000d04:	d100      	bne.n	8000d08 <__aeabi_fsub+0xd0>
 8000d06:	e090      	b.n	8000e2a <__aeabi_fsub+0x1f2>
 8000d08:	2280      	movs	r2, #128	; 0x80
 8000d0a:	03d2      	lsls	r2, r2, #15
 8000d0c:	0013      	movs	r3, r2
 8000d0e:	433b      	orrs	r3, r7
 8000d10:	025b      	lsls	r3, r3, #9
 8000d12:	0a5b      	lsrs	r3, r3, #9
 8000d14:	24ff      	movs	r4, #255	; 0xff
 8000d16:	e7bc      	b.n	8000c92 <__aeabi_fsub+0x5a>
 8000d18:	2800      	cmp	r0, #0
 8000d1a:	dd4f      	ble.n	8000dbc <__aeabi_fsub+0x184>
 8000d1c:	2e00      	cmp	r6, #0
 8000d1e:	d02e      	beq.n	8000d7e <__aeabi_fsub+0x146>
 8000d20:	2cff      	cmp	r4, #255	; 0xff
 8000d22:	d0a4      	beq.n	8000c6e <__aeabi_fsub+0x36>
 8000d24:	2580      	movs	r5, #128	; 0x80
 8000d26:	04ed      	lsls	r5, r5, #19
 8000d28:	432a      	orrs	r2, r5
 8000d2a:	281b      	cmp	r0, #27
 8000d2c:	dd00      	ble.n	8000d30 <__aeabi_fsub+0xf8>
 8000d2e:	e097      	b.n	8000e60 <__aeabi_fsub+0x228>
 8000d30:	0016      	movs	r6, r2
 8000d32:	2520      	movs	r5, #32
 8000d34:	40c6      	lsrs	r6, r0
 8000d36:	1a28      	subs	r0, r5, r0
 8000d38:	4082      	lsls	r2, r0
 8000d3a:	1e50      	subs	r0, r2, #1
 8000d3c:	4182      	sbcs	r2, r0
 8000d3e:	4332      	orrs	r2, r6
 8000d40:	189b      	adds	r3, r3, r2
 8000d42:	015a      	lsls	r2, r3, #5
 8000d44:	d5d5      	bpl.n	8000cf2 <__aeabi_fsub+0xba>
 8000d46:	3401      	adds	r4, #1
 8000d48:	2cff      	cmp	r4, #255	; 0xff
 8000d4a:	d06d      	beq.n	8000e28 <__aeabi_fsub+0x1f0>
 8000d4c:	2201      	movs	r2, #1
 8000d4e:	487b      	ldr	r0, [pc, #492]	; (8000f3c <__aeabi_fsub+0x304>)
 8000d50:	401a      	ands	r2, r3
 8000d52:	085b      	lsrs	r3, r3, #1
 8000d54:	4003      	ands	r3, r0
 8000d56:	4313      	orrs	r3, r2
 8000d58:	000d      	movs	r5, r1
 8000d5a:	e788      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000d5c:	2a00      	cmp	r2, #0
 8000d5e:	d000      	beq.n	8000d62 <__aeabi_fsub+0x12a>
 8000d60:	e77a      	b.n	8000c58 <__aeabi_fsub+0x20>
 8000d62:	e777      	b.n	8000c54 <__aeabi_fsub+0x1c>
 8000d64:	1e03      	subs	r3, r0, #0
 8000d66:	d1c5      	bne.n	8000cf4 <__aeabi_fsub+0xbc>
 8000d68:	2500      	movs	r5, #0
 8000d6a:	027b      	lsls	r3, r7, #9
 8000d6c:	0a5b      	lsrs	r3, r3, #9
 8000d6e:	b2e4      	uxtb	r4, r4
 8000d70:	e78f      	b.n	8000c92 <__aeabi_fsub+0x5a>
 8000d72:	3801      	subs	r0, #1
 8000d74:	2800      	cmp	r0, #0
 8000d76:	d0a4      	beq.n	8000cc2 <__aeabi_fsub+0x8a>
 8000d78:	2cff      	cmp	r4, #255	; 0xff
 8000d7a:	d197      	bne.n	8000cac <__aeabi_fsub+0x74>
 8000d7c:	e777      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000d7e:	2a00      	cmp	r2, #0
 8000d80:	d100      	bne.n	8000d84 <__aeabi_fsub+0x14c>
 8000d82:	e774      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000d84:	3801      	subs	r0, #1
 8000d86:	2800      	cmp	r0, #0
 8000d88:	d0da      	beq.n	8000d40 <__aeabi_fsub+0x108>
 8000d8a:	2cff      	cmp	r4, #255	; 0xff
 8000d8c:	d1cd      	bne.n	8000d2a <__aeabi_fsub+0xf2>
 8000d8e:	e76e      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000d90:	2800      	cmp	r0, #0
 8000d92:	d121      	bne.n	8000dd8 <__aeabi_fsub+0x1a0>
 8000d94:	1c60      	adds	r0, r4, #1
 8000d96:	b2c0      	uxtb	r0, r0
 8000d98:	2801      	cmp	r0, #1
 8000d9a:	dd58      	ble.n	8000e4e <__aeabi_fsub+0x216>
 8000d9c:	2780      	movs	r7, #128	; 0x80
 8000d9e:	1a9e      	subs	r6, r3, r2
 8000da0:	04ff      	lsls	r7, r7, #19
 8000da2:	4037      	ands	r7, r6
 8000da4:	d02f      	beq.n	8000e06 <__aeabi_fsub+0x1ce>
 8000da6:	1ad6      	subs	r6, r2, r3
 8000da8:	000d      	movs	r5, r1
 8000daa:	e78f      	b.n	8000ccc <__aeabi_fsub+0x94>
 8000dac:	2301      	movs	r3, #1
 8000dae:	401d      	ands	r5, r3
 8000db0:	2300      	movs	r3, #0
 8000db2:	e76e      	b.n	8000c92 <__aeabi_fsub+0x5a>
 8000db4:	4b62      	ldr	r3, [pc, #392]	; (8000f40 <__aeabi_fsub+0x308>)
 8000db6:	1a24      	subs	r4, r4, r0
 8000db8:	4033      	ands	r3, r6
 8000dba:	e758      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000dbc:	2800      	cmp	r0, #0
 8000dbe:	d151      	bne.n	8000e64 <__aeabi_fsub+0x22c>
 8000dc0:	1c60      	adds	r0, r4, #1
 8000dc2:	b2c6      	uxtb	r6, r0
 8000dc4:	2e01      	cmp	r6, #1
 8000dc6:	dd33      	ble.n	8000e30 <__aeabi_fsub+0x1f8>
 8000dc8:	28ff      	cmp	r0, #255	; 0xff
 8000dca:	d02d      	beq.n	8000e28 <__aeabi_fsub+0x1f0>
 8000dcc:	189b      	adds	r3, r3, r2
 8000dce:	085b      	lsrs	r3, r3, #1
 8000dd0:	0004      	movs	r4, r0
 8000dd2:	e74c      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000dd4:	2201      	movs	r2, #1
 8000dd6:	e774      	b.n	8000cc2 <__aeabi_fsub+0x8a>
 8000dd8:	2c00      	cmp	r4, #0
 8000dda:	d01a      	beq.n	8000e12 <__aeabi_fsub+0x1da>
 8000ddc:	2eff      	cmp	r6, #255	; 0xff
 8000dde:	d01f      	beq.n	8000e20 <__aeabi_fsub+0x1e8>
 8000de0:	2480      	movs	r4, #128	; 0x80
 8000de2:	04e4      	lsls	r4, r4, #19
 8000de4:	4240      	negs	r0, r0
 8000de6:	4323      	orrs	r3, r4
 8000de8:	281b      	cmp	r0, #27
 8000dea:	dd00      	ble.n	8000dee <__aeabi_fsub+0x1b6>
 8000dec:	e096      	b.n	8000f1c <__aeabi_fsub+0x2e4>
 8000dee:	001d      	movs	r5, r3
 8000df0:	2420      	movs	r4, #32
 8000df2:	40c5      	lsrs	r5, r0
 8000df4:	1a20      	subs	r0, r4, r0
 8000df6:	4083      	lsls	r3, r0
 8000df8:	1e58      	subs	r0, r3, #1
 8000dfa:	4183      	sbcs	r3, r0
 8000dfc:	432b      	orrs	r3, r5
 8000dfe:	1ad3      	subs	r3, r2, r3
 8000e00:	0034      	movs	r4, r6
 8000e02:	000d      	movs	r5, r1
 8000e04:	e75e      	b.n	8000cc4 <__aeabi_fsub+0x8c>
 8000e06:	2e00      	cmp	r6, #0
 8000e08:	d000      	beq.n	8000e0c <__aeabi_fsub+0x1d4>
 8000e0a:	e75f      	b.n	8000ccc <__aeabi_fsub+0x94>
 8000e0c:	2500      	movs	r5, #0
 8000e0e:	2400      	movs	r4, #0
 8000e10:	e7ab      	b.n	8000d6a <__aeabi_fsub+0x132>
 8000e12:	2b00      	cmp	r3, #0
 8000e14:	d044      	beq.n	8000ea0 <__aeabi_fsub+0x268>
 8000e16:	43c0      	mvns	r0, r0
 8000e18:	2800      	cmp	r0, #0
 8000e1a:	d0f0      	beq.n	8000dfe <__aeabi_fsub+0x1c6>
 8000e1c:	2eff      	cmp	r6, #255	; 0xff
 8000e1e:	d1e3      	bne.n	8000de8 <__aeabi_fsub+0x1b0>
 8000e20:	0013      	movs	r3, r2
 8000e22:	24ff      	movs	r4, #255	; 0xff
 8000e24:	000d      	movs	r5, r1
 8000e26:	e722      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000e28:	000d      	movs	r5, r1
 8000e2a:	24ff      	movs	r4, #255	; 0xff
 8000e2c:	2300      	movs	r3, #0
 8000e2e:	e730      	b.n	8000c92 <__aeabi_fsub+0x5a>
 8000e30:	2c00      	cmp	r4, #0
 8000e32:	d15d      	bne.n	8000ef0 <__aeabi_fsub+0x2b8>
 8000e34:	2b00      	cmp	r3, #0
 8000e36:	d07d      	beq.n	8000f34 <__aeabi_fsub+0x2fc>
 8000e38:	2a00      	cmp	r2, #0
 8000e3a:	d100      	bne.n	8000e3e <__aeabi_fsub+0x206>
 8000e3c:	e717      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000e3e:	189b      	adds	r3, r3, r2
 8000e40:	015a      	lsls	r2, r3, #5
 8000e42:	d400      	bmi.n	8000e46 <__aeabi_fsub+0x20e>
 8000e44:	e756      	b.n	8000cf4 <__aeabi_fsub+0xbc>
 8000e46:	4a3e      	ldr	r2, [pc, #248]	; (8000f40 <__aeabi_fsub+0x308>)
 8000e48:	0004      	movs	r4, r0
 8000e4a:	4013      	ands	r3, r2
 8000e4c:	e70f      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000e4e:	2c00      	cmp	r4, #0
 8000e50:	d11e      	bne.n	8000e90 <__aeabi_fsub+0x258>
 8000e52:	2b00      	cmp	r3, #0
 8000e54:	d12f      	bne.n	8000eb6 <__aeabi_fsub+0x27e>
 8000e56:	2a00      	cmp	r2, #0
 8000e58:	d065      	beq.n	8000f26 <__aeabi_fsub+0x2ee>
 8000e5a:	0013      	movs	r3, r2
 8000e5c:	000d      	movs	r5, r1
 8000e5e:	e706      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000e60:	2201      	movs	r2, #1
 8000e62:	e76d      	b.n	8000d40 <__aeabi_fsub+0x108>
 8000e64:	2c00      	cmp	r4, #0
 8000e66:	d11f      	bne.n	8000ea8 <__aeabi_fsub+0x270>
 8000e68:	2b00      	cmp	r3, #0
 8000e6a:	d059      	beq.n	8000f20 <__aeabi_fsub+0x2e8>
 8000e6c:	43c0      	mvns	r0, r0
 8000e6e:	2800      	cmp	r0, #0
 8000e70:	d00b      	beq.n	8000e8a <__aeabi_fsub+0x252>
 8000e72:	2eff      	cmp	r6, #255	; 0xff
 8000e74:	d04f      	beq.n	8000f16 <__aeabi_fsub+0x2de>
 8000e76:	281b      	cmp	r0, #27
 8000e78:	dc5e      	bgt.n	8000f38 <__aeabi_fsub+0x300>
 8000e7a:	001d      	movs	r5, r3
 8000e7c:	2420      	movs	r4, #32
 8000e7e:	40c5      	lsrs	r5, r0
 8000e80:	1a20      	subs	r0, r4, r0
 8000e82:	4083      	lsls	r3, r0
 8000e84:	1e58      	subs	r0, r3, #1
 8000e86:	4183      	sbcs	r3, r0
 8000e88:	432b      	orrs	r3, r5
 8000e8a:	189b      	adds	r3, r3, r2
 8000e8c:	0034      	movs	r4, r6
 8000e8e:	e758      	b.n	8000d42 <__aeabi_fsub+0x10a>
 8000e90:	2b00      	cmp	r3, #0
 8000e92:	d11c      	bne.n	8000ece <__aeabi_fsub+0x296>
 8000e94:	2a00      	cmp	r2, #0
 8000e96:	d049      	beq.n	8000f2c <__aeabi_fsub+0x2f4>
 8000e98:	0013      	movs	r3, r2
 8000e9a:	000d      	movs	r5, r1
 8000e9c:	24ff      	movs	r4, #255	; 0xff
 8000e9e:	e6e6      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000ea0:	0013      	movs	r3, r2
 8000ea2:	0034      	movs	r4, r6
 8000ea4:	000d      	movs	r5, r1
 8000ea6:	e6e2      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000ea8:	2eff      	cmp	r6, #255	; 0xff
 8000eaa:	d034      	beq.n	8000f16 <__aeabi_fsub+0x2de>
 8000eac:	2480      	movs	r4, #128	; 0x80
 8000eae:	04e4      	lsls	r4, r4, #19
 8000eb0:	4240      	negs	r0, r0
 8000eb2:	4323      	orrs	r3, r4
 8000eb4:	e7df      	b.n	8000e76 <__aeabi_fsub+0x23e>
 8000eb6:	2a00      	cmp	r2, #0
 8000eb8:	d100      	bne.n	8000ebc <__aeabi_fsub+0x284>
 8000eba:	e6d8      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000ebc:	2780      	movs	r7, #128	; 0x80
 8000ebe:	1a98      	subs	r0, r3, r2
 8000ec0:	04ff      	lsls	r7, r7, #19
 8000ec2:	4007      	ands	r7, r0
 8000ec4:	d100      	bne.n	8000ec8 <__aeabi_fsub+0x290>
 8000ec6:	e74d      	b.n	8000d64 <__aeabi_fsub+0x12c>
 8000ec8:	1ad3      	subs	r3, r2, r3
 8000eca:	000d      	movs	r5, r1
 8000ecc:	e6cf      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000ece:	24ff      	movs	r4, #255	; 0xff
 8000ed0:	2a00      	cmp	r2, #0
 8000ed2:	d100      	bne.n	8000ed6 <__aeabi_fsub+0x29e>
 8000ed4:	e6cb      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000ed6:	2080      	movs	r0, #128	; 0x80
 8000ed8:	08db      	lsrs	r3, r3, #3
 8000eda:	03c0      	lsls	r0, r0, #15
 8000edc:	4203      	tst	r3, r0
 8000ede:	d004      	beq.n	8000eea <__aeabi_fsub+0x2b2>
 8000ee0:	08d2      	lsrs	r2, r2, #3
 8000ee2:	4202      	tst	r2, r0
 8000ee4:	d101      	bne.n	8000eea <__aeabi_fsub+0x2b2>
 8000ee6:	0013      	movs	r3, r2
 8000ee8:	000d      	movs	r5, r1
 8000eea:	00db      	lsls	r3, r3, #3
 8000eec:	24ff      	movs	r4, #255	; 0xff
 8000eee:	e6be      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000ef0:	2b00      	cmp	r3, #0
 8000ef2:	d010      	beq.n	8000f16 <__aeabi_fsub+0x2de>
 8000ef4:	24ff      	movs	r4, #255	; 0xff
 8000ef6:	2a00      	cmp	r2, #0
 8000ef8:	d100      	bne.n	8000efc <__aeabi_fsub+0x2c4>
 8000efa:	e6b8      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000efc:	2080      	movs	r0, #128	; 0x80
 8000efe:	08db      	lsrs	r3, r3, #3
 8000f00:	03c0      	lsls	r0, r0, #15
 8000f02:	4203      	tst	r3, r0
 8000f04:	d003      	beq.n	8000f0e <__aeabi_fsub+0x2d6>
 8000f06:	08d2      	lsrs	r2, r2, #3
 8000f08:	4202      	tst	r2, r0
 8000f0a:	d100      	bne.n	8000f0e <__aeabi_fsub+0x2d6>
 8000f0c:	0013      	movs	r3, r2
 8000f0e:	00db      	lsls	r3, r3, #3
 8000f10:	000d      	movs	r5, r1
 8000f12:	24ff      	movs	r4, #255	; 0xff
 8000f14:	e6ab      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000f16:	0013      	movs	r3, r2
 8000f18:	24ff      	movs	r4, #255	; 0xff
 8000f1a:	e6a8      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000f1c:	2301      	movs	r3, #1
 8000f1e:	e76e      	b.n	8000dfe <__aeabi_fsub+0x1c6>
 8000f20:	0013      	movs	r3, r2
 8000f22:	0034      	movs	r4, r6
 8000f24:	e6a3      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000f26:	2700      	movs	r7, #0
 8000f28:	2500      	movs	r5, #0
 8000f2a:	e71e      	b.n	8000d6a <__aeabi_fsub+0x132>
 8000f2c:	2780      	movs	r7, #128	; 0x80
 8000f2e:	2500      	movs	r5, #0
 8000f30:	03ff      	lsls	r7, r7, #15
 8000f32:	e6e9      	b.n	8000d08 <__aeabi_fsub+0xd0>
 8000f34:	0013      	movs	r3, r2
 8000f36:	e69a      	b.n	8000c6e <__aeabi_fsub+0x36>
 8000f38:	2301      	movs	r3, #1
 8000f3a:	e7a6      	b.n	8000e8a <__aeabi_fsub+0x252>
 8000f3c:	7dffffff 	.word	0x7dffffff
 8000f40:	fbffffff 	.word	0xfbffffff

08000f44 <__aeabi_fcmpun>:
 8000f44:	0243      	lsls	r3, r0, #9
 8000f46:	0a5a      	lsrs	r2, r3, #9
 8000f48:	0040      	lsls	r0, r0, #1
 8000f4a:	024b      	lsls	r3, r1, #9
 8000f4c:	0049      	lsls	r1, r1, #1
 8000f4e:	0e00      	lsrs	r0, r0, #24
 8000f50:	0a5b      	lsrs	r3, r3, #9
 8000f52:	0e09      	lsrs	r1, r1, #24
 8000f54:	28ff      	cmp	r0, #255	; 0xff
 8000f56:	d003      	beq.n	8000f60 <__aeabi_fcmpun+0x1c>
 8000f58:	2000      	movs	r0, #0
 8000f5a:	29ff      	cmp	r1, #255	; 0xff
 8000f5c:	d006      	beq.n	8000f6c <__aeabi_fcmpun+0x28>
 8000f5e:	4770      	bx	lr
 8000f60:	38fe      	subs	r0, #254	; 0xfe
 8000f62:	2a00      	cmp	r2, #0
 8000f64:	d1fb      	bne.n	8000f5e <__aeabi_fcmpun+0x1a>
 8000f66:	2000      	movs	r0, #0
 8000f68:	29ff      	cmp	r1, #255	; 0xff
 8000f6a:	d1f8      	bne.n	8000f5e <__aeabi_fcmpun+0x1a>
 8000f6c:	0018      	movs	r0, r3
 8000f6e:	1e43      	subs	r3, r0, #1
 8000f70:	4198      	sbcs	r0, r3
 8000f72:	e7f4      	b.n	8000f5e <__aeabi_fcmpun+0x1a>

08000f74 <__aeabi_f2iz>:
 8000f74:	0243      	lsls	r3, r0, #9
 8000f76:	0a59      	lsrs	r1, r3, #9
 8000f78:	0043      	lsls	r3, r0, #1
 8000f7a:	0fc2      	lsrs	r2, r0, #31
 8000f7c:	0e1b      	lsrs	r3, r3, #24
 8000f7e:	2000      	movs	r0, #0
 8000f80:	2b7e      	cmp	r3, #126	; 0x7e
 8000f82:	dd0e      	ble.n	8000fa2 <__aeabi_f2iz+0x2e>
 8000f84:	2b9d      	cmp	r3, #157	; 0x9d
 8000f86:	dc0d      	bgt.n	8000fa4 <__aeabi_f2iz+0x30>
 8000f88:	2080      	movs	r0, #128	; 0x80
 8000f8a:	0400      	lsls	r0, r0, #16
 8000f8c:	4301      	orrs	r1, r0
 8000f8e:	2b95      	cmp	r3, #149	; 0x95
 8000f90:	dc0b      	bgt.n	8000faa <__aeabi_f2iz+0x36>
 8000f92:	2096      	movs	r0, #150	; 0x96
 8000f94:	1ac3      	subs	r3, r0, r3
 8000f96:	40d9      	lsrs	r1, r3
 8000f98:	000b      	movs	r3, r1
 8000f9a:	4258      	negs	r0, r3
 8000f9c:	2a00      	cmp	r2, #0
 8000f9e:	d100      	bne.n	8000fa2 <__aeabi_f2iz+0x2e>
 8000fa0:	0018      	movs	r0, r3
 8000fa2:	4770      	bx	lr
 8000fa4:	4b03      	ldr	r3, [pc, #12]	; (8000fb4 <__aeabi_f2iz+0x40>)
 8000fa6:	18d0      	adds	r0, r2, r3
 8000fa8:	e7fb      	b.n	8000fa2 <__aeabi_f2iz+0x2e>
 8000faa:	3b96      	subs	r3, #150	; 0x96
 8000fac:	4099      	lsls	r1, r3
 8000fae:	000b      	movs	r3, r1
 8000fb0:	e7f3      	b.n	8000f9a <__aeabi_f2iz+0x26>
 8000fb2:	46c0      	nop			; (mov r8, r8)
 8000fb4:	7fffffff 	.word	0x7fffffff

08000fb8 <__aeabi_i2f>:
 8000fb8:	b570      	push	{r4, r5, r6, lr}
 8000fba:	2800      	cmp	r0, #0
 8000fbc:	d030      	beq.n	8001020 <__aeabi_i2f+0x68>
 8000fbe:	17c3      	asrs	r3, r0, #31
 8000fc0:	18c5      	adds	r5, r0, r3
 8000fc2:	405d      	eors	r5, r3
 8000fc4:	0fc4      	lsrs	r4, r0, #31
 8000fc6:	0028      	movs	r0, r5
 8000fc8:	f001 fc36 	bl	8002838 <__clzsi2>
 8000fcc:	239e      	movs	r3, #158	; 0x9e
 8000fce:	1a1b      	subs	r3, r3, r0
 8000fd0:	2b96      	cmp	r3, #150	; 0x96
 8000fd2:	dc0d      	bgt.n	8000ff0 <__aeabi_i2f+0x38>
 8000fd4:	2296      	movs	r2, #150	; 0x96
 8000fd6:	1ad2      	subs	r2, r2, r3
 8000fd8:	4095      	lsls	r5, r2
 8000fda:	026a      	lsls	r2, r5, #9
 8000fdc:	0a52      	lsrs	r2, r2, #9
 8000fde:	b2d8      	uxtb	r0, r3
 8000fe0:	0252      	lsls	r2, r2, #9
 8000fe2:	05c0      	lsls	r0, r0, #23
 8000fe4:	0a52      	lsrs	r2, r2, #9
 8000fe6:	07e4      	lsls	r4, r4, #31
 8000fe8:	4302      	orrs	r2, r0
 8000fea:	4322      	orrs	r2, r4
 8000fec:	0010      	movs	r0, r2
 8000fee:	bd70      	pop	{r4, r5, r6, pc}
 8000ff0:	2b99      	cmp	r3, #153	; 0x99
 8000ff2:	dc19      	bgt.n	8001028 <__aeabi_i2f+0x70>
 8000ff4:	2299      	movs	r2, #153	; 0x99
 8000ff6:	1ad2      	subs	r2, r2, r3
 8000ff8:	4095      	lsls	r5, r2
 8000ffa:	4a12      	ldr	r2, [pc, #72]	; (8001044 <__aeabi_i2f+0x8c>)
 8000ffc:	402a      	ands	r2, r5
 8000ffe:	0769      	lsls	r1, r5, #29
 8001000:	d004      	beq.n	800100c <__aeabi_i2f+0x54>
 8001002:	210f      	movs	r1, #15
 8001004:	400d      	ands	r5, r1
 8001006:	2d04      	cmp	r5, #4
 8001008:	d000      	beq.n	800100c <__aeabi_i2f+0x54>
 800100a:	3204      	adds	r2, #4
 800100c:	0151      	lsls	r1, r2, #5
 800100e:	d503      	bpl.n	8001018 <__aeabi_i2f+0x60>
 8001010:	4b0c      	ldr	r3, [pc, #48]	; (8001044 <__aeabi_i2f+0x8c>)
 8001012:	401a      	ands	r2, r3
 8001014:	239f      	movs	r3, #159	; 0x9f
 8001016:	1a1b      	subs	r3, r3, r0
 8001018:	0192      	lsls	r2, r2, #6
 800101a:	0a52      	lsrs	r2, r2, #9
 800101c:	b2d8      	uxtb	r0, r3
 800101e:	e7df      	b.n	8000fe0 <__aeabi_i2f+0x28>
 8001020:	2400      	movs	r4, #0
 8001022:	2000      	movs	r0, #0
 8001024:	2200      	movs	r2, #0
 8001026:	e7db      	b.n	8000fe0 <__aeabi_i2f+0x28>
 8001028:	2205      	movs	r2, #5
 800102a:	002e      	movs	r6, r5
 800102c:	1a12      	subs	r2, r2, r0
 800102e:	21b9      	movs	r1, #185	; 0xb9
 8001030:	40d6      	lsrs	r6, r2
 8001032:	002a      	movs	r2, r5
 8001034:	1ac9      	subs	r1, r1, r3
 8001036:	408a      	lsls	r2, r1
 8001038:	1e55      	subs	r5, r2, #1
 800103a:	41aa      	sbcs	r2, r5
 800103c:	0035      	movs	r5, r6
 800103e:	4315      	orrs	r5, r2
 8001040:	e7db      	b.n	8000ffa <__aeabi_i2f+0x42>
 8001042:	46c0      	nop			; (mov r8, r8)
 8001044:	fbffffff 	.word	0xfbffffff

08001048 <__aeabi_ui2f>:
 8001048:	b570      	push	{r4, r5, r6, lr}
 800104a:	1e04      	subs	r4, r0, #0
 800104c:	d028      	beq.n	80010a0 <__aeabi_ui2f+0x58>
 800104e:	f001 fbf3 	bl	8002838 <__clzsi2>
 8001052:	239e      	movs	r3, #158	; 0x9e
 8001054:	1a1b      	subs	r3, r3, r0
 8001056:	2b96      	cmp	r3, #150	; 0x96
 8001058:	dc0a      	bgt.n	8001070 <__aeabi_ui2f+0x28>
 800105a:	2296      	movs	r2, #150	; 0x96
 800105c:	1ad2      	subs	r2, r2, r3
 800105e:	4094      	lsls	r4, r2
 8001060:	0262      	lsls	r2, r4, #9
 8001062:	0a52      	lsrs	r2, r2, #9
 8001064:	b2d8      	uxtb	r0, r3
 8001066:	0252      	lsls	r2, r2, #9
 8001068:	0a52      	lsrs	r2, r2, #9
 800106a:	05c0      	lsls	r0, r0, #23
 800106c:	4310      	orrs	r0, r2
 800106e:	bd70      	pop	{r4, r5, r6, pc}
 8001070:	2b99      	cmp	r3, #153	; 0x99
 8001072:	dc18      	bgt.n	80010a6 <__aeabi_ui2f+0x5e>
 8001074:	2299      	movs	r2, #153	; 0x99
 8001076:	1ad2      	subs	r2, r2, r3
 8001078:	4094      	lsls	r4, r2
 800107a:	4a11      	ldr	r2, [pc, #68]	; (80010c0 <__aeabi_ui2f+0x78>)
 800107c:	4022      	ands	r2, r4
 800107e:	0761      	lsls	r1, r4, #29
 8001080:	d004      	beq.n	800108c <__aeabi_ui2f+0x44>
 8001082:	210f      	movs	r1, #15
 8001084:	400c      	ands	r4, r1
 8001086:	2c04      	cmp	r4, #4
 8001088:	d000      	beq.n	800108c <__aeabi_ui2f+0x44>
 800108a:	3204      	adds	r2, #4
 800108c:	0151      	lsls	r1, r2, #5
 800108e:	d503      	bpl.n	8001098 <__aeabi_ui2f+0x50>
 8001090:	4b0b      	ldr	r3, [pc, #44]	; (80010c0 <__aeabi_ui2f+0x78>)
 8001092:	401a      	ands	r2, r3
 8001094:	239f      	movs	r3, #159	; 0x9f
 8001096:	1a1b      	subs	r3, r3, r0
 8001098:	0192      	lsls	r2, r2, #6
 800109a:	0a52      	lsrs	r2, r2, #9
 800109c:	b2d8      	uxtb	r0, r3
 800109e:	e7e2      	b.n	8001066 <__aeabi_ui2f+0x1e>
 80010a0:	2000      	movs	r0, #0
 80010a2:	2200      	movs	r2, #0
 80010a4:	e7df      	b.n	8001066 <__aeabi_ui2f+0x1e>
 80010a6:	2205      	movs	r2, #5
 80010a8:	0025      	movs	r5, r4
 80010aa:	1a12      	subs	r2, r2, r0
 80010ac:	21b9      	movs	r1, #185	; 0xb9
 80010ae:	40d5      	lsrs	r5, r2
 80010b0:	0022      	movs	r2, r4
 80010b2:	1ac9      	subs	r1, r1, r3
 80010b4:	408a      	lsls	r2, r1
 80010b6:	1e54      	subs	r4, r2, #1
 80010b8:	41a2      	sbcs	r2, r4
 80010ba:	002c      	movs	r4, r5
 80010bc:	4314      	orrs	r4, r2
 80010be:	e7dc      	b.n	800107a <__aeabi_ui2f+0x32>
 80010c0:	fbffffff 	.word	0xfbffffff

080010c4 <__aeabi_dadd>:
 80010c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80010c6:	4656      	mov	r6, sl
 80010c8:	465f      	mov	r7, fp
 80010ca:	464d      	mov	r5, r9
 80010cc:	4644      	mov	r4, r8
 80010ce:	b4f0      	push	{r4, r5, r6, r7}
 80010d0:	000f      	movs	r7, r1
 80010d2:	0ffd      	lsrs	r5, r7, #31
 80010d4:	46aa      	mov	sl, r5
 80010d6:	0309      	lsls	r1, r1, #12
 80010d8:	007c      	lsls	r4, r7, #1
 80010da:	002e      	movs	r6, r5
 80010dc:	005f      	lsls	r7, r3, #1
 80010de:	0f45      	lsrs	r5, r0, #29
 80010e0:	0a49      	lsrs	r1, r1, #9
 80010e2:	0d7f      	lsrs	r7, r7, #21
 80010e4:	4329      	orrs	r1, r5
 80010e6:	00c5      	lsls	r5, r0, #3
 80010e8:	0318      	lsls	r0, r3, #12
 80010ea:	46bc      	mov	ip, r7
 80010ec:	0a40      	lsrs	r0, r0, #9
 80010ee:	0f57      	lsrs	r7, r2, #29
 80010f0:	0d64      	lsrs	r4, r4, #21
 80010f2:	0fdb      	lsrs	r3, r3, #31
 80010f4:	4338      	orrs	r0, r7
 80010f6:	00d2      	lsls	r2, r2, #3
 80010f8:	459a      	cmp	sl, r3
 80010fa:	d100      	bne.n	80010fe <__aeabi_dadd+0x3a>
 80010fc:	e0aa      	b.n	8001254 <__aeabi_dadd+0x190>
 80010fe:	4666      	mov	r6, ip
 8001100:	1ba6      	subs	r6, r4, r6
 8001102:	2e00      	cmp	r6, #0
 8001104:	dc00      	bgt.n	8001108 <__aeabi_dadd+0x44>
 8001106:	e0ff      	b.n	8001308 <__aeabi_dadd+0x244>
 8001108:	4663      	mov	r3, ip
 800110a:	2b00      	cmp	r3, #0
 800110c:	d139      	bne.n	8001182 <__aeabi_dadd+0xbe>
 800110e:	0003      	movs	r3, r0
 8001110:	4313      	orrs	r3, r2
 8001112:	d000      	beq.n	8001116 <__aeabi_dadd+0x52>
 8001114:	e0d9      	b.n	80012ca <__aeabi_dadd+0x206>
 8001116:	076b      	lsls	r3, r5, #29
 8001118:	d009      	beq.n	800112e <__aeabi_dadd+0x6a>
 800111a:	230f      	movs	r3, #15
 800111c:	402b      	ands	r3, r5
 800111e:	2b04      	cmp	r3, #4
 8001120:	d005      	beq.n	800112e <__aeabi_dadd+0x6a>
 8001122:	1d2b      	adds	r3, r5, #4
 8001124:	42ab      	cmp	r3, r5
 8001126:	41ad      	sbcs	r5, r5
 8001128:	426d      	negs	r5, r5
 800112a:	1949      	adds	r1, r1, r5
 800112c:	001d      	movs	r5, r3
 800112e:	020b      	lsls	r3, r1, #8
 8001130:	d400      	bmi.n	8001134 <__aeabi_dadd+0x70>
 8001132:	e082      	b.n	800123a <__aeabi_dadd+0x176>
 8001134:	4bca      	ldr	r3, [pc, #808]	; (8001460 <__aeabi_dadd+0x39c>)
 8001136:	3401      	adds	r4, #1
 8001138:	429c      	cmp	r4, r3
 800113a:	d100      	bne.n	800113e <__aeabi_dadd+0x7a>
 800113c:	e0fe      	b.n	800133c <__aeabi_dadd+0x278>
 800113e:	000a      	movs	r2, r1
 8001140:	4656      	mov	r6, sl
 8001142:	4bc8      	ldr	r3, [pc, #800]	; (8001464 <__aeabi_dadd+0x3a0>)
 8001144:	08ed      	lsrs	r5, r5, #3
 8001146:	401a      	ands	r2, r3
 8001148:	0750      	lsls	r0, r2, #29
 800114a:	0564      	lsls	r4, r4, #21
 800114c:	0252      	lsls	r2, r2, #9
 800114e:	4305      	orrs	r5, r0
 8001150:	0b12      	lsrs	r2, r2, #12
 8001152:	0d64      	lsrs	r4, r4, #21
 8001154:	2100      	movs	r1, #0
 8001156:	0312      	lsls	r2, r2, #12
 8001158:	0d0b      	lsrs	r3, r1, #20
 800115a:	051b      	lsls	r3, r3, #20
 800115c:	0564      	lsls	r4, r4, #21
 800115e:	0b12      	lsrs	r2, r2, #12
 8001160:	431a      	orrs	r2, r3
 8001162:	0863      	lsrs	r3, r4, #1
 8001164:	4cc0      	ldr	r4, [pc, #768]	; (8001468 <__aeabi_dadd+0x3a4>)
 8001166:	07f6      	lsls	r6, r6, #31
 8001168:	4014      	ands	r4, r2
 800116a:	431c      	orrs	r4, r3
 800116c:	0064      	lsls	r4, r4, #1
 800116e:	0864      	lsrs	r4, r4, #1
 8001170:	4334      	orrs	r4, r6
 8001172:	0028      	movs	r0, r5
 8001174:	0021      	movs	r1, r4
 8001176:	bc3c      	pop	{r2, r3, r4, r5}
 8001178:	4690      	mov	r8, r2
 800117a:	4699      	mov	r9, r3
 800117c:	46a2      	mov	sl, r4
 800117e:	46ab      	mov	fp, r5
 8001180:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001182:	4bb7      	ldr	r3, [pc, #732]	; (8001460 <__aeabi_dadd+0x39c>)
 8001184:	429c      	cmp	r4, r3
 8001186:	d0c6      	beq.n	8001116 <__aeabi_dadd+0x52>
 8001188:	2380      	movs	r3, #128	; 0x80
 800118a:	041b      	lsls	r3, r3, #16
 800118c:	4318      	orrs	r0, r3
 800118e:	2e38      	cmp	r6, #56	; 0x38
 8001190:	dd00      	ble.n	8001194 <__aeabi_dadd+0xd0>
 8001192:	e0eb      	b.n	800136c <__aeabi_dadd+0x2a8>
 8001194:	2e1f      	cmp	r6, #31
 8001196:	dd00      	ble.n	800119a <__aeabi_dadd+0xd6>
 8001198:	e11e      	b.n	80013d8 <__aeabi_dadd+0x314>
 800119a:	2320      	movs	r3, #32
 800119c:	1b9b      	subs	r3, r3, r6
 800119e:	469c      	mov	ip, r3
 80011a0:	0003      	movs	r3, r0
 80011a2:	4667      	mov	r7, ip
 80011a4:	40bb      	lsls	r3, r7
 80011a6:	4698      	mov	r8, r3
 80011a8:	0013      	movs	r3, r2
 80011aa:	4647      	mov	r7, r8
 80011ac:	40f3      	lsrs	r3, r6
 80011ae:	433b      	orrs	r3, r7
 80011b0:	4667      	mov	r7, ip
 80011b2:	40ba      	lsls	r2, r7
 80011b4:	1e57      	subs	r7, r2, #1
 80011b6:	41ba      	sbcs	r2, r7
 80011b8:	4313      	orrs	r3, r2
 80011ba:	0002      	movs	r2, r0
 80011bc:	40f2      	lsrs	r2, r6
 80011be:	1aeb      	subs	r3, r5, r3
 80011c0:	429d      	cmp	r5, r3
 80011c2:	41b6      	sbcs	r6, r6
 80011c4:	001d      	movs	r5, r3
 80011c6:	1a8a      	subs	r2, r1, r2
 80011c8:	4276      	negs	r6, r6
 80011ca:	1b91      	subs	r1, r2, r6
 80011cc:	020b      	lsls	r3, r1, #8
 80011ce:	d531      	bpl.n	8001234 <__aeabi_dadd+0x170>
 80011d0:	024a      	lsls	r2, r1, #9
 80011d2:	0a56      	lsrs	r6, r2, #9
 80011d4:	2e00      	cmp	r6, #0
 80011d6:	d100      	bne.n	80011da <__aeabi_dadd+0x116>
 80011d8:	e0b4      	b.n	8001344 <__aeabi_dadd+0x280>
 80011da:	0030      	movs	r0, r6
 80011dc:	f001 fb2c 	bl	8002838 <__clzsi2>
 80011e0:	0003      	movs	r3, r0
 80011e2:	3b08      	subs	r3, #8
 80011e4:	2b1f      	cmp	r3, #31
 80011e6:	dd00      	ble.n	80011ea <__aeabi_dadd+0x126>
 80011e8:	e0b5      	b.n	8001356 <__aeabi_dadd+0x292>
 80011ea:	2220      	movs	r2, #32
 80011ec:	0029      	movs	r1, r5
 80011ee:	1ad2      	subs	r2, r2, r3
 80011f0:	40d1      	lsrs	r1, r2
 80011f2:	409e      	lsls	r6, r3
 80011f4:	000a      	movs	r2, r1
 80011f6:	409d      	lsls	r5, r3
 80011f8:	4332      	orrs	r2, r6
 80011fa:	429c      	cmp	r4, r3
 80011fc:	dd00      	ble.n	8001200 <__aeabi_dadd+0x13c>
 80011fe:	e0b1      	b.n	8001364 <__aeabi_dadd+0x2a0>
 8001200:	1b1c      	subs	r4, r3, r4
 8001202:	1c63      	adds	r3, r4, #1
 8001204:	2b1f      	cmp	r3, #31
 8001206:	dd00      	ble.n	800120a <__aeabi_dadd+0x146>
 8001208:	e0d5      	b.n	80013b6 <__aeabi_dadd+0x2f2>
 800120a:	2120      	movs	r1, #32
 800120c:	0014      	movs	r4, r2
 800120e:	0028      	movs	r0, r5
 8001210:	1ac9      	subs	r1, r1, r3
 8001212:	408c      	lsls	r4, r1
 8001214:	40d8      	lsrs	r0, r3
 8001216:	408d      	lsls	r5, r1
 8001218:	4304      	orrs	r4, r0
 800121a:	40da      	lsrs	r2, r3
 800121c:	1e68      	subs	r0, r5, #1
 800121e:	4185      	sbcs	r5, r0
 8001220:	0011      	movs	r1, r2
 8001222:	4325      	orrs	r5, r4
 8001224:	2400      	movs	r4, #0
 8001226:	e776      	b.n	8001116 <__aeabi_dadd+0x52>
 8001228:	4641      	mov	r1, r8
 800122a:	4331      	orrs	r1, r6
 800122c:	d100      	bne.n	8001230 <__aeabi_dadd+0x16c>
 800122e:	e234      	b.n	800169a <__aeabi_dadd+0x5d6>
 8001230:	0031      	movs	r1, r6
 8001232:	4645      	mov	r5, r8
 8001234:	076b      	lsls	r3, r5, #29
 8001236:	d000      	beq.n	800123a <__aeabi_dadd+0x176>
 8001238:	e76f      	b.n	800111a <__aeabi_dadd+0x56>
 800123a:	4656      	mov	r6, sl
 800123c:	0748      	lsls	r0, r1, #29
 800123e:	08ed      	lsrs	r5, r5, #3
 8001240:	08c9      	lsrs	r1, r1, #3
 8001242:	4305      	orrs	r5, r0
 8001244:	4b86      	ldr	r3, [pc, #536]	; (8001460 <__aeabi_dadd+0x39c>)
 8001246:	429c      	cmp	r4, r3
 8001248:	d035      	beq.n	80012b6 <__aeabi_dadd+0x1f2>
 800124a:	030a      	lsls	r2, r1, #12
 800124c:	0564      	lsls	r4, r4, #21
 800124e:	0b12      	lsrs	r2, r2, #12
 8001250:	0d64      	lsrs	r4, r4, #21
 8001252:	e77f      	b.n	8001154 <__aeabi_dadd+0x90>
 8001254:	4663      	mov	r3, ip
 8001256:	1ae3      	subs	r3, r4, r3
 8001258:	469b      	mov	fp, r3
 800125a:	2b00      	cmp	r3, #0
 800125c:	dc00      	bgt.n	8001260 <__aeabi_dadd+0x19c>
 800125e:	e08b      	b.n	8001378 <__aeabi_dadd+0x2b4>
 8001260:	4667      	mov	r7, ip
 8001262:	2f00      	cmp	r7, #0
 8001264:	d03c      	beq.n	80012e0 <__aeabi_dadd+0x21c>
 8001266:	4f7e      	ldr	r7, [pc, #504]	; (8001460 <__aeabi_dadd+0x39c>)
 8001268:	42bc      	cmp	r4, r7
 800126a:	d100      	bne.n	800126e <__aeabi_dadd+0x1aa>
 800126c:	e753      	b.n	8001116 <__aeabi_dadd+0x52>
 800126e:	2780      	movs	r7, #128	; 0x80
 8001270:	043f      	lsls	r7, r7, #16
 8001272:	4338      	orrs	r0, r7
 8001274:	465b      	mov	r3, fp
 8001276:	2b38      	cmp	r3, #56	; 0x38
 8001278:	dc00      	bgt.n	800127c <__aeabi_dadd+0x1b8>
 800127a:	e0f7      	b.n	800146c <__aeabi_dadd+0x3a8>
 800127c:	4302      	orrs	r2, r0
 800127e:	1e50      	subs	r0, r2, #1
 8001280:	4182      	sbcs	r2, r0
 8001282:	2000      	movs	r0, #0
 8001284:	b2d2      	uxtb	r2, r2
 8001286:	1953      	adds	r3, r2, r5
 8001288:	1842      	adds	r2, r0, r1
 800128a:	42ab      	cmp	r3, r5
 800128c:	4189      	sbcs	r1, r1
 800128e:	001d      	movs	r5, r3
 8001290:	4249      	negs	r1, r1
 8001292:	1889      	adds	r1, r1, r2
 8001294:	020b      	lsls	r3, r1, #8
 8001296:	d5cd      	bpl.n	8001234 <__aeabi_dadd+0x170>
 8001298:	4b71      	ldr	r3, [pc, #452]	; (8001460 <__aeabi_dadd+0x39c>)
 800129a:	3401      	adds	r4, #1
 800129c:	429c      	cmp	r4, r3
 800129e:	d100      	bne.n	80012a2 <__aeabi_dadd+0x1de>
 80012a0:	e13d      	b.n	800151e <__aeabi_dadd+0x45a>
 80012a2:	2001      	movs	r0, #1
 80012a4:	4a6f      	ldr	r2, [pc, #444]	; (8001464 <__aeabi_dadd+0x3a0>)
 80012a6:	086b      	lsrs	r3, r5, #1
 80012a8:	400a      	ands	r2, r1
 80012aa:	4028      	ands	r0, r5
 80012ac:	4318      	orrs	r0, r3
 80012ae:	07d5      	lsls	r5, r2, #31
 80012b0:	4305      	orrs	r5, r0
 80012b2:	0851      	lsrs	r1, r2, #1
 80012b4:	e72f      	b.n	8001116 <__aeabi_dadd+0x52>
 80012b6:	002b      	movs	r3, r5
 80012b8:	430b      	orrs	r3, r1
 80012ba:	d100      	bne.n	80012be <__aeabi_dadd+0x1fa>
 80012bc:	e1cb      	b.n	8001656 <__aeabi_dadd+0x592>
 80012be:	2380      	movs	r3, #128	; 0x80
 80012c0:	031b      	lsls	r3, r3, #12
 80012c2:	430b      	orrs	r3, r1
 80012c4:	031a      	lsls	r2, r3, #12
 80012c6:	0b12      	lsrs	r2, r2, #12
 80012c8:	e744      	b.n	8001154 <__aeabi_dadd+0x90>
 80012ca:	3e01      	subs	r6, #1
 80012cc:	2e00      	cmp	r6, #0
 80012ce:	d16d      	bne.n	80013ac <__aeabi_dadd+0x2e8>
 80012d0:	1aae      	subs	r6, r5, r2
 80012d2:	42b5      	cmp	r5, r6
 80012d4:	419b      	sbcs	r3, r3
 80012d6:	1a09      	subs	r1, r1, r0
 80012d8:	425b      	negs	r3, r3
 80012da:	1ac9      	subs	r1, r1, r3
 80012dc:	0035      	movs	r5, r6
 80012de:	e775      	b.n	80011cc <__aeabi_dadd+0x108>
 80012e0:	0007      	movs	r7, r0
 80012e2:	4317      	orrs	r7, r2
 80012e4:	d100      	bne.n	80012e8 <__aeabi_dadd+0x224>
 80012e6:	e716      	b.n	8001116 <__aeabi_dadd+0x52>
 80012e8:	2301      	movs	r3, #1
 80012ea:	425b      	negs	r3, r3
 80012ec:	469c      	mov	ip, r3
 80012ee:	44e3      	add	fp, ip
 80012f0:	465b      	mov	r3, fp
 80012f2:	2b00      	cmp	r3, #0
 80012f4:	d000      	beq.n	80012f8 <__aeabi_dadd+0x234>
 80012f6:	e0e0      	b.n	80014ba <__aeabi_dadd+0x3f6>
 80012f8:	18aa      	adds	r2, r5, r2
 80012fa:	42aa      	cmp	r2, r5
 80012fc:	419b      	sbcs	r3, r3
 80012fe:	1809      	adds	r1, r1, r0
 8001300:	425b      	negs	r3, r3
 8001302:	1859      	adds	r1, r3, r1
 8001304:	0015      	movs	r5, r2
 8001306:	e7c5      	b.n	8001294 <__aeabi_dadd+0x1d0>
 8001308:	2e00      	cmp	r6, #0
 800130a:	d175      	bne.n	80013f8 <__aeabi_dadd+0x334>
 800130c:	1c66      	adds	r6, r4, #1
 800130e:	0576      	lsls	r6, r6, #21
 8001310:	0d76      	lsrs	r6, r6, #21
 8001312:	2e01      	cmp	r6, #1
 8001314:	dc00      	bgt.n	8001318 <__aeabi_dadd+0x254>
 8001316:	e0f3      	b.n	8001500 <__aeabi_dadd+0x43c>
 8001318:	1aae      	subs	r6, r5, r2
 800131a:	46b0      	mov	r8, r6
 800131c:	4545      	cmp	r5, r8
 800131e:	41bf      	sbcs	r7, r7
 8001320:	1a0e      	subs	r6, r1, r0
 8001322:	427f      	negs	r7, r7
 8001324:	1bf6      	subs	r6, r6, r7
 8001326:	0237      	lsls	r7, r6, #8
 8001328:	d400      	bmi.n	800132c <__aeabi_dadd+0x268>
 800132a:	e08f      	b.n	800144c <__aeabi_dadd+0x388>
 800132c:	1b55      	subs	r5, r2, r5
 800132e:	42aa      	cmp	r2, r5
 8001330:	41b6      	sbcs	r6, r6
 8001332:	1a41      	subs	r1, r0, r1
 8001334:	4276      	negs	r6, r6
 8001336:	1b8e      	subs	r6, r1, r6
 8001338:	469a      	mov	sl, r3
 800133a:	e74b      	b.n	80011d4 <__aeabi_dadd+0x110>
 800133c:	4656      	mov	r6, sl
 800133e:	2200      	movs	r2, #0
 8001340:	2500      	movs	r5, #0
 8001342:	e707      	b.n	8001154 <__aeabi_dadd+0x90>
 8001344:	0028      	movs	r0, r5
 8001346:	f001 fa77 	bl	8002838 <__clzsi2>
 800134a:	3020      	adds	r0, #32
 800134c:	0003      	movs	r3, r0
 800134e:	3b08      	subs	r3, #8
 8001350:	2b1f      	cmp	r3, #31
 8001352:	dc00      	bgt.n	8001356 <__aeabi_dadd+0x292>
 8001354:	e749      	b.n	80011ea <__aeabi_dadd+0x126>
 8001356:	002a      	movs	r2, r5
 8001358:	3828      	subs	r0, #40	; 0x28
 800135a:	4082      	lsls	r2, r0
 800135c:	2500      	movs	r5, #0
 800135e:	429c      	cmp	r4, r3
 8001360:	dc00      	bgt.n	8001364 <__aeabi_dadd+0x2a0>
 8001362:	e74d      	b.n	8001200 <__aeabi_dadd+0x13c>
 8001364:	493f      	ldr	r1, [pc, #252]	; (8001464 <__aeabi_dadd+0x3a0>)
 8001366:	1ae4      	subs	r4, r4, r3
 8001368:	4011      	ands	r1, r2
 800136a:	e6d4      	b.n	8001116 <__aeabi_dadd+0x52>
 800136c:	4302      	orrs	r2, r0
 800136e:	1e50      	subs	r0, r2, #1
 8001370:	4182      	sbcs	r2, r0
 8001372:	b2d3      	uxtb	r3, r2
 8001374:	2200      	movs	r2, #0
 8001376:	e722      	b.n	80011be <__aeabi_dadd+0xfa>
 8001378:	2b00      	cmp	r3, #0
 800137a:	d000      	beq.n	800137e <__aeabi_dadd+0x2ba>
 800137c:	e0f3      	b.n	8001566 <__aeabi_dadd+0x4a2>
 800137e:	1c63      	adds	r3, r4, #1
 8001380:	469c      	mov	ip, r3
 8001382:	055b      	lsls	r3, r3, #21
 8001384:	0d5b      	lsrs	r3, r3, #21
 8001386:	2b01      	cmp	r3, #1
 8001388:	dc00      	bgt.n	800138c <__aeabi_dadd+0x2c8>
 800138a:	e09f      	b.n	80014cc <__aeabi_dadd+0x408>
 800138c:	4b34      	ldr	r3, [pc, #208]	; (8001460 <__aeabi_dadd+0x39c>)
 800138e:	459c      	cmp	ip, r3
 8001390:	d100      	bne.n	8001394 <__aeabi_dadd+0x2d0>
 8001392:	e0c3      	b.n	800151c <__aeabi_dadd+0x458>
 8001394:	18aa      	adds	r2, r5, r2
 8001396:	1809      	adds	r1, r1, r0
 8001398:	42aa      	cmp	r2, r5
 800139a:	4180      	sbcs	r0, r0
 800139c:	4240      	negs	r0, r0
 800139e:	1841      	adds	r1, r0, r1
 80013a0:	07cd      	lsls	r5, r1, #31
 80013a2:	0852      	lsrs	r2, r2, #1
 80013a4:	4315      	orrs	r5, r2
 80013a6:	0849      	lsrs	r1, r1, #1
 80013a8:	4664      	mov	r4, ip
 80013aa:	e6b4      	b.n	8001116 <__aeabi_dadd+0x52>
 80013ac:	4b2c      	ldr	r3, [pc, #176]	; (8001460 <__aeabi_dadd+0x39c>)
 80013ae:	429c      	cmp	r4, r3
 80013b0:	d000      	beq.n	80013b4 <__aeabi_dadd+0x2f0>
 80013b2:	e6ec      	b.n	800118e <__aeabi_dadd+0xca>
 80013b4:	e6af      	b.n	8001116 <__aeabi_dadd+0x52>
 80013b6:	0011      	movs	r1, r2
 80013b8:	3c1f      	subs	r4, #31
 80013ba:	40e1      	lsrs	r1, r4
 80013bc:	000c      	movs	r4, r1
 80013be:	2b20      	cmp	r3, #32
 80013c0:	d100      	bne.n	80013c4 <__aeabi_dadd+0x300>
 80013c2:	e07f      	b.n	80014c4 <__aeabi_dadd+0x400>
 80013c4:	2140      	movs	r1, #64	; 0x40
 80013c6:	1acb      	subs	r3, r1, r3
 80013c8:	409a      	lsls	r2, r3
 80013ca:	4315      	orrs	r5, r2
 80013cc:	1e6a      	subs	r2, r5, #1
 80013ce:	4195      	sbcs	r5, r2
 80013d0:	2100      	movs	r1, #0
 80013d2:	4325      	orrs	r5, r4
 80013d4:	2400      	movs	r4, #0
 80013d6:	e72d      	b.n	8001234 <__aeabi_dadd+0x170>
 80013d8:	0033      	movs	r3, r6
 80013da:	0007      	movs	r7, r0
 80013dc:	3b20      	subs	r3, #32
 80013de:	40df      	lsrs	r7, r3
 80013e0:	003b      	movs	r3, r7
 80013e2:	2e20      	cmp	r6, #32
 80013e4:	d070      	beq.n	80014c8 <__aeabi_dadd+0x404>
 80013e6:	2740      	movs	r7, #64	; 0x40
 80013e8:	1bbe      	subs	r6, r7, r6
 80013ea:	40b0      	lsls	r0, r6
 80013ec:	4302      	orrs	r2, r0
 80013ee:	1e50      	subs	r0, r2, #1
 80013f0:	4182      	sbcs	r2, r0
 80013f2:	4313      	orrs	r3, r2
 80013f4:	2200      	movs	r2, #0
 80013f6:	e6e2      	b.n	80011be <__aeabi_dadd+0xfa>
 80013f8:	2c00      	cmp	r4, #0
 80013fa:	d04f      	beq.n	800149c <__aeabi_dadd+0x3d8>
 80013fc:	4c18      	ldr	r4, [pc, #96]	; (8001460 <__aeabi_dadd+0x39c>)
 80013fe:	45a4      	cmp	ip, r4
 8001400:	d100      	bne.n	8001404 <__aeabi_dadd+0x340>
 8001402:	e0ab      	b.n	800155c <__aeabi_dadd+0x498>
 8001404:	2480      	movs	r4, #128	; 0x80
 8001406:	0424      	lsls	r4, r4, #16
 8001408:	4276      	negs	r6, r6
 800140a:	4321      	orrs	r1, r4
 800140c:	2e38      	cmp	r6, #56	; 0x38
 800140e:	dd00      	ble.n	8001412 <__aeabi_dadd+0x34e>
 8001410:	e0df      	b.n	80015d2 <__aeabi_dadd+0x50e>
 8001412:	2e1f      	cmp	r6, #31
 8001414:	dd00      	ble.n	8001418 <__aeabi_dadd+0x354>
 8001416:	e143      	b.n	80016a0 <__aeabi_dadd+0x5dc>
 8001418:	2720      	movs	r7, #32
 800141a:	1bbc      	subs	r4, r7, r6
 800141c:	46a1      	mov	r9, r4
 800141e:	000c      	movs	r4, r1
 8001420:	464f      	mov	r7, r9
 8001422:	40bc      	lsls	r4, r7
 8001424:	46a0      	mov	r8, r4
 8001426:	002c      	movs	r4, r5
 8001428:	4647      	mov	r7, r8
 800142a:	40f4      	lsrs	r4, r6
 800142c:	433c      	orrs	r4, r7
 800142e:	464f      	mov	r7, r9
 8001430:	40bd      	lsls	r5, r7
 8001432:	1e6f      	subs	r7, r5, #1
 8001434:	41bd      	sbcs	r5, r7
 8001436:	40f1      	lsrs	r1, r6
 8001438:	432c      	orrs	r4, r5
 800143a:	1b15      	subs	r5, r2, r4
 800143c:	42aa      	cmp	r2, r5
 800143e:	4192      	sbcs	r2, r2
 8001440:	1a41      	subs	r1, r0, r1
 8001442:	4252      	negs	r2, r2
 8001444:	1a89      	subs	r1, r1, r2
 8001446:	4664      	mov	r4, ip
 8001448:	469a      	mov	sl, r3
 800144a:	e6bf      	b.n	80011cc <__aeabi_dadd+0x108>
 800144c:	4641      	mov	r1, r8
 800144e:	4645      	mov	r5, r8
 8001450:	4331      	orrs	r1, r6
 8001452:	d000      	beq.n	8001456 <__aeabi_dadd+0x392>
 8001454:	e6be      	b.n	80011d4 <__aeabi_dadd+0x110>
 8001456:	2600      	movs	r6, #0
 8001458:	2400      	movs	r4, #0
 800145a:	2500      	movs	r5, #0
 800145c:	e6f2      	b.n	8001244 <__aeabi_dadd+0x180>
 800145e:	46c0      	nop			; (mov r8, r8)
 8001460:	000007ff 	.word	0x000007ff
 8001464:	ff7fffff 	.word	0xff7fffff
 8001468:	800fffff 	.word	0x800fffff
 800146c:	2b1f      	cmp	r3, #31
 800146e:	dc59      	bgt.n	8001524 <__aeabi_dadd+0x460>
 8001470:	2720      	movs	r7, #32
 8001472:	1aff      	subs	r7, r7, r3
 8001474:	46bc      	mov	ip, r7
 8001476:	0007      	movs	r7, r0
 8001478:	4663      	mov	r3, ip
 800147a:	409f      	lsls	r7, r3
 800147c:	465b      	mov	r3, fp
 800147e:	46b9      	mov	r9, r7
 8001480:	0017      	movs	r7, r2
 8001482:	40df      	lsrs	r7, r3
 8001484:	46b8      	mov	r8, r7
 8001486:	464f      	mov	r7, r9
 8001488:	4643      	mov	r3, r8
 800148a:	431f      	orrs	r7, r3
 800148c:	4663      	mov	r3, ip
 800148e:	409a      	lsls	r2, r3
 8001490:	1e53      	subs	r3, r2, #1
 8001492:	419a      	sbcs	r2, r3
 8001494:	465b      	mov	r3, fp
 8001496:	433a      	orrs	r2, r7
 8001498:	40d8      	lsrs	r0, r3
 800149a:	e6f4      	b.n	8001286 <__aeabi_dadd+0x1c2>
 800149c:	000c      	movs	r4, r1
 800149e:	432c      	orrs	r4, r5
 80014a0:	d05c      	beq.n	800155c <__aeabi_dadd+0x498>
 80014a2:	43f6      	mvns	r6, r6
 80014a4:	2e00      	cmp	r6, #0
 80014a6:	d155      	bne.n	8001554 <__aeabi_dadd+0x490>
 80014a8:	1b55      	subs	r5, r2, r5
 80014aa:	42aa      	cmp	r2, r5
 80014ac:	41a4      	sbcs	r4, r4
 80014ae:	1a41      	subs	r1, r0, r1
 80014b0:	4264      	negs	r4, r4
 80014b2:	1b09      	subs	r1, r1, r4
 80014b4:	469a      	mov	sl, r3
 80014b6:	4664      	mov	r4, ip
 80014b8:	e688      	b.n	80011cc <__aeabi_dadd+0x108>
 80014ba:	4f96      	ldr	r7, [pc, #600]	; (8001714 <__aeabi_dadd+0x650>)
 80014bc:	42bc      	cmp	r4, r7
 80014be:	d000      	beq.n	80014c2 <__aeabi_dadd+0x3fe>
 80014c0:	e6d8      	b.n	8001274 <__aeabi_dadd+0x1b0>
 80014c2:	e628      	b.n	8001116 <__aeabi_dadd+0x52>
 80014c4:	2200      	movs	r2, #0
 80014c6:	e780      	b.n	80013ca <__aeabi_dadd+0x306>
 80014c8:	2000      	movs	r0, #0
 80014ca:	e78f      	b.n	80013ec <__aeabi_dadd+0x328>
 80014cc:	000b      	movs	r3, r1
 80014ce:	432b      	orrs	r3, r5
 80014d0:	2c00      	cmp	r4, #0
 80014d2:	d000      	beq.n	80014d6 <__aeabi_dadd+0x412>
 80014d4:	e0c2      	b.n	800165c <__aeabi_dadd+0x598>
 80014d6:	2b00      	cmp	r3, #0
 80014d8:	d100      	bne.n	80014dc <__aeabi_dadd+0x418>
 80014da:	e101      	b.n	80016e0 <__aeabi_dadd+0x61c>
 80014dc:	0003      	movs	r3, r0
 80014de:	4313      	orrs	r3, r2
 80014e0:	d100      	bne.n	80014e4 <__aeabi_dadd+0x420>
 80014e2:	e618      	b.n	8001116 <__aeabi_dadd+0x52>
 80014e4:	18ab      	adds	r3, r5, r2
 80014e6:	42ab      	cmp	r3, r5
 80014e8:	41b6      	sbcs	r6, r6
 80014ea:	1809      	adds	r1, r1, r0
 80014ec:	4276      	negs	r6, r6
 80014ee:	1871      	adds	r1, r6, r1
 80014f0:	020a      	lsls	r2, r1, #8
 80014f2:	d400      	bmi.n	80014f6 <__aeabi_dadd+0x432>
 80014f4:	e109      	b.n	800170a <__aeabi_dadd+0x646>
 80014f6:	4a88      	ldr	r2, [pc, #544]	; (8001718 <__aeabi_dadd+0x654>)
 80014f8:	001d      	movs	r5, r3
 80014fa:	4011      	ands	r1, r2
 80014fc:	4664      	mov	r4, ip
 80014fe:	e60a      	b.n	8001116 <__aeabi_dadd+0x52>
 8001500:	2c00      	cmp	r4, #0
 8001502:	d15b      	bne.n	80015bc <__aeabi_dadd+0x4f8>
 8001504:	000e      	movs	r6, r1
 8001506:	432e      	orrs	r6, r5
 8001508:	d000      	beq.n	800150c <__aeabi_dadd+0x448>
 800150a:	e08a      	b.n	8001622 <__aeabi_dadd+0x55e>
 800150c:	0001      	movs	r1, r0
 800150e:	4311      	orrs	r1, r2
 8001510:	d100      	bne.n	8001514 <__aeabi_dadd+0x450>
 8001512:	e0c2      	b.n	800169a <__aeabi_dadd+0x5d6>
 8001514:	0001      	movs	r1, r0
 8001516:	0015      	movs	r5, r2
 8001518:	469a      	mov	sl, r3
 800151a:	e5fc      	b.n	8001116 <__aeabi_dadd+0x52>
 800151c:	4664      	mov	r4, ip
 800151e:	2100      	movs	r1, #0
 8001520:	2500      	movs	r5, #0
 8001522:	e68f      	b.n	8001244 <__aeabi_dadd+0x180>
 8001524:	2320      	movs	r3, #32
 8001526:	425b      	negs	r3, r3
 8001528:	469c      	mov	ip, r3
 800152a:	44dc      	add	ip, fp
 800152c:	4663      	mov	r3, ip
 800152e:	0007      	movs	r7, r0
 8001530:	40df      	lsrs	r7, r3
 8001532:	465b      	mov	r3, fp
 8001534:	46bc      	mov	ip, r7
 8001536:	2b20      	cmp	r3, #32
 8001538:	d100      	bne.n	800153c <__aeabi_dadd+0x478>
 800153a:	e0ac      	b.n	8001696 <__aeabi_dadd+0x5d2>
 800153c:	2340      	movs	r3, #64	; 0x40
 800153e:	465f      	mov	r7, fp
 8001540:	1bdb      	subs	r3, r3, r7
 8001542:	4098      	lsls	r0, r3
 8001544:	4302      	orrs	r2, r0
 8001546:	1e50      	subs	r0, r2, #1
 8001548:	4182      	sbcs	r2, r0
 800154a:	4663      	mov	r3, ip
 800154c:	4313      	orrs	r3, r2
 800154e:	001a      	movs	r2, r3
 8001550:	2000      	movs	r0, #0
 8001552:	e698      	b.n	8001286 <__aeabi_dadd+0x1c2>
 8001554:	4c6f      	ldr	r4, [pc, #444]	; (8001714 <__aeabi_dadd+0x650>)
 8001556:	45a4      	cmp	ip, r4
 8001558:	d000      	beq.n	800155c <__aeabi_dadd+0x498>
 800155a:	e757      	b.n	800140c <__aeabi_dadd+0x348>
 800155c:	0001      	movs	r1, r0
 800155e:	0015      	movs	r5, r2
 8001560:	4664      	mov	r4, ip
 8001562:	469a      	mov	sl, r3
 8001564:	e5d7      	b.n	8001116 <__aeabi_dadd+0x52>
 8001566:	2c00      	cmp	r4, #0
 8001568:	d139      	bne.n	80015de <__aeabi_dadd+0x51a>
 800156a:	000c      	movs	r4, r1
 800156c:	432c      	orrs	r4, r5
 800156e:	d06e      	beq.n	800164e <__aeabi_dadd+0x58a>
 8001570:	43db      	mvns	r3, r3
 8001572:	2b00      	cmp	r3, #0
 8001574:	d01a      	beq.n	80015ac <__aeabi_dadd+0x4e8>
 8001576:	4c67      	ldr	r4, [pc, #412]	; (8001714 <__aeabi_dadd+0x650>)
 8001578:	45a4      	cmp	ip, r4
 800157a:	d068      	beq.n	800164e <__aeabi_dadd+0x58a>
 800157c:	2b38      	cmp	r3, #56	; 0x38
 800157e:	dd00      	ble.n	8001582 <__aeabi_dadd+0x4be>
 8001580:	e0a4      	b.n	80016cc <__aeabi_dadd+0x608>
 8001582:	2b1f      	cmp	r3, #31
 8001584:	dd00      	ble.n	8001588 <__aeabi_dadd+0x4c4>
 8001586:	e0ae      	b.n	80016e6 <__aeabi_dadd+0x622>
 8001588:	2420      	movs	r4, #32
 800158a:	000f      	movs	r7, r1
 800158c:	1ae4      	subs	r4, r4, r3
 800158e:	40a7      	lsls	r7, r4
 8001590:	46b9      	mov	r9, r7
 8001592:	002f      	movs	r7, r5
 8001594:	40df      	lsrs	r7, r3
 8001596:	46b8      	mov	r8, r7
 8001598:	46a3      	mov	fp, r4
 800159a:	464f      	mov	r7, r9
 800159c:	4644      	mov	r4, r8
 800159e:	4327      	orrs	r7, r4
 80015a0:	465c      	mov	r4, fp
 80015a2:	40a5      	lsls	r5, r4
 80015a4:	1e6c      	subs	r4, r5, #1
 80015a6:	41a5      	sbcs	r5, r4
 80015a8:	40d9      	lsrs	r1, r3
 80015aa:	433d      	orrs	r5, r7
 80015ac:	18ad      	adds	r5, r5, r2
 80015ae:	4295      	cmp	r5, r2
 80015b0:	419b      	sbcs	r3, r3
 80015b2:	1809      	adds	r1, r1, r0
 80015b4:	425b      	negs	r3, r3
 80015b6:	1859      	adds	r1, r3, r1
 80015b8:	4664      	mov	r4, ip
 80015ba:	e66b      	b.n	8001294 <__aeabi_dadd+0x1d0>
 80015bc:	000c      	movs	r4, r1
 80015be:	432c      	orrs	r4, r5
 80015c0:	d115      	bne.n	80015ee <__aeabi_dadd+0x52a>
 80015c2:	0001      	movs	r1, r0
 80015c4:	4311      	orrs	r1, r2
 80015c6:	d07b      	beq.n	80016c0 <__aeabi_dadd+0x5fc>
 80015c8:	0001      	movs	r1, r0
 80015ca:	0015      	movs	r5, r2
 80015cc:	469a      	mov	sl, r3
 80015ce:	4c51      	ldr	r4, [pc, #324]	; (8001714 <__aeabi_dadd+0x650>)
 80015d0:	e5a1      	b.n	8001116 <__aeabi_dadd+0x52>
 80015d2:	430d      	orrs	r5, r1
 80015d4:	1e69      	subs	r1, r5, #1
 80015d6:	418d      	sbcs	r5, r1
 80015d8:	2100      	movs	r1, #0
 80015da:	b2ec      	uxtb	r4, r5
 80015dc:	e72d      	b.n	800143a <__aeabi_dadd+0x376>
 80015de:	4c4d      	ldr	r4, [pc, #308]	; (8001714 <__aeabi_dadd+0x650>)
 80015e0:	45a4      	cmp	ip, r4
 80015e2:	d034      	beq.n	800164e <__aeabi_dadd+0x58a>
 80015e4:	2480      	movs	r4, #128	; 0x80
 80015e6:	0424      	lsls	r4, r4, #16
 80015e8:	425b      	negs	r3, r3
 80015ea:	4321      	orrs	r1, r4
 80015ec:	e7c6      	b.n	800157c <__aeabi_dadd+0x4b8>
 80015ee:	0004      	movs	r4, r0
 80015f0:	4314      	orrs	r4, r2
 80015f2:	d04e      	beq.n	8001692 <__aeabi_dadd+0x5ce>
 80015f4:	08ed      	lsrs	r5, r5, #3
 80015f6:	074c      	lsls	r4, r1, #29
 80015f8:	432c      	orrs	r4, r5
 80015fa:	2580      	movs	r5, #128	; 0x80
 80015fc:	08c9      	lsrs	r1, r1, #3
 80015fe:	032d      	lsls	r5, r5, #12
 8001600:	4229      	tst	r1, r5
 8001602:	d008      	beq.n	8001616 <__aeabi_dadd+0x552>
 8001604:	08c6      	lsrs	r6, r0, #3
 8001606:	422e      	tst	r6, r5
 8001608:	d105      	bne.n	8001616 <__aeabi_dadd+0x552>
 800160a:	08d2      	lsrs	r2, r2, #3
 800160c:	0741      	lsls	r1, r0, #29
 800160e:	4311      	orrs	r1, r2
 8001610:	000c      	movs	r4, r1
 8001612:	469a      	mov	sl, r3
 8001614:	0031      	movs	r1, r6
 8001616:	0f62      	lsrs	r2, r4, #29
 8001618:	00c9      	lsls	r1, r1, #3
 800161a:	00e5      	lsls	r5, r4, #3
 800161c:	4311      	orrs	r1, r2
 800161e:	4c3d      	ldr	r4, [pc, #244]	; (8001714 <__aeabi_dadd+0x650>)
 8001620:	e579      	b.n	8001116 <__aeabi_dadd+0x52>
 8001622:	0006      	movs	r6, r0
 8001624:	4316      	orrs	r6, r2
 8001626:	d100      	bne.n	800162a <__aeabi_dadd+0x566>
 8001628:	e575      	b.n	8001116 <__aeabi_dadd+0x52>
 800162a:	1aae      	subs	r6, r5, r2
 800162c:	46b0      	mov	r8, r6
 800162e:	4545      	cmp	r5, r8
 8001630:	41bf      	sbcs	r7, r7
 8001632:	1a0e      	subs	r6, r1, r0
 8001634:	427f      	negs	r7, r7
 8001636:	1bf6      	subs	r6, r6, r7
 8001638:	0237      	lsls	r7, r6, #8
 800163a:	d400      	bmi.n	800163e <__aeabi_dadd+0x57a>
 800163c:	e5f4      	b.n	8001228 <__aeabi_dadd+0x164>
 800163e:	1b55      	subs	r5, r2, r5
 8001640:	42aa      	cmp	r2, r5
 8001642:	41b6      	sbcs	r6, r6
 8001644:	1a41      	subs	r1, r0, r1
 8001646:	4276      	negs	r6, r6
 8001648:	1b89      	subs	r1, r1, r6
 800164a:	469a      	mov	sl, r3
 800164c:	e563      	b.n	8001116 <__aeabi_dadd+0x52>
 800164e:	0001      	movs	r1, r0
 8001650:	0015      	movs	r5, r2
 8001652:	4664      	mov	r4, ip
 8001654:	e55f      	b.n	8001116 <__aeabi_dadd+0x52>
 8001656:	2200      	movs	r2, #0
 8001658:	2500      	movs	r5, #0
 800165a:	e57b      	b.n	8001154 <__aeabi_dadd+0x90>
 800165c:	2b00      	cmp	r3, #0
 800165e:	d03b      	beq.n	80016d8 <__aeabi_dadd+0x614>
 8001660:	0003      	movs	r3, r0
 8001662:	4313      	orrs	r3, r2
 8001664:	d015      	beq.n	8001692 <__aeabi_dadd+0x5ce>
 8001666:	08ed      	lsrs	r5, r5, #3
 8001668:	074b      	lsls	r3, r1, #29
 800166a:	432b      	orrs	r3, r5
 800166c:	2580      	movs	r5, #128	; 0x80
 800166e:	08c9      	lsrs	r1, r1, #3
 8001670:	032d      	lsls	r5, r5, #12
 8001672:	4229      	tst	r1, r5
 8001674:	d007      	beq.n	8001686 <__aeabi_dadd+0x5c2>
 8001676:	08c4      	lsrs	r4, r0, #3
 8001678:	422c      	tst	r4, r5
 800167a:	d104      	bne.n	8001686 <__aeabi_dadd+0x5c2>
 800167c:	0741      	lsls	r1, r0, #29
 800167e:	000b      	movs	r3, r1
 8001680:	0021      	movs	r1, r4
 8001682:	08d2      	lsrs	r2, r2, #3
 8001684:	4313      	orrs	r3, r2
 8001686:	00c9      	lsls	r1, r1, #3
 8001688:	0f5a      	lsrs	r2, r3, #29
 800168a:	4311      	orrs	r1, r2
 800168c:	00dd      	lsls	r5, r3, #3
 800168e:	4c21      	ldr	r4, [pc, #132]	; (8001714 <__aeabi_dadd+0x650>)
 8001690:	e541      	b.n	8001116 <__aeabi_dadd+0x52>
 8001692:	4c20      	ldr	r4, [pc, #128]	; (8001714 <__aeabi_dadd+0x650>)
 8001694:	e53f      	b.n	8001116 <__aeabi_dadd+0x52>
 8001696:	2000      	movs	r0, #0
 8001698:	e754      	b.n	8001544 <__aeabi_dadd+0x480>
 800169a:	2600      	movs	r6, #0
 800169c:	2500      	movs	r5, #0
 800169e:	e5d1      	b.n	8001244 <__aeabi_dadd+0x180>
 80016a0:	0034      	movs	r4, r6
 80016a2:	000f      	movs	r7, r1
 80016a4:	3c20      	subs	r4, #32
 80016a6:	40e7      	lsrs	r7, r4
 80016a8:	003c      	movs	r4, r7
 80016aa:	2e20      	cmp	r6, #32
 80016ac:	d02b      	beq.n	8001706 <__aeabi_dadd+0x642>
 80016ae:	2740      	movs	r7, #64	; 0x40
 80016b0:	1bbe      	subs	r6, r7, r6
 80016b2:	40b1      	lsls	r1, r6
 80016b4:	430d      	orrs	r5, r1
 80016b6:	1e69      	subs	r1, r5, #1
 80016b8:	418d      	sbcs	r5, r1
 80016ba:	2100      	movs	r1, #0
 80016bc:	432c      	orrs	r4, r5
 80016be:	e6bc      	b.n	800143a <__aeabi_dadd+0x376>
 80016c0:	2180      	movs	r1, #128	; 0x80
 80016c2:	2600      	movs	r6, #0
 80016c4:	0309      	lsls	r1, r1, #12
 80016c6:	4c13      	ldr	r4, [pc, #76]	; (8001714 <__aeabi_dadd+0x650>)
 80016c8:	2500      	movs	r5, #0
 80016ca:	e5bb      	b.n	8001244 <__aeabi_dadd+0x180>
 80016cc:	430d      	orrs	r5, r1
 80016ce:	1e69      	subs	r1, r5, #1
 80016d0:	418d      	sbcs	r5, r1
 80016d2:	2100      	movs	r1, #0
 80016d4:	b2ed      	uxtb	r5, r5
 80016d6:	e769      	b.n	80015ac <__aeabi_dadd+0x4e8>
 80016d8:	0001      	movs	r1, r0
 80016da:	0015      	movs	r5, r2
 80016dc:	4c0d      	ldr	r4, [pc, #52]	; (8001714 <__aeabi_dadd+0x650>)
 80016de:	e51a      	b.n	8001116 <__aeabi_dadd+0x52>
 80016e0:	0001      	movs	r1, r0
 80016e2:	0015      	movs	r5, r2
 80016e4:	e517      	b.n	8001116 <__aeabi_dadd+0x52>
 80016e6:	001c      	movs	r4, r3
 80016e8:	000f      	movs	r7, r1
 80016ea:	3c20      	subs	r4, #32
 80016ec:	40e7      	lsrs	r7, r4
 80016ee:	003c      	movs	r4, r7
 80016f0:	2b20      	cmp	r3, #32
 80016f2:	d00c      	beq.n	800170e <__aeabi_dadd+0x64a>
 80016f4:	2740      	movs	r7, #64	; 0x40
 80016f6:	1afb      	subs	r3, r7, r3
 80016f8:	4099      	lsls	r1, r3
 80016fa:	430d      	orrs	r5, r1
 80016fc:	1e69      	subs	r1, r5, #1
 80016fe:	418d      	sbcs	r5, r1
 8001700:	2100      	movs	r1, #0
 8001702:	4325      	orrs	r5, r4
 8001704:	e752      	b.n	80015ac <__aeabi_dadd+0x4e8>
 8001706:	2100      	movs	r1, #0
 8001708:	e7d4      	b.n	80016b4 <__aeabi_dadd+0x5f0>
 800170a:	001d      	movs	r5, r3
 800170c:	e592      	b.n	8001234 <__aeabi_dadd+0x170>
 800170e:	2100      	movs	r1, #0
 8001710:	e7f3      	b.n	80016fa <__aeabi_dadd+0x636>
 8001712:	46c0      	nop			; (mov r8, r8)
 8001714:	000007ff 	.word	0x000007ff
 8001718:	ff7fffff 	.word	0xff7fffff

0800171c <__aeabi_ddiv>:
 800171c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800171e:	4656      	mov	r6, sl
 8001720:	464d      	mov	r5, r9
 8001722:	4644      	mov	r4, r8
 8001724:	465f      	mov	r7, fp
 8001726:	b4f0      	push	{r4, r5, r6, r7}
 8001728:	001d      	movs	r5, r3
 800172a:	030e      	lsls	r6, r1, #12
 800172c:	004c      	lsls	r4, r1, #1
 800172e:	0fcb      	lsrs	r3, r1, #31
 8001730:	b087      	sub	sp, #28
 8001732:	0007      	movs	r7, r0
 8001734:	4692      	mov	sl, r2
 8001736:	4681      	mov	r9, r0
 8001738:	0b36      	lsrs	r6, r6, #12
 800173a:	0d64      	lsrs	r4, r4, #21
 800173c:	4698      	mov	r8, r3
 800173e:	d06a      	beq.n	8001816 <__aeabi_ddiv+0xfa>
 8001740:	4b6d      	ldr	r3, [pc, #436]	; (80018f8 <__aeabi_ddiv+0x1dc>)
 8001742:	429c      	cmp	r4, r3
 8001744:	d035      	beq.n	80017b2 <__aeabi_ddiv+0x96>
 8001746:	2280      	movs	r2, #128	; 0x80
 8001748:	0f43      	lsrs	r3, r0, #29
 800174a:	0412      	lsls	r2, r2, #16
 800174c:	4313      	orrs	r3, r2
 800174e:	00f6      	lsls	r6, r6, #3
 8001750:	431e      	orrs	r6, r3
 8001752:	00c3      	lsls	r3, r0, #3
 8001754:	4699      	mov	r9, r3
 8001756:	4b69      	ldr	r3, [pc, #420]	; (80018fc <__aeabi_ddiv+0x1e0>)
 8001758:	2700      	movs	r7, #0
 800175a:	469c      	mov	ip, r3
 800175c:	2300      	movs	r3, #0
 800175e:	4464      	add	r4, ip
 8001760:	9302      	str	r3, [sp, #8]
 8001762:	032b      	lsls	r3, r5, #12
 8001764:	0068      	lsls	r0, r5, #1
 8001766:	0b1b      	lsrs	r3, r3, #12
 8001768:	0fed      	lsrs	r5, r5, #31
 800176a:	4651      	mov	r1, sl
 800176c:	469b      	mov	fp, r3
 800176e:	0d40      	lsrs	r0, r0, #21
 8001770:	9500      	str	r5, [sp, #0]
 8001772:	d100      	bne.n	8001776 <__aeabi_ddiv+0x5a>
 8001774:	e078      	b.n	8001868 <__aeabi_ddiv+0x14c>
 8001776:	4b60      	ldr	r3, [pc, #384]	; (80018f8 <__aeabi_ddiv+0x1dc>)
 8001778:	4298      	cmp	r0, r3
 800177a:	d06c      	beq.n	8001856 <__aeabi_ddiv+0x13a>
 800177c:	465b      	mov	r3, fp
 800177e:	00da      	lsls	r2, r3, #3
 8001780:	0f4b      	lsrs	r3, r1, #29
 8001782:	2180      	movs	r1, #128	; 0x80
 8001784:	0409      	lsls	r1, r1, #16
 8001786:	430b      	orrs	r3, r1
 8001788:	4313      	orrs	r3, r2
 800178a:	469b      	mov	fp, r3
 800178c:	4653      	mov	r3, sl
 800178e:	00d9      	lsls	r1, r3, #3
 8001790:	4b5a      	ldr	r3, [pc, #360]	; (80018fc <__aeabi_ddiv+0x1e0>)
 8001792:	469c      	mov	ip, r3
 8001794:	2300      	movs	r3, #0
 8001796:	4460      	add	r0, ip
 8001798:	4642      	mov	r2, r8
 800179a:	1a20      	subs	r0, r4, r0
 800179c:	406a      	eors	r2, r5
 800179e:	4692      	mov	sl, r2
 80017a0:	9001      	str	r0, [sp, #4]
 80017a2:	431f      	orrs	r7, r3
 80017a4:	2f0f      	cmp	r7, #15
 80017a6:	d900      	bls.n	80017aa <__aeabi_ddiv+0x8e>
 80017a8:	e0b0      	b.n	800190c <__aeabi_ddiv+0x1f0>
 80017aa:	4855      	ldr	r0, [pc, #340]	; (8001900 <__aeabi_ddiv+0x1e4>)
 80017ac:	00bf      	lsls	r7, r7, #2
 80017ae:	59c0      	ldr	r0, [r0, r7]
 80017b0:	4687      	mov	pc, r0
 80017b2:	4337      	orrs	r7, r6
 80017b4:	d000      	beq.n	80017b8 <__aeabi_ddiv+0x9c>
 80017b6:	e088      	b.n	80018ca <__aeabi_ddiv+0x1ae>
 80017b8:	2300      	movs	r3, #0
 80017ba:	4699      	mov	r9, r3
 80017bc:	3302      	adds	r3, #2
 80017be:	2708      	movs	r7, #8
 80017c0:	2600      	movs	r6, #0
 80017c2:	9302      	str	r3, [sp, #8]
 80017c4:	e7cd      	b.n	8001762 <__aeabi_ddiv+0x46>
 80017c6:	4643      	mov	r3, r8
 80017c8:	46b3      	mov	fp, r6
 80017ca:	4649      	mov	r1, r9
 80017cc:	9300      	str	r3, [sp, #0]
 80017ce:	9b02      	ldr	r3, [sp, #8]
 80017d0:	9a00      	ldr	r2, [sp, #0]
 80017d2:	4692      	mov	sl, r2
 80017d4:	2b02      	cmp	r3, #2
 80017d6:	d000      	beq.n	80017da <__aeabi_ddiv+0xbe>
 80017d8:	e1bf      	b.n	8001b5a <__aeabi_ddiv+0x43e>
 80017da:	2100      	movs	r1, #0
 80017dc:	4653      	mov	r3, sl
 80017de:	2201      	movs	r2, #1
 80017e0:	2600      	movs	r6, #0
 80017e2:	4689      	mov	r9, r1
 80017e4:	401a      	ands	r2, r3
 80017e6:	4b44      	ldr	r3, [pc, #272]	; (80018f8 <__aeabi_ddiv+0x1dc>)
 80017e8:	2100      	movs	r1, #0
 80017ea:	0336      	lsls	r6, r6, #12
 80017ec:	0d0c      	lsrs	r4, r1, #20
 80017ee:	0524      	lsls	r4, r4, #20
 80017f0:	0b36      	lsrs	r6, r6, #12
 80017f2:	4326      	orrs	r6, r4
 80017f4:	4c43      	ldr	r4, [pc, #268]	; (8001904 <__aeabi_ddiv+0x1e8>)
 80017f6:	051b      	lsls	r3, r3, #20
 80017f8:	4026      	ands	r6, r4
 80017fa:	431e      	orrs	r6, r3
 80017fc:	0076      	lsls	r6, r6, #1
 80017fe:	07d2      	lsls	r2, r2, #31
 8001800:	0876      	lsrs	r6, r6, #1
 8001802:	4316      	orrs	r6, r2
 8001804:	4648      	mov	r0, r9
 8001806:	0031      	movs	r1, r6
 8001808:	b007      	add	sp, #28
 800180a:	bc3c      	pop	{r2, r3, r4, r5}
 800180c:	4690      	mov	r8, r2
 800180e:	4699      	mov	r9, r3
 8001810:	46a2      	mov	sl, r4
 8001812:	46ab      	mov	fp, r5
 8001814:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001816:	0033      	movs	r3, r6
 8001818:	4303      	orrs	r3, r0
 800181a:	d04f      	beq.n	80018bc <__aeabi_ddiv+0x1a0>
 800181c:	2e00      	cmp	r6, #0
 800181e:	d100      	bne.n	8001822 <__aeabi_ddiv+0x106>
 8001820:	e1bc      	b.n	8001b9c <__aeabi_ddiv+0x480>
 8001822:	0030      	movs	r0, r6
 8001824:	f001 f808 	bl	8002838 <__clzsi2>
 8001828:	0003      	movs	r3, r0
 800182a:	3b0b      	subs	r3, #11
 800182c:	2b1c      	cmp	r3, #28
 800182e:	dd00      	ble.n	8001832 <__aeabi_ddiv+0x116>
 8001830:	e1ad      	b.n	8001b8e <__aeabi_ddiv+0x472>
 8001832:	221d      	movs	r2, #29
 8001834:	0001      	movs	r1, r0
 8001836:	1ad3      	subs	r3, r2, r3
 8001838:	3908      	subs	r1, #8
 800183a:	003a      	movs	r2, r7
 800183c:	408f      	lsls	r7, r1
 800183e:	408e      	lsls	r6, r1
 8001840:	40da      	lsrs	r2, r3
 8001842:	46b9      	mov	r9, r7
 8001844:	4316      	orrs	r6, r2
 8001846:	4b30      	ldr	r3, [pc, #192]	; (8001908 <__aeabi_ddiv+0x1ec>)
 8001848:	2700      	movs	r7, #0
 800184a:	469c      	mov	ip, r3
 800184c:	2300      	movs	r3, #0
 800184e:	4460      	add	r0, ip
 8001850:	4244      	negs	r4, r0
 8001852:	9302      	str	r3, [sp, #8]
 8001854:	e785      	b.n	8001762 <__aeabi_ddiv+0x46>
 8001856:	4653      	mov	r3, sl
 8001858:	465a      	mov	r2, fp
 800185a:	4313      	orrs	r3, r2
 800185c:	d12c      	bne.n	80018b8 <__aeabi_ddiv+0x19c>
 800185e:	2300      	movs	r3, #0
 8001860:	2100      	movs	r1, #0
 8001862:	469b      	mov	fp, r3
 8001864:	3302      	adds	r3, #2
 8001866:	e797      	b.n	8001798 <__aeabi_ddiv+0x7c>
 8001868:	430b      	orrs	r3, r1
 800186a:	d020      	beq.n	80018ae <__aeabi_ddiv+0x192>
 800186c:	465b      	mov	r3, fp
 800186e:	2b00      	cmp	r3, #0
 8001870:	d100      	bne.n	8001874 <__aeabi_ddiv+0x158>
 8001872:	e19e      	b.n	8001bb2 <__aeabi_ddiv+0x496>
 8001874:	4658      	mov	r0, fp
 8001876:	f000 ffdf 	bl	8002838 <__clzsi2>
 800187a:	0003      	movs	r3, r0
 800187c:	3b0b      	subs	r3, #11
 800187e:	2b1c      	cmp	r3, #28
 8001880:	dd00      	ble.n	8001884 <__aeabi_ddiv+0x168>
 8001882:	e18f      	b.n	8001ba4 <__aeabi_ddiv+0x488>
 8001884:	0002      	movs	r2, r0
 8001886:	4659      	mov	r1, fp
 8001888:	3a08      	subs	r2, #8
 800188a:	4091      	lsls	r1, r2
 800188c:	468b      	mov	fp, r1
 800188e:	211d      	movs	r1, #29
 8001890:	1acb      	subs	r3, r1, r3
 8001892:	4651      	mov	r1, sl
 8001894:	40d9      	lsrs	r1, r3
 8001896:	000b      	movs	r3, r1
 8001898:	4659      	mov	r1, fp
 800189a:	430b      	orrs	r3, r1
 800189c:	4651      	mov	r1, sl
 800189e:	469b      	mov	fp, r3
 80018a0:	4091      	lsls	r1, r2
 80018a2:	4b19      	ldr	r3, [pc, #100]	; (8001908 <__aeabi_ddiv+0x1ec>)
 80018a4:	469c      	mov	ip, r3
 80018a6:	4460      	add	r0, ip
 80018a8:	4240      	negs	r0, r0
 80018aa:	2300      	movs	r3, #0
 80018ac:	e774      	b.n	8001798 <__aeabi_ddiv+0x7c>
 80018ae:	2300      	movs	r3, #0
 80018b0:	2100      	movs	r1, #0
 80018b2:	469b      	mov	fp, r3
 80018b4:	3301      	adds	r3, #1
 80018b6:	e76f      	b.n	8001798 <__aeabi_ddiv+0x7c>
 80018b8:	2303      	movs	r3, #3
 80018ba:	e76d      	b.n	8001798 <__aeabi_ddiv+0x7c>
 80018bc:	2300      	movs	r3, #0
 80018be:	4699      	mov	r9, r3
 80018c0:	3301      	adds	r3, #1
 80018c2:	2704      	movs	r7, #4
 80018c4:	2600      	movs	r6, #0
 80018c6:	9302      	str	r3, [sp, #8]
 80018c8:	e74b      	b.n	8001762 <__aeabi_ddiv+0x46>
 80018ca:	2303      	movs	r3, #3
 80018cc:	270c      	movs	r7, #12
 80018ce:	9302      	str	r3, [sp, #8]
 80018d0:	e747      	b.n	8001762 <__aeabi_ddiv+0x46>
 80018d2:	2201      	movs	r2, #1
 80018d4:	1ad5      	subs	r5, r2, r3
 80018d6:	2d38      	cmp	r5, #56	; 0x38
 80018d8:	dc00      	bgt.n	80018dc <__aeabi_ddiv+0x1c0>
 80018da:	e1b0      	b.n	8001c3e <__aeabi_ddiv+0x522>
 80018dc:	4653      	mov	r3, sl
 80018de:	401a      	ands	r2, r3
 80018e0:	2100      	movs	r1, #0
 80018e2:	2300      	movs	r3, #0
 80018e4:	2600      	movs	r6, #0
 80018e6:	4689      	mov	r9, r1
 80018e8:	e77e      	b.n	80017e8 <__aeabi_ddiv+0xcc>
 80018ea:	2300      	movs	r3, #0
 80018ec:	2680      	movs	r6, #128	; 0x80
 80018ee:	4699      	mov	r9, r3
 80018f0:	2200      	movs	r2, #0
 80018f2:	0336      	lsls	r6, r6, #12
 80018f4:	4b00      	ldr	r3, [pc, #0]	; (80018f8 <__aeabi_ddiv+0x1dc>)
 80018f6:	e777      	b.n	80017e8 <__aeabi_ddiv+0xcc>
 80018f8:	000007ff 	.word	0x000007ff
 80018fc:	fffffc01 	.word	0xfffffc01
 8001900:	0800d6cc 	.word	0x0800d6cc
 8001904:	800fffff 	.word	0x800fffff
 8001908:	000003f3 	.word	0x000003f3
 800190c:	455e      	cmp	r6, fp
 800190e:	d900      	bls.n	8001912 <__aeabi_ddiv+0x1f6>
 8001910:	e172      	b.n	8001bf8 <__aeabi_ddiv+0x4dc>
 8001912:	d100      	bne.n	8001916 <__aeabi_ddiv+0x1fa>
 8001914:	e16d      	b.n	8001bf2 <__aeabi_ddiv+0x4d6>
 8001916:	9b01      	ldr	r3, [sp, #4]
 8001918:	464d      	mov	r5, r9
 800191a:	3b01      	subs	r3, #1
 800191c:	9301      	str	r3, [sp, #4]
 800191e:	2300      	movs	r3, #0
 8001920:	0034      	movs	r4, r6
 8001922:	9302      	str	r3, [sp, #8]
 8001924:	465b      	mov	r3, fp
 8001926:	021e      	lsls	r6, r3, #8
 8001928:	0e0b      	lsrs	r3, r1, #24
 800192a:	431e      	orrs	r6, r3
 800192c:	020b      	lsls	r3, r1, #8
 800192e:	9303      	str	r3, [sp, #12]
 8001930:	0c33      	lsrs	r3, r6, #16
 8001932:	4699      	mov	r9, r3
 8001934:	0433      	lsls	r3, r6, #16
 8001936:	0c1b      	lsrs	r3, r3, #16
 8001938:	4649      	mov	r1, r9
 800193a:	0020      	movs	r0, r4
 800193c:	9300      	str	r3, [sp, #0]
 800193e:	f7fe fbed 	bl	800011c <__aeabi_uidiv>
 8001942:	9b00      	ldr	r3, [sp, #0]
 8001944:	0037      	movs	r7, r6
 8001946:	4343      	muls	r3, r0
 8001948:	0006      	movs	r6, r0
 800194a:	4649      	mov	r1, r9
 800194c:	0020      	movs	r0, r4
 800194e:	4698      	mov	r8, r3
 8001950:	f7fe fc6a 	bl	8000228 <__aeabi_uidivmod>
 8001954:	0c2c      	lsrs	r4, r5, #16
 8001956:	0409      	lsls	r1, r1, #16
 8001958:	430c      	orrs	r4, r1
 800195a:	45a0      	cmp	r8, r4
 800195c:	d909      	bls.n	8001972 <__aeabi_ddiv+0x256>
 800195e:	19e4      	adds	r4, r4, r7
 8001960:	1e73      	subs	r3, r6, #1
 8001962:	42a7      	cmp	r7, r4
 8001964:	d900      	bls.n	8001968 <__aeabi_ddiv+0x24c>
 8001966:	e15c      	b.n	8001c22 <__aeabi_ddiv+0x506>
 8001968:	45a0      	cmp	r8, r4
 800196a:	d800      	bhi.n	800196e <__aeabi_ddiv+0x252>
 800196c:	e159      	b.n	8001c22 <__aeabi_ddiv+0x506>
 800196e:	3e02      	subs	r6, #2
 8001970:	19e4      	adds	r4, r4, r7
 8001972:	4643      	mov	r3, r8
 8001974:	1ae4      	subs	r4, r4, r3
 8001976:	4649      	mov	r1, r9
 8001978:	0020      	movs	r0, r4
 800197a:	f7fe fbcf 	bl	800011c <__aeabi_uidiv>
 800197e:	0003      	movs	r3, r0
 8001980:	9a00      	ldr	r2, [sp, #0]
 8001982:	4680      	mov	r8, r0
 8001984:	4353      	muls	r3, r2
 8001986:	4649      	mov	r1, r9
 8001988:	0020      	movs	r0, r4
 800198a:	469b      	mov	fp, r3
 800198c:	f7fe fc4c 	bl	8000228 <__aeabi_uidivmod>
 8001990:	042a      	lsls	r2, r5, #16
 8001992:	0409      	lsls	r1, r1, #16
 8001994:	0c12      	lsrs	r2, r2, #16
 8001996:	430a      	orrs	r2, r1
 8001998:	4593      	cmp	fp, r2
 800199a:	d90d      	bls.n	80019b8 <__aeabi_ddiv+0x29c>
 800199c:	4643      	mov	r3, r8
 800199e:	19d2      	adds	r2, r2, r7
 80019a0:	3b01      	subs	r3, #1
 80019a2:	4297      	cmp	r7, r2
 80019a4:	d900      	bls.n	80019a8 <__aeabi_ddiv+0x28c>
 80019a6:	e13a      	b.n	8001c1e <__aeabi_ddiv+0x502>
 80019a8:	4593      	cmp	fp, r2
 80019aa:	d800      	bhi.n	80019ae <__aeabi_ddiv+0x292>
 80019ac:	e137      	b.n	8001c1e <__aeabi_ddiv+0x502>
 80019ae:	2302      	movs	r3, #2
 80019b0:	425b      	negs	r3, r3
 80019b2:	469c      	mov	ip, r3
 80019b4:	19d2      	adds	r2, r2, r7
 80019b6:	44e0      	add	r8, ip
 80019b8:	465b      	mov	r3, fp
 80019ba:	1ad2      	subs	r2, r2, r3
 80019bc:	4643      	mov	r3, r8
 80019be:	0436      	lsls	r6, r6, #16
 80019c0:	4333      	orrs	r3, r6
 80019c2:	469b      	mov	fp, r3
 80019c4:	9903      	ldr	r1, [sp, #12]
 80019c6:	0c18      	lsrs	r0, r3, #16
 80019c8:	0c0b      	lsrs	r3, r1, #16
 80019ca:	001d      	movs	r5, r3
 80019cc:	9305      	str	r3, [sp, #20]
 80019ce:	0409      	lsls	r1, r1, #16
 80019d0:	465b      	mov	r3, fp
 80019d2:	0c09      	lsrs	r1, r1, #16
 80019d4:	000c      	movs	r4, r1
 80019d6:	041b      	lsls	r3, r3, #16
 80019d8:	0c1b      	lsrs	r3, r3, #16
 80019da:	4344      	muls	r4, r0
 80019dc:	9104      	str	r1, [sp, #16]
 80019de:	4359      	muls	r1, r3
 80019e0:	436b      	muls	r3, r5
 80019e2:	4368      	muls	r0, r5
 80019e4:	191b      	adds	r3, r3, r4
 80019e6:	0c0d      	lsrs	r5, r1, #16
 80019e8:	18eb      	adds	r3, r5, r3
 80019ea:	429c      	cmp	r4, r3
 80019ec:	d903      	bls.n	80019f6 <__aeabi_ddiv+0x2da>
 80019ee:	2480      	movs	r4, #128	; 0x80
 80019f0:	0264      	lsls	r4, r4, #9
 80019f2:	46a4      	mov	ip, r4
 80019f4:	4460      	add	r0, ip
 80019f6:	0c1c      	lsrs	r4, r3, #16
 80019f8:	0409      	lsls	r1, r1, #16
 80019fa:	041b      	lsls	r3, r3, #16
 80019fc:	0c09      	lsrs	r1, r1, #16
 80019fe:	1820      	adds	r0, r4, r0
 8001a00:	185d      	adds	r5, r3, r1
 8001a02:	4282      	cmp	r2, r0
 8001a04:	d200      	bcs.n	8001a08 <__aeabi_ddiv+0x2ec>
 8001a06:	e0de      	b.n	8001bc6 <__aeabi_ddiv+0x4aa>
 8001a08:	d100      	bne.n	8001a0c <__aeabi_ddiv+0x2f0>
 8001a0a:	e0d7      	b.n	8001bbc <__aeabi_ddiv+0x4a0>
 8001a0c:	1a16      	subs	r6, r2, r0
 8001a0e:	9b02      	ldr	r3, [sp, #8]
 8001a10:	469c      	mov	ip, r3
 8001a12:	1b5d      	subs	r5, r3, r5
 8001a14:	45ac      	cmp	ip, r5
 8001a16:	419b      	sbcs	r3, r3
 8001a18:	425b      	negs	r3, r3
 8001a1a:	1af6      	subs	r6, r6, r3
 8001a1c:	42b7      	cmp	r7, r6
 8001a1e:	d100      	bne.n	8001a22 <__aeabi_ddiv+0x306>
 8001a20:	e106      	b.n	8001c30 <__aeabi_ddiv+0x514>
 8001a22:	4649      	mov	r1, r9
 8001a24:	0030      	movs	r0, r6
 8001a26:	f7fe fb79 	bl	800011c <__aeabi_uidiv>
 8001a2a:	9b00      	ldr	r3, [sp, #0]
 8001a2c:	0004      	movs	r4, r0
 8001a2e:	4343      	muls	r3, r0
 8001a30:	4649      	mov	r1, r9
 8001a32:	0030      	movs	r0, r6
 8001a34:	4698      	mov	r8, r3
 8001a36:	f7fe fbf7 	bl	8000228 <__aeabi_uidivmod>
 8001a3a:	0c2e      	lsrs	r6, r5, #16
 8001a3c:	0409      	lsls	r1, r1, #16
 8001a3e:	430e      	orrs	r6, r1
 8001a40:	45b0      	cmp	r8, r6
 8001a42:	d909      	bls.n	8001a58 <__aeabi_ddiv+0x33c>
 8001a44:	19f6      	adds	r6, r6, r7
 8001a46:	1e63      	subs	r3, r4, #1
 8001a48:	42b7      	cmp	r7, r6
 8001a4a:	d900      	bls.n	8001a4e <__aeabi_ddiv+0x332>
 8001a4c:	e0f3      	b.n	8001c36 <__aeabi_ddiv+0x51a>
 8001a4e:	45b0      	cmp	r8, r6
 8001a50:	d800      	bhi.n	8001a54 <__aeabi_ddiv+0x338>
 8001a52:	e0f0      	b.n	8001c36 <__aeabi_ddiv+0x51a>
 8001a54:	3c02      	subs	r4, #2
 8001a56:	19f6      	adds	r6, r6, r7
 8001a58:	4643      	mov	r3, r8
 8001a5a:	1af3      	subs	r3, r6, r3
 8001a5c:	4649      	mov	r1, r9
 8001a5e:	0018      	movs	r0, r3
 8001a60:	9302      	str	r3, [sp, #8]
 8001a62:	f7fe fb5b 	bl	800011c <__aeabi_uidiv>
 8001a66:	9b00      	ldr	r3, [sp, #0]
 8001a68:	0006      	movs	r6, r0
 8001a6a:	4343      	muls	r3, r0
 8001a6c:	4649      	mov	r1, r9
 8001a6e:	9802      	ldr	r0, [sp, #8]
 8001a70:	4698      	mov	r8, r3
 8001a72:	f7fe fbd9 	bl	8000228 <__aeabi_uidivmod>
 8001a76:	042d      	lsls	r5, r5, #16
 8001a78:	0409      	lsls	r1, r1, #16
 8001a7a:	0c2d      	lsrs	r5, r5, #16
 8001a7c:	430d      	orrs	r5, r1
 8001a7e:	45a8      	cmp	r8, r5
 8001a80:	d909      	bls.n	8001a96 <__aeabi_ddiv+0x37a>
 8001a82:	19ed      	adds	r5, r5, r7
 8001a84:	1e73      	subs	r3, r6, #1
 8001a86:	42af      	cmp	r7, r5
 8001a88:	d900      	bls.n	8001a8c <__aeabi_ddiv+0x370>
 8001a8a:	e0d6      	b.n	8001c3a <__aeabi_ddiv+0x51e>
 8001a8c:	45a8      	cmp	r8, r5
 8001a8e:	d800      	bhi.n	8001a92 <__aeabi_ddiv+0x376>
 8001a90:	e0d3      	b.n	8001c3a <__aeabi_ddiv+0x51e>
 8001a92:	3e02      	subs	r6, #2
 8001a94:	19ed      	adds	r5, r5, r7
 8001a96:	0424      	lsls	r4, r4, #16
 8001a98:	0021      	movs	r1, r4
 8001a9a:	4643      	mov	r3, r8
 8001a9c:	4331      	orrs	r1, r6
 8001a9e:	9e04      	ldr	r6, [sp, #16]
 8001aa0:	9a05      	ldr	r2, [sp, #20]
 8001aa2:	0030      	movs	r0, r6
 8001aa4:	1aed      	subs	r5, r5, r3
 8001aa6:	040b      	lsls	r3, r1, #16
 8001aa8:	0c0c      	lsrs	r4, r1, #16
 8001aaa:	0c1b      	lsrs	r3, r3, #16
 8001aac:	4358      	muls	r0, r3
 8001aae:	4366      	muls	r6, r4
 8001ab0:	4353      	muls	r3, r2
 8001ab2:	4354      	muls	r4, r2
 8001ab4:	199a      	adds	r2, r3, r6
 8001ab6:	0c03      	lsrs	r3, r0, #16
 8001ab8:	189b      	adds	r3, r3, r2
 8001aba:	429e      	cmp	r6, r3
 8001abc:	d903      	bls.n	8001ac6 <__aeabi_ddiv+0x3aa>
 8001abe:	2280      	movs	r2, #128	; 0x80
 8001ac0:	0252      	lsls	r2, r2, #9
 8001ac2:	4694      	mov	ip, r2
 8001ac4:	4464      	add	r4, ip
 8001ac6:	0c1a      	lsrs	r2, r3, #16
 8001ac8:	0400      	lsls	r0, r0, #16
 8001aca:	041b      	lsls	r3, r3, #16
 8001acc:	0c00      	lsrs	r0, r0, #16
 8001ace:	1914      	adds	r4, r2, r4
 8001ad0:	181b      	adds	r3, r3, r0
 8001ad2:	42a5      	cmp	r5, r4
 8001ad4:	d350      	bcc.n	8001b78 <__aeabi_ddiv+0x45c>
 8001ad6:	d04d      	beq.n	8001b74 <__aeabi_ddiv+0x458>
 8001ad8:	2301      	movs	r3, #1
 8001ada:	4319      	orrs	r1, r3
 8001adc:	4a96      	ldr	r2, [pc, #600]	; (8001d38 <__aeabi_ddiv+0x61c>)
 8001ade:	9b01      	ldr	r3, [sp, #4]
 8001ae0:	4694      	mov	ip, r2
 8001ae2:	4463      	add	r3, ip
 8001ae4:	2b00      	cmp	r3, #0
 8001ae6:	dc00      	bgt.n	8001aea <__aeabi_ddiv+0x3ce>
 8001ae8:	e6f3      	b.n	80018d2 <__aeabi_ddiv+0x1b6>
 8001aea:	074a      	lsls	r2, r1, #29
 8001aec:	d009      	beq.n	8001b02 <__aeabi_ddiv+0x3e6>
 8001aee:	220f      	movs	r2, #15
 8001af0:	400a      	ands	r2, r1
 8001af2:	2a04      	cmp	r2, #4
 8001af4:	d005      	beq.n	8001b02 <__aeabi_ddiv+0x3e6>
 8001af6:	1d0a      	adds	r2, r1, #4
 8001af8:	428a      	cmp	r2, r1
 8001afa:	4189      	sbcs	r1, r1
 8001afc:	4249      	negs	r1, r1
 8001afe:	448b      	add	fp, r1
 8001b00:	0011      	movs	r1, r2
 8001b02:	465a      	mov	r2, fp
 8001b04:	01d2      	lsls	r2, r2, #7
 8001b06:	d508      	bpl.n	8001b1a <__aeabi_ddiv+0x3fe>
 8001b08:	465a      	mov	r2, fp
 8001b0a:	4b8c      	ldr	r3, [pc, #560]	; (8001d3c <__aeabi_ddiv+0x620>)
 8001b0c:	401a      	ands	r2, r3
 8001b0e:	4693      	mov	fp, r2
 8001b10:	2280      	movs	r2, #128	; 0x80
 8001b12:	00d2      	lsls	r2, r2, #3
 8001b14:	4694      	mov	ip, r2
 8001b16:	9b01      	ldr	r3, [sp, #4]
 8001b18:	4463      	add	r3, ip
 8001b1a:	4a89      	ldr	r2, [pc, #548]	; (8001d40 <__aeabi_ddiv+0x624>)
 8001b1c:	4293      	cmp	r3, r2
 8001b1e:	dd00      	ble.n	8001b22 <__aeabi_ddiv+0x406>
 8001b20:	e65b      	b.n	80017da <__aeabi_ddiv+0xbe>
 8001b22:	465a      	mov	r2, fp
 8001b24:	08c9      	lsrs	r1, r1, #3
 8001b26:	0750      	lsls	r0, r2, #29
 8001b28:	4308      	orrs	r0, r1
 8001b2a:	0256      	lsls	r6, r2, #9
 8001b2c:	4651      	mov	r1, sl
 8001b2e:	2201      	movs	r2, #1
 8001b30:	055b      	lsls	r3, r3, #21
 8001b32:	4681      	mov	r9, r0
 8001b34:	0b36      	lsrs	r6, r6, #12
 8001b36:	0d5b      	lsrs	r3, r3, #21
 8001b38:	400a      	ands	r2, r1
 8001b3a:	e655      	b.n	80017e8 <__aeabi_ddiv+0xcc>
 8001b3c:	2380      	movs	r3, #128	; 0x80
 8001b3e:	031b      	lsls	r3, r3, #12
 8001b40:	421e      	tst	r6, r3
 8001b42:	d011      	beq.n	8001b68 <__aeabi_ddiv+0x44c>
 8001b44:	465a      	mov	r2, fp
 8001b46:	421a      	tst	r2, r3
 8001b48:	d10e      	bne.n	8001b68 <__aeabi_ddiv+0x44c>
 8001b4a:	465e      	mov	r6, fp
 8001b4c:	431e      	orrs	r6, r3
 8001b4e:	0336      	lsls	r6, r6, #12
 8001b50:	0b36      	lsrs	r6, r6, #12
 8001b52:	002a      	movs	r2, r5
 8001b54:	4689      	mov	r9, r1
 8001b56:	4b7b      	ldr	r3, [pc, #492]	; (8001d44 <__aeabi_ddiv+0x628>)
 8001b58:	e646      	b.n	80017e8 <__aeabi_ddiv+0xcc>
 8001b5a:	2b03      	cmp	r3, #3
 8001b5c:	d100      	bne.n	8001b60 <__aeabi_ddiv+0x444>
 8001b5e:	e0e1      	b.n	8001d24 <__aeabi_ddiv+0x608>
 8001b60:	2b01      	cmp	r3, #1
 8001b62:	d1bb      	bne.n	8001adc <__aeabi_ddiv+0x3c0>
 8001b64:	401a      	ands	r2, r3
 8001b66:	e6bb      	b.n	80018e0 <__aeabi_ddiv+0x1c4>
 8001b68:	431e      	orrs	r6, r3
 8001b6a:	0336      	lsls	r6, r6, #12
 8001b6c:	0b36      	lsrs	r6, r6, #12
 8001b6e:	4642      	mov	r2, r8
 8001b70:	4b74      	ldr	r3, [pc, #464]	; (8001d44 <__aeabi_ddiv+0x628>)
 8001b72:	e639      	b.n	80017e8 <__aeabi_ddiv+0xcc>
 8001b74:	2b00      	cmp	r3, #0
 8001b76:	d0b1      	beq.n	8001adc <__aeabi_ddiv+0x3c0>
 8001b78:	197d      	adds	r5, r7, r5
 8001b7a:	1e4a      	subs	r2, r1, #1
 8001b7c:	42af      	cmp	r7, r5
 8001b7e:	d952      	bls.n	8001c26 <__aeabi_ddiv+0x50a>
 8001b80:	0011      	movs	r1, r2
 8001b82:	42a5      	cmp	r5, r4
 8001b84:	d1a8      	bne.n	8001ad8 <__aeabi_ddiv+0x3bc>
 8001b86:	9a03      	ldr	r2, [sp, #12]
 8001b88:	429a      	cmp	r2, r3
 8001b8a:	d1a5      	bne.n	8001ad8 <__aeabi_ddiv+0x3bc>
 8001b8c:	e7a6      	b.n	8001adc <__aeabi_ddiv+0x3c0>
 8001b8e:	0003      	movs	r3, r0
 8001b90:	003e      	movs	r6, r7
 8001b92:	3b28      	subs	r3, #40	; 0x28
 8001b94:	409e      	lsls	r6, r3
 8001b96:	2300      	movs	r3, #0
 8001b98:	4699      	mov	r9, r3
 8001b9a:	e654      	b.n	8001846 <__aeabi_ddiv+0x12a>
 8001b9c:	f000 fe4c 	bl	8002838 <__clzsi2>
 8001ba0:	3020      	adds	r0, #32
 8001ba2:	e641      	b.n	8001828 <__aeabi_ddiv+0x10c>
 8001ba4:	0003      	movs	r3, r0
 8001ba6:	4652      	mov	r2, sl
 8001ba8:	3b28      	subs	r3, #40	; 0x28
 8001baa:	409a      	lsls	r2, r3
 8001bac:	2100      	movs	r1, #0
 8001bae:	4693      	mov	fp, r2
 8001bb0:	e677      	b.n	80018a2 <__aeabi_ddiv+0x186>
 8001bb2:	4650      	mov	r0, sl
 8001bb4:	f000 fe40 	bl	8002838 <__clzsi2>
 8001bb8:	3020      	adds	r0, #32
 8001bba:	e65e      	b.n	800187a <__aeabi_ddiv+0x15e>
 8001bbc:	9b02      	ldr	r3, [sp, #8]
 8001bbe:	2600      	movs	r6, #0
 8001bc0:	42ab      	cmp	r3, r5
 8001bc2:	d300      	bcc.n	8001bc6 <__aeabi_ddiv+0x4aa>
 8001bc4:	e723      	b.n	8001a0e <__aeabi_ddiv+0x2f2>
 8001bc6:	9e03      	ldr	r6, [sp, #12]
 8001bc8:	9902      	ldr	r1, [sp, #8]
 8001bca:	46b4      	mov	ip, r6
 8001bcc:	4461      	add	r1, ip
 8001bce:	4688      	mov	r8, r1
 8001bd0:	45b0      	cmp	r8, r6
 8001bd2:	41b6      	sbcs	r6, r6
 8001bd4:	465b      	mov	r3, fp
 8001bd6:	4276      	negs	r6, r6
 8001bd8:	19f6      	adds	r6, r6, r7
 8001bda:	18b2      	adds	r2, r6, r2
 8001bdc:	3b01      	subs	r3, #1
 8001bde:	9102      	str	r1, [sp, #8]
 8001be0:	4297      	cmp	r7, r2
 8001be2:	d213      	bcs.n	8001c0c <__aeabi_ddiv+0x4f0>
 8001be4:	4290      	cmp	r0, r2
 8001be6:	d84f      	bhi.n	8001c88 <__aeabi_ddiv+0x56c>
 8001be8:	d100      	bne.n	8001bec <__aeabi_ddiv+0x4d0>
 8001bea:	e08e      	b.n	8001d0a <__aeabi_ddiv+0x5ee>
 8001bec:	1a16      	subs	r6, r2, r0
 8001bee:	469b      	mov	fp, r3
 8001bf0:	e70d      	b.n	8001a0e <__aeabi_ddiv+0x2f2>
 8001bf2:	4589      	cmp	r9, r1
 8001bf4:	d200      	bcs.n	8001bf8 <__aeabi_ddiv+0x4dc>
 8001bf6:	e68e      	b.n	8001916 <__aeabi_ddiv+0x1fa>
 8001bf8:	0874      	lsrs	r4, r6, #1
 8001bfa:	464b      	mov	r3, r9
 8001bfc:	07f6      	lsls	r6, r6, #31
 8001bfe:	0035      	movs	r5, r6
 8001c00:	085b      	lsrs	r3, r3, #1
 8001c02:	431d      	orrs	r5, r3
 8001c04:	464b      	mov	r3, r9
 8001c06:	07db      	lsls	r3, r3, #31
 8001c08:	9302      	str	r3, [sp, #8]
 8001c0a:	e68b      	b.n	8001924 <__aeabi_ddiv+0x208>
 8001c0c:	4297      	cmp	r7, r2
 8001c0e:	d1ed      	bne.n	8001bec <__aeabi_ddiv+0x4d0>
 8001c10:	9903      	ldr	r1, [sp, #12]
 8001c12:	9c02      	ldr	r4, [sp, #8]
 8001c14:	42a1      	cmp	r1, r4
 8001c16:	d9e5      	bls.n	8001be4 <__aeabi_ddiv+0x4c8>
 8001c18:	1a3e      	subs	r6, r7, r0
 8001c1a:	469b      	mov	fp, r3
 8001c1c:	e6f7      	b.n	8001a0e <__aeabi_ddiv+0x2f2>
 8001c1e:	4698      	mov	r8, r3
 8001c20:	e6ca      	b.n	80019b8 <__aeabi_ddiv+0x29c>
 8001c22:	001e      	movs	r6, r3
 8001c24:	e6a5      	b.n	8001972 <__aeabi_ddiv+0x256>
 8001c26:	42ac      	cmp	r4, r5
 8001c28:	d83e      	bhi.n	8001ca8 <__aeabi_ddiv+0x58c>
 8001c2a:	d074      	beq.n	8001d16 <__aeabi_ddiv+0x5fa>
 8001c2c:	0011      	movs	r1, r2
 8001c2e:	e753      	b.n	8001ad8 <__aeabi_ddiv+0x3bc>
 8001c30:	2101      	movs	r1, #1
 8001c32:	4249      	negs	r1, r1
 8001c34:	e752      	b.n	8001adc <__aeabi_ddiv+0x3c0>
 8001c36:	001c      	movs	r4, r3
 8001c38:	e70e      	b.n	8001a58 <__aeabi_ddiv+0x33c>
 8001c3a:	001e      	movs	r6, r3
 8001c3c:	e72b      	b.n	8001a96 <__aeabi_ddiv+0x37a>
 8001c3e:	2d1f      	cmp	r5, #31
 8001c40:	dc3c      	bgt.n	8001cbc <__aeabi_ddiv+0x5a0>
 8001c42:	2320      	movs	r3, #32
 8001c44:	000a      	movs	r2, r1
 8001c46:	4658      	mov	r0, fp
 8001c48:	1b5b      	subs	r3, r3, r5
 8001c4a:	4098      	lsls	r0, r3
 8001c4c:	40ea      	lsrs	r2, r5
 8001c4e:	4099      	lsls	r1, r3
 8001c50:	4302      	orrs	r2, r0
 8001c52:	1e48      	subs	r0, r1, #1
 8001c54:	4181      	sbcs	r1, r0
 8001c56:	465e      	mov	r6, fp
 8001c58:	4311      	orrs	r1, r2
 8001c5a:	40ee      	lsrs	r6, r5
 8001c5c:	074b      	lsls	r3, r1, #29
 8001c5e:	d009      	beq.n	8001c74 <__aeabi_ddiv+0x558>
 8001c60:	230f      	movs	r3, #15
 8001c62:	400b      	ands	r3, r1
 8001c64:	2b04      	cmp	r3, #4
 8001c66:	d005      	beq.n	8001c74 <__aeabi_ddiv+0x558>
 8001c68:	000b      	movs	r3, r1
 8001c6a:	1d19      	adds	r1, r3, #4
 8001c6c:	4299      	cmp	r1, r3
 8001c6e:	419b      	sbcs	r3, r3
 8001c70:	425b      	negs	r3, r3
 8001c72:	18f6      	adds	r6, r6, r3
 8001c74:	0233      	lsls	r3, r6, #8
 8001c76:	d53c      	bpl.n	8001cf2 <__aeabi_ddiv+0x5d6>
 8001c78:	4653      	mov	r3, sl
 8001c7a:	2201      	movs	r2, #1
 8001c7c:	2100      	movs	r1, #0
 8001c7e:	401a      	ands	r2, r3
 8001c80:	2600      	movs	r6, #0
 8001c82:	2301      	movs	r3, #1
 8001c84:	4689      	mov	r9, r1
 8001c86:	e5af      	b.n	80017e8 <__aeabi_ddiv+0xcc>
 8001c88:	2302      	movs	r3, #2
 8001c8a:	425b      	negs	r3, r3
 8001c8c:	469c      	mov	ip, r3
 8001c8e:	9c03      	ldr	r4, [sp, #12]
 8001c90:	44e3      	add	fp, ip
 8001c92:	46a4      	mov	ip, r4
 8001c94:	9b02      	ldr	r3, [sp, #8]
 8001c96:	4463      	add	r3, ip
 8001c98:	4698      	mov	r8, r3
 8001c9a:	45a0      	cmp	r8, r4
 8001c9c:	41b6      	sbcs	r6, r6
 8001c9e:	4276      	negs	r6, r6
 8001ca0:	19f6      	adds	r6, r6, r7
 8001ca2:	9302      	str	r3, [sp, #8]
 8001ca4:	18b2      	adds	r2, r6, r2
 8001ca6:	e6b1      	b.n	8001a0c <__aeabi_ddiv+0x2f0>
 8001ca8:	9803      	ldr	r0, [sp, #12]
 8001caa:	1e8a      	subs	r2, r1, #2
 8001cac:	0041      	lsls	r1, r0, #1
 8001cae:	4281      	cmp	r1, r0
 8001cb0:	41b6      	sbcs	r6, r6
 8001cb2:	4276      	negs	r6, r6
 8001cb4:	19f6      	adds	r6, r6, r7
 8001cb6:	19ad      	adds	r5, r5, r6
 8001cb8:	9103      	str	r1, [sp, #12]
 8001cba:	e761      	b.n	8001b80 <__aeabi_ddiv+0x464>
 8001cbc:	221f      	movs	r2, #31
 8001cbe:	4252      	negs	r2, r2
 8001cc0:	1ad3      	subs	r3, r2, r3
 8001cc2:	465a      	mov	r2, fp
 8001cc4:	40da      	lsrs	r2, r3
 8001cc6:	0013      	movs	r3, r2
 8001cc8:	2d20      	cmp	r5, #32
 8001cca:	d029      	beq.n	8001d20 <__aeabi_ddiv+0x604>
 8001ccc:	2240      	movs	r2, #64	; 0x40
 8001cce:	4658      	mov	r0, fp
 8001cd0:	1b55      	subs	r5, r2, r5
 8001cd2:	40a8      	lsls	r0, r5
 8001cd4:	4301      	orrs	r1, r0
 8001cd6:	1e48      	subs	r0, r1, #1
 8001cd8:	4181      	sbcs	r1, r0
 8001cda:	2007      	movs	r0, #7
 8001cdc:	430b      	orrs	r3, r1
 8001cde:	4018      	ands	r0, r3
 8001ce0:	2600      	movs	r6, #0
 8001ce2:	2800      	cmp	r0, #0
 8001ce4:	d009      	beq.n	8001cfa <__aeabi_ddiv+0x5de>
 8001ce6:	220f      	movs	r2, #15
 8001ce8:	2600      	movs	r6, #0
 8001cea:	401a      	ands	r2, r3
 8001cec:	0019      	movs	r1, r3
 8001cee:	2a04      	cmp	r2, #4
 8001cf0:	d1bb      	bne.n	8001c6a <__aeabi_ddiv+0x54e>
 8001cf2:	000b      	movs	r3, r1
 8001cf4:	0770      	lsls	r0, r6, #29
 8001cf6:	0276      	lsls	r6, r6, #9
 8001cf8:	0b36      	lsrs	r6, r6, #12
 8001cfa:	08db      	lsrs	r3, r3, #3
 8001cfc:	4303      	orrs	r3, r0
 8001cfe:	4699      	mov	r9, r3
 8001d00:	2201      	movs	r2, #1
 8001d02:	4653      	mov	r3, sl
 8001d04:	401a      	ands	r2, r3
 8001d06:	2300      	movs	r3, #0
 8001d08:	e56e      	b.n	80017e8 <__aeabi_ddiv+0xcc>
 8001d0a:	9902      	ldr	r1, [sp, #8]
 8001d0c:	428d      	cmp	r5, r1
 8001d0e:	d8bb      	bhi.n	8001c88 <__aeabi_ddiv+0x56c>
 8001d10:	469b      	mov	fp, r3
 8001d12:	2600      	movs	r6, #0
 8001d14:	e67b      	b.n	8001a0e <__aeabi_ddiv+0x2f2>
 8001d16:	9803      	ldr	r0, [sp, #12]
 8001d18:	4298      	cmp	r0, r3
 8001d1a:	d3c5      	bcc.n	8001ca8 <__aeabi_ddiv+0x58c>
 8001d1c:	0011      	movs	r1, r2
 8001d1e:	e732      	b.n	8001b86 <__aeabi_ddiv+0x46a>
 8001d20:	2000      	movs	r0, #0
 8001d22:	e7d7      	b.n	8001cd4 <__aeabi_ddiv+0x5b8>
 8001d24:	2680      	movs	r6, #128	; 0x80
 8001d26:	465b      	mov	r3, fp
 8001d28:	0336      	lsls	r6, r6, #12
 8001d2a:	431e      	orrs	r6, r3
 8001d2c:	0336      	lsls	r6, r6, #12
 8001d2e:	0b36      	lsrs	r6, r6, #12
 8001d30:	9a00      	ldr	r2, [sp, #0]
 8001d32:	4689      	mov	r9, r1
 8001d34:	4b03      	ldr	r3, [pc, #12]	; (8001d44 <__aeabi_ddiv+0x628>)
 8001d36:	e557      	b.n	80017e8 <__aeabi_ddiv+0xcc>
 8001d38:	000003ff 	.word	0x000003ff
 8001d3c:	feffffff 	.word	0xfeffffff
 8001d40:	000007fe 	.word	0x000007fe
 8001d44:	000007ff 	.word	0x000007ff

08001d48 <__eqdf2>:
 8001d48:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001d4a:	465f      	mov	r7, fp
 8001d4c:	4656      	mov	r6, sl
 8001d4e:	464d      	mov	r5, r9
 8001d50:	4644      	mov	r4, r8
 8001d52:	b4f0      	push	{r4, r5, r6, r7}
 8001d54:	031f      	lsls	r7, r3, #12
 8001d56:	005c      	lsls	r4, r3, #1
 8001d58:	0fdb      	lsrs	r3, r3, #31
 8001d5a:	469a      	mov	sl, r3
 8001d5c:	4b19      	ldr	r3, [pc, #100]	; (8001dc4 <__eqdf2+0x7c>)
 8001d5e:	030e      	lsls	r6, r1, #12
 8001d60:	004d      	lsls	r5, r1, #1
 8001d62:	0fc9      	lsrs	r1, r1, #31
 8001d64:	4680      	mov	r8, r0
 8001d66:	0b36      	lsrs	r6, r6, #12
 8001d68:	0d6d      	lsrs	r5, r5, #21
 8001d6a:	468b      	mov	fp, r1
 8001d6c:	4691      	mov	r9, r2
 8001d6e:	0b3f      	lsrs	r7, r7, #12
 8001d70:	0d64      	lsrs	r4, r4, #21
 8001d72:	429d      	cmp	r5, r3
 8001d74:	d019      	beq.n	8001daa <__eqdf2+0x62>
 8001d76:	4b13      	ldr	r3, [pc, #76]	; (8001dc4 <__eqdf2+0x7c>)
 8001d78:	429c      	cmp	r4, r3
 8001d7a:	d01b      	beq.n	8001db4 <__eqdf2+0x6c>
 8001d7c:	2301      	movs	r3, #1
 8001d7e:	42a5      	cmp	r5, r4
 8001d80:	d006      	beq.n	8001d90 <__eqdf2+0x48>
 8001d82:	0018      	movs	r0, r3
 8001d84:	bc3c      	pop	{r2, r3, r4, r5}
 8001d86:	4690      	mov	r8, r2
 8001d88:	4699      	mov	r9, r3
 8001d8a:	46a2      	mov	sl, r4
 8001d8c:	46ab      	mov	fp, r5
 8001d8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001d90:	42be      	cmp	r6, r7
 8001d92:	d1f6      	bne.n	8001d82 <__eqdf2+0x3a>
 8001d94:	45c8      	cmp	r8, r9
 8001d96:	d1f4      	bne.n	8001d82 <__eqdf2+0x3a>
 8001d98:	45d3      	cmp	fp, sl
 8001d9a:	d010      	beq.n	8001dbe <__eqdf2+0x76>
 8001d9c:	2d00      	cmp	r5, #0
 8001d9e:	d1f0      	bne.n	8001d82 <__eqdf2+0x3a>
 8001da0:	4330      	orrs	r0, r6
 8001da2:	0003      	movs	r3, r0
 8001da4:	1e5a      	subs	r2, r3, #1
 8001da6:	4193      	sbcs	r3, r2
 8001da8:	e7eb      	b.n	8001d82 <__eqdf2+0x3a>
 8001daa:	0031      	movs	r1, r6
 8001dac:	2301      	movs	r3, #1
 8001dae:	4301      	orrs	r1, r0
 8001db0:	d1e7      	bne.n	8001d82 <__eqdf2+0x3a>
 8001db2:	e7e0      	b.n	8001d76 <__eqdf2+0x2e>
 8001db4:	433a      	orrs	r2, r7
 8001db6:	2301      	movs	r3, #1
 8001db8:	2a00      	cmp	r2, #0
 8001dba:	d1e2      	bne.n	8001d82 <__eqdf2+0x3a>
 8001dbc:	e7de      	b.n	8001d7c <__eqdf2+0x34>
 8001dbe:	2300      	movs	r3, #0
 8001dc0:	e7df      	b.n	8001d82 <__eqdf2+0x3a>
 8001dc2:	46c0      	nop			; (mov r8, r8)
 8001dc4:	000007ff 	.word	0x000007ff

08001dc8 <__gedf2>:
 8001dc8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001dca:	465f      	mov	r7, fp
 8001dcc:	4644      	mov	r4, r8
 8001dce:	4656      	mov	r6, sl
 8001dd0:	464d      	mov	r5, r9
 8001dd2:	b4f0      	push	{r4, r5, r6, r7}
 8001dd4:	031f      	lsls	r7, r3, #12
 8001dd6:	0b3c      	lsrs	r4, r7, #12
 8001dd8:	4f2c      	ldr	r7, [pc, #176]	; (8001e8c <__gedf2+0xc4>)
 8001dda:	030e      	lsls	r6, r1, #12
 8001ddc:	004d      	lsls	r5, r1, #1
 8001dde:	46a3      	mov	fp, r4
 8001de0:	005c      	lsls	r4, r3, #1
 8001de2:	4684      	mov	ip, r0
 8001de4:	0b36      	lsrs	r6, r6, #12
 8001de6:	0d6d      	lsrs	r5, r5, #21
 8001de8:	0fc9      	lsrs	r1, r1, #31
 8001dea:	4690      	mov	r8, r2
 8001dec:	0d64      	lsrs	r4, r4, #21
 8001dee:	0fdb      	lsrs	r3, r3, #31
 8001df0:	42bd      	cmp	r5, r7
 8001df2:	d02b      	beq.n	8001e4c <__gedf2+0x84>
 8001df4:	4f25      	ldr	r7, [pc, #148]	; (8001e8c <__gedf2+0xc4>)
 8001df6:	42bc      	cmp	r4, r7
 8001df8:	d02e      	beq.n	8001e58 <__gedf2+0x90>
 8001dfa:	2d00      	cmp	r5, #0
 8001dfc:	d10e      	bne.n	8001e1c <__gedf2+0x54>
 8001dfe:	4330      	orrs	r0, r6
 8001e00:	0007      	movs	r7, r0
 8001e02:	4681      	mov	r9, r0
 8001e04:	4278      	negs	r0, r7
 8001e06:	4178      	adcs	r0, r7
 8001e08:	2c00      	cmp	r4, #0
 8001e0a:	d117      	bne.n	8001e3c <__gedf2+0x74>
 8001e0c:	465f      	mov	r7, fp
 8001e0e:	433a      	orrs	r2, r7
 8001e10:	d114      	bne.n	8001e3c <__gedf2+0x74>
 8001e12:	464b      	mov	r3, r9
 8001e14:	2000      	movs	r0, #0
 8001e16:	2b00      	cmp	r3, #0
 8001e18:	d00a      	beq.n	8001e30 <__gedf2+0x68>
 8001e1a:	e006      	b.n	8001e2a <__gedf2+0x62>
 8001e1c:	2c00      	cmp	r4, #0
 8001e1e:	d102      	bne.n	8001e26 <__gedf2+0x5e>
 8001e20:	4658      	mov	r0, fp
 8001e22:	4302      	orrs	r2, r0
 8001e24:	d001      	beq.n	8001e2a <__gedf2+0x62>
 8001e26:	4299      	cmp	r1, r3
 8001e28:	d01a      	beq.n	8001e60 <__gedf2+0x98>
 8001e2a:	2301      	movs	r3, #1
 8001e2c:	4248      	negs	r0, r1
 8001e2e:	4318      	orrs	r0, r3
 8001e30:	bc3c      	pop	{r2, r3, r4, r5}
 8001e32:	4690      	mov	r8, r2
 8001e34:	4699      	mov	r9, r3
 8001e36:	46a2      	mov	sl, r4
 8001e38:	46ab      	mov	fp, r5
 8001e3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001e3c:	2800      	cmp	r0, #0
 8001e3e:	d0f2      	beq.n	8001e26 <__gedf2+0x5e>
 8001e40:	4258      	negs	r0, r3
 8001e42:	4158      	adcs	r0, r3
 8001e44:	2201      	movs	r2, #1
 8001e46:	4240      	negs	r0, r0
 8001e48:	4310      	orrs	r0, r2
 8001e4a:	e7f1      	b.n	8001e30 <__gedf2+0x68>
 8001e4c:	0037      	movs	r7, r6
 8001e4e:	4307      	orrs	r7, r0
 8001e50:	d0d0      	beq.n	8001df4 <__gedf2+0x2c>
 8001e52:	2002      	movs	r0, #2
 8001e54:	4240      	negs	r0, r0
 8001e56:	e7eb      	b.n	8001e30 <__gedf2+0x68>
 8001e58:	465f      	mov	r7, fp
 8001e5a:	4317      	orrs	r7, r2
 8001e5c:	d0cd      	beq.n	8001dfa <__gedf2+0x32>
 8001e5e:	e7f8      	b.n	8001e52 <__gedf2+0x8a>
 8001e60:	42a5      	cmp	r5, r4
 8001e62:	dce2      	bgt.n	8001e2a <__gedf2+0x62>
 8001e64:	db05      	blt.n	8001e72 <__gedf2+0xaa>
 8001e66:	455e      	cmp	r6, fp
 8001e68:	d8df      	bhi.n	8001e2a <__gedf2+0x62>
 8001e6a:	d008      	beq.n	8001e7e <__gedf2+0xb6>
 8001e6c:	2000      	movs	r0, #0
 8001e6e:	455e      	cmp	r6, fp
 8001e70:	d2de      	bcs.n	8001e30 <__gedf2+0x68>
 8001e72:	4248      	negs	r0, r1
 8001e74:	4148      	adcs	r0, r1
 8001e76:	2301      	movs	r3, #1
 8001e78:	4240      	negs	r0, r0
 8001e7a:	4318      	orrs	r0, r3
 8001e7c:	e7d8      	b.n	8001e30 <__gedf2+0x68>
 8001e7e:	45c4      	cmp	ip, r8
 8001e80:	d8d3      	bhi.n	8001e2a <__gedf2+0x62>
 8001e82:	2000      	movs	r0, #0
 8001e84:	45c4      	cmp	ip, r8
 8001e86:	d3f4      	bcc.n	8001e72 <__gedf2+0xaa>
 8001e88:	e7d2      	b.n	8001e30 <__gedf2+0x68>
 8001e8a:	46c0      	nop			; (mov r8, r8)
 8001e8c:	000007ff 	.word	0x000007ff

08001e90 <__ledf2>:
 8001e90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001e92:	465f      	mov	r7, fp
 8001e94:	464d      	mov	r5, r9
 8001e96:	4644      	mov	r4, r8
 8001e98:	4656      	mov	r6, sl
 8001e9a:	b4f0      	push	{r4, r5, r6, r7}
 8001e9c:	031c      	lsls	r4, r3, #12
 8001e9e:	0b24      	lsrs	r4, r4, #12
 8001ea0:	46a4      	mov	ip, r4
 8001ea2:	4c2f      	ldr	r4, [pc, #188]	; (8001f60 <__ledf2+0xd0>)
 8001ea4:	030f      	lsls	r7, r1, #12
 8001ea6:	004d      	lsls	r5, r1, #1
 8001ea8:	005e      	lsls	r6, r3, #1
 8001eaa:	0fc9      	lsrs	r1, r1, #31
 8001eac:	4680      	mov	r8, r0
 8001eae:	0b3f      	lsrs	r7, r7, #12
 8001eb0:	0d6d      	lsrs	r5, r5, #21
 8001eb2:	468b      	mov	fp, r1
 8001eb4:	4691      	mov	r9, r2
 8001eb6:	0d76      	lsrs	r6, r6, #21
 8001eb8:	0fdb      	lsrs	r3, r3, #31
 8001eba:	42a5      	cmp	r5, r4
 8001ebc:	d020      	beq.n	8001f00 <__ledf2+0x70>
 8001ebe:	4c28      	ldr	r4, [pc, #160]	; (8001f60 <__ledf2+0xd0>)
 8001ec0:	42a6      	cmp	r6, r4
 8001ec2:	d022      	beq.n	8001f0a <__ledf2+0x7a>
 8001ec4:	2d00      	cmp	r5, #0
 8001ec6:	d112      	bne.n	8001eee <__ledf2+0x5e>
 8001ec8:	4338      	orrs	r0, r7
 8001eca:	4244      	negs	r4, r0
 8001ecc:	4144      	adcs	r4, r0
 8001ece:	2e00      	cmp	r6, #0
 8001ed0:	d020      	beq.n	8001f14 <__ledf2+0x84>
 8001ed2:	2c00      	cmp	r4, #0
 8001ed4:	d00d      	beq.n	8001ef2 <__ledf2+0x62>
 8001ed6:	425c      	negs	r4, r3
 8001ed8:	4163      	adcs	r3, r4
 8001eda:	2401      	movs	r4, #1
 8001edc:	425b      	negs	r3, r3
 8001ede:	431c      	orrs	r4, r3
 8001ee0:	0020      	movs	r0, r4
 8001ee2:	bc3c      	pop	{r2, r3, r4, r5}
 8001ee4:	4690      	mov	r8, r2
 8001ee6:	4699      	mov	r9, r3
 8001ee8:	46a2      	mov	sl, r4
 8001eea:	46ab      	mov	fp, r5
 8001eec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001eee:	2e00      	cmp	r6, #0
 8001ef0:	d017      	beq.n	8001f22 <__ledf2+0x92>
 8001ef2:	455b      	cmp	r3, fp
 8001ef4:	d019      	beq.n	8001f2a <__ledf2+0x9a>
 8001ef6:	465b      	mov	r3, fp
 8001ef8:	425c      	negs	r4, r3
 8001efa:	2301      	movs	r3, #1
 8001efc:	431c      	orrs	r4, r3
 8001efe:	e7ef      	b.n	8001ee0 <__ledf2+0x50>
 8001f00:	0039      	movs	r1, r7
 8001f02:	2402      	movs	r4, #2
 8001f04:	4301      	orrs	r1, r0
 8001f06:	d1eb      	bne.n	8001ee0 <__ledf2+0x50>
 8001f08:	e7d9      	b.n	8001ebe <__ledf2+0x2e>
 8001f0a:	4661      	mov	r1, ip
 8001f0c:	2402      	movs	r4, #2
 8001f0e:	4311      	orrs	r1, r2
 8001f10:	d1e6      	bne.n	8001ee0 <__ledf2+0x50>
 8001f12:	e7d7      	b.n	8001ec4 <__ledf2+0x34>
 8001f14:	4661      	mov	r1, ip
 8001f16:	430a      	orrs	r2, r1
 8001f18:	d1db      	bne.n	8001ed2 <__ledf2+0x42>
 8001f1a:	2400      	movs	r4, #0
 8001f1c:	2800      	cmp	r0, #0
 8001f1e:	d0df      	beq.n	8001ee0 <__ledf2+0x50>
 8001f20:	e7e9      	b.n	8001ef6 <__ledf2+0x66>
 8001f22:	4661      	mov	r1, ip
 8001f24:	430a      	orrs	r2, r1
 8001f26:	d1e4      	bne.n	8001ef2 <__ledf2+0x62>
 8001f28:	e7e5      	b.n	8001ef6 <__ledf2+0x66>
 8001f2a:	42b5      	cmp	r5, r6
 8001f2c:	dd03      	ble.n	8001f36 <__ledf2+0xa6>
 8001f2e:	2201      	movs	r2, #1
 8001f30:	425c      	negs	r4, r3
 8001f32:	4314      	orrs	r4, r2
 8001f34:	e7d4      	b.n	8001ee0 <__ledf2+0x50>
 8001f36:	42b5      	cmp	r5, r6
 8001f38:	dbcd      	blt.n	8001ed6 <__ledf2+0x46>
 8001f3a:	4567      	cmp	r7, ip
 8001f3c:	d8db      	bhi.n	8001ef6 <__ledf2+0x66>
 8001f3e:	d009      	beq.n	8001f54 <__ledf2+0xc4>
 8001f40:	2400      	movs	r4, #0
 8001f42:	4567      	cmp	r7, ip
 8001f44:	d2cc      	bcs.n	8001ee0 <__ledf2+0x50>
 8001f46:	4659      	mov	r1, fp
 8001f48:	424c      	negs	r4, r1
 8001f4a:	4161      	adcs	r1, r4
 8001f4c:	2401      	movs	r4, #1
 8001f4e:	4249      	negs	r1, r1
 8001f50:	430c      	orrs	r4, r1
 8001f52:	e7c5      	b.n	8001ee0 <__ledf2+0x50>
 8001f54:	45c8      	cmp	r8, r9
 8001f56:	d8ce      	bhi.n	8001ef6 <__ledf2+0x66>
 8001f58:	2400      	movs	r4, #0
 8001f5a:	45c8      	cmp	r8, r9
 8001f5c:	d3f3      	bcc.n	8001f46 <__ledf2+0xb6>
 8001f5e:	e7bf      	b.n	8001ee0 <__ledf2+0x50>
 8001f60:	000007ff 	.word	0x000007ff

08001f64 <__aeabi_dsub>:
 8001f64:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001f66:	4657      	mov	r7, sl
 8001f68:	464e      	mov	r6, r9
 8001f6a:	4645      	mov	r5, r8
 8001f6c:	b4e0      	push	{r5, r6, r7}
 8001f6e:	000e      	movs	r6, r1
 8001f70:	0011      	movs	r1, r2
 8001f72:	0ff2      	lsrs	r2, r6, #31
 8001f74:	4692      	mov	sl, r2
 8001f76:	00c5      	lsls	r5, r0, #3
 8001f78:	0f42      	lsrs	r2, r0, #29
 8001f7a:	0318      	lsls	r0, r3, #12
 8001f7c:	0337      	lsls	r7, r6, #12
 8001f7e:	0074      	lsls	r4, r6, #1
 8001f80:	0a40      	lsrs	r0, r0, #9
 8001f82:	0f4e      	lsrs	r6, r1, #29
 8001f84:	0a7f      	lsrs	r7, r7, #9
 8001f86:	4330      	orrs	r0, r6
 8001f88:	4ecf      	ldr	r6, [pc, #828]	; (80022c8 <__aeabi_dsub+0x364>)
 8001f8a:	4317      	orrs	r7, r2
 8001f8c:	005a      	lsls	r2, r3, #1
 8001f8e:	0d64      	lsrs	r4, r4, #21
 8001f90:	0d52      	lsrs	r2, r2, #21
 8001f92:	0fdb      	lsrs	r3, r3, #31
 8001f94:	00c9      	lsls	r1, r1, #3
 8001f96:	42b2      	cmp	r2, r6
 8001f98:	d100      	bne.n	8001f9c <__aeabi_dsub+0x38>
 8001f9a:	e0e5      	b.n	8002168 <__aeabi_dsub+0x204>
 8001f9c:	2601      	movs	r6, #1
 8001f9e:	4073      	eors	r3, r6
 8001fa0:	1aa6      	subs	r6, r4, r2
 8001fa2:	46b4      	mov	ip, r6
 8001fa4:	4553      	cmp	r3, sl
 8001fa6:	d100      	bne.n	8001faa <__aeabi_dsub+0x46>
 8001fa8:	e0af      	b.n	800210a <__aeabi_dsub+0x1a6>
 8001faa:	2e00      	cmp	r6, #0
 8001fac:	dc00      	bgt.n	8001fb0 <__aeabi_dsub+0x4c>
 8001fae:	e10d      	b.n	80021cc <__aeabi_dsub+0x268>
 8001fb0:	2a00      	cmp	r2, #0
 8001fb2:	d13a      	bne.n	800202a <__aeabi_dsub+0xc6>
 8001fb4:	0003      	movs	r3, r0
 8001fb6:	430b      	orrs	r3, r1
 8001fb8:	d000      	beq.n	8001fbc <__aeabi_dsub+0x58>
 8001fba:	e0e4      	b.n	8002186 <__aeabi_dsub+0x222>
 8001fbc:	076b      	lsls	r3, r5, #29
 8001fbe:	d009      	beq.n	8001fd4 <__aeabi_dsub+0x70>
 8001fc0:	230f      	movs	r3, #15
 8001fc2:	402b      	ands	r3, r5
 8001fc4:	2b04      	cmp	r3, #4
 8001fc6:	d005      	beq.n	8001fd4 <__aeabi_dsub+0x70>
 8001fc8:	1d2b      	adds	r3, r5, #4
 8001fca:	42ab      	cmp	r3, r5
 8001fcc:	41ad      	sbcs	r5, r5
 8001fce:	426d      	negs	r5, r5
 8001fd0:	197f      	adds	r7, r7, r5
 8001fd2:	001d      	movs	r5, r3
 8001fd4:	023b      	lsls	r3, r7, #8
 8001fd6:	d400      	bmi.n	8001fda <__aeabi_dsub+0x76>
 8001fd8:	e088      	b.n	80020ec <__aeabi_dsub+0x188>
 8001fda:	4bbb      	ldr	r3, [pc, #748]	; (80022c8 <__aeabi_dsub+0x364>)
 8001fdc:	3401      	adds	r4, #1
 8001fde:	429c      	cmp	r4, r3
 8001fe0:	d100      	bne.n	8001fe4 <__aeabi_dsub+0x80>
 8001fe2:	e110      	b.n	8002206 <__aeabi_dsub+0x2a2>
 8001fe4:	003a      	movs	r2, r7
 8001fe6:	4bb9      	ldr	r3, [pc, #740]	; (80022cc <__aeabi_dsub+0x368>)
 8001fe8:	4651      	mov	r1, sl
 8001fea:	401a      	ands	r2, r3
 8001fec:	2301      	movs	r3, #1
 8001fee:	0750      	lsls	r0, r2, #29
 8001ff0:	08ed      	lsrs	r5, r5, #3
 8001ff2:	0252      	lsls	r2, r2, #9
 8001ff4:	0564      	lsls	r4, r4, #21
 8001ff6:	4305      	orrs	r5, r0
 8001ff8:	0b12      	lsrs	r2, r2, #12
 8001ffa:	0d64      	lsrs	r4, r4, #21
 8001ffc:	400b      	ands	r3, r1
 8001ffe:	2100      	movs	r1, #0
 8002000:	0028      	movs	r0, r5
 8002002:	0312      	lsls	r2, r2, #12
 8002004:	0d0d      	lsrs	r5, r1, #20
 8002006:	0b12      	lsrs	r2, r2, #12
 8002008:	0564      	lsls	r4, r4, #21
 800200a:	052d      	lsls	r5, r5, #20
 800200c:	4315      	orrs	r5, r2
 800200e:	0862      	lsrs	r2, r4, #1
 8002010:	4caf      	ldr	r4, [pc, #700]	; (80022d0 <__aeabi_dsub+0x36c>)
 8002012:	07db      	lsls	r3, r3, #31
 8002014:	402c      	ands	r4, r5
 8002016:	4314      	orrs	r4, r2
 8002018:	0064      	lsls	r4, r4, #1
 800201a:	0864      	lsrs	r4, r4, #1
 800201c:	431c      	orrs	r4, r3
 800201e:	0021      	movs	r1, r4
 8002020:	bc1c      	pop	{r2, r3, r4}
 8002022:	4690      	mov	r8, r2
 8002024:	4699      	mov	r9, r3
 8002026:	46a2      	mov	sl, r4
 8002028:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800202a:	4ba7      	ldr	r3, [pc, #668]	; (80022c8 <__aeabi_dsub+0x364>)
 800202c:	429c      	cmp	r4, r3
 800202e:	d0c5      	beq.n	8001fbc <__aeabi_dsub+0x58>
 8002030:	2380      	movs	r3, #128	; 0x80
 8002032:	041b      	lsls	r3, r3, #16
 8002034:	4318      	orrs	r0, r3
 8002036:	4663      	mov	r3, ip
 8002038:	2b38      	cmp	r3, #56	; 0x38
 800203a:	dd00      	ble.n	800203e <__aeabi_dsub+0xda>
 800203c:	e0fd      	b.n	800223a <__aeabi_dsub+0x2d6>
 800203e:	2b1f      	cmp	r3, #31
 8002040:	dd00      	ble.n	8002044 <__aeabi_dsub+0xe0>
 8002042:	e130      	b.n	80022a6 <__aeabi_dsub+0x342>
 8002044:	4662      	mov	r2, ip
 8002046:	2320      	movs	r3, #32
 8002048:	1a9b      	subs	r3, r3, r2
 800204a:	0002      	movs	r2, r0
 800204c:	409a      	lsls	r2, r3
 800204e:	4666      	mov	r6, ip
 8002050:	4690      	mov	r8, r2
 8002052:	000a      	movs	r2, r1
 8002054:	4099      	lsls	r1, r3
 8002056:	40f2      	lsrs	r2, r6
 8002058:	4646      	mov	r6, r8
 800205a:	1e4b      	subs	r3, r1, #1
 800205c:	4199      	sbcs	r1, r3
 800205e:	4332      	orrs	r2, r6
 8002060:	4311      	orrs	r1, r2
 8002062:	4663      	mov	r3, ip
 8002064:	0002      	movs	r2, r0
 8002066:	40da      	lsrs	r2, r3
 8002068:	1a69      	subs	r1, r5, r1
 800206a:	428d      	cmp	r5, r1
 800206c:	419b      	sbcs	r3, r3
 800206e:	000d      	movs	r5, r1
 8002070:	1aba      	subs	r2, r7, r2
 8002072:	425b      	negs	r3, r3
 8002074:	1ad7      	subs	r7, r2, r3
 8002076:	023b      	lsls	r3, r7, #8
 8002078:	d535      	bpl.n	80020e6 <__aeabi_dsub+0x182>
 800207a:	027a      	lsls	r2, r7, #9
 800207c:	0a53      	lsrs	r3, r2, #9
 800207e:	4698      	mov	r8, r3
 8002080:	4643      	mov	r3, r8
 8002082:	2b00      	cmp	r3, #0
 8002084:	d100      	bne.n	8002088 <__aeabi_dsub+0x124>
 8002086:	e0c4      	b.n	8002212 <__aeabi_dsub+0x2ae>
 8002088:	4640      	mov	r0, r8
 800208a:	f000 fbd5 	bl	8002838 <__clzsi2>
 800208e:	0003      	movs	r3, r0
 8002090:	3b08      	subs	r3, #8
 8002092:	2b1f      	cmp	r3, #31
 8002094:	dd00      	ble.n	8002098 <__aeabi_dsub+0x134>
 8002096:	e0c5      	b.n	8002224 <__aeabi_dsub+0x2c0>
 8002098:	2220      	movs	r2, #32
 800209a:	0029      	movs	r1, r5
 800209c:	1ad2      	subs	r2, r2, r3
 800209e:	4647      	mov	r7, r8
 80020a0:	40d1      	lsrs	r1, r2
 80020a2:	409f      	lsls	r7, r3
 80020a4:	000a      	movs	r2, r1
 80020a6:	409d      	lsls	r5, r3
 80020a8:	433a      	orrs	r2, r7
 80020aa:	429c      	cmp	r4, r3
 80020ac:	dd00      	ble.n	80020b0 <__aeabi_dsub+0x14c>
 80020ae:	e0c0      	b.n	8002232 <__aeabi_dsub+0x2ce>
 80020b0:	1b1c      	subs	r4, r3, r4
 80020b2:	1c63      	adds	r3, r4, #1
 80020b4:	2b1f      	cmp	r3, #31
 80020b6:	dd00      	ble.n	80020ba <__aeabi_dsub+0x156>
 80020b8:	e0e4      	b.n	8002284 <__aeabi_dsub+0x320>
 80020ba:	2120      	movs	r1, #32
 80020bc:	0014      	movs	r4, r2
 80020be:	0028      	movs	r0, r5
 80020c0:	1ac9      	subs	r1, r1, r3
 80020c2:	40d8      	lsrs	r0, r3
 80020c4:	408c      	lsls	r4, r1
 80020c6:	408d      	lsls	r5, r1
 80020c8:	4304      	orrs	r4, r0
 80020ca:	40da      	lsrs	r2, r3
 80020cc:	1e68      	subs	r0, r5, #1
 80020ce:	4185      	sbcs	r5, r0
 80020d0:	0017      	movs	r7, r2
 80020d2:	4325      	orrs	r5, r4
 80020d4:	2400      	movs	r4, #0
 80020d6:	e771      	b.n	8001fbc <__aeabi_dsub+0x58>
 80020d8:	4642      	mov	r2, r8
 80020da:	4663      	mov	r3, ip
 80020dc:	431a      	orrs	r2, r3
 80020de:	d100      	bne.n	80020e2 <__aeabi_dsub+0x17e>
 80020e0:	e24c      	b.n	800257c <__aeabi_dsub+0x618>
 80020e2:	4667      	mov	r7, ip
 80020e4:	4645      	mov	r5, r8
 80020e6:	076b      	lsls	r3, r5, #29
 80020e8:	d000      	beq.n	80020ec <__aeabi_dsub+0x188>
 80020ea:	e769      	b.n	8001fc0 <__aeabi_dsub+0x5c>
 80020ec:	2301      	movs	r3, #1
 80020ee:	4651      	mov	r1, sl
 80020f0:	0778      	lsls	r0, r7, #29
 80020f2:	08ed      	lsrs	r5, r5, #3
 80020f4:	08fa      	lsrs	r2, r7, #3
 80020f6:	400b      	ands	r3, r1
 80020f8:	4305      	orrs	r5, r0
 80020fa:	4973      	ldr	r1, [pc, #460]	; (80022c8 <__aeabi_dsub+0x364>)
 80020fc:	428c      	cmp	r4, r1
 80020fe:	d038      	beq.n	8002172 <__aeabi_dsub+0x20e>
 8002100:	0312      	lsls	r2, r2, #12
 8002102:	0564      	lsls	r4, r4, #21
 8002104:	0b12      	lsrs	r2, r2, #12
 8002106:	0d64      	lsrs	r4, r4, #21
 8002108:	e779      	b.n	8001ffe <__aeabi_dsub+0x9a>
 800210a:	2e00      	cmp	r6, #0
 800210c:	dc00      	bgt.n	8002110 <__aeabi_dsub+0x1ac>
 800210e:	e09a      	b.n	8002246 <__aeabi_dsub+0x2e2>
 8002110:	2a00      	cmp	r2, #0
 8002112:	d047      	beq.n	80021a4 <__aeabi_dsub+0x240>
 8002114:	4a6c      	ldr	r2, [pc, #432]	; (80022c8 <__aeabi_dsub+0x364>)
 8002116:	4294      	cmp	r4, r2
 8002118:	d100      	bne.n	800211c <__aeabi_dsub+0x1b8>
 800211a:	e74f      	b.n	8001fbc <__aeabi_dsub+0x58>
 800211c:	2280      	movs	r2, #128	; 0x80
 800211e:	0412      	lsls	r2, r2, #16
 8002120:	4310      	orrs	r0, r2
 8002122:	4662      	mov	r2, ip
 8002124:	2a38      	cmp	r2, #56	; 0x38
 8002126:	dc00      	bgt.n	800212a <__aeabi_dsub+0x1c6>
 8002128:	e108      	b.n	800233c <__aeabi_dsub+0x3d8>
 800212a:	4301      	orrs	r1, r0
 800212c:	1e48      	subs	r0, r1, #1
 800212e:	4181      	sbcs	r1, r0
 8002130:	2200      	movs	r2, #0
 8002132:	b2c9      	uxtb	r1, r1
 8002134:	1949      	adds	r1, r1, r5
 8002136:	19d2      	adds	r2, r2, r7
 8002138:	42a9      	cmp	r1, r5
 800213a:	41bf      	sbcs	r7, r7
 800213c:	000d      	movs	r5, r1
 800213e:	427f      	negs	r7, r7
 8002140:	18bf      	adds	r7, r7, r2
 8002142:	023a      	lsls	r2, r7, #8
 8002144:	d400      	bmi.n	8002148 <__aeabi_dsub+0x1e4>
 8002146:	e142      	b.n	80023ce <__aeabi_dsub+0x46a>
 8002148:	4a5f      	ldr	r2, [pc, #380]	; (80022c8 <__aeabi_dsub+0x364>)
 800214a:	3401      	adds	r4, #1
 800214c:	4294      	cmp	r4, r2
 800214e:	d100      	bne.n	8002152 <__aeabi_dsub+0x1ee>
 8002150:	e14e      	b.n	80023f0 <__aeabi_dsub+0x48c>
 8002152:	2001      	movs	r0, #1
 8002154:	4a5d      	ldr	r2, [pc, #372]	; (80022cc <__aeabi_dsub+0x368>)
 8002156:	0869      	lsrs	r1, r5, #1
 8002158:	403a      	ands	r2, r7
 800215a:	4028      	ands	r0, r5
 800215c:	4308      	orrs	r0, r1
 800215e:	07d5      	lsls	r5, r2, #31
 8002160:	4305      	orrs	r5, r0
 8002162:	0857      	lsrs	r7, r2, #1
 8002164:	469a      	mov	sl, r3
 8002166:	e729      	b.n	8001fbc <__aeabi_dsub+0x58>
 8002168:	0006      	movs	r6, r0
 800216a:	430e      	orrs	r6, r1
 800216c:	d000      	beq.n	8002170 <__aeabi_dsub+0x20c>
 800216e:	e717      	b.n	8001fa0 <__aeabi_dsub+0x3c>
 8002170:	e714      	b.n	8001f9c <__aeabi_dsub+0x38>
 8002172:	0029      	movs	r1, r5
 8002174:	4311      	orrs	r1, r2
 8002176:	d100      	bne.n	800217a <__aeabi_dsub+0x216>
 8002178:	e1f9      	b.n	800256e <__aeabi_dsub+0x60a>
 800217a:	2180      	movs	r1, #128	; 0x80
 800217c:	0309      	lsls	r1, r1, #12
 800217e:	430a      	orrs	r2, r1
 8002180:	0312      	lsls	r2, r2, #12
 8002182:	0b12      	lsrs	r2, r2, #12
 8002184:	e73b      	b.n	8001ffe <__aeabi_dsub+0x9a>
 8002186:	2301      	movs	r3, #1
 8002188:	425b      	negs	r3, r3
 800218a:	4698      	mov	r8, r3
 800218c:	44c4      	add	ip, r8
 800218e:	4663      	mov	r3, ip
 8002190:	2b00      	cmp	r3, #0
 8002192:	d172      	bne.n	800227a <__aeabi_dsub+0x316>
 8002194:	1a69      	subs	r1, r5, r1
 8002196:	428d      	cmp	r5, r1
 8002198:	419b      	sbcs	r3, r3
 800219a:	1a3f      	subs	r7, r7, r0
 800219c:	425b      	negs	r3, r3
 800219e:	1aff      	subs	r7, r7, r3
 80021a0:	000d      	movs	r5, r1
 80021a2:	e768      	b.n	8002076 <__aeabi_dsub+0x112>
 80021a4:	0002      	movs	r2, r0
 80021a6:	430a      	orrs	r2, r1
 80021a8:	d100      	bne.n	80021ac <__aeabi_dsub+0x248>
 80021aa:	e707      	b.n	8001fbc <__aeabi_dsub+0x58>
 80021ac:	2201      	movs	r2, #1
 80021ae:	4252      	negs	r2, r2
 80021b0:	4690      	mov	r8, r2
 80021b2:	44c4      	add	ip, r8
 80021b4:	4662      	mov	r2, ip
 80021b6:	2a00      	cmp	r2, #0
 80021b8:	d000      	beq.n	80021bc <__aeabi_dsub+0x258>
 80021ba:	e0e6      	b.n	800238a <__aeabi_dsub+0x426>
 80021bc:	1869      	adds	r1, r5, r1
 80021be:	42a9      	cmp	r1, r5
 80021c0:	41b6      	sbcs	r6, r6
 80021c2:	183f      	adds	r7, r7, r0
 80021c4:	4276      	negs	r6, r6
 80021c6:	19f7      	adds	r7, r6, r7
 80021c8:	000d      	movs	r5, r1
 80021ca:	e7ba      	b.n	8002142 <__aeabi_dsub+0x1de>
 80021cc:	2e00      	cmp	r6, #0
 80021ce:	d000      	beq.n	80021d2 <__aeabi_dsub+0x26e>
 80021d0:	e080      	b.n	80022d4 <__aeabi_dsub+0x370>
 80021d2:	1c62      	adds	r2, r4, #1
 80021d4:	0552      	lsls	r2, r2, #21
 80021d6:	0d52      	lsrs	r2, r2, #21
 80021d8:	2a01      	cmp	r2, #1
 80021da:	dc00      	bgt.n	80021de <__aeabi_dsub+0x27a>
 80021dc:	e0f9      	b.n	80023d2 <__aeabi_dsub+0x46e>
 80021de:	1a6a      	subs	r2, r5, r1
 80021e0:	4691      	mov	r9, r2
 80021e2:	454d      	cmp	r5, r9
 80021e4:	41b6      	sbcs	r6, r6
 80021e6:	1a3a      	subs	r2, r7, r0
 80021e8:	4276      	negs	r6, r6
 80021ea:	1b92      	subs	r2, r2, r6
 80021ec:	4690      	mov	r8, r2
 80021ee:	0212      	lsls	r2, r2, #8
 80021f0:	d400      	bmi.n	80021f4 <__aeabi_dsub+0x290>
 80021f2:	e099      	b.n	8002328 <__aeabi_dsub+0x3c4>
 80021f4:	1b4d      	subs	r5, r1, r5
 80021f6:	42a9      	cmp	r1, r5
 80021f8:	4189      	sbcs	r1, r1
 80021fa:	1bc7      	subs	r7, r0, r7
 80021fc:	4249      	negs	r1, r1
 80021fe:	1a7a      	subs	r2, r7, r1
 8002200:	4690      	mov	r8, r2
 8002202:	469a      	mov	sl, r3
 8002204:	e73c      	b.n	8002080 <__aeabi_dsub+0x11c>
 8002206:	4652      	mov	r2, sl
 8002208:	2301      	movs	r3, #1
 800220a:	2500      	movs	r5, #0
 800220c:	4013      	ands	r3, r2
 800220e:	2200      	movs	r2, #0
 8002210:	e6f5      	b.n	8001ffe <__aeabi_dsub+0x9a>
 8002212:	0028      	movs	r0, r5
 8002214:	f000 fb10 	bl	8002838 <__clzsi2>
 8002218:	3020      	adds	r0, #32
 800221a:	0003      	movs	r3, r0
 800221c:	3b08      	subs	r3, #8
 800221e:	2b1f      	cmp	r3, #31
 8002220:	dc00      	bgt.n	8002224 <__aeabi_dsub+0x2c0>
 8002222:	e739      	b.n	8002098 <__aeabi_dsub+0x134>
 8002224:	002a      	movs	r2, r5
 8002226:	3828      	subs	r0, #40	; 0x28
 8002228:	4082      	lsls	r2, r0
 800222a:	2500      	movs	r5, #0
 800222c:	429c      	cmp	r4, r3
 800222e:	dc00      	bgt.n	8002232 <__aeabi_dsub+0x2ce>
 8002230:	e73e      	b.n	80020b0 <__aeabi_dsub+0x14c>
 8002232:	4f26      	ldr	r7, [pc, #152]	; (80022cc <__aeabi_dsub+0x368>)
 8002234:	1ae4      	subs	r4, r4, r3
 8002236:	4017      	ands	r7, r2
 8002238:	e6c0      	b.n	8001fbc <__aeabi_dsub+0x58>
 800223a:	4301      	orrs	r1, r0
 800223c:	1e48      	subs	r0, r1, #1
 800223e:	4181      	sbcs	r1, r0
 8002240:	2200      	movs	r2, #0
 8002242:	b2c9      	uxtb	r1, r1
 8002244:	e710      	b.n	8002068 <__aeabi_dsub+0x104>
 8002246:	2e00      	cmp	r6, #0
 8002248:	d000      	beq.n	800224c <__aeabi_dsub+0x2e8>
 800224a:	e0f1      	b.n	8002430 <__aeabi_dsub+0x4cc>
 800224c:	1c62      	adds	r2, r4, #1
 800224e:	4694      	mov	ip, r2
 8002250:	0552      	lsls	r2, r2, #21
 8002252:	0d52      	lsrs	r2, r2, #21
 8002254:	2a01      	cmp	r2, #1
 8002256:	dc00      	bgt.n	800225a <__aeabi_dsub+0x2f6>
 8002258:	e0a0      	b.n	800239c <__aeabi_dsub+0x438>
 800225a:	4a1b      	ldr	r2, [pc, #108]	; (80022c8 <__aeabi_dsub+0x364>)
 800225c:	4594      	cmp	ip, r2
 800225e:	d100      	bne.n	8002262 <__aeabi_dsub+0x2fe>
 8002260:	e0c5      	b.n	80023ee <__aeabi_dsub+0x48a>
 8002262:	1869      	adds	r1, r5, r1
 8002264:	42a9      	cmp	r1, r5
 8002266:	4192      	sbcs	r2, r2
 8002268:	183f      	adds	r7, r7, r0
 800226a:	4252      	negs	r2, r2
 800226c:	19d2      	adds	r2, r2, r7
 800226e:	0849      	lsrs	r1, r1, #1
 8002270:	07d5      	lsls	r5, r2, #31
 8002272:	430d      	orrs	r5, r1
 8002274:	0857      	lsrs	r7, r2, #1
 8002276:	4664      	mov	r4, ip
 8002278:	e6a0      	b.n	8001fbc <__aeabi_dsub+0x58>
 800227a:	4b13      	ldr	r3, [pc, #76]	; (80022c8 <__aeabi_dsub+0x364>)
 800227c:	429c      	cmp	r4, r3
 800227e:	d000      	beq.n	8002282 <__aeabi_dsub+0x31e>
 8002280:	e6d9      	b.n	8002036 <__aeabi_dsub+0xd2>
 8002282:	e69b      	b.n	8001fbc <__aeabi_dsub+0x58>
 8002284:	0011      	movs	r1, r2
 8002286:	3c1f      	subs	r4, #31
 8002288:	40e1      	lsrs	r1, r4
 800228a:	000c      	movs	r4, r1
 800228c:	2b20      	cmp	r3, #32
 800228e:	d100      	bne.n	8002292 <__aeabi_dsub+0x32e>
 8002290:	e080      	b.n	8002394 <__aeabi_dsub+0x430>
 8002292:	2140      	movs	r1, #64	; 0x40
 8002294:	1acb      	subs	r3, r1, r3
 8002296:	409a      	lsls	r2, r3
 8002298:	4315      	orrs	r5, r2
 800229a:	1e6a      	subs	r2, r5, #1
 800229c:	4195      	sbcs	r5, r2
 800229e:	2700      	movs	r7, #0
 80022a0:	4325      	orrs	r5, r4
 80022a2:	2400      	movs	r4, #0
 80022a4:	e71f      	b.n	80020e6 <__aeabi_dsub+0x182>
 80022a6:	4663      	mov	r3, ip
 80022a8:	0002      	movs	r2, r0
 80022aa:	3b20      	subs	r3, #32
 80022ac:	40da      	lsrs	r2, r3
 80022ae:	4663      	mov	r3, ip
 80022b0:	2b20      	cmp	r3, #32
 80022b2:	d071      	beq.n	8002398 <__aeabi_dsub+0x434>
 80022b4:	2340      	movs	r3, #64	; 0x40
 80022b6:	4666      	mov	r6, ip
 80022b8:	1b9b      	subs	r3, r3, r6
 80022ba:	4098      	lsls	r0, r3
 80022bc:	4301      	orrs	r1, r0
 80022be:	1e48      	subs	r0, r1, #1
 80022c0:	4181      	sbcs	r1, r0
 80022c2:	4311      	orrs	r1, r2
 80022c4:	2200      	movs	r2, #0
 80022c6:	e6cf      	b.n	8002068 <__aeabi_dsub+0x104>
 80022c8:	000007ff 	.word	0x000007ff
 80022cc:	ff7fffff 	.word	0xff7fffff
 80022d0:	800fffff 	.word	0x800fffff
 80022d4:	2c00      	cmp	r4, #0
 80022d6:	d048      	beq.n	800236a <__aeabi_dsub+0x406>
 80022d8:	4cca      	ldr	r4, [pc, #808]	; (8002604 <__aeabi_dsub+0x6a0>)
 80022da:	42a2      	cmp	r2, r4
 80022dc:	d100      	bne.n	80022e0 <__aeabi_dsub+0x37c>
 80022de:	e0a2      	b.n	8002426 <__aeabi_dsub+0x4c2>
 80022e0:	4274      	negs	r4, r6
 80022e2:	46a1      	mov	r9, r4
 80022e4:	2480      	movs	r4, #128	; 0x80
 80022e6:	0424      	lsls	r4, r4, #16
 80022e8:	4327      	orrs	r7, r4
 80022ea:	464c      	mov	r4, r9
 80022ec:	2c38      	cmp	r4, #56	; 0x38
 80022ee:	dd00      	ble.n	80022f2 <__aeabi_dsub+0x38e>
 80022f0:	e0db      	b.n	80024aa <__aeabi_dsub+0x546>
 80022f2:	2c1f      	cmp	r4, #31
 80022f4:	dd00      	ble.n	80022f8 <__aeabi_dsub+0x394>
 80022f6:	e144      	b.n	8002582 <__aeabi_dsub+0x61e>
 80022f8:	464e      	mov	r6, r9
 80022fa:	2420      	movs	r4, #32
 80022fc:	1ba4      	subs	r4, r4, r6
 80022fe:	003e      	movs	r6, r7
 8002300:	40a6      	lsls	r6, r4
 8002302:	46a2      	mov	sl, r4
 8002304:	46b0      	mov	r8, r6
 8002306:	464c      	mov	r4, r9
 8002308:	002e      	movs	r6, r5
 800230a:	40e6      	lsrs	r6, r4
 800230c:	46b4      	mov	ip, r6
 800230e:	4646      	mov	r6, r8
 8002310:	4664      	mov	r4, ip
 8002312:	4326      	orrs	r6, r4
 8002314:	4654      	mov	r4, sl
 8002316:	40a5      	lsls	r5, r4
 8002318:	1e6c      	subs	r4, r5, #1
 800231a:	41a5      	sbcs	r5, r4
 800231c:	0034      	movs	r4, r6
 800231e:	432c      	orrs	r4, r5
 8002320:	464d      	mov	r5, r9
 8002322:	40ef      	lsrs	r7, r5
 8002324:	1b0d      	subs	r5, r1, r4
 8002326:	e028      	b.n	800237a <__aeabi_dsub+0x416>
 8002328:	464a      	mov	r2, r9
 800232a:	4643      	mov	r3, r8
 800232c:	464d      	mov	r5, r9
 800232e:	431a      	orrs	r2, r3
 8002330:	d000      	beq.n	8002334 <__aeabi_dsub+0x3d0>
 8002332:	e6a5      	b.n	8002080 <__aeabi_dsub+0x11c>
 8002334:	2300      	movs	r3, #0
 8002336:	2400      	movs	r4, #0
 8002338:	2500      	movs	r5, #0
 800233a:	e6de      	b.n	80020fa <__aeabi_dsub+0x196>
 800233c:	2a1f      	cmp	r2, #31
 800233e:	dc5a      	bgt.n	80023f6 <__aeabi_dsub+0x492>
 8002340:	4666      	mov	r6, ip
 8002342:	2220      	movs	r2, #32
 8002344:	1b92      	subs	r2, r2, r6
 8002346:	0006      	movs	r6, r0
 8002348:	4096      	lsls	r6, r2
 800234a:	4691      	mov	r9, r2
 800234c:	46b0      	mov	r8, r6
 800234e:	4662      	mov	r2, ip
 8002350:	000e      	movs	r6, r1
 8002352:	40d6      	lsrs	r6, r2
 8002354:	4642      	mov	r2, r8
 8002356:	4316      	orrs	r6, r2
 8002358:	464a      	mov	r2, r9
 800235a:	4091      	lsls	r1, r2
 800235c:	1e4a      	subs	r2, r1, #1
 800235e:	4191      	sbcs	r1, r2
 8002360:	0002      	movs	r2, r0
 8002362:	4660      	mov	r0, ip
 8002364:	4331      	orrs	r1, r6
 8002366:	40c2      	lsrs	r2, r0
 8002368:	e6e4      	b.n	8002134 <__aeabi_dsub+0x1d0>
 800236a:	003c      	movs	r4, r7
 800236c:	432c      	orrs	r4, r5
 800236e:	d05a      	beq.n	8002426 <__aeabi_dsub+0x4c2>
 8002370:	43f4      	mvns	r4, r6
 8002372:	46a1      	mov	r9, r4
 8002374:	2c00      	cmp	r4, #0
 8002376:	d152      	bne.n	800241e <__aeabi_dsub+0x4ba>
 8002378:	1b4d      	subs	r5, r1, r5
 800237a:	42a9      	cmp	r1, r5
 800237c:	4189      	sbcs	r1, r1
 800237e:	1bc7      	subs	r7, r0, r7
 8002380:	4249      	negs	r1, r1
 8002382:	1a7f      	subs	r7, r7, r1
 8002384:	0014      	movs	r4, r2
 8002386:	469a      	mov	sl, r3
 8002388:	e675      	b.n	8002076 <__aeabi_dsub+0x112>
 800238a:	4a9e      	ldr	r2, [pc, #632]	; (8002604 <__aeabi_dsub+0x6a0>)
 800238c:	4294      	cmp	r4, r2
 800238e:	d000      	beq.n	8002392 <__aeabi_dsub+0x42e>
 8002390:	e6c7      	b.n	8002122 <__aeabi_dsub+0x1be>
 8002392:	e613      	b.n	8001fbc <__aeabi_dsub+0x58>
 8002394:	2200      	movs	r2, #0
 8002396:	e77f      	b.n	8002298 <__aeabi_dsub+0x334>
 8002398:	2000      	movs	r0, #0
 800239a:	e78f      	b.n	80022bc <__aeabi_dsub+0x358>
 800239c:	2c00      	cmp	r4, #0
 800239e:	d000      	beq.n	80023a2 <__aeabi_dsub+0x43e>
 80023a0:	e0c8      	b.n	8002534 <__aeabi_dsub+0x5d0>
 80023a2:	003b      	movs	r3, r7
 80023a4:	432b      	orrs	r3, r5
 80023a6:	d100      	bne.n	80023aa <__aeabi_dsub+0x446>
 80023a8:	e10f      	b.n	80025ca <__aeabi_dsub+0x666>
 80023aa:	0003      	movs	r3, r0
 80023ac:	430b      	orrs	r3, r1
 80023ae:	d100      	bne.n	80023b2 <__aeabi_dsub+0x44e>
 80023b0:	e604      	b.n	8001fbc <__aeabi_dsub+0x58>
 80023b2:	1869      	adds	r1, r5, r1
 80023b4:	42a9      	cmp	r1, r5
 80023b6:	419b      	sbcs	r3, r3
 80023b8:	183f      	adds	r7, r7, r0
 80023ba:	425b      	negs	r3, r3
 80023bc:	19df      	adds	r7, r3, r7
 80023be:	023b      	lsls	r3, r7, #8
 80023c0:	d400      	bmi.n	80023c4 <__aeabi_dsub+0x460>
 80023c2:	e11a      	b.n	80025fa <__aeabi_dsub+0x696>
 80023c4:	4b90      	ldr	r3, [pc, #576]	; (8002608 <__aeabi_dsub+0x6a4>)
 80023c6:	000d      	movs	r5, r1
 80023c8:	401f      	ands	r7, r3
 80023ca:	4664      	mov	r4, ip
 80023cc:	e5f6      	b.n	8001fbc <__aeabi_dsub+0x58>
 80023ce:	469a      	mov	sl, r3
 80023d0:	e689      	b.n	80020e6 <__aeabi_dsub+0x182>
 80023d2:	003a      	movs	r2, r7
 80023d4:	432a      	orrs	r2, r5
 80023d6:	2c00      	cmp	r4, #0
 80023d8:	d15c      	bne.n	8002494 <__aeabi_dsub+0x530>
 80023da:	2a00      	cmp	r2, #0
 80023dc:	d175      	bne.n	80024ca <__aeabi_dsub+0x566>
 80023de:	0002      	movs	r2, r0
 80023e0:	430a      	orrs	r2, r1
 80023e2:	d100      	bne.n	80023e6 <__aeabi_dsub+0x482>
 80023e4:	e0ca      	b.n	800257c <__aeabi_dsub+0x618>
 80023e6:	0007      	movs	r7, r0
 80023e8:	000d      	movs	r5, r1
 80023ea:	469a      	mov	sl, r3
 80023ec:	e5e6      	b.n	8001fbc <__aeabi_dsub+0x58>
 80023ee:	4664      	mov	r4, ip
 80023f0:	2200      	movs	r2, #0
 80023f2:	2500      	movs	r5, #0
 80023f4:	e681      	b.n	80020fa <__aeabi_dsub+0x196>
 80023f6:	4662      	mov	r2, ip
 80023f8:	0006      	movs	r6, r0
 80023fa:	3a20      	subs	r2, #32
 80023fc:	40d6      	lsrs	r6, r2
 80023fe:	4662      	mov	r2, ip
 8002400:	46b0      	mov	r8, r6
 8002402:	2a20      	cmp	r2, #32
 8002404:	d100      	bne.n	8002408 <__aeabi_dsub+0x4a4>
 8002406:	e0b7      	b.n	8002578 <__aeabi_dsub+0x614>
 8002408:	2240      	movs	r2, #64	; 0x40
 800240a:	4666      	mov	r6, ip
 800240c:	1b92      	subs	r2, r2, r6
 800240e:	4090      	lsls	r0, r2
 8002410:	4301      	orrs	r1, r0
 8002412:	4642      	mov	r2, r8
 8002414:	1e48      	subs	r0, r1, #1
 8002416:	4181      	sbcs	r1, r0
 8002418:	4311      	orrs	r1, r2
 800241a:	2200      	movs	r2, #0
 800241c:	e68a      	b.n	8002134 <__aeabi_dsub+0x1d0>
 800241e:	4c79      	ldr	r4, [pc, #484]	; (8002604 <__aeabi_dsub+0x6a0>)
 8002420:	42a2      	cmp	r2, r4
 8002422:	d000      	beq.n	8002426 <__aeabi_dsub+0x4c2>
 8002424:	e761      	b.n	80022ea <__aeabi_dsub+0x386>
 8002426:	0007      	movs	r7, r0
 8002428:	000d      	movs	r5, r1
 800242a:	0014      	movs	r4, r2
 800242c:	469a      	mov	sl, r3
 800242e:	e5c5      	b.n	8001fbc <__aeabi_dsub+0x58>
 8002430:	2c00      	cmp	r4, #0
 8002432:	d141      	bne.n	80024b8 <__aeabi_dsub+0x554>
 8002434:	003c      	movs	r4, r7
 8002436:	432c      	orrs	r4, r5
 8002438:	d078      	beq.n	800252c <__aeabi_dsub+0x5c8>
 800243a:	43f4      	mvns	r4, r6
 800243c:	46a1      	mov	r9, r4
 800243e:	2c00      	cmp	r4, #0
 8002440:	d020      	beq.n	8002484 <__aeabi_dsub+0x520>
 8002442:	4c70      	ldr	r4, [pc, #448]	; (8002604 <__aeabi_dsub+0x6a0>)
 8002444:	42a2      	cmp	r2, r4
 8002446:	d071      	beq.n	800252c <__aeabi_dsub+0x5c8>
 8002448:	464c      	mov	r4, r9
 800244a:	2c38      	cmp	r4, #56	; 0x38
 800244c:	dd00      	ble.n	8002450 <__aeabi_dsub+0x4ec>
 800244e:	e0b2      	b.n	80025b6 <__aeabi_dsub+0x652>
 8002450:	2c1f      	cmp	r4, #31
 8002452:	dd00      	ble.n	8002456 <__aeabi_dsub+0x4f2>
 8002454:	e0bc      	b.n	80025d0 <__aeabi_dsub+0x66c>
 8002456:	2620      	movs	r6, #32
 8002458:	1b34      	subs	r4, r6, r4
 800245a:	46a2      	mov	sl, r4
 800245c:	003c      	movs	r4, r7
 800245e:	4656      	mov	r6, sl
 8002460:	40b4      	lsls	r4, r6
 8002462:	464e      	mov	r6, r9
 8002464:	46a0      	mov	r8, r4
 8002466:	002c      	movs	r4, r5
 8002468:	40f4      	lsrs	r4, r6
 800246a:	46a4      	mov	ip, r4
 800246c:	4644      	mov	r4, r8
 800246e:	4666      	mov	r6, ip
 8002470:	4334      	orrs	r4, r6
 8002472:	46a4      	mov	ip, r4
 8002474:	4654      	mov	r4, sl
 8002476:	40a5      	lsls	r5, r4
 8002478:	4664      	mov	r4, ip
 800247a:	1e6e      	subs	r6, r5, #1
 800247c:	41b5      	sbcs	r5, r6
 800247e:	4325      	orrs	r5, r4
 8002480:	464c      	mov	r4, r9
 8002482:	40e7      	lsrs	r7, r4
 8002484:	186d      	adds	r5, r5, r1
 8002486:	428d      	cmp	r5, r1
 8002488:	4189      	sbcs	r1, r1
 800248a:	183f      	adds	r7, r7, r0
 800248c:	4249      	negs	r1, r1
 800248e:	19cf      	adds	r7, r1, r7
 8002490:	0014      	movs	r4, r2
 8002492:	e656      	b.n	8002142 <__aeabi_dsub+0x1de>
 8002494:	2a00      	cmp	r2, #0
 8002496:	d12f      	bne.n	80024f8 <__aeabi_dsub+0x594>
 8002498:	0002      	movs	r2, r0
 800249a:	430a      	orrs	r2, r1
 800249c:	d100      	bne.n	80024a0 <__aeabi_dsub+0x53c>
 800249e:	e084      	b.n	80025aa <__aeabi_dsub+0x646>
 80024a0:	0007      	movs	r7, r0
 80024a2:	000d      	movs	r5, r1
 80024a4:	469a      	mov	sl, r3
 80024a6:	4c57      	ldr	r4, [pc, #348]	; (8002604 <__aeabi_dsub+0x6a0>)
 80024a8:	e588      	b.n	8001fbc <__aeabi_dsub+0x58>
 80024aa:	433d      	orrs	r5, r7
 80024ac:	1e6f      	subs	r7, r5, #1
 80024ae:	41bd      	sbcs	r5, r7
 80024b0:	b2ec      	uxtb	r4, r5
 80024b2:	2700      	movs	r7, #0
 80024b4:	1b0d      	subs	r5, r1, r4
 80024b6:	e760      	b.n	800237a <__aeabi_dsub+0x416>
 80024b8:	4c52      	ldr	r4, [pc, #328]	; (8002604 <__aeabi_dsub+0x6a0>)
 80024ba:	42a2      	cmp	r2, r4
 80024bc:	d036      	beq.n	800252c <__aeabi_dsub+0x5c8>
 80024be:	4274      	negs	r4, r6
 80024c0:	2680      	movs	r6, #128	; 0x80
 80024c2:	0436      	lsls	r6, r6, #16
 80024c4:	46a1      	mov	r9, r4
 80024c6:	4337      	orrs	r7, r6
 80024c8:	e7be      	b.n	8002448 <__aeabi_dsub+0x4e4>
 80024ca:	0002      	movs	r2, r0
 80024cc:	430a      	orrs	r2, r1
 80024ce:	d100      	bne.n	80024d2 <__aeabi_dsub+0x56e>
 80024d0:	e574      	b.n	8001fbc <__aeabi_dsub+0x58>
 80024d2:	1a6a      	subs	r2, r5, r1
 80024d4:	4690      	mov	r8, r2
 80024d6:	4545      	cmp	r5, r8
 80024d8:	41b6      	sbcs	r6, r6
 80024da:	1a3a      	subs	r2, r7, r0
 80024dc:	4276      	negs	r6, r6
 80024de:	1b92      	subs	r2, r2, r6
 80024e0:	4694      	mov	ip, r2
 80024e2:	0212      	lsls	r2, r2, #8
 80024e4:	d400      	bmi.n	80024e8 <__aeabi_dsub+0x584>
 80024e6:	e5f7      	b.n	80020d8 <__aeabi_dsub+0x174>
 80024e8:	1b4d      	subs	r5, r1, r5
 80024ea:	42a9      	cmp	r1, r5
 80024ec:	4189      	sbcs	r1, r1
 80024ee:	1bc7      	subs	r7, r0, r7
 80024f0:	4249      	negs	r1, r1
 80024f2:	1a7f      	subs	r7, r7, r1
 80024f4:	469a      	mov	sl, r3
 80024f6:	e561      	b.n	8001fbc <__aeabi_dsub+0x58>
 80024f8:	0002      	movs	r2, r0
 80024fa:	430a      	orrs	r2, r1
 80024fc:	d03a      	beq.n	8002574 <__aeabi_dsub+0x610>
 80024fe:	08ed      	lsrs	r5, r5, #3
 8002500:	077c      	lsls	r4, r7, #29
 8002502:	432c      	orrs	r4, r5
 8002504:	2580      	movs	r5, #128	; 0x80
 8002506:	08fa      	lsrs	r2, r7, #3
 8002508:	032d      	lsls	r5, r5, #12
 800250a:	422a      	tst	r2, r5
 800250c:	d008      	beq.n	8002520 <__aeabi_dsub+0x5bc>
 800250e:	08c7      	lsrs	r7, r0, #3
 8002510:	422f      	tst	r7, r5
 8002512:	d105      	bne.n	8002520 <__aeabi_dsub+0x5bc>
 8002514:	0745      	lsls	r5, r0, #29
 8002516:	002c      	movs	r4, r5
 8002518:	003a      	movs	r2, r7
 800251a:	469a      	mov	sl, r3
 800251c:	08c9      	lsrs	r1, r1, #3
 800251e:	430c      	orrs	r4, r1
 8002520:	0f67      	lsrs	r7, r4, #29
 8002522:	00d2      	lsls	r2, r2, #3
 8002524:	00e5      	lsls	r5, r4, #3
 8002526:	4317      	orrs	r7, r2
 8002528:	4c36      	ldr	r4, [pc, #216]	; (8002604 <__aeabi_dsub+0x6a0>)
 800252a:	e547      	b.n	8001fbc <__aeabi_dsub+0x58>
 800252c:	0007      	movs	r7, r0
 800252e:	000d      	movs	r5, r1
 8002530:	0014      	movs	r4, r2
 8002532:	e543      	b.n	8001fbc <__aeabi_dsub+0x58>
 8002534:	003a      	movs	r2, r7
 8002536:	432a      	orrs	r2, r5
 8002538:	d043      	beq.n	80025c2 <__aeabi_dsub+0x65e>
 800253a:	0002      	movs	r2, r0
 800253c:	430a      	orrs	r2, r1
 800253e:	d019      	beq.n	8002574 <__aeabi_dsub+0x610>
 8002540:	08ed      	lsrs	r5, r5, #3
 8002542:	077c      	lsls	r4, r7, #29
 8002544:	432c      	orrs	r4, r5
 8002546:	2580      	movs	r5, #128	; 0x80
 8002548:	08fa      	lsrs	r2, r7, #3
 800254a:	032d      	lsls	r5, r5, #12
 800254c:	422a      	tst	r2, r5
 800254e:	d007      	beq.n	8002560 <__aeabi_dsub+0x5fc>
 8002550:	08c6      	lsrs	r6, r0, #3
 8002552:	422e      	tst	r6, r5
 8002554:	d104      	bne.n	8002560 <__aeabi_dsub+0x5fc>
 8002556:	0747      	lsls	r7, r0, #29
 8002558:	003c      	movs	r4, r7
 800255a:	0032      	movs	r2, r6
 800255c:	08c9      	lsrs	r1, r1, #3
 800255e:	430c      	orrs	r4, r1
 8002560:	00d7      	lsls	r7, r2, #3
 8002562:	0f62      	lsrs	r2, r4, #29
 8002564:	00e5      	lsls	r5, r4, #3
 8002566:	4317      	orrs	r7, r2
 8002568:	469a      	mov	sl, r3
 800256a:	4c26      	ldr	r4, [pc, #152]	; (8002604 <__aeabi_dsub+0x6a0>)
 800256c:	e526      	b.n	8001fbc <__aeabi_dsub+0x58>
 800256e:	2200      	movs	r2, #0
 8002570:	2500      	movs	r5, #0
 8002572:	e544      	b.n	8001ffe <__aeabi_dsub+0x9a>
 8002574:	4c23      	ldr	r4, [pc, #140]	; (8002604 <__aeabi_dsub+0x6a0>)
 8002576:	e521      	b.n	8001fbc <__aeabi_dsub+0x58>
 8002578:	2000      	movs	r0, #0
 800257a:	e749      	b.n	8002410 <__aeabi_dsub+0x4ac>
 800257c:	2300      	movs	r3, #0
 800257e:	2500      	movs	r5, #0
 8002580:	e5bb      	b.n	80020fa <__aeabi_dsub+0x196>
 8002582:	464c      	mov	r4, r9
 8002584:	003e      	movs	r6, r7
 8002586:	3c20      	subs	r4, #32
 8002588:	40e6      	lsrs	r6, r4
 800258a:	464c      	mov	r4, r9
 800258c:	46b4      	mov	ip, r6
 800258e:	2c20      	cmp	r4, #32
 8002590:	d031      	beq.n	80025f6 <__aeabi_dsub+0x692>
 8002592:	2440      	movs	r4, #64	; 0x40
 8002594:	464e      	mov	r6, r9
 8002596:	1ba6      	subs	r6, r4, r6
 8002598:	40b7      	lsls	r7, r6
 800259a:	433d      	orrs	r5, r7
 800259c:	1e6c      	subs	r4, r5, #1
 800259e:	41a5      	sbcs	r5, r4
 80025a0:	4664      	mov	r4, ip
 80025a2:	432c      	orrs	r4, r5
 80025a4:	2700      	movs	r7, #0
 80025a6:	1b0d      	subs	r5, r1, r4
 80025a8:	e6e7      	b.n	800237a <__aeabi_dsub+0x416>
 80025aa:	2280      	movs	r2, #128	; 0x80
 80025ac:	2300      	movs	r3, #0
 80025ae:	0312      	lsls	r2, r2, #12
 80025b0:	4c14      	ldr	r4, [pc, #80]	; (8002604 <__aeabi_dsub+0x6a0>)
 80025b2:	2500      	movs	r5, #0
 80025b4:	e5a1      	b.n	80020fa <__aeabi_dsub+0x196>
 80025b6:	433d      	orrs	r5, r7
 80025b8:	1e6f      	subs	r7, r5, #1
 80025ba:	41bd      	sbcs	r5, r7
 80025bc:	2700      	movs	r7, #0
 80025be:	b2ed      	uxtb	r5, r5
 80025c0:	e760      	b.n	8002484 <__aeabi_dsub+0x520>
 80025c2:	0007      	movs	r7, r0
 80025c4:	000d      	movs	r5, r1
 80025c6:	4c0f      	ldr	r4, [pc, #60]	; (8002604 <__aeabi_dsub+0x6a0>)
 80025c8:	e4f8      	b.n	8001fbc <__aeabi_dsub+0x58>
 80025ca:	0007      	movs	r7, r0
 80025cc:	000d      	movs	r5, r1
 80025ce:	e4f5      	b.n	8001fbc <__aeabi_dsub+0x58>
 80025d0:	464e      	mov	r6, r9
 80025d2:	003c      	movs	r4, r7
 80025d4:	3e20      	subs	r6, #32
 80025d6:	40f4      	lsrs	r4, r6
 80025d8:	46a0      	mov	r8, r4
 80025da:	464c      	mov	r4, r9
 80025dc:	2c20      	cmp	r4, #32
 80025de:	d00e      	beq.n	80025fe <__aeabi_dsub+0x69a>
 80025e0:	2440      	movs	r4, #64	; 0x40
 80025e2:	464e      	mov	r6, r9
 80025e4:	1ba4      	subs	r4, r4, r6
 80025e6:	40a7      	lsls	r7, r4
 80025e8:	433d      	orrs	r5, r7
 80025ea:	1e6f      	subs	r7, r5, #1
 80025ec:	41bd      	sbcs	r5, r7
 80025ee:	4644      	mov	r4, r8
 80025f0:	2700      	movs	r7, #0
 80025f2:	4325      	orrs	r5, r4
 80025f4:	e746      	b.n	8002484 <__aeabi_dsub+0x520>
 80025f6:	2700      	movs	r7, #0
 80025f8:	e7cf      	b.n	800259a <__aeabi_dsub+0x636>
 80025fa:	000d      	movs	r5, r1
 80025fc:	e573      	b.n	80020e6 <__aeabi_dsub+0x182>
 80025fe:	2700      	movs	r7, #0
 8002600:	e7f2      	b.n	80025e8 <__aeabi_dsub+0x684>
 8002602:	46c0      	nop			; (mov r8, r8)
 8002604:	000007ff 	.word	0x000007ff
 8002608:	ff7fffff 	.word	0xff7fffff

0800260c <__aeabi_d2iz>:
 800260c:	030b      	lsls	r3, r1, #12
 800260e:	b530      	push	{r4, r5, lr}
 8002610:	4d13      	ldr	r5, [pc, #76]	; (8002660 <__aeabi_d2iz+0x54>)
 8002612:	0b1a      	lsrs	r2, r3, #12
 8002614:	004b      	lsls	r3, r1, #1
 8002616:	0d5b      	lsrs	r3, r3, #21
 8002618:	0fc9      	lsrs	r1, r1, #31
 800261a:	2400      	movs	r4, #0
 800261c:	42ab      	cmp	r3, r5
 800261e:	dd11      	ble.n	8002644 <__aeabi_d2iz+0x38>
 8002620:	4c10      	ldr	r4, [pc, #64]	; (8002664 <__aeabi_d2iz+0x58>)
 8002622:	42a3      	cmp	r3, r4
 8002624:	dc10      	bgt.n	8002648 <__aeabi_d2iz+0x3c>
 8002626:	2480      	movs	r4, #128	; 0x80
 8002628:	0364      	lsls	r4, r4, #13
 800262a:	4322      	orrs	r2, r4
 800262c:	4c0e      	ldr	r4, [pc, #56]	; (8002668 <__aeabi_d2iz+0x5c>)
 800262e:	1ae4      	subs	r4, r4, r3
 8002630:	2c1f      	cmp	r4, #31
 8002632:	dd0c      	ble.n	800264e <__aeabi_d2iz+0x42>
 8002634:	480d      	ldr	r0, [pc, #52]	; (800266c <__aeabi_d2iz+0x60>)
 8002636:	1ac3      	subs	r3, r0, r3
 8002638:	40da      	lsrs	r2, r3
 800263a:	0013      	movs	r3, r2
 800263c:	425c      	negs	r4, r3
 800263e:	2900      	cmp	r1, #0
 8002640:	d100      	bne.n	8002644 <__aeabi_d2iz+0x38>
 8002642:	001c      	movs	r4, r3
 8002644:	0020      	movs	r0, r4
 8002646:	bd30      	pop	{r4, r5, pc}
 8002648:	4b09      	ldr	r3, [pc, #36]	; (8002670 <__aeabi_d2iz+0x64>)
 800264a:	18cc      	adds	r4, r1, r3
 800264c:	e7fa      	b.n	8002644 <__aeabi_d2iz+0x38>
 800264e:	40e0      	lsrs	r0, r4
 8002650:	4c08      	ldr	r4, [pc, #32]	; (8002674 <__aeabi_d2iz+0x68>)
 8002652:	46a4      	mov	ip, r4
 8002654:	4463      	add	r3, ip
 8002656:	409a      	lsls	r2, r3
 8002658:	0013      	movs	r3, r2
 800265a:	4303      	orrs	r3, r0
 800265c:	e7ee      	b.n	800263c <__aeabi_d2iz+0x30>
 800265e:	46c0      	nop			; (mov r8, r8)
 8002660:	000003fe 	.word	0x000003fe
 8002664:	0000041d 	.word	0x0000041d
 8002668:	00000433 	.word	0x00000433
 800266c:	00000413 	.word	0x00000413
 8002670:	7fffffff 	.word	0x7fffffff
 8002674:	fffffbed 	.word	0xfffffbed

08002678 <__aeabi_f2d>:
 8002678:	0042      	lsls	r2, r0, #1
 800267a:	0e12      	lsrs	r2, r2, #24
 800267c:	1c51      	adds	r1, r2, #1
 800267e:	0243      	lsls	r3, r0, #9
 8002680:	b2c9      	uxtb	r1, r1
 8002682:	b570      	push	{r4, r5, r6, lr}
 8002684:	0a5d      	lsrs	r5, r3, #9
 8002686:	0fc4      	lsrs	r4, r0, #31
 8002688:	2901      	cmp	r1, #1
 800268a:	dd15      	ble.n	80026b8 <__aeabi_f2d+0x40>
 800268c:	21e0      	movs	r1, #224	; 0xe0
 800268e:	0089      	lsls	r1, r1, #2
 8002690:	468c      	mov	ip, r1
 8002692:	076d      	lsls	r5, r5, #29
 8002694:	0b1b      	lsrs	r3, r3, #12
 8002696:	4462      	add	r2, ip
 8002698:	2100      	movs	r1, #0
 800269a:	0028      	movs	r0, r5
 800269c:	0d0d      	lsrs	r5, r1, #20
 800269e:	052d      	lsls	r5, r5, #20
 80026a0:	432b      	orrs	r3, r5
 80026a2:	4d1c      	ldr	r5, [pc, #112]	; (8002714 <__aeabi_f2d+0x9c>)
 80026a4:	0552      	lsls	r2, r2, #21
 80026a6:	402b      	ands	r3, r5
 80026a8:	0852      	lsrs	r2, r2, #1
 80026aa:	4313      	orrs	r3, r2
 80026ac:	005b      	lsls	r3, r3, #1
 80026ae:	07e4      	lsls	r4, r4, #31
 80026b0:	085b      	lsrs	r3, r3, #1
 80026b2:	4323      	orrs	r3, r4
 80026b4:	0019      	movs	r1, r3
 80026b6:	bd70      	pop	{r4, r5, r6, pc}
 80026b8:	2a00      	cmp	r2, #0
 80026ba:	d115      	bne.n	80026e8 <__aeabi_f2d+0x70>
 80026bc:	2d00      	cmp	r5, #0
 80026be:	d01f      	beq.n	8002700 <__aeabi_f2d+0x88>
 80026c0:	0028      	movs	r0, r5
 80026c2:	f000 f8b9 	bl	8002838 <__clzsi2>
 80026c6:	280a      	cmp	r0, #10
 80026c8:	dc1d      	bgt.n	8002706 <__aeabi_f2d+0x8e>
 80026ca:	230b      	movs	r3, #11
 80026cc:	002a      	movs	r2, r5
 80026ce:	1a1b      	subs	r3, r3, r0
 80026d0:	40da      	lsrs	r2, r3
 80026d2:	0013      	movs	r3, r2
 80026d4:	0002      	movs	r2, r0
 80026d6:	3215      	adds	r2, #21
 80026d8:	4095      	lsls	r5, r2
 80026da:	4a0f      	ldr	r2, [pc, #60]	; (8002718 <__aeabi_f2d+0xa0>)
 80026dc:	031b      	lsls	r3, r3, #12
 80026de:	1a12      	subs	r2, r2, r0
 80026e0:	0552      	lsls	r2, r2, #21
 80026e2:	0b1b      	lsrs	r3, r3, #12
 80026e4:	0d52      	lsrs	r2, r2, #21
 80026e6:	e7d7      	b.n	8002698 <__aeabi_f2d+0x20>
 80026e8:	2d00      	cmp	r5, #0
 80026ea:	d006      	beq.n	80026fa <__aeabi_f2d+0x82>
 80026ec:	2280      	movs	r2, #128	; 0x80
 80026ee:	0b1b      	lsrs	r3, r3, #12
 80026f0:	0312      	lsls	r2, r2, #12
 80026f2:	4313      	orrs	r3, r2
 80026f4:	076d      	lsls	r5, r5, #29
 80026f6:	4a09      	ldr	r2, [pc, #36]	; (800271c <__aeabi_f2d+0xa4>)
 80026f8:	e7ce      	b.n	8002698 <__aeabi_f2d+0x20>
 80026fa:	4a08      	ldr	r2, [pc, #32]	; (800271c <__aeabi_f2d+0xa4>)
 80026fc:	2300      	movs	r3, #0
 80026fe:	e7cb      	b.n	8002698 <__aeabi_f2d+0x20>
 8002700:	2200      	movs	r2, #0
 8002702:	2300      	movs	r3, #0
 8002704:	e7c8      	b.n	8002698 <__aeabi_f2d+0x20>
 8002706:	0003      	movs	r3, r0
 8002708:	3b0b      	subs	r3, #11
 800270a:	409d      	lsls	r5, r3
 800270c:	002b      	movs	r3, r5
 800270e:	2500      	movs	r5, #0
 8002710:	e7e3      	b.n	80026da <__aeabi_f2d+0x62>
 8002712:	46c0      	nop			; (mov r8, r8)
 8002714:	800fffff 	.word	0x800fffff
 8002718:	00000389 	.word	0x00000389
 800271c:	000007ff 	.word	0x000007ff

08002720 <__aeabi_d2f>:
 8002720:	004b      	lsls	r3, r1, #1
 8002722:	b570      	push	{r4, r5, r6, lr}
 8002724:	0d5e      	lsrs	r6, r3, #21
 8002726:	030c      	lsls	r4, r1, #12
 8002728:	1c75      	adds	r5, r6, #1
 800272a:	0a64      	lsrs	r4, r4, #9
 800272c:	0f42      	lsrs	r2, r0, #29
 800272e:	056d      	lsls	r5, r5, #21
 8002730:	4322      	orrs	r2, r4
 8002732:	0fc9      	lsrs	r1, r1, #31
 8002734:	00c4      	lsls	r4, r0, #3
 8002736:	0d6d      	lsrs	r5, r5, #21
 8002738:	2d01      	cmp	r5, #1
 800273a:	dd2a      	ble.n	8002792 <__aeabi_d2f+0x72>
 800273c:	4b3b      	ldr	r3, [pc, #236]	; (800282c <__aeabi_d2f+0x10c>)
 800273e:	18f3      	adds	r3, r6, r3
 8002740:	2bfe      	cmp	r3, #254	; 0xfe
 8002742:	dc1a      	bgt.n	800277a <__aeabi_d2f+0x5a>
 8002744:	2b00      	cmp	r3, #0
 8002746:	dd42      	ble.n	80027ce <__aeabi_d2f+0xae>
 8002748:	0180      	lsls	r0, r0, #6
 800274a:	1e45      	subs	r5, r0, #1
 800274c:	41a8      	sbcs	r0, r5
 800274e:	00d2      	lsls	r2, r2, #3
 8002750:	4310      	orrs	r0, r2
 8002752:	0f62      	lsrs	r2, r4, #29
 8002754:	4302      	orrs	r2, r0
 8002756:	0750      	lsls	r0, r2, #29
 8002758:	d004      	beq.n	8002764 <__aeabi_d2f+0x44>
 800275a:	200f      	movs	r0, #15
 800275c:	4010      	ands	r0, r2
 800275e:	2804      	cmp	r0, #4
 8002760:	d000      	beq.n	8002764 <__aeabi_d2f+0x44>
 8002762:	3204      	adds	r2, #4
 8002764:	2080      	movs	r0, #128	; 0x80
 8002766:	04c0      	lsls	r0, r0, #19
 8002768:	4010      	ands	r0, r2
 800276a:	d021      	beq.n	80027b0 <__aeabi_d2f+0x90>
 800276c:	3301      	adds	r3, #1
 800276e:	2bff      	cmp	r3, #255	; 0xff
 8002770:	d003      	beq.n	800277a <__aeabi_d2f+0x5a>
 8002772:	0192      	lsls	r2, r2, #6
 8002774:	0a52      	lsrs	r2, r2, #9
 8002776:	b2db      	uxtb	r3, r3
 8002778:	e001      	b.n	800277e <__aeabi_d2f+0x5e>
 800277a:	23ff      	movs	r3, #255	; 0xff
 800277c:	2200      	movs	r2, #0
 800277e:	0252      	lsls	r2, r2, #9
 8002780:	0a52      	lsrs	r2, r2, #9
 8002782:	05db      	lsls	r3, r3, #23
 8002784:	4313      	orrs	r3, r2
 8002786:	005b      	lsls	r3, r3, #1
 8002788:	07c9      	lsls	r1, r1, #31
 800278a:	085b      	lsrs	r3, r3, #1
 800278c:	430b      	orrs	r3, r1
 800278e:	0018      	movs	r0, r3
 8002790:	bd70      	pop	{r4, r5, r6, pc}
 8002792:	2e00      	cmp	r6, #0
 8002794:	d007      	beq.n	80027a6 <__aeabi_d2f+0x86>
 8002796:	4314      	orrs	r4, r2
 8002798:	d0ef      	beq.n	800277a <__aeabi_d2f+0x5a>
 800279a:	2080      	movs	r0, #128	; 0x80
 800279c:	00d2      	lsls	r2, r2, #3
 800279e:	0480      	lsls	r0, r0, #18
 80027a0:	4302      	orrs	r2, r0
 80027a2:	23ff      	movs	r3, #255	; 0xff
 80027a4:	e7d7      	b.n	8002756 <__aeabi_d2f+0x36>
 80027a6:	4322      	orrs	r2, r4
 80027a8:	2300      	movs	r3, #0
 80027aa:	2a00      	cmp	r2, #0
 80027ac:	d003      	beq.n	80027b6 <__aeabi_d2f+0x96>
 80027ae:	2205      	movs	r2, #5
 80027b0:	08d2      	lsrs	r2, r2, #3
 80027b2:	2bff      	cmp	r3, #255	; 0xff
 80027b4:	d003      	beq.n	80027be <__aeabi_d2f+0x9e>
 80027b6:	0252      	lsls	r2, r2, #9
 80027b8:	0a52      	lsrs	r2, r2, #9
 80027ba:	b2db      	uxtb	r3, r3
 80027bc:	e7df      	b.n	800277e <__aeabi_d2f+0x5e>
 80027be:	2a00      	cmp	r2, #0
 80027c0:	d032      	beq.n	8002828 <__aeabi_d2f+0x108>
 80027c2:	2080      	movs	r0, #128	; 0x80
 80027c4:	03c0      	lsls	r0, r0, #15
 80027c6:	4302      	orrs	r2, r0
 80027c8:	0252      	lsls	r2, r2, #9
 80027ca:	0a52      	lsrs	r2, r2, #9
 80027cc:	e7d7      	b.n	800277e <__aeabi_d2f+0x5e>
 80027ce:	0018      	movs	r0, r3
 80027d0:	3017      	adds	r0, #23
 80027d2:	db14      	blt.n	80027fe <__aeabi_d2f+0xde>
 80027d4:	2080      	movs	r0, #128	; 0x80
 80027d6:	0400      	lsls	r0, r0, #16
 80027d8:	4302      	orrs	r2, r0
 80027da:	201e      	movs	r0, #30
 80027dc:	1ac0      	subs	r0, r0, r3
 80027de:	281f      	cmp	r0, #31
 80027e0:	dc0f      	bgt.n	8002802 <__aeabi_d2f+0xe2>
 80027e2:	0025      	movs	r5, r4
 80027e4:	4b12      	ldr	r3, [pc, #72]	; (8002830 <__aeabi_d2f+0x110>)
 80027e6:	18f3      	adds	r3, r6, r3
 80027e8:	409d      	lsls	r5, r3
 80027ea:	1e6e      	subs	r6, r5, #1
 80027ec:	41b5      	sbcs	r5, r6
 80027ee:	409a      	lsls	r2, r3
 80027f0:	002b      	movs	r3, r5
 80027f2:	4313      	orrs	r3, r2
 80027f4:	0022      	movs	r2, r4
 80027f6:	40c2      	lsrs	r2, r0
 80027f8:	431a      	orrs	r2, r3
 80027fa:	2300      	movs	r3, #0
 80027fc:	e7ab      	b.n	8002756 <__aeabi_d2f+0x36>
 80027fe:	2300      	movs	r3, #0
 8002800:	e7d5      	b.n	80027ae <__aeabi_d2f+0x8e>
 8002802:	2502      	movs	r5, #2
 8002804:	426d      	negs	r5, r5
 8002806:	1aeb      	subs	r3, r5, r3
 8002808:	0015      	movs	r5, r2
 800280a:	40dd      	lsrs	r5, r3
 800280c:	2820      	cmp	r0, #32
 800280e:	d009      	beq.n	8002824 <__aeabi_d2f+0x104>
 8002810:	4b08      	ldr	r3, [pc, #32]	; (8002834 <__aeabi_d2f+0x114>)
 8002812:	18f3      	adds	r3, r6, r3
 8002814:	409a      	lsls	r2, r3
 8002816:	4314      	orrs	r4, r2
 8002818:	1e62      	subs	r2, r4, #1
 800281a:	4194      	sbcs	r4, r2
 800281c:	0022      	movs	r2, r4
 800281e:	2300      	movs	r3, #0
 8002820:	432a      	orrs	r2, r5
 8002822:	e798      	b.n	8002756 <__aeabi_d2f+0x36>
 8002824:	2200      	movs	r2, #0
 8002826:	e7f6      	b.n	8002816 <__aeabi_d2f+0xf6>
 8002828:	2200      	movs	r2, #0
 800282a:	e7a8      	b.n	800277e <__aeabi_d2f+0x5e>
 800282c:	fffffc80 	.word	0xfffffc80
 8002830:	fffffc82 	.word	0xfffffc82
 8002834:	fffffca2 	.word	0xfffffca2

08002838 <__clzsi2>:
 8002838:	211c      	movs	r1, #28
 800283a:	2301      	movs	r3, #1
 800283c:	041b      	lsls	r3, r3, #16
 800283e:	4298      	cmp	r0, r3
 8002840:	d301      	bcc.n	8002846 <__clzsi2+0xe>
 8002842:	0c00      	lsrs	r0, r0, #16
 8002844:	3910      	subs	r1, #16
 8002846:	0a1b      	lsrs	r3, r3, #8
 8002848:	4298      	cmp	r0, r3
 800284a:	d301      	bcc.n	8002850 <__clzsi2+0x18>
 800284c:	0a00      	lsrs	r0, r0, #8
 800284e:	3908      	subs	r1, #8
 8002850:	091b      	lsrs	r3, r3, #4
 8002852:	4298      	cmp	r0, r3
 8002854:	d301      	bcc.n	800285a <__clzsi2+0x22>
 8002856:	0900      	lsrs	r0, r0, #4
 8002858:	3904      	subs	r1, #4
 800285a:	a202      	add	r2, pc, #8	; (adr r2, 8002864 <__clzsi2+0x2c>)
 800285c:	5c10      	ldrb	r0, [r2, r0]
 800285e:	1840      	adds	r0, r0, r1
 8002860:	4770      	bx	lr
 8002862:	46c0      	nop			; (mov r8, r8)
 8002864:	02020304 	.word	0x02020304
 8002868:	01010101 	.word	0x01010101
	...

08002874 <EXTI_Init>:
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure that 
  *         contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8002874:	b580      	push	{r7, lr}
 8002876:	b084      	sub	sp, #16
 8002878:	af00      	add	r7, sp, #0
 800287a:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 800287c:	2300      	movs	r3, #0
 800287e:	60fb      	str	r3, [r7, #12]
  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));
  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
 8002880:	4b33      	ldr	r3, [pc, #204]	; (8002950 <EXTI_Init+0xdc>)
 8002882:	60fb      	str	r3, [r7, #12]

  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8002884:	687b      	ldr	r3, [r7, #4]
 8002886:	799b      	ldrb	r3, [r3, #6]
 8002888:	2b00      	cmp	r3, #0
 800288a:	d04f      	beq.n	800292c <EXTI_Init+0xb8>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 800288c:	4a30      	ldr	r2, [pc, #192]	; (8002950 <EXTI_Init+0xdc>)
 800288e:	4b30      	ldr	r3, [pc, #192]	; (8002950 <EXTI_Init+0xdc>)
 8002890:	6819      	ldr	r1, [r3, #0]
 8002892:	687b      	ldr	r3, [r7, #4]
 8002894:	681b      	ldr	r3, [r3, #0]
 8002896:	43db      	mvns	r3, r3
 8002898:	400b      	ands	r3, r1
 800289a:	6013      	str	r3, [r2, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 800289c:	4a2c      	ldr	r2, [pc, #176]	; (8002950 <EXTI_Init+0xdc>)
 800289e:	4b2c      	ldr	r3, [pc, #176]	; (8002950 <EXTI_Init+0xdc>)
 80028a0:	6859      	ldr	r1, [r3, #4]
 80028a2:	687b      	ldr	r3, [r7, #4]
 80028a4:	681b      	ldr	r3, [r3, #0]
 80028a6:	43db      	mvns	r3, r3
 80028a8:	400b      	ands	r3, r1
 80028aa:	6053      	str	r3, [r2, #4]

    tmp += EXTI_InitStruct->EXTI_Mode;
 80028ac:	687b      	ldr	r3, [r7, #4]
 80028ae:	791b      	ldrb	r3, [r3, #4]
 80028b0:	001a      	movs	r2, r3
 80028b2:	68fb      	ldr	r3, [r7, #12]
 80028b4:	189b      	adds	r3, r3, r2
 80028b6:	60fb      	str	r3, [r7, #12]

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80028b8:	68fb      	ldr	r3, [r7, #12]
 80028ba:	68fa      	ldr	r2, [r7, #12]
 80028bc:	6811      	ldr	r1, [r2, #0]
 80028be:	687a      	ldr	r2, [r7, #4]
 80028c0:	6812      	ldr	r2, [r2, #0]
 80028c2:	430a      	orrs	r2, r1
 80028c4:	601a      	str	r2, [r3, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 80028c6:	4a22      	ldr	r2, [pc, #136]	; (8002950 <EXTI_Init+0xdc>)
 80028c8:	4b21      	ldr	r3, [pc, #132]	; (8002950 <EXTI_Init+0xdc>)
 80028ca:	6899      	ldr	r1, [r3, #8]
 80028cc:	687b      	ldr	r3, [r7, #4]
 80028ce:	681b      	ldr	r3, [r3, #0]
 80028d0:	43db      	mvns	r3, r3
 80028d2:	400b      	ands	r3, r1
 80028d4:	6093      	str	r3, [r2, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80028d6:	4a1e      	ldr	r2, [pc, #120]	; (8002950 <EXTI_Init+0xdc>)
 80028d8:	4b1d      	ldr	r3, [pc, #116]	; (8002950 <EXTI_Init+0xdc>)
 80028da:	68d9      	ldr	r1, [r3, #12]
 80028dc:	687b      	ldr	r3, [r7, #4]
 80028de:	681b      	ldr	r3, [r3, #0]
 80028e0:	43db      	mvns	r3, r3
 80028e2:	400b      	ands	r3, r1
 80028e4:	60d3      	str	r3, [r2, #12]

    /* Select the trigger for the selected interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80028e6:	687b      	ldr	r3, [r7, #4]
 80028e8:	795b      	ldrb	r3, [r3, #5]
 80028ea:	2b10      	cmp	r3, #16
 80028ec:	d10e      	bne.n	800290c <EXTI_Init+0x98>
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 80028ee:	4a18      	ldr	r2, [pc, #96]	; (8002950 <EXTI_Init+0xdc>)
 80028f0:	4b17      	ldr	r3, [pc, #92]	; (8002950 <EXTI_Init+0xdc>)
 80028f2:	6899      	ldr	r1, [r3, #8]
 80028f4:	687b      	ldr	r3, [r7, #4]
 80028f6:	681b      	ldr	r3, [r3, #0]
 80028f8:	430b      	orrs	r3, r1
 80028fa:	6093      	str	r3, [r2, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 80028fc:	4a14      	ldr	r2, [pc, #80]	; (8002950 <EXTI_Init+0xdc>)
 80028fe:	4b14      	ldr	r3, [pc, #80]	; (8002950 <EXTI_Init+0xdc>)
 8002900:	68d9      	ldr	r1, [r3, #12]
 8002902:	687b      	ldr	r3, [r7, #4]
 8002904:	681b      	ldr	r3, [r3, #0]
 8002906:	430b      	orrs	r3, r1
 8002908:	60d3      	str	r3, [r2, #12]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 800290a:	e01d      	b.n	8002948 <EXTI_Init+0xd4>
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
 800290c:	4b10      	ldr	r3, [pc, #64]	; (8002950 <EXTI_Init+0xdc>)
 800290e:	60fb      	str	r3, [r7, #12]
      tmp += EXTI_InitStruct->EXTI_Trigger;
 8002910:	687b      	ldr	r3, [r7, #4]
 8002912:	795b      	ldrb	r3, [r3, #5]
 8002914:	001a      	movs	r2, r3
 8002916:	68fb      	ldr	r3, [r7, #12]
 8002918:	189b      	adds	r3, r3, r2
 800291a:	60fb      	str	r3, [r7, #12]

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 800291c:	68fb      	ldr	r3, [r7, #12]
 800291e:	68fa      	ldr	r2, [r7, #12]
 8002920:	6811      	ldr	r1, [r2, #0]
 8002922:	687a      	ldr	r2, [r7, #4]
 8002924:	6812      	ldr	r2, [r2, #0]
 8002926:	430a      	orrs	r2, r1
 8002928:	601a      	str	r2, [r3, #0]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 800292a:	e00d      	b.n	8002948 <EXTI_Init+0xd4>
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
    }
  }
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;
 800292c:	687b      	ldr	r3, [r7, #4]
 800292e:	791b      	ldrb	r3, [r3, #4]
 8002930:	001a      	movs	r2, r3
 8002932:	68fb      	ldr	r3, [r7, #12]
 8002934:	189b      	adds	r3, r3, r2
 8002936:	60fb      	str	r3, [r7, #12]

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 8002938:	68fb      	ldr	r3, [r7, #12]
 800293a:	68fa      	ldr	r2, [r7, #12]
 800293c:	6811      	ldr	r1, [r2, #0]
 800293e:	687a      	ldr	r2, [r7, #4]
 8002940:	6812      	ldr	r2, [r2, #0]
 8002942:	43d2      	mvns	r2, r2
 8002944:	400a      	ands	r2, r1
 8002946:	601a      	str	r2, [r3, #0]
  }
}
 8002948:	46c0      	nop			; (mov r8, r8)
 800294a:	46bd      	mov	sp, r7
 800294c:	b004      	add	sp, #16
 800294e:	bd80      	pop	{r7, pc}
 8002950:	40010400 	.word	0x40010400

08002954 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8002954:	b580      	push	{r7, lr}
 8002956:	b086      	sub	sp, #24
 8002958:	af00      	add	r7, sp, #0
 800295a:	6078      	str	r0, [r7, #4]
 800295c:	6039      	str	r1, [r7, #0]
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 800295e:	2300      	movs	r3, #0
 8002960:	617b      	str	r3, [r7, #20]
 8002962:	2300      	movs	r3, #0
 8002964:	613b      	str	r3, [r7, #16]
 8002966:	2300      	movs	r3, #0
 8002968:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 800296a:	2300      	movs	r3, #0
 800296c:	617b      	str	r3, [r7, #20]
 800296e:	e081      	b.n	8002a74 <GPIO_Init+0x120>
  {
    pos = ((uint32_t)0x01) << pinpos;
 8002970:	2201      	movs	r2, #1
 8002972:	697b      	ldr	r3, [r7, #20]
 8002974:	409a      	lsls	r2, r3
 8002976:	0013      	movs	r3, r2
 8002978:	613b      	str	r3, [r7, #16]

    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 800297a:	683b      	ldr	r3, [r7, #0]
 800297c:	681b      	ldr	r3, [r3, #0]
 800297e:	693a      	ldr	r2, [r7, #16]
 8002980:	4013      	ands	r3, r2
 8002982:	60fb      	str	r3, [r7, #12]

    if (currentpin == pos)
 8002984:	68fa      	ldr	r2, [r7, #12]
 8002986:	693b      	ldr	r3, [r7, #16]
 8002988:	429a      	cmp	r2, r3
 800298a:	d170      	bne.n	8002a6e <GPIO_Init+0x11a>
    {
      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 800298c:	683b      	ldr	r3, [r7, #0]
 800298e:	791b      	ldrb	r3, [r3, #4]
 8002990:	2b01      	cmp	r3, #1
 8002992:	d003      	beq.n	800299c <GPIO_Init+0x48>
 8002994:	683b      	ldr	r3, [r7, #0]
 8002996:	791b      	ldrb	r3, [r3, #4]
 8002998:	2b02      	cmp	r3, #2
 800299a:	d138      	bne.n	8002a0e <GPIO_Init+0xba>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 800299c:	687b      	ldr	r3, [r7, #4]
 800299e:	689b      	ldr	r3, [r3, #8]
 80029a0:	697a      	ldr	r2, [r7, #20]
 80029a2:	0052      	lsls	r2, r2, #1
 80029a4:	2103      	movs	r1, #3
 80029a6:	4091      	lsls	r1, r2
 80029a8:	000a      	movs	r2, r1
 80029aa:	43d2      	mvns	r2, r2
 80029ac:	401a      	ands	r2, r3
 80029ae:	687b      	ldr	r3, [r7, #4]
 80029b0:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80029b2:	687b      	ldr	r3, [r7, #4]
 80029b4:	689a      	ldr	r2, [r3, #8]
 80029b6:	683b      	ldr	r3, [r7, #0]
 80029b8:	795b      	ldrb	r3, [r3, #5]
 80029ba:	0019      	movs	r1, r3
 80029bc:	697b      	ldr	r3, [r7, #20]
 80029be:	005b      	lsls	r3, r3, #1
 80029c0:	4099      	lsls	r1, r3
 80029c2:	000b      	movs	r3, r1
 80029c4:	431a      	orrs	r2, r3
 80029c6:	687b      	ldr	r3, [r7, #4]
 80029c8:	609a      	str	r2, [r3, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration */
        GPIOx->OTYPER &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos));
 80029ca:	687b      	ldr	r3, [r7, #4]
 80029cc:	889b      	ldrh	r3, [r3, #4]
 80029ce:	b29b      	uxth	r3, r3
 80029d0:	697a      	ldr	r2, [r7, #20]
 80029d2:	0412      	lsls	r2, r2, #16
 80029d4:	0c12      	lsrs	r2, r2, #16
 80029d6:	2101      	movs	r1, #1
 80029d8:	4091      	lsls	r1, r2
 80029da:	000a      	movs	r2, r1
 80029dc:	b292      	uxth	r2, r2
 80029de:	43d2      	mvns	r2, r2
 80029e0:	b292      	uxth	r2, r2
 80029e2:	4013      	ands	r3, r2
 80029e4:	b29a      	uxth	r2, r3
 80029e6:	687b      	ldr	r3, [r7, #4]
 80029e8:	809a      	strh	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 80029ea:	687b      	ldr	r3, [r7, #4]
 80029ec:	889b      	ldrh	r3, [r3, #4]
 80029ee:	b29b      	uxth	r3, r3
 80029f0:	b21a      	sxth	r2, r3
 80029f2:	683b      	ldr	r3, [r7, #0]
 80029f4:	799b      	ldrb	r3, [r3, #6]
 80029f6:	0019      	movs	r1, r3
 80029f8:	697b      	ldr	r3, [r7, #20]
 80029fa:	041b      	lsls	r3, r3, #16
 80029fc:	0c1b      	lsrs	r3, r3, #16
 80029fe:	4099      	lsls	r1, r3
 8002a00:	000b      	movs	r3, r1
 8002a02:	b21b      	sxth	r3, r3
 8002a04:	4313      	orrs	r3, r2
 8002a06:	b21b      	sxth	r3, r3
 8002a08:	b29a      	uxth	r2, r3
 8002a0a:	687b      	ldr	r3, [r7, #4]
 8002a0c:	809a      	strh	r2, [r3, #4]
      }

      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8002a0e:	687b      	ldr	r3, [r7, #4]
 8002a10:	681b      	ldr	r3, [r3, #0]
 8002a12:	697a      	ldr	r2, [r7, #20]
 8002a14:	0052      	lsls	r2, r2, #1
 8002a16:	2103      	movs	r1, #3
 8002a18:	4091      	lsls	r1, r2
 8002a1a:	000a      	movs	r2, r1
 8002a1c:	43d2      	mvns	r2, r2
 8002a1e:	401a      	ands	r2, r3
 8002a20:	687b      	ldr	r3, [r7, #4]
 8002a22:	601a      	str	r2, [r3, #0]

      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8002a24:	687b      	ldr	r3, [r7, #4]
 8002a26:	681a      	ldr	r2, [r3, #0]
 8002a28:	683b      	ldr	r3, [r7, #0]
 8002a2a:	791b      	ldrb	r3, [r3, #4]
 8002a2c:	0019      	movs	r1, r3
 8002a2e:	697b      	ldr	r3, [r7, #20]
 8002a30:	005b      	lsls	r3, r3, #1
 8002a32:	4099      	lsls	r1, r3
 8002a34:	000b      	movs	r3, r1
 8002a36:	431a      	orrs	r2, r3
 8002a38:	687b      	ldr	r3, [r7, #4]
 8002a3a:	601a      	str	r2, [r3, #0]

      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8002a3c:	687b      	ldr	r3, [r7, #4]
 8002a3e:	68db      	ldr	r3, [r3, #12]
 8002a40:	697a      	ldr	r2, [r7, #20]
 8002a42:	0412      	lsls	r2, r2, #16
 8002a44:	0c12      	lsrs	r2, r2, #16
 8002a46:	0052      	lsls	r2, r2, #1
 8002a48:	2103      	movs	r1, #3
 8002a4a:	4091      	lsls	r1, r2
 8002a4c:	000a      	movs	r2, r1
 8002a4e:	43d2      	mvns	r2, r2
 8002a50:	401a      	ands	r2, r3
 8002a52:	687b      	ldr	r3, [r7, #4]
 8002a54:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8002a56:	687b      	ldr	r3, [r7, #4]
 8002a58:	68da      	ldr	r2, [r3, #12]
 8002a5a:	683b      	ldr	r3, [r7, #0]
 8002a5c:	79db      	ldrb	r3, [r3, #7]
 8002a5e:	0019      	movs	r1, r3
 8002a60:	697b      	ldr	r3, [r7, #20]
 8002a62:	005b      	lsls	r3, r3, #1
 8002a64:	4099      	lsls	r1, r3
 8002a66:	000b      	movs	r3, r1
 8002a68:	431a      	orrs	r2, r3
 8002a6a:	687b      	ldr	r3, [r7, #4]
 8002a6c:	60da      	str	r2, [r3, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8002a6e:	697b      	ldr	r3, [r7, #20]
 8002a70:	3301      	adds	r3, #1
 8002a72:	617b      	str	r3, [r7, #20]
 8002a74:	697b      	ldr	r3, [r7, #20]
 8002a76:	2b0f      	cmp	r3, #15
 8002a78:	d800      	bhi.n	8002a7c <GPIO_Init+0x128>
 8002a7a:	e779      	b.n	8002970 <GPIO_Init+0x1c>
      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 8002a7c:	46c0      	nop			; (mov r8, r8)
 8002a7e:	46bd      	mov	sp, r7
 8002a80:	b006      	add	sp, #24
 8002a82:	bd80      	pop	{r7, pc}

08002a84 <GPIO_ReadInputData>:
  * @note   GPIOE is available only for STM32F072.
  * @note   GPIOD is not available for STM32F031.   
  * @retval The input port pin value.
  */
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
 8002a84:	b580      	push	{r7, lr}
 8002a86:	b082      	sub	sp, #8
 8002a88:	af00      	add	r7, sp, #0
 8002a8a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 8002a8c:	687b      	ldr	r3, [r7, #4]
 8002a8e:	8a1b      	ldrh	r3, [r3, #16]
 8002a90:	b29b      	uxth	r3, r3
}
 8002a92:	0018      	movs	r0, r3
 8002a94:	46bd      	mov	sp, r7
 8002a96:	b002      	add	sp, #8
 8002a98:	bd80      	pop	{r7, pc}
 8002a9a:	46c0      	nop			; (mov r8, r8)

08002a9c <GPIO_ReadOutputData>:
  * @note   GPIOE is available only for STM32F072.
  * @note   GPIOD is not available for STM32F031.    
  * @retval GPIO output data port value.
  */
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
 8002a9c:	b580      	push	{r7, lr}
 8002a9e:	b082      	sub	sp, #8
 8002aa0:	af00      	add	r7, sp, #0
 8002aa2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 8002aa4:	687b      	ldr	r3, [r7, #4]
 8002aa6:	8a9b      	ldrh	r3, [r3, #20]
 8002aa8:	b29b      	uxth	r3, r3
}
 8002aaa:	0018      	movs	r0, r3
 8002aac:	46bd      	mov	sp, r7
 8002aae:	b002      	add	sp, #8
 8002ab0:	bd80      	pop	{r7, pc}
 8002ab2:	46c0      	nop			; (mov r8, r8)

08002ab4 <GPIO_SetBits>:
  *         For STM32F072: (0..15) for GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, (0..10) for GPIOF.
  *         For STM32F031: (0..15) for GPIOA, GPIOB, (13..15) for GPIOC and (0..1, 6..7) for GPIOF. 
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8002ab4:	b580      	push	{r7, lr}
 8002ab6:	b082      	sub	sp, #8
 8002ab8:	af00      	add	r7, sp, #0
 8002aba:	6078      	str	r0, [r7, #4]
 8002abc:	000a      	movs	r2, r1
 8002abe:	1cbb      	adds	r3, r7, #2
 8002ac0:	801a      	strh	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRR = GPIO_Pin;
 8002ac2:	1cbb      	adds	r3, r7, #2
 8002ac4:	881a      	ldrh	r2, [r3, #0]
 8002ac6:	687b      	ldr	r3, [r7, #4]
 8002ac8:	619a      	str	r2, [r3, #24]
}
 8002aca:	46c0      	nop			; (mov r8, r8)
 8002acc:	46bd      	mov	sp, r7
 8002ace:	b002      	add	sp, #8
 8002ad0:	bd80      	pop	{r7, pc}
 8002ad2:	46c0      	nop			; (mov r8, r8)

08002ad4 <GPIO_ResetBits>:
  *         For STM32F072: (0..15) for GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, (0..10) for GPIOF.
  *         For STM32F031: (0..15) for GPIOA, GPIOB, (13..15) for GPIOC and (0..1, 6..7) for GPIOF. 
  * @retval None
  */
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8002ad4:	b580      	push	{r7, lr}
 8002ad6:	b082      	sub	sp, #8
 8002ad8:	af00      	add	r7, sp, #0
 8002ada:	6078      	str	r0, [r7, #4]
 8002adc:	000a      	movs	r2, r1
 8002ade:	1cbb      	adds	r3, r7, #2
 8002ae0:	801a      	strh	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BRR = GPIO_Pin;
 8002ae2:	687b      	ldr	r3, [r7, #4]
 8002ae4:	1cba      	adds	r2, r7, #2
 8002ae6:	8812      	ldrh	r2, [r2, #0]
 8002ae8:	851a      	strh	r2, [r3, #40]	; 0x28
}
 8002aea:	46c0      	nop			; (mov r8, r8)
 8002aec:	46bd      	mov	sp, r7
 8002aee:	b002      	add	sp, #8
 8002af0:	bd80      	pop	{r7, pc}
 8002af2:	46c0      	nop			; (mov r8, r8)

08002af4 <GPIO_WriteBit>:
  *         For STM32F072: (0..15) for GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, (0..10) for GPIOF.
  *         For STM32F031: (0..15) for GPIOA, GPIOB, (13..15) for GPIOC and (0..1, 6..7) for GPIOF.
  * @retval None
  */
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
{
 8002af4:	b580      	push	{r7, lr}
 8002af6:	b082      	sub	sp, #8
 8002af8:	af00      	add	r7, sp, #0
 8002afa:	6078      	str	r0, [r7, #4]
 8002afc:	0008      	movs	r0, r1
 8002afe:	0011      	movs	r1, r2
 8002b00:	1cbb      	adds	r3, r7, #2
 8002b02:	1c02      	adds	r2, r0, #0
 8002b04:	801a      	strh	r2, [r3, #0]
 8002b06:	1c7b      	adds	r3, r7, #1
 8002b08:	1c0a      	adds	r2, r1, #0
 8002b0a:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 8002b0c:	1c7b      	adds	r3, r7, #1
 8002b0e:	781b      	ldrb	r3, [r3, #0]
 8002b10:	2b00      	cmp	r3, #0
 8002b12:	d004      	beq.n	8002b1e <GPIO_WriteBit+0x2a>
  {
    GPIOx->BSRR = GPIO_Pin;
 8002b14:	1cbb      	adds	r3, r7, #2
 8002b16:	881a      	ldrh	r2, [r3, #0]
 8002b18:	687b      	ldr	r3, [r7, #4]
 8002b1a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
  }
}
 8002b1c:	e003      	b.n	8002b26 <GPIO_WriteBit+0x32>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
 8002b1e:	687b      	ldr	r3, [r7, #4]
 8002b20:	1cba      	adds	r2, r7, #2
 8002b22:	8812      	ldrh	r2, [r2, #0]
 8002b24:	851a      	strh	r2, [r3, #40]	; 0x28
  }
}
 8002b26:	46c0      	nop			; (mov r8, r8)
 8002b28:	46bd      	mov	sp, r7
 8002b2a:	b002      	add	sp, #8
 8002b2c:	bd80      	pop	{r7, pc}
 8002b2e:	46c0      	nop			; (mov r8, r8)

08002b30 <GPIO_Write>:
  * @note   GPIOD is not available for STM32F031.  
  * @param  PortVal: specifies the value to be written to the port output data register.
  * @retval None
  */
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
 8002b30:	b580      	push	{r7, lr}
 8002b32:	b082      	sub	sp, #8
 8002b34:	af00      	add	r7, sp, #0
 8002b36:	6078      	str	r0, [r7, #4]
 8002b38:	000a      	movs	r2, r1
 8002b3a:	1cbb      	adds	r3, r7, #2
 8002b3c:	801a      	strh	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 8002b3e:	687b      	ldr	r3, [r7, #4]
 8002b40:	1cba      	adds	r2, r7, #2
 8002b42:	8812      	ldrh	r2, [r2, #0]
 8002b44:	829a      	strh	r2, [r3, #20]
}
 8002b46:	46c0      	nop			; (mov r8, r8)
 8002b48:	46bd      	mov	sp, r7
 8002b4a:	b002      	add	sp, #8
 8002b4c:	bd80      	pop	{r7, pc}
 8002b4e:	46c0      	nop			; (mov r8, r8)

08002b50 <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8002b50:	b580      	push	{r7, lr}
 8002b52:	b084      	sub	sp, #16
 8002b54:	af00      	add	r7, sp, #0
 8002b56:	6078      	str	r0, [r7, #4]
  uint32_t tmppriority = 0x00;
 8002b58:	2300      	movs	r3, #0
 8002b5a:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPriority));  
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8002b5c:	687b      	ldr	r3, [r7, #4]
 8002b5e:	789b      	ldrb	r3, [r3, #2]
 8002b60:	2b00      	cmp	r3, #0
 8002b62:	d039      	beq.n	8002bd8 <NVIC_Init+0x88>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel >> 0x02];
 8002b64:	4a24      	ldr	r2, [pc, #144]	; (8002bf8 <NVIC_Init+0xa8>)
 8002b66:	687b      	ldr	r3, [r7, #4]
 8002b68:	781b      	ldrb	r3, [r3, #0]
 8002b6a:	089b      	lsrs	r3, r3, #2
 8002b6c:	b2db      	uxtb	r3, r3
 8002b6e:	33c0      	adds	r3, #192	; 0xc0
 8002b70:	009b      	lsls	r3, r3, #2
 8002b72:	589b      	ldr	r3, [r3, r2]
 8002b74:	60fb      	str	r3, [r7, #12]
    tmppriority &= (uint32_t)(~(((uint32_t)0xFF) << ((NVIC_InitStruct->NVIC_IRQChannel & 0x03) * 8)));
 8002b76:	687b      	ldr	r3, [r7, #4]
 8002b78:	781b      	ldrb	r3, [r3, #0]
 8002b7a:	001a      	movs	r2, r3
 8002b7c:	2303      	movs	r3, #3
 8002b7e:	4013      	ands	r3, r2
 8002b80:	00db      	lsls	r3, r3, #3
 8002b82:	22ff      	movs	r2, #255	; 0xff
 8002b84:	409a      	lsls	r2, r3
 8002b86:	0013      	movs	r3, r2
 8002b88:	43da      	mvns	r2, r3
 8002b8a:	68fb      	ldr	r3, [r7, #12]
 8002b8c:	4013      	ands	r3, r2
 8002b8e:	60fb      	str	r3, [r7, #12]
    tmppriority |= (uint32_t)((((uint32_t)NVIC_InitStruct->NVIC_IRQChannelPriority << 6) & 0xFF) << ((NVIC_InitStruct->NVIC_IRQChannel & 0x03) * 8));    
 8002b90:	687b      	ldr	r3, [r7, #4]
 8002b92:	785b      	ldrb	r3, [r3, #1]
 8002b94:	019b      	lsls	r3, r3, #6
 8002b96:	22ff      	movs	r2, #255	; 0xff
 8002b98:	401a      	ands	r2, r3
 8002b9a:	687b      	ldr	r3, [r7, #4]
 8002b9c:	781b      	ldrb	r3, [r3, #0]
 8002b9e:	0019      	movs	r1, r3
 8002ba0:	2303      	movs	r3, #3
 8002ba2:	400b      	ands	r3, r1
 8002ba4:	00db      	lsls	r3, r3, #3
 8002ba6:	409a      	lsls	r2, r3
 8002ba8:	0013      	movs	r3, r2
 8002baa:	68fa      	ldr	r2, [r7, #12]
 8002bac:	4313      	orrs	r3, r2
 8002bae:	60fb      	str	r3, [r7, #12]
    
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel >> 0x02] = tmppriority;
 8002bb0:	4911      	ldr	r1, [pc, #68]	; (8002bf8 <NVIC_Init+0xa8>)
 8002bb2:	687b      	ldr	r3, [r7, #4]
 8002bb4:	781b      	ldrb	r3, [r3, #0]
 8002bb6:	089b      	lsrs	r3, r3, #2
 8002bb8:	b2db      	uxtb	r3, r3
 8002bba:	33c0      	adds	r3, #192	; 0xc0
 8002bbc:	009b      	lsls	r3, r3, #2
 8002bbe:	68fa      	ldr	r2, [r7, #12]
 8002bc0:	505a      	str	r2, [r3, r1]
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[0] = (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8002bc2:	4b0d      	ldr	r3, [pc, #52]	; (8002bf8 <NVIC_Init+0xa8>)
 8002bc4:	687a      	ldr	r2, [r7, #4]
 8002bc6:	7812      	ldrb	r2, [r2, #0]
 8002bc8:	0011      	movs	r1, r2
 8002bca:	221f      	movs	r2, #31
 8002bcc:	400a      	ands	r2, r1
 8002bce:	2101      	movs	r1, #1
 8002bd0:	4091      	lsls	r1, r2
 8002bd2:	000a      	movs	r2, r1
 8002bd4:	601a      	str	r2, [r3, #0]
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[0] = (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8002bd6:	e00a      	b.n	8002bee <NVIC_Init+0x9e>
    NVIC->ISER[0] = (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[0] = (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8002bd8:	4907      	ldr	r1, [pc, #28]	; (8002bf8 <NVIC_Init+0xa8>)
 8002bda:	687b      	ldr	r3, [r7, #4]
 8002bdc:	781b      	ldrb	r3, [r3, #0]
 8002bde:	001a      	movs	r2, r3
 8002be0:	231f      	movs	r3, #31
 8002be2:	4013      	ands	r3, r2
 8002be4:	2201      	movs	r2, #1
 8002be6:	409a      	lsls	r2, r3
 8002be8:	0013      	movs	r3, r2
 8002bea:	2280      	movs	r2, #128	; 0x80
 8002bec:	508b      	str	r3, [r1, r2]
  }
}
 8002bee:	46c0      	nop			; (mov r8, r8)
 8002bf0:	46bd      	mov	sp, r7
 8002bf2:	b004      	add	sp, #16
 8002bf4:	bd80      	pop	{r7, pc}
 8002bf6:	46c0      	nop			; (mov r8, r8)
 8002bf8:	e000e100 	.word	0xe000e100

08002bfc <RCC_AdjustHSI14CalibrationValue>:
  * @param  HSI14CalibrationValue: specifies the HSI14 calibration trimming value.
  *          This parameter must be a number between 0 and 0x1F.
  * @retval None
  */
void RCC_AdjustHSI14CalibrationValue(uint8_t HSI14CalibrationValue)
{
 8002bfc:	b580      	push	{r7, lr}
 8002bfe:	b084      	sub	sp, #16
 8002c00:	af00      	add	r7, sp, #0
 8002c02:	0002      	movs	r2, r0
 8002c04:	1dfb      	adds	r3, r7, #7
 8002c06:	701a      	strb	r2, [r3, #0]
  uint32_t tmpreg = 0;
 8002c08:	2300      	movs	r3, #0
 8002c0a:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_HSI14_CALIBRATION_VALUE(HSI14CalibrationValue));
  
  tmpreg = RCC->CR2;
 8002c0c:	4b09      	ldr	r3, [pc, #36]	; (8002c34 <RCC_AdjustHSI14CalibrationValue+0x38>)
 8002c0e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002c10:	60fb      	str	r3, [r7, #12]
  
  /* Clear HSI14TRIM[4:0] bits */
  tmpreg &= ~RCC_CR2_HSI14TRIM;
 8002c12:	68fb      	ldr	r3, [r7, #12]
 8002c14:	22f8      	movs	r2, #248	; 0xf8
 8002c16:	4393      	bics	r3, r2
 8002c18:	60fb      	str	r3, [r7, #12]
  
  /* Set the HSITRIM14[4:0] bits according to HSI14CalibrationValue value */
  tmpreg |= (uint32_t)HSI14CalibrationValue << 3;
 8002c1a:	1dfb      	adds	r3, r7, #7
 8002c1c:	781b      	ldrb	r3, [r3, #0]
 8002c1e:	00db      	lsls	r3, r3, #3
 8002c20:	68fa      	ldr	r2, [r7, #12]
 8002c22:	4313      	orrs	r3, r2
 8002c24:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CR2 = tmpreg;
 8002c26:	4b03      	ldr	r3, [pc, #12]	; (8002c34 <RCC_AdjustHSI14CalibrationValue+0x38>)
 8002c28:	68fa      	ldr	r2, [r7, #12]
 8002c2a:	635a      	str	r2, [r3, #52]	; 0x34
}
 8002c2c:	46c0      	nop			; (mov r8, r8)
 8002c2e:	46bd      	mov	sp, r7
 8002c30:	b004      	add	sp, #16
 8002c32:	bd80      	pop	{r7, pc}
 8002c34:	40021000 	.word	0x40021000

08002c38 <RCC_PLLConfig>:
  *          This parameter can be RCC_PLLMul_x where x:[2,16] 
  *
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
{
 8002c38:	b580      	push	{r7, lr}
 8002c3a:	b082      	sub	sp, #8
 8002c3c:	af00      	add	r7, sp, #0
 8002c3e:	6078      	str	r0, [r7, #4]
 8002c40:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  /* Clear PLL Source [16] and Multiplier [21:18] bits */
  RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
 8002c42:	4b09      	ldr	r3, [pc, #36]	; (8002c68 <RCC_PLLConfig+0x30>)
 8002c44:	4a08      	ldr	r2, [pc, #32]	; (8002c68 <RCC_PLLConfig+0x30>)
 8002c46:	6852      	ldr	r2, [r2, #4]
 8002c48:	4908      	ldr	r1, [pc, #32]	; (8002c6c <RCC_PLLConfig+0x34>)
 8002c4a:	400a      	ands	r2, r1
 8002c4c:	605a      	str	r2, [r3, #4]

  /* Set the PLL Source and Multiplier */
  RCC->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
 8002c4e:	4b06      	ldr	r3, [pc, #24]	; (8002c68 <RCC_PLLConfig+0x30>)
 8002c50:	4a05      	ldr	r2, [pc, #20]	; (8002c68 <RCC_PLLConfig+0x30>)
 8002c52:	6851      	ldr	r1, [r2, #4]
 8002c54:	6878      	ldr	r0, [r7, #4]
 8002c56:	683a      	ldr	r2, [r7, #0]
 8002c58:	4302      	orrs	r2, r0
 8002c5a:	430a      	orrs	r2, r1
 8002c5c:	605a      	str	r2, [r3, #4]
}
 8002c5e:	46c0      	nop			; (mov r8, r8)
 8002c60:	46bd      	mov	sp, r7
 8002c62:	b002      	add	sp, #8
 8002c64:	bd80      	pop	{r7, pc}
 8002c66:	46c0      	nop			; (mov r8, r8)
 8002c68:	40021000 	.word	0x40021000
 8002c6c:	ffc27fff 	.word	0xffc27fff

08002c70 <RCC_PLLCmd>:
  * @param  NewState: new state of the PLL.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLLCmd(FunctionalState NewState)
{
 8002c70:	b580      	push	{r7, lr}
 8002c72:	b082      	sub	sp, #8
 8002c74:	af00      	add	r7, sp, #0
 8002c76:	0002      	movs	r2, r0
 8002c78:	1dfb      	adds	r3, r7, #7
 8002c7a:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8002c7c:	1dfb      	adds	r3, r7, #7
 8002c7e:	781b      	ldrb	r3, [r3, #0]
 8002c80:	2b00      	cmp	r3, #0
 8002c82:	d007      	beq.n	8002c94 <RCC_PLLCmd+0x24>
  {
    RCC->CR |= RCC_CR_PLLON;
 8002c84:	4b08      	ldr	r3, [pc, #32]	; (8002ca8 <RCC_PLLCmd+0x38>)
 8002c86:	4a08      	ldr	r2, [pc, #32]	; (8002ca8 <RCC_PLLCmd+0x38>)
 8002c88:	6812      	ldr	r2, [r2, #0]
 8002c8a:	2180      	movs	r1, #128	; 0x80
 8002c8c:	0449      	lsls	r1, r1, #17
 8002c8e:	430a      	orrs	r2, r1
 8002c90:	601a      	str	r2, [r3, #0]
  }
  else
  {
    RCC->CR &= ~RCC_CR_PLLON;
  }
}
 8002c92:	e005      	b.n	8002ca0 <RCC_PLLCmd+0x30>
  {
    RCC->CR |= RCC_CR_PLLON;
  }
  else
  {
    RCC->CR &= ~RCC_CR_PLLON;
 8002c94:	4b04      	ldr	r3, [pc, #16]	; (8002ca8 <RCC_PLLCmd+0x38>)
 8002c96:	4a04      	ldr	r2, [pc, #16]	; (8002ca8 <RCC_PLLCmd+0x38>)
 8002c98:	6812      	ldr	r2, [r2, #0]
 8002c9a:	4904      	ldr	r1, [pc, #16]	; (8002cac <RCC_PLLCmd+0x3c>)
 8002c9c:	400a      	ands	r2, r1
 8002c9e:	601a      	str	r2, [r3, #0]
  }
}
 8002ca0:	46c0      	nop			; (mov r8, r8)
 8002ca2:	46bd      	mov	sp, r7
 8002ca4:	b002      	add	sp, #8
 8002ca6:	bd80      	pop	{r7, pc}
 8002ca8:	40021000 	.word	0x40021000
 8002cac:	feffffff 	.word	0xfeffffff

08002cb0 <RCC_SYSCLKConfig>:
  *            @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
  *            @arg RCC_SYSCLKSource_HSI48:  HSI48 selected as system clock source, applicable only for STM32F072 devices  
  * @retval None
  */
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
 8002cb0:	b580      	push	{r7, lr}
 8002cb2:	b084      	sub	sp, #16
 8002cb4:	af00      	add	r7, sp, #0
 8002cb6:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8002cb8:	2300      	movs	r3, #0
 8002cba:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  
  tmpreg = RCC->CFGR;
 8002cbc:	4b08      	ldr	r3, [pc, #32]	; (8002ce0 <RCC_SYSCLKConfig+0x30>)
 8002cbe:	685b      	ldr	r3, [r3, #4]
 8002cc0:	60fb      	str	r3, [r7, #12]
  
  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 8002cc2:	68fb      	ldr	r3, [r7, #12]
 8002cc4:	2203      	movs	r2, #3
 8002cc6:	4393      	bics	r3, r2
 8002cc8:	60fb      	str	r3, [r7, #12]
  
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8002cca:	68fa      	ldr	r2, [r7, #12]
 8002ccc:	687b      	ldr	r3, [r7, #4]
 8002cce:	4313      	orrs	r3, r2
 8002cd0:	60fb      	str	r3, [r7, #12]
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8002cd2:	4b03      	ldr	r3, [pc, #12]	; (8002ce0 <RCC_SYSCLKConfig+0x30>)
 8002cd4:	68fa      	ldr	r2, [r7, #12]
 8002cd6:	605a      	str	r2, [r3, #4]
}
 8002cd8:	46c0      	nop			; (mov r8, r8)
 8002cda:	46bd      	mov	sp, r7
 8002cdc:	b004      	add	sp, #16
 8002cde:	bd80      	pop	{r7, pc}
 8002ce0:	40021000 	.word	0x40021000

08002ce4 <RCC_HCLKConfig>:
  *            @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
  *            @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
  * @retval None
  */
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
 8002ce4:	b580      	push	{r7, lr}
 8002ce6:	b084      	sub	sp, #16
 8002ce8:	af00      	add	r7, sp, #0
 8002cea:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8002cec:	2300      	movs	r3, #0
 8002cee:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  
  tmpreg = RCC->CFGR;
 8002cf0:	4b08      	ldr	r3, [pc, #32]	; (8002d14 <RCC_HCLKConfig+0x30>)
 8002cf2:	685b      	ldr	r3, [r3, #4]
 8002cf4:	60fb      	str	r3, [r7, #12]
  
  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 8002cf6:	68fb      	ldr	r3, [r7, #12]
 8002cf8:	22f0      	movs	r2, #240	; 0xf0
 8002cfa:	4393      	bics	r3, r2
 8002cfc:	60fb      	str	r3, [r7, #12]
  
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8002cfe:	68fa      	ldr	r2, [r7, #12]
 8002d00:	687b      	ldr	r3, [r7, #4]
 8002d02:	4313      	orrs	r3, r2
 8002d04:	60fb      	str	r3, [r7, #12]
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8002d06:	4b03      	ldr	r3, [pc, #12]	; (8002d14 <RCC_HCLKConfig+0x30>)
 8002d08:	68fa      	ldr	r2, [r7, #12]
 8002d0a:	605a      	str	r2, [r3, #4]
}
 8002d0c:	46c0      	nop			; (mov r8, r8)
 8002d0e:	46bd      	mov	sp, r7
 8002d10:	b004      	add	sp, #16
 8002d12:	bd80      	pop	{r7, pc}
 8002d14:	40021000 	.word	0x40021000

08002d18 <RCC_USARTCLKConfig>:
  *             @arg RCC_USART3CLK_LSE: USART3 clock = LSE Clock, applicable only for STM32F091 devices
  *             @arg RCC_USART3CLK_HSI: USART3 clock = HSI Clock, applicable only for STM32F091 devices   
  * @retval None
  */
void RCC_USARTCLKConfig(uint32_t RCC_USARTCLK)
{ 
 8002d18:	b580      	push	{r7, lr}
 8002d1a:	b084      	sub	sp, #16
 8002d1c:	af00      	add	r7, sp, #0
 8002d1e:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 8002d20:	2300      	movs	r3, #0
 8002d22:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));

  /* Get USART index */
  tmp = (RCC_USARTCLK >> 28);
 8002d24:	687b      	ldr	r3, [r7, #4]
 8002d26:	0f1b      	lsrs	r3, r3, #28
 8002d28:	60fb      	str	r3, [r7, #12]

  /* Clear USARTSW[1:0] bit */
  if (tmp == (uint32_t)0x00000001)
 8002d2a:	68fb      	ldr	r3, [r7, #12]
 8002d2c:	2b01      	cmp	r3, #1
 8002d2e:	d106      	bne.n	8002d3e <RCC_USARTCLKConfig+0x26>
  {
    /* Clear USART1SW[1:0] bit */  
    RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
 8002d30:	4b10      	ldr	r3, [pc, #64]	; (8002d74 <RCC_USARTCLKConfig+0x5c>)
 8002d32:	4a10      	ldr	r2, [pc, #64]	; (8002d74 <RCC_USARTCLKConfig+0x5c>)
 8002d34:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8002d36:	2103      	movs	r1, #3
 8002d38:	438a      	bics	r2, r1
 8002d3a:	631a      	str	r2, [r3, #48]	; 0x30
 8002d3c:	e00f      	b.n	8002d5e <RCC_USARTCLKConfig+0x46>
  }
  else if (tmp == (uint32_t)0x00000002)
 8002d3e:	68fb      	ldr	r3, [r7, #12]
 8002d40:	2b02      	cmp	r3, #2
 8002d42:	d106      	bne.n	8002d52 <RCC_USARTCLKConfig+0x3a>
  {
    /* Clear USART2SW[1:0] bit */
    RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
 8002d44:	4b0b      	ldr	r3, [pc, #44]	; (8002d74 <RCC_USARTCLKConfig+0x5c>)
 8002d46:	4a0b      	ldr	r2, [pc, #44]	; (8002d74 <RCC_USARTCLKConfig+0x5c>)
 8002d48:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8002d4a:	490b      	ldr	r1, [pc, #44]	; (8002d78 <RCC_USARTCLKConfig+0x60>)
 8002d4c:	400a      	ands	r2, r1
 8002d4e:	631a      	str	r2, [r3, #48]	; 0x30
 8002d50:	e005      	b.n	8002d5e <RCC_USARTCLKConfig+0x46>
  }
  else 
  {
    /* Clear USART3SW[1:0] bit */
    RCC->CFGR3 &= ~RCC_CFGR3_USART3SW;
 8002d52:	4b08      	ldr	r3, [pc, #32]	; (8002d74 <RCC_USARTCLKConfig+0x5c>)
 8002d54:	4a07      	ldr	r2, [pc, #28]	; (8002d74 <RCC_USARTCLKConfig+0x5c>)
 8002d56:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8002d58:	4908      	ldr	r1, [pc, #32]	; (8002d7c <RCC_USARTCLKConfig+0x64>)
 8002d5a:	400a      	ands	r2, r1
 8002d5c:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Set USARTxSW bits according to RCC_USARTCLK value */
  RCC->CFGR3 |= RCC_USARTCLK;
 8002d5e:	4b05      	ldr	r3, [pc, #20]	; (8002d74 <RCC_USARTCLKConfig+0x5c>)
 8002d60:	4a04      	ldr	r2, [pc, #16]	; (8002d74 <RCC_USARTCLKConfig+0x5c>)
 8002d62:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8002d64:	687a      	ldr	r2, [r7, #4]
 8002d66:	430a      	orrs	r2, r1
 8002d68:	631a      	str	r2, [r3, #48]	; 0x30
}
 8002d6a:	46c0      	nop			; (mov r8, r8)
 8002d6c:	46bd      	mov	sp, r7
 8002d6e:	b004      	add	sp, #16
 8002d70:	bd80      	pop	{r7, pc}
 8002d72:	46c0      	nop			; (mov r8, r8)
 8002d74:	40021000 	.word	0x40021000
 8002d78:	fffcffff 	.word	0xfffcffff
 8002d7c:	fff3ffff 	.word	0xfff3ffff

08002d80 <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8002d80:	b580      	push	{r7, lr}
 8002d82:	b088      	sub	sp, #32
 8002d84:	af00      	add	r7, sp, #0
 8002d86:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
 8002d88:	2300      	movs	r3, #0
 8002d8a:	61bb      	str	r3, [r7, #24]
 8002d8c:	2300      	movs	r3, #0
 8002d8e:	617b      	str	r3, [r7, #20]
 8002d90:	2300      	movs	r3, #0
 8002d92:	613b      	str	r3, [r7, #16]
 8002d94:	2300      	movs	r3, #0
 8002d96:	60fb      	str	r3, [r7, #12]
 8002d98:	2300      	movs	r3, #0
 8002d9a:	60bb      	str	r3, [r7, #8]
 8002d9c:	2300      	movs	r3, #0
 8002d9e:	61fb      	str	r3, [r7, #28]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8002da0:	4ba4      	ldr	r3, [pc, #656]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002da2:	685b      	ldr	r3, [r3, #4]
 8002da4:	220c      	movs	r2, #12
 8002da6:	4013      	ands	r3, r2
 8002da8:	61bb      	str	r3, [r7, #24]
  
  switch (tmp)
 8002daa:	69bb      	ldr	r3, [r7, #24]
 8002dac:	2b04      	cmp	r3, #4
 8002dae:	d00c      	beq.n	8002dca <RCC_GetClocksFreq+0x4a>
 8002db0:	d802      	bhi.n	8002db8 <RCC_GetClocksFreq+0x38>
 8002db2:	2b00      	cmp	r3, #0
 8002db4:	d005      	beq.n	8002dc2 <RCC_GetClocksFreq+0x42>
 8002db6:	e03b      	b.n	8002e30 <RCC_GetClocksFreq+0xb0>
 8002db8:	2b08      	cmp	r3, #8
 8002dba:	d00a      	beq.n	8002dd2 <RCC_GetClocksFreq+0x52>
 8002dbc:	2b0c      	cmp	r3, #12
 8002dbe:	d033      	beq.n	8002e28 <RCC_GetClocksFreq+0xa8>
 8002dc0:	e036      	b.n	8002e30 <RCC_GetClocksFreq+0xb0>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8002dc2:	687b      	ldr	r3, [r7, #4]
 8002dc4:	4a9c      	ldr	r2, [pc, #624]	; (8003038 <RCC_GetClocksFreq+0x2b8>)
 8002dc6:	601a      	str	r2, [r3, #0]
      break;
 8002dc8:	e036      	b.n	8002e38 <RCC_GetClocksFreq+0xb8>
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8002dca:	687b      	ldr	r3, [r7, #4]
 8002dcc:	4a9a      	ldr	r2, [pc, #616]	; (8003038 <RCC_GetClocksFreq+0x2b8>)
 8002dce:	601a      	str	r2, [r3, #0]
      break;
 8002dd0:	e032      	b.n	8002e38 <RCC_GetClocksFreq+0xb8>
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 8002dd2:	4b98      	ldr	r3, [pc, #608]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002dd4:	685a      	ldr	r2, [r3, #4]
 8002dd6:	23f0      	movs	r3, #240	; 0xf0
 8002dd8:	039b      	lsls	r3, r3, #14
 8002dda:	4013      	ands	r3, r2
 8002ddc:	617b      	str	r3, [r7, #20]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 8002dde:	4b95      	ldr	r3, [pc, #596]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002de0:	685a      	ldr	r2, [r3, #4]
 8002de2:	23c0      	movs	r3, #192	; 0xc0
 8002de4:	025b      	lsls	r3, r3, #9
 8002de6:	4013      	ands	r3, r2
 8002de8:	613b      	str	r3, [r7, #16]
      pllmull = ( pllmull >> 18) + 2;
 8002dea:	697b      	ldr	r3, [r7, #20]
 8002dec:	0c9b      	lsrs	r3, r3, #18
 8002dee:	3302      	adds	r3, #2
 8002df0:	617b      	str	r3, [r7, #20]
      
      if (pllsource == 0x00)
 8002df2:	693b      	ldr	r3, [r7, #16]
 8002df4:	2b00      	cmp	r3, #0
 8002df6:	d104      	bne.n	8002e02 <RCC_GetClocksFreq+0x82>
      {
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        pllclk = (HSI_VALUE >> 1) * pllmull;
 8002df8:	697b      	ldr	r3, [r7, #20]
 8002dfa:	4a90      	ldr	r2, [pc, #576]	; (800303c <RCC_GetClocksFreq+0x2bc>)
 8002dfc:	4353      	muls	r3, r2
 8002dfe:	61fb      	str	r3, [r7, #28]
 8002e00:	e00e      	b.n	8002e20 <RCC_GetClocksFreq+0xa0>
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 8002e02:	4b8c      	ldr	r3, [pc, #560]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002e04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002e06:	220f      	movs	r2, #15
 8002e08:	4013      	ands	r3, r2
 8002e0a:	3301      	adds	r3, #1
 8002e0c:	60fb      	str	r3, [r7, #12]
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
 8002e0e:	68f9      	ldr	r1, [r7, #12]
 8002e10:	4889      	ldr	r0, [pc, #548]	; (8003038 <RCC_GetClocksFreq+0x2b8>)
 8002e12:	f7fd f983 	bl	800011c <__aeabi_uidiv>
 8002e16:	0003      	movs	r3, r0
 8002e18:	001a      	movs	r2, r3
 8002e1a:	697b      	ldr	r3, [r7, #20]
 8002e1c:	4353      	muls	r3, r2
 8002e1e:	61fb      	str	r3, [r7, #28]
      }
      RCC_Clocks->SYSCLK_Frequency = pllclk;      
 8002e20:	687b      	ldr	r3, [r7, #4]
 8002e22:	69fa      	ldr	r2, [r7, #28]
 8002e24:	601a      	str	r2, [r3, #0]
      break;
 8002e26:	e007      	b.n	8002e38 <RCC_GetClocksFreq+0xb8>
    case 0x0C:  /* HSI48 used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI48_VALUE;
 8002e28:	687b      	ldr	r3, [r7, #4]
 8002e2a:	4a85      	ldr	r2, [pc, #532]	; (8003040 <RCC_GetClocksFreq+0x2c0>)
 8002e2c:	601a      	str	r2, [r3, #0]
      break;
 8002e2e:	e003      	b.n	8002e38 <RCC_GetClocksFreq+0xb8>
    default: /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8002e30:	687b      	ldr	r3, [r7, #4]
 8002e32:	4a81      	ldr	r2, [pc, #516]	; (8003038 <RCC_GetClocksFreq+0x2b8>)
 8002e34:	601a      	str	r2, [r3, #0]
      break;
 8002e36:	46c0      	nop			; (mov r8, r8)
  }
  /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8002e38:	4b7e      	ldr	r3, [pc, #504]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002e3a:	685b      	ldr	r3, [r3, #4]
 8002e3c:	22f0      	movs	r2, #240	; 0xf0
 8002e3e:	4013      	ands	r3, r2
 8002e40:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 4;
 8002e42:	69bb      	ldr	r3, [r7, #24]
 8002e44:	091b      	lsrs	r3, r3, #4
 8002e46:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp]; 
 8002e48:	4a7e      	ldr	r2, [pc, #504]	; (8003044 <RCC_GetClocksFreq+0x2c4>)
 8002e4a:	69bb      	ldr	r3, [r7, #24]
 8002e4c:	18d3      	adds	r3, r2, r3
 8002e4e:	781b      	ldrb	r3, [r3, #0]
 8002e50:	b2db      	uxtb	r3, r3
 8002e52:	60bb      	str	r3, [r7, #8]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8002e54:	687b      	ldr	r3, [r7, #4]
 8002e56:	681a      	ldr	r2, [r3, #0]
 8002e58:	68bb      	ldr	r3, [r7, #8]
 8002e5a:	40da      	lsrs	r2, r3
 8002e5c:	687b      	ldr	r3, [r7, #4]
 8002e5e:	605a      	str	r2, [r3, #4]

  /* Get PCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE;
 8002e60:	4b74      	ldr	r3, [pc, #464]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002e62:	685a      	ldr	r2, [r3, #4]
 8002e64:	23e0      	movs	r3, #224	; 0xe0
 8002e66:	00db      	lsls	r3, r3, #3
 8002e68:	4013      	ands	r3, r2
 8002e6a:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 8;
 8002e6c:	69bb      	ldr	r3, [r7, #24]
 8002e6e:	0a1b      	lsrs	r3, r3, #8
 8002e70:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8002e72:	4a74      	ldr	r2, [pc, #464]	; (8003044 <RCC_GetClocksFreq+0x2c4>)
 8002e74:	69bb      	ldr	r3, [r7, #24]
 8002e76:	18d3      	adds	r3, r2, r3
 8002e78:	781b      	ldrb	r3, [r3, #0]
 8002e7a:	b2db      	uxtb	r3, r3
 8002e7c:	60bb      	str	r3, [r7, #8]
  /* PCLK clock frequency */
  RCC_Clocks->PCLK_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8002e7e:	687b      	ldr	r3, [r7, #4]
 8002e80:	685a      	ldr	r2, [r3, #4]
 8002e82:	68bb      	ldr	r3, [r7, #8]
 8002e84:	40da      	lsrs	r2, r3
 8002e86:	687b      	ldr	r3, [r7, #4]
 8002e88:	609a      	str	r2, [r3, #8]

  /* ADCCLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_ADCSW) != RCC_CFGR3_ADCSW)
 8002e8a:	4b6a      	ldr	r3, [pc, #424]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002e8c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002e8e:	2380      	movs	r3, #128	; 0x80
 8002e90:	005b      	lsls	r3, r3, #1
 8002e92:	4013      	ands	r3, r2
 8002e94:	d103      	bne.n	8002e9e <RCC_GetClocksFreq+0x11e>
  {
    /* ADC Clock is HSI14 Osc. */
    RCC_Clocks->ADCCLK_Frequency = HSI14_VALUE;
 8002e96:	687b      	ldr	r3, [r7, #4]
 8002e98:	4a6b      	ldr	r2, [pc, #428]	; (8003048 <RCC_GetClocksFreq+0x2c8>)
 8002e9a:	60da      	str	r2, [r3, #12]
 8002e9c:	e010      	b.n	8002ec0 <RCC_GetClocksFreq+0x140>
  }
  else
  {
    if((RCC->CFGR & RCC_CFGR_ADCPRE) != RCC_CFGR_ADCPRE)
 8002e9e:	4b65      	ldr	r3, [pc, #404]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002ea0:	685a      	ldr	r2, [r3, #4]
 8002ea2:	2380      	movs	r3, #128	; 0x80
 8002ea4:	01db      	lsls	r3, r3, #7
 8002ea6:	4013      	ands	r3, r2
 8002ea8:	d105      	bne.n	8002eb6 <RCC_GetClocksFreq+0x136>
    {
      /* ADC Clock is derived from PCLK/2 */
      RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK_Frequency >> 1;
 8002eaa:	687b      	ldr	r3, [r7, #4]
 8002eac:	689b      	ldr	r3, [r3, #8]
 8002eae:	085a      	lsrs	r2, r3, #1
 8002eb0:	687b      	ldr	r3, [r7, #4]
 8002eb2:	60da      	str	r2, [r3, #12]
 8002eb4:	e004      	b.n	8002ec0 <RCC_GetClocksFreq+0x140>
    }
    else
    {
      /* ADC Clock is derived from PCLK/4 */
      RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK_Frequency >> 2;
 8002eb6:	687b      	ldr	r3, [r7, #4]
 8002eb8:	689b      	ldr	r3, [r3, #8]
 8002eba:	089a      	lsrs	r2, r3, #2
 8002ebc:	687b      	ldr	r3, [r7, #4]
 8002ebe:	60da      	str	r2, [r3, #12]
    }
    
  }

  /* CECCLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_CECSW) != RCC_CFGR3_CECSW)
 8002ec0:	4b5c      	ldr	r3, [pc, #368]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002ec2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002ec4:	2240      	movs	r2, #64	; 0x40
 8002ec6:	4013      	ands	r3, r2
 8002ec8:	d103      	bne.n	8002ed2 <RCC_GetClocksFreq+0x152>
  {
    /* CEC Clock is HSI/244 */
    RCC_Clocks->CECCLK_Frequency = HSI_VALUE / 244;
 8002eca:	687b      	ldr	r3, [r7, #4]
 8002ecc:	4a5f      	ldr	r2, [pc, #380]	; (800304c <RCC_GetClocksFreq+0x2cc>)
 8002ece:	611a      	str	r2, [r3, #16]
 8002ed0:	e003      	b.n	8002eda <RCC_GetClocksFreq+0x15a>
  }
  else
  {
    /* CECC Clock is LSE Osc. */
    RCC_Clocks->CECCLK_Frequency = LSE_VALUE;
 8002ed2:	687b      	ldr	r3, [r7, #4]
 8002ed4:	2280      	movs	r2, #128	; 0x80
 8002ed6:	0212      	lsls	r2, r2, #8
 8002ed8:	611a      	str	r2, [r3, #16]
  }

  /* I2C1CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
 8002eda:	4b56      	ldr	r3, [pc, #344]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002edc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002ede:	2210      	movs	r2, #16
 8002ee0:	4013      	ands	r3, r2
 8002ee2:	d103      	bne.n	8002eec <RCC_GetClocksFreq+0x16c>
  {
    /* I2C1 Clock is HSI Osc. */
    RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
 8002ee4:	687b      	ldr	r3, [r7, #4]
 8002ee6:	4a54      	ldr	r2, [pc, #336]	; (8003038 <RCC_GetClocksFreq+0x2b8>)
 8002ee8:	615a      	str	r2, [r3, #20]
 8002eea:	e003      	b.n	8002ef4 <RCC_GetClocksFreq+0x174>
  }
  else
  {
    /* I2C1 Clock is System Clock */
    RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8002eec:	687b      	ldr	r3, [r7, #4]
 8002eee:	681a      	ldr	r2, [r3, #0]
 8002ef0:	687b      	ldr	r3, [r7, #4]
 8002ef2:	615a      	str	r2, [r3, #20]
  }

  /* USART1CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
 8002ef4:	4b4f      	ldr	r3, [pc, #316]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002ef6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002ef8:	2203      	movs	r2, #3
 8002efa:	4013      	ands	r3, r2
 8002efc:	d104      	bne.n	8002f08 <RCC_GetClocksFreq+0x188>
  {
    /* USART1 Clock is PCLK */
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK_Frequency;
 8002efe:	687b      	ldr	r3, [r7, #4]
 8002f00:	689a      	ldr	r2, [r3, #8]
 8002f02:	687b      	ldr	r3, [r7, #4]
 8002f04:	619a      	str	r2, [r3, #24]
 8002f06:	e01e      	b.n	8002f46 <RCC_GetClocksFreq+0x1c6>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
 8002f08:	4b4a      	ldr	r3, [pc, #296]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002f0a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002f0c:	2203      	movs	r2, #3
 8002f0e:	4013      	ands	r3, r2
 8002f10:	2b01      	cmp	r3, #1
 8002f12:	d104      	bne.n	8002f1e <RCC_GetClocksFreq+0x19e>
  {
    /* USART1 Clock is System Clock */
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8002f14:	687b      	ldr	r3, [r7, #4]
 8002f16:	681a      	ldr	r2, [r3, #0]
 8002f18:	687b      	ldr	r3, [r7, #4]
 8002f1a:	619a      	str	r2, [r3, #24]
 8002f1c:	e013      	b.n	8002f46 <RCC_GetClocksFreq+0x1c6>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
 8002f1e:	4b45      	ldr	r3, [pc, #276]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002f20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002f22:	2203      	movs	r2, #3
 8002f24:	4013      	ands	r3, r2
 8002f26:	2b02      	cmp	r3, #2
 8002f28:	d104      	bne.n	8002f34 <RCC_GetClocksFreq+0x1b4>
  {
    /* USART1 Clock is LSE Osc. */
    RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
 8002f2a:	687b      	ldr	r3, [r7, #4]
 8002f2c:	2280      	movs	r2, #128	; 0x80
 8002f2e:	0212      	lsls	r2, r2, #8
 8002f30:	619a      	str	r2, [r3, #24]
 8002f32:	e008      	b.n	8002f46 <RCC_GetClocksFreq+0x1c6>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
 8002f34:	4b3f      	ldr	r3, [pc, #252]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002f36:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002f38:	2203      	movs	r2, #3
 8002f3a:	4013      	ands	r3, r2
 8002f3c:	2b03      	cmp	r3, #3
 8002f3e:	d102      	bne.n	8002f46 <RCC_GetClocksFreq+0x1c6>
  {
    /* USART1 Clock is HSI Osc. */
    RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
 8002f40:	687b      	ldr	r3, [r7, #4]
 8002f42:	4a3d      	ldr	r2, [pc, #244]	; (8003038 <RCC_GetClocksFreq+0x2b8>)
 8002f44:	619a      	str	r2, [r3, #24]
  }
  
  /* USART2CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == 0x0)
 8002f46:	4b3b      	ldr	r3, [pc, #236]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002f48:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002f4a:	23c0      	movs	r3, #192	; 0xc0
 8002f4c:	029b      	lsls	r3, r3, #10
 8002f4e:	4013      	ands	r3, r2
 8002f50:	d104      	bne.n	8002f5c <RCC_GetClocksFreq+0x1dc>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK_Frequency;
 8002f52:	687b      	ldr	r3, [r7, #4]
 8002f54:	689a      	ldr	r2, [r3, #8]
 8002f56:	687b      	ldr	r3, [r7, #4]
 8002f58:	61da      	str	r2, [r3, #28]
 8002f5a:	e027      	b.n	8002fac <RCC_GetClocksFreq+0x22c>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_0)
 8002f5c:	4b35      	ldr	r3, [pc, #212]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002f5e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002f60:	23c0      	movs	r3, #192	; 0xc0
 8002f62:	029b      	lsls	r3, r3, #10
 8002f64:	401a      	ands	r2, r3
 8002f66:	2380      	movs	r3, #128	; 0x80
 8002f68:	025b      	lsls	r3, r3, #9
 8002f6a:	429a      	cmp	r2, r3
 8002f6c:	d104      	bne.n	8002f78 <RCC_GetClocksFreq+0x1f8>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8002f6e:	687b      	ldr	r3, [r7, #4]
 8002f70:	681a      	ldr	r2, [r3, #0]
 8002f72:	687b      	ldr	r3, [r7, #4]
 8002f74:	61da      	str	r2, [r3, #28]
 8002f76:	e019      	b.n	8002fac <RCC_GetClocksFreq+0x22c>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_1)
 8002f78:	4b2e      	ldr	r3, [pc, #184]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002f7a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002f7c:	23c0      	movs	r3, #192	; 0xc0
 8002f7e:	029b      	lsls	r3, r3, #10
 8002f80:	401a      	ands	r2, r3
 8002f82:	2380      	movs	r3, #128	; 0x80
 8002f84:	029b      	lsls	r3, r3, #10
 8002f86:	429a      	cmp	r2, r3
 8002f88:	d104      	bne.n	8002f94 <RCC_GetClocksFreq+0x214>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART2CLK_Frequency = LSE_VALUE;
 8002f8a:	687b      	ldr	r3, [r7, #4]
 8002f8c:	2280      	movs	r2, #128	; 0x80
 8002f8e:	0212      	lsls	r2, r2, #8
 8002f90:	61da      	str	r2, [r3, #28]
 8002f92:	e00b      	b.n	8002fac <RCC_GetClocksFreq+0x22c>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW)
 8002f94:	4b27      	ldr	r3, [pc, #156]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002f96:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002f98:	23c0      	movs	r3, #192	; 0xc0
 8002f9a:	029b      	lsls	r3, r3, #10
 8002f9c:	401a      	ands	r2, r3
 8002f9e:	23c0      	movs	r3, #192	; 0xc0
 8002fa0:	029b      	lsls	r3, r3, #10
 8002fa2:	429a      	cmp	r2, r3
 8002fa4:	d102      	bne.n	8002fac <RCC_GetClocksFreq+0x22c>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART2CLK_Frequency = HSI_VALUE;
 8002fa6:	687b      	ldr	r3, [r7, #4]
 8002fa8:	4a23      	ldr	r2, [pc, #140]	; (8003038 <RCC_GetClocksFreq+0x2b8>)
 8002faa:	61da      	str	r2, [r3, #28]
  }
  
  /* USART3CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == 0x0)
 8002fac:	4b21      	ldr	r3, [pc, #132]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002fae:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002fb0:	23c0      	movs	r3, #192	; 0xc0
 8002fb2:	031b      	lsls	r3, r3, #12
 8002fb4:	4013      	ands	r3, r2
 8002fb6:	d104      	bne.n	8002fc2 <RCC_GetClocksFreq+0x242>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->PCLK_Frequency;
 8002fb8:	687b      	ldr	r3, [r7, #4]
 8002fba:	689a      	ldr	r2, [r3, #8]
 8002fbc:	687b      	ldr	r3, [r7, #4]
 8002fbe:	621a      	str	r2, [r3, #32]
 8002fc0:	e027      	b.n	8003012 <RCC_GetClocksFreq+0x292>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_0)
 8002fc2:	4b1c      	ldr	r3, [pc, #112]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002fc4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002fc6:	23c0      	movs	r3, #192	; 0xc0
 8002fc8:	031b      	lsls	r3, r3, #12
 8002fca:	401a      	ands	r2, r3
 8002fcc:	2380      	movs	r3, #128	; 0x80
 8002fce:	02db      	lsls	r3, r3, #11
 8002fd0:	429a      	cmp	r2, r3
 8002fd2:	d104      	bne.n	8002fde <RCC_GetClocksFreq+0x25e>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8002fd4:	687b      	ldr	r3, [r7, #4]
 8002fd6:	681a      	ldr	r2, [r3, #0]
 8002fd8:	687b      	ldr	r3, [r7, #4]
 8002fda:	621a      	str	r2, [r3, #32]
 8002fdc:	e019      	b.n	8003012 <RCC_GetClocksFreq+0x292>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_1)
 8002fde:	4b15      	ldr	r3, [pc, #84]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002fe0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002fe2:	23c0      	movs	r3, #192	; 0xc0
 8002fe4:	031b      	lsls	r3, r3, #12
 8002fe6:	401a      	ands	r2, r3
 8002fe8:	2380      	movs	r3, #128	; 0x80
 8002fea:	031b      	lsls	r3, r3, #12
 8002fec:	429a      	cmp	r2, r3
 8002fee:	d104      	bne.n	8002ffa <RCC_GetClocksFreq+0x27a>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART3CLK_Frequency = LSE_VALUE;
 8002ff0:	687b      	ldr	r3, [r7, #4]
 8002ff2:	2280      	movs	r2, #128	; 0x80
 8002ff4:	0212      	lsls	r2, r2, #8
 8002ff6:	621a      	str	r2, [r3, #32]
 8002ff8:	e00b      	b.n	8003012 <RCC_GetClocksFreq+0x292>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW)
 8002ffa:	4b0e      	ldr	r3, [pc, #56]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8002ffc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002ffe:	23c0      	movs	r3, #192	; 0xc0
 8003000:	031b      	lsls	r3, r3, #12
 8003002:	401a      	ands	r2, r3
 8003004:	23c0      	movs	r3, #192	; 0xc0
 8003006:	031b      	lsls	r3, r3, #12
 8003008:	429a      	cmp	r2, r3
 800300a:	d102      	bne.n	8003012 <RCC_GetClocksFreq+0x292>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART3CLK_Frequency = HSI_VALUE;
 800300c:	687b      	ldr	r3, [r7, #4]
 800300e:	4a0a      	ldr	r2, [pc, #40]	; (8003038 <RCC_GetClocksFreq+0x2b8>)
 8003010:	621a      	str	r2, [r3, #32]
  }
  
  /* USBCLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USBSW) != RCC_CFGR3_USBSW)
 8003012:	4b08      	ldr	r3, [pc, #32]	; (8003034 <RCC_GetClocksFreq+0x2b4>)
 8003014:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003016:	2280      	movs	r2, #128	; 0x80
 8003018:	4013      	ands	r3, r2
 800301a:	d103      	bne.n	8003024 <RCC_GetClocksFreq+0x2a4>
  {
    /* USB Clock is HSI48 */
    RCC_Clocks->USBCLK_Frequency = HSI48_VALUE;
 800301c:	687b      	ldr	r3, [r7, #4]
 800301e:	4a08      	ldr	r2, [pc, #32]	; (8003040 <RCC_GetClocksFreq+0x2c0>)
 8003020:	625a      	str	r2, [r3, #36]	; 0x24
  else
  {
    /* USB Clock is PLL clock */
    RCC_Clocks->USBCLK_Frequency = pllclk;
  }   
}
 8003022:	e002      	b.n	800302a <RCC_GetClocksFreq+0x2aa>
    RCC_Clocks->USBCLK_Frequency = HSI48_VALUE;
  }
  else
  {
    /* USB Clock is PLL clock */
    RCC_Clocks->USBCLK_Frequency = pllclk;
 8003024:	687b      	ldr	r3, [r7, #4]
 8003026:	69fa      	ldr	r2, [r7, #28]
 8003028:	625a      	str	r2, [r3, #36]	; 0x24
  }   
}
 800302a:	46c0      	nop			; (mov r8, r8)
 800302c:	46bd      	mov	sp, r7
 800302e:	b008      	add	sp, #32
 8003030:	bd80      	pop	{r7, pc}
 8003032:	46c0      	nop			; (mov r8, r8)
 8003034:	40021000 	.word	0x40021000
 8003038:	007a1200 	.word	0x007a1200
 800303c:	003d0900 	.word	0x003d0900
 8003040:	02dc6c00 	.word	0x02dc6c00
 8003044:	20000000 	.word	0x20000000
 8003048:	00d59f80 	.word	0x00d59f80
 800304c:	00008012 	.word	0x00008012

08003050 <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 8003050:	b580      	push	{r7, lr}
 8003052:	b082      	sub	sp, #8
 8003054:	af00      	add	r7, sp, #0
 8003056:	6078      	str	r0, [r7, #4]
 8003058:	000a      	movs	r2, r1
 800305a:	1cfb      	adds	r3, r7, #3
 800305c:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800305e:	1cfb      	adds	r3, r7, #3
 8003060:	781b      	ldrb	r3, [r3, #0]
 8003062:	2b00      	cmp	r3, #0
 8003064:	d006      	beq.n	8003074 <RCC_AHBPeriphClockCmd+0x24>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 8003066:	4b09      	ldr	r3, [pc, #36]	; (800308c <RCC_AHBPeriphClockCmd+0x3c>)
 8003068:	4a08      	ldr	r2, [pc, #32]	; (800308c <RCC_AHBPeriphClockCmd+0x3c>)
 800306a:	6951      	ldr	r1, [r2, #20]
 800306c:	687a      	ldr	r2, [r7, #4]
 800306e:	430a      	orrs	r2, r1
 8003070:	615a      	str	r2, [r3, #20]
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
  }
}
 8003072:	e006      	b.n	8003082 <RCC_AHBPeriphClockCmd+0x32>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 8003074:	4b05      	ldr	r3, [pc, #20]	; (800308c <RCC_AHBPeriphClockCmd+0x3c>)
 8003076:	4a05      	ldr	r2, [pc, #20]	; (800308c <RCC_AHBPeriphClockCmd+0x3c>)
 8003078:	6952      	ldr	r2, [r2, #20]
 800307a:	6879      	ldr	r1, [r7, #4]
 800307c:	43c9      	mvns	r1, r1
 800307e:	400a      	ands	r2, r1
 8003080:	615a      	str	r2, [r3, #20]
  }
}
 8003082:	46c0      	nop			; (mov r8, r8)
 8003084:	46bd      	mov	sp, r7
 8003086:	b002      	add	sp, #8
 8003088:	bd80      	pop	{r7, pc}
 800308a:	46c0      	nop			; (mov r8, r8)
 800308c:	40021000 	.word	0x40021000

08003090 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8003090:	b580      	push	{r7, lr}
 8003092:	b082      	sub	sp, #8
 8003094:	af00      	add	r7, sp, #0
 8003096:	6078      	str	r0, [r7, #4]
 8003098:	000a      	movs	r2, r1
 800309a:	1cfb      	adds	r3, r7, #3
 800309c:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800309e:	1cfb      	adds	r3, r7, #3
 80030a0:	781b      	ldrb	r3, [r3, #0]
 80030a2:	2b00      	cmp	r3, #0
 80030a4:	d006      	beq.n	80030b4 <RCC_APB2PeriphClockCmd+0x24>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80030a6:	4b09      	ldr	r3, [pc, #36]	; (80030cc <RCC_APB2PeriphClockCmd+0x3c>)
 80030a8:	4a08      	ldr	r2, [pc, #32]	; (80030cc <RCC_APB2PeriphClockCmd+0x3c>)
 80030aa:	6991      	ldr	r1, [r2, #24]
 80030ac:	687a      	ldr	r2, [r7, #4]
 80030ae:	430a      	orrs	r2, r1
 80030b0:	619a      	str	r2, [r3, #24]
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
  }
}
 80030b2:	e006      	b.n	80030c2 <RCC_APB2PeriphClockCmd+0x32>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 80030b4:	4b05      	ldr	r3, [pc, #20]	; (80030cc <RCC_APB2PeriphClockCmd+0x3c>)
 80030b6:	4a05      	ldr	r2, [pc, #20]	; (80030cc <RCC_APB2PeriphClockCmd+0x3c>)
 80030b8:	6992      	ldr	r2, [r2, #24]
 80030ba:	6879      	ldr	r1, [r7, #4]
 80030bc:	43c9      	mvns	r1, r1
 80030be:	400a      	ands	r2, r1
 80030c0:	619a      	str	r2, [r3, #24]
  }
}
 80030c2:	46c0      	nop			; (mov r8, r8)
 80030c4:	46bd      	mov	sp, r7
 80030c6:	b002      	add	sp, #8
 80030c8:	bd80      	pop	{r7, pc}
 80030ca:	46c0      	nop			; (mov r8, r8)
 80030cc:	40021000 	.word	0x40021000

080030d0 <SYSCFG_EXTILineConfig>:
  *         For STM32F072: (0..15) for GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, (0..10) for GPIOF.
  *         For STM32F031: (0..15) for GPIOA, GPIOB, (13..15) for GPIOC and (0..1, 6..7) for GPIOF.
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 80030d0:	b5b0      	push	{r4, r5, r7, lr}
 80030d2:	b084      	sub	sp, #16
 80030d4:	af00      	add	r7, sp, #0
 80030d6:	0002      	movs	r2, r0
 80030d8:	1dfb      	adds	r3, r7, #7
 80030da:	701a      	strb	r2, [r3, #0]
 80030dc:	1dbb      	adds	r3, r7, #6
 80030de:	1c0a      	adds	r2, r1, #0
 80030e0:	701a      	strb	r2, [r3, #0]
  uint32_t tmp = 0x00;
 80030e2:	2300      	movs	r3, #0
 80030e4:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 80030e6:	1dbb      	adds	r3, r7, #6
 80030e8:	781b      	ldrb	r3, [r3, #0]
 80030ea:	2203      	movs	r2, #3
 80030ec:	4013      	ands	r3, r2
 80030ee:	009b      	lsls	r3, r3, #2
 80030f0:	220f      	movs	r2, #15
 80030f2:	409a      	lsls	r2, r3
 80030f4:	0013      	movs	r3, r2
 80030f6:	60fb      	str	r3, [r7, #12]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 80030f8:	4919      	ldr	r1, [pc, #100]	; (8003160 <SYSCFG_EXTILineConfig+0x90>)
 80030fa:	1dbb      	adds	r3, r7, #6
 80030fc:	781b      	ldrb	r3, [r3, #0]
 80030fe:	089b      	lsrs	r3, r3, #2
 8003100:	b2db      	uxtb	r3, r3
 8003102:	0018      	movs	r0, r3
 8003104:	4a16      	ldr	r2, [pc, #88]	; (8003160 <SYSCFG_EXTILineConfig+0x90>)
 8003106:	1dbb      	adds	r3, r7, #6
 8003108:	781b      	ldrb	r3, [r3, #0]
 800310a:	089b      	lsrs	r3, r3, #2
 800310c:	b2db      	uxtb	r3, r3
 800310e:	3302      	adds	r3, #2
 8003110:	009b      	lsls	r3, r3, #2
 8003112:	589b      	ldr	r3, [r3, r2]
 8003114:	68fa      	ldr	r2, [r7, #12]
 8003116:	43d2      	mvns	r2, r2
 8003118:	401a      	ands	r2, r3
 800311a:	1c83      	adds	r3, r0, #2
 800311c:	009b      	lsls	r3, r3, #2
 800311e:	505a      	str	r2, [r3, r1]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 8003120:	480f      	ldr	r0, [pc, #60]	; (8003160 <SYSCFG_EXTILineConfig+0x90>)
 8003122:	1dbb      	adds	r3, r7, #6
 8003124:	781b      	ldrb	r3, [r3, #0]
 8003126:	089b      	lsrs	r3, r3, #2
 8003128:	b2db      	uxtb	r3, r3
 800312a:	001d      	movs	r5, r3
 800312c:	4a0c      	ldr	r2, [pc, #48]	; (8003160 <SYSCFG_EXTILineConfig+0x90>)
 800312e:	1dbb      	adds	r3, r7, #6
 8003130:	781b      	ldrb	r3, [r3, #0]
 8003132:	089b      	lsrs	r3, r3, #2
 8003134:	b2db      	uxtb	r3, r3
 8003136:	3302      	adds	r3, #2
 8003138:	009b      	lsls	r3, r3, #2
 800313a:	589a      	ldr	r2, [r3, r2]
 800313c:	1dfb      	adds	r3, r7, #7
 800313e:	7819      	ldrb	r1, [r3, #0]
 8003140:	1dbb      	adds	r3, r7, #6
 8003142:	781b      	ldrb	r3, [r3, #0]
 8003144:	2403      	movs	r4, #3
 8003146:	4023      	ands	r3, r4
 8003148:	009b      	lsls	r3, r3, #2
 800314a:	4099      	lsls	r1, r3
 800314c:	000b      	movs	r3, r1
 800314e:	431a      	orrs	r2, r3
 8003150:	1cab      	adds	r3, r5, #2
 8003152:	009b      	lsls	r3, r3, #2
 8003154:	501a      	str	r2, [r3, r0]
}
 8003156:	46c0      	nop			; (mov r8, r8)
 8003158:	46bd      	mov	sp, r7
 800315a:	b004      	add	sp, #16
 800315c:	bdb0      	pop	{r4, r5, r7, pc}
 800315e:	46c0      	nop			; (mov r8, r8)
 8003160:	40010000 	.word	0x40010000

08003164 <TIM_TimeBaseInit>:
  *         structure that contains the configuration information for
  *         the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 8003164:	b580      	push	{r7, lr}
 8003166:	b084      	sub	sp, #16
 8003168:	af00      	add	r7, sp, #0
 800316a:	6078      	str	r0, [r7, #4]
 800316c:	6039      	str	r1, [r7, #0]
  uint16_t tmpcr1 = 0;
 800316e:	230e      	movs	r3, #14
 8003170:	18fb      	adds	r3, r7, r3
 8003172:	2200      	movs	r2, #0
 8003174:	801a      	strh	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8003176:	230e      	movs	r3, #14
 8003178:	18fb      	adds	r3, r7, r3
 800317a:	687a      	ldr	r2, [r7, #4]
 800317c:	8812      	ldrh	r2, [r2, #0]
 800317e:	801a      	strh	r2, [r3, #0]

  if((TIMx == TIM1) || (TIMx == TIM2) || (TIMx == TIM3))
 8003180:	687b      	ldr	r3, [r7, #4]
 8003182:	4a2d      	ldr	r2, [pc, #180]	; (8003238 <TIM_TimeBaseInit+0xd4>)
 8003184:	4293      	cmp	r3, r2
 8003186:	d008      	beq.n	800319a <TIM_TimeBaseInit+0x36>
 8003188:	687a      	ldr	r2, [r7, #4]
 800318a:	2380      	movs	r3, #128	; 0x80
 800318c:	05db      	lsls	r3, r3, #23
 800318e:	429a      	cmp	r2, r3
 8003190:	d003      	beq.n	800319a <TIM_TimeBaseInit+0x36>
 8003192:	687b      	ldr	r3, [r7, #4]
 8003194:	4a29      	ldr	r2, [pc, #164]	; (800323c <TIM_TimeBaseInit+0xd8>)
 8003196:	4293      	cmp	r3, r2
 8003198:	d110      	bne.n	80031bc <TIM_TimeBaseInit+0x58>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
 800319a:	230e      	movs	r3, #14
 800319c:	18fb      	adds	r3, r7, r3
 800319e:	220e      	movs	r2, #14
 80031a0:	18ba      	adds	r2, r7, r2
 80031a2:	8812      	ldrh	r2, [r2, #0]
 80031a4:	2170      	movs	r1, #112	; 0x70
 80031a6:	438a      	bics	r2, r1
 80031a8:	801a      	strh	r2, [r3, #0]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 80031aa:	683b      	ldr	r3, [r7, #0]
 80031ac:	8859      	ldrh	r1, [r3, #2]
 80031ae:	230e      	movs	r3, #14
 80031b0:	18fb      	adds	r3, r7, r3
 80031b2:	220e      	movs	r2, #14
 80031b4:	18ba      	adds	r2, r7, r2
 80031b6:	8812      	ldrh	r2, [r2, #0]
 80031b8:	430a      	orrs	r2, r1
 80031ba:	801a      	strh	r2, [r3, #0]
  }
 
  if(TIMx != TIM6)
 80031bc:	687b      	ldr	r3, [r7, #4]
 80031be:	4a20      	ldr	r2, [pc, #128]	; (8003240 <TIM_TimeBaseInit+0xdc>)
 80031c0:	4293      	cmp	r3, r2
 80031c2:	d010      	beq.n	80031e6 <TIM_TimeBaseInit+0x82>
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 80031c4:	230e      	movs	r3, #14
 80031c6:	18fb      	adds	r3, r7, r3
 80031c8:	220e      	movs	r2, #14
 80031ca:	18ba      	adds	r2, r7, r2
 80031cc:	8812      	ldrh	r2, [r2, #0]
 80031ce:	491d      	ldr	r1, [pc, #116]	; (8003244 <TIM_TimeBaseInit+0xe0>)
 80031d0:	400a      	ands	r2, r1
 80031d2:	801a      	strh	r2, [r3, #0]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 80031d4:	683b      	ldr	r3, [r7, #0]
 80031d6:	8919      	ldrh	r1, [r3, #8]
 80031d8:	230e      	movs	r3, #14
 80031da:	18fb      	adds	r3, r7, r3
 80031dc:	220e      	movs	r2, #14
 80031de:	18ba      	adds	r2, r7, r2
 80031e0:	8812      	ldrh	r2, [r2, #0]
 80031e2:	430a      	orrs	r2, r1
 80031e4:	801a      	strh	r2, [r3, #0]
  }

  TIMx->CR1 = tmpcr1;
 80031e6:	687b      	ldr	r3, [r7, #4]
 80031e8:	220e      	movs	r2, #14
 80031ea:	18ba      	adds	r2, r7, r2
 80031ec:	8812      	ldrh	r2, [r2, #0]
 80031ee:	801a      	strh	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 80031f0:	683b      	ldr	r3, [r7, #0]
 80031f2:	685a      	ldr	r2, [r3, #4]
 80031f4:	687b      	ldr	r3, [r7, #4]
 80031f6:	62da      	str	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 80031f8:	683b      	ldr	r3, [r7, #0]
 80031fa:	881a      	ldrh	r2, [r3, #0]
 80031fc:	687b      	ldr	r3, [r7, #4]
 80031fe:	851a      	strh	r2, [r3, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
 8003200:	687b      	ldr	r3, [r7, #4]
 8003202:	4a0d      	ldr	r2, [pc, #52]	; (8003238 <TIM_TimeBaseInit+0xd4>)
 8003204:	4293      	cmp	r3, r2
 8003206:	d00b      	beq.n	8003220 <TIM_TimeBaseInit+0xbc>
 8003208:	687b      	ldr	r3, [r7, #4]
 800320a:	4a0f      	ldr	r2, [pc, #60]	; (8003248 <TIM_TimeBaseInit+0xe4>)
 800320c:	4293      	cmp	r3, r2
 800320e:	d007      	beq.n	8003220 <TIM_TimeBaseInit+0xbc>
 8003210:	687b      	ldr	r3, [r7, #4]
 8003212:	4a0e      	ldr	r2, [pc, #56]	; (800324c <TIM_TimeBaseInit+0xe8>)
 8003214:	4293      	cmp	r3, r2
 8003216:	d003      	beq.n	8003220 <TIM_TimeBaseInit+0xbc>
 8003218:	687b      	ldr	r3, [r7, #4]
 800321a:	4a0d      	ldr	r2, [pc, #52]	; (8003250 <TIM_TimeBaseInit+0xec>)
 800321c:	4293      	cmp	r3, r2
 800321e:	d104      	bne.n	800322a <TIM_TimeBaseInit+0xc6>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8003220:	683b      	ldr	r3, [r7, #0]
 8003222:	7a9b      	ldrb	r3, [r3, #10]
 8003224:	b29a      	uxth	r2, r3
 8003226:	687b      	ldr	r3, [r7, #4]
 8003228:	861a      	strh	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler and the Repetition counter
     values immediately */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;           
 800322a:	687b      	ldr	r3, [r7, #4]
 800322c:	2201      	movs	r2, #1
 800322e:	829a      	strh	r2, [r3, #20]
}
 8003230:	46c0      	nop			; (mov r8, r8)
 8003232:	46bd      	mov	sp, r7
 8003234:	b004      	add	sp, #16
 8003236:	bd80      	pop	{r7, pc}
 8003238:	40012c00 	.word	0x40012c00
 800323c:	40000400 	.word	0x40000400
 8003240:	40001000 	.word	0x40001000
 8003244:	fffffcff 	.word	0xfffffcff
 8003248:	40014000 	.word	0x40014000
 800324c:	40014400 	.word	0x40014400
 8003250:	40014800 	.word	0x40014800

08003254 <TIM_TimeBaseStructInit>:
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
  *         which will be initialized.
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 8003254:	b580      	push	{r7, lr}
 8003256:	b082      	sub	sp, #8
 8003258:	af00      	add	r7, sp, #0
 800325a:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
 800325c:	687b      	ldr	r3, [r7, #4]
 800325e:	2201      	movs	r2, #1
 8003260:	4252      	negs	r2, r2
 8003262:	605a      	str	r2, [r3, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 8003264:	687b      	ldr	r3, [r7, #4]
 8003266:	2200      	movs	r2, #0
 8003268:	801a      	strh	r2, [r3, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 800326a:	687b      	ldr	r3, [r7, #4]
 800326c:	2200      	movs	r2, #0
 800326e:	811a      	strh	r2, [r3, #8]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 8003270:	687b      	ldr	r3, [r7, #4]
 8003272:	2200      	movs	r2, #0
 8003274:	805a      	strh	r2, [r3, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 8003276:	687b      	ldr	r3, [r7, #4]
 8003278:	2200      	movs	r2, #0
 800327a:	729a      	strb	r2, [r3, #10]
}
 800327c:	46c0      	nop			; (mov r8, r8)
 800327e:	46bd      	mov	sp, r7
 8003280:	b002      	add	sp, #8
 8003282:	bd80      	pop	{r7, pc}

08003284 <TIM_Cmd>:
  * @param  NewState: new state of the TIMx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 8003284:	b580      	push	{r7, lr}
 8003286:	b082      	sub	sp, #8
 8003288:	af00      	add	r7, sp, #0
 800328a:	6078      	str	r0, [r7, #4]
 800328c:	000a      	movs	r2, r1
 800328e:	1cfb      	adds	r3, r7, #3
 8003290:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003292:	1cfb      	adds	r3, r7, #3
 8003294:	781b      	ldrb	r3, [r3, #0]
 8003296:	2b00      	cmp	r3, #0
 8003298:	d008      	beq.n	80032ac <TIM_Cmd+0x28>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 800329a:	687b      	ldr	r3, [r7, #4]
 800329c:	881b      	ldrh	r3, [r3, #0]
 800329e:	b29b      	uxth	r3, r3
 80032a0:	2201      	movs	r2, #1
 80032a2:	4313      	orrs	r3, r2
 80032a4:	b29a      	uxth	r2, r3
 80032a6:	687b      	ldr	r3, [r7, #4]
 80032a8:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
  }
}
 80032aa:	e007      	b.n	80032bc <TIM_Cmd+0x38>
    TIMx->CR1 |= TIM_CR1_CEN;
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
 80032ac:	687b      	ldr	r3, [r7, #4]
 80032ae:	881b      	ldrh	r3, [r3, #0]
 80032b0:	b29b      	uxth	r3, r3
 80032b2:	2201      	movs	r2, #1
 80032b4:	4393      	bics	r3, r2
 80032b6:	b29a      	uxth	r2, r3
 80032b8:	687b      	ldr	r3, [r7, #4]
 80032ba:	801a      	strh	r2, [r3, #0]
  }
}
 80032bc:	46c0      	nop			; (mov r8, r8)
 80032be:	46bd      	mov	sp, r7
 80032c0:	b002      	add	sp, #8
 80032c2:	bd80      	pop	{r7, pc}

080032c4 <TIM_CtrlPWMOutputs>:
  * @param  NewState: new state of the TIM peripheral Main Outputs.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 80032c4:	b580      	push	{r7, lr}
 80032c6:	b082      	sub	sp, #8
 80032c8:	af00      	add	r7, sp, #0
 80032ca:	6078      	str	r0, [r7, #4]
 80032cc:	000a      	movs	r2, r1
 80032ce:	1cfb      	adds	r3, r7, #3
 80032d0:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80032d2:	1cfb      	adds	r3, r7, #3
 80032d4:	781b      	ldrb	r3, [r3, #0]
 80032d6:	2b00      	cmp	r3, #0
 80032d8:	d00a      	beq.n	80032f0 <TIM_CtrlPWMOutputs+0x2c>
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 80032da:	687b      	ldr	r3, [r7, #4]
 80032dc:	2244      	movs	r2, #68	; 0x44
 80032de:	5a9b      	ldrh	r3, [r3, r2]
 80032e0:	b29b      	uxth	r3, r3
 80032e2:	4a0a      	ldr	r2, [pc, #40]	; (800330c <TIM_CtrlPWMOutputs+0x48>)
 80032e4:	4313      	orrs	r3, r2
 80032e6:	b299      	uxth	r1, r3
 80032e8:	687b      	ldr	r3, [r7, #4]
 80032ea:	2244      	movs	r2, #68	; 0x44
 80032ec:	5299      	strh	r1, [r3, r2]
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
  }  
}
 80032ee:	e009      	b.n	8003304 <TIM_CtrlPWMOutputs+0x40>
    TIMx->BDTR |= TIM_BDTR_MOE;
  }
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
 80032f0:	687b      	ldr	r3, [r7, #4]
 80032f2:	2244      	movs	r2, #68	; 0x44
 80032f4:	5a9b      	ldrh	r3, [r3, r2]
 80032f6:	b29b      	uxth	r3, r3
 80032f8:	045b      	lsls	r3, r3, #17
 80032fa:	0c5b      	lsrs	r3, r3, #17
 80032fc:	b299      	uxth	r1, r3
 80032fe:	687b      	ldr	r3, [r7, #4]
 8003300:	2244      	movs	r2, #68	; 0x44
 8003302:	5299      	strh	r1, [r3, r2]
  }  
}
 8003304:	46c0      	nop			; (mov r8, r8)
 8003306:	46bd      	mov	sp, r7
 8003308:	b002      	add	sp, #8
 800330a:	bd80      	pop	{r7, pc}
 800330c:	ffff8000 	.word	0xffff8000

08003310 <TIM_OC1Init>:
  *         that contains the configuration information for the specified TIM 
  *         peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8003310:	b580      	push	{r7, lr}
 8003312:	b084      	sub	sp, #16
 8003314:	af00      	add	r7, sp, #0
 8003316:	6078      	str	r0, [r7, #4]
 8003318:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 800331a:	230a      	movs	r3, #10
 800331c:	18fb      	adds	r3, r7, r3
 800331e:	2200      	movs	r2, #0
 8003320:	801a      	strh	r2, [r3, #0]
 8003322:	230e      	movs	r3, #14
 8003324:	18fb      	adds	r3, r7, r3
 8003326:	2200      	movs	r2, #0
 8003328:	801a      	strh	r2, [r3, #0]
 800332a:	230c      	movs	r3, #12
 800332c:	18fb      	adds	r3, r7, r3
 800332e:	2200      	movs	r2, #0
 8003330:	801a      	strh	r2, [r3, #0]
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
 /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
 8003332:	687b      	ldr	r3, [r7, #4]
 8003334:	8c1b      	ldrh	r3, [r3, #32]
 8003336:	b29b      	uxth	r3, r3
 8003338:	2201      	movs	r2, #1
 800333a:	4393      	bics	r3, r2
 800333c:	b29a      	uxth	r2, r3
 800333e:	687b      	ldr	r3, [r7, #4]
 8003340:	841a      	strh	r2, [r3, #32]
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8003342:	230e      	movs	r3, #14
 8003344:	18fb      	adds	r3, r7, r3
 8003346:	687a      	ldr	r2, [r7, #4]
 8003348:	8c12      	ldrh	r2, [r2, #32]
 800334a:	801a      	strh	r2, [r3, #0]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800334c:	230c      	movs	r3, #12
 800334e:	18fb      	adds	r3, r7, r3
 8003350:	687a      	ldr	r2, [r7, #4]
 8003352:	8892      	ldrh	r2, [r2, #4]
 8003354:	801a      	strh	r2, [r3, #0]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8003356:	230a      	movs	r3, #10
 8003358:	18fb      	adds	r3, r7, r3
 800335a:	687a      	ldr	r2, [r7, #4]
 800335c:	8b12      	ldrh	r2, [r2, #24]
 800335e:	801a      	strh	r2, [r3, #0]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
 8003360:	230a      	movs	r3, #10
 8003362:	18fb      	adds	r3, r7, r3
 8003364:	220a      	movs	r2, #10
 8003366:	18ba      	adds	r2, r7, r2
 8003368:	8812      	ldrh	r2, [r2, #0]
 800336a:	2170      	movs	r1, #112	; 0x70
 800336c:	438a      	bics	r2, r1
 800336e:	801a      	strh	r2, [r3, #0]
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
 8003370:	230a      	movs	r3, #10
 8003372:	18fb      	adds	r3, r7, r3
 8003374:	220a      	movs	r2, #10
 8003376:	18ba      	adds	r2, r7, r2
 8003378:	8812      	ldrh	r2, [r2, #0]
 800337a:	2103      	movs	r1, #3
 800337c:	438a      	bics	r2, r1
 800337e:	801a      	strh	r2, [r3, #0]

  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8003380:	683b      	ldr	r3, [r7, #0]
 8003382:	8819      	ldrh	r1, [r3, #0]
 8003384:	230a      	movs	r3, #10
 8003386:	18fb      	adds	r3, r7, r3
 8003388:	220a      	movs	r2, #10
 800338a:	18ba      	adds	r2, r7, r2
 800338c:	8812      	ldrh	r2, [r2, #0]
 800338e:	430a      	orrs	r2, r1
 8003390:	801a      	strh	r2, [r3, #0]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
 8003392:	230e      	movs	r3, #14
 8003394:	18fb      	adds	r3, r7, r3
 8003396:	220e      	movs	r2, #14
 8003398:	18ba      	adds	r2, r7, r2
 800339a:	8812      	ldrh	r2, [r2, #0]
 800339c:	2102      	movs	r1, #2
 800339e:	438a      	bics	r2, r1
 80033a0:	801a      	strh	r2, [r3, #0]
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 80033a2:	683b      	ldr	r3, [r7, #0]
 80033a4:	8999      	ldrh	r1, [r3, #12]
 80033a6:	230e      	movs	r3, #14
 80033a8:	18fb      	adds	r3, r7, r3
 80033aa:	220e      	movs	r2, #14
 80033ac:	18ba      	adds	r2, r7, r2
 80033ae:	8812      	ldrh	r2, [r2, #0]
 80033b0:	430a      	orrs	r2, r1
 80033b2:	801a      	strh	r2, [r3, #0]
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 80033b4:	683b      	ldr	r3, [r7, #0]
 80033b6:	8859      	ldrh	r1, [r3, #2]
 80033b8:	230e      	movs	r3, #14
 80033ba:	18fb      	adds	r3, r7, r3
 80033bc:	220e      	movs	r2, #14
 80033be:	18ba      	adds	r2, r7, r2
 80033c0:	8812      	ldrh	r2, [r2, #0]
 80033c2:	430a      	orrs	r2, r1
 80033c4:	801a      	strh	r2, [r3, #0]
    
  if((TIMx == TIM1) || (TIMx == TIM15) || (TIMx == TIM16) || (TIMx == TIM17))
 80033c6:	687b      	ldr	r3, [r7, #4]
 80033c8:	4a34      	ldr	r2, [pc, #208]	; (800349c <TIM_OC1Init+0x18c>)
 80033ca:	4293      	cmp	r3, r2
 80033cc:	d00b      	beq.n	80033e6 <TIM_OC1Init+0xd6>
 80033ce:	687b      	ldr	r3, [r7, #4]
 80033d0:	4a33      	ldr	r2, [pc, #204]	; (80034a0 <TIM_OC1Init+0x190>)
 80033d2:	4293      	cmp	r3, r2
 80033d4:	d007      	beq.n	80033e6 <TIM_OC1Init+0xd6>
 80033d6:	687b      	ldr	r3, [r7, #4]
 80033d8:	4a32      	ldr	r2, [pc, #200]	; (80034a4 <TIM_OC1Init+0x194>)
 80033da:	4293      	cmp	r3, r2
 80033dc:	d003      	beq.n	80033e6 <TIM_OC1Init+0xd6>
 80033de:	687b      	ldr	r3, [r7, #4]
 80033e0:	4a31      	ldr	r2, [pc, #196]	; (80034a8 <TIM_OC1Init+0x198>)
 80033e2:	4293      	cmp	r3, r2
 80033e4:	d143      	bne.n	800346e <TIM_OC1Init+0x15e>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
 80033e6:	230e      	movs	r3, #14
 80033e8:	18fb      	adds	r3, r7, r3
 80033ea:	220e      	movs	r2, #14
 80033ec:	18ba      	adds	r2, r7, r2
 80033ee:	8812      	ldrh	r2, [r2, #0]
 80033f0:	2108      	movs	r1, #8
 80033f2:	438a      	bics	r2, r1
 80033f4:	801a      	strh	r2, [r3, #0]
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 80033f6:	683b      	ldr	r3, [r7, #0]
 80033f8:	89d9      	ldrh	r1, [r3, #14]
 80033fa:	230e      	movs	r3, #14
 80033fc:	18fb      	adds	r3, r7, r3
 80033fe:	220e      	movs	r2, #14
 8003400:	18ba      	adds	r2, r7, r2
 8003402:	8812      	ldrh	r2, [r2, #0]
 8003404:	430a      	orrs	r2, r1
 8003406:	801a      	strh	r2, [r3, #0]
    
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
 8003408:	230e      	movs	r3, #14
 800340a:	18fb      	adds	r3, r7, r3
 800340c:	220e      	movs	r2, #14
 800340e:	18ba      	adds	r2, r7, r2
 8003410:	8812      	ldrh	r2, [r2, #0]
 8003412:	2104      	movs	r1, #4
 8003414:	438a      	bics	r2, r1
 8003416:	801a      	strh	r2, [r3, #0]
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8003418:	683b      	ldr	r3, [r7, #0]
 800341a:	8899      	ldrh	r1, [r3, #4]
 800341c:	230e      	movs	r3, #14
 800341e:	18fb      	adds	r3, r7, r3
 8003420:	220e      	movs	r2, #14
 8003422:	18ba      	adds	r2, r7, r2
 8003424:	8812      	ldrh	r2, [r2, #0]
 8003426:	430a      	orrs	r2, r1
 8003428:	801a      	strh	r2, [r3, #0]
    
    /* Reset the Ouput Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
 800342a:	230c      	movs	r3, #12
 800342c:	18fb      	adds	r3, r7, r3
 800342e:	220c      	movs	r2, #12
 8003430:	18ba      	adds	r2, r7, r2
 8003432:	8812      	ldrh	r2, [r2, #0]
 8003434:	491d      	ldr	r1, [pc, #116]	; (80034ac <TIM_OC1Init+0x19c>)
 8003436:	400a      	ands	r2, r1
 8003438:	801a      	strh	r2, [r3, #0]
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
 800343a:	230c      	movs	r3, #12
 800343c:	18fb      	adds	r3, r7, r3
 800343e:	220c      	movs	r2, #12
 8003440:	18ba      	adds	r2, r7, r2
 8003442:	8812      	ldrh	r2, [r2, #0]
 8003444:	491a      	ldr	r1, [pc, #104]	; (80034b0 <TIM_OC1Init+0x1a0>)
 8003446:	400a      	ands	r2, r1
 8003448:	801a      	strh	r2, [r3, #0]
    
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 800344a:	683b      	ldr	r3, [r7, #0]
 800344c:	8a19      	ldrh	r1, [r3, #16]
 800344e:	230c      	movs	r3, #12
 8003450:	18fb      	adds	r3, r7, r3
 8003452:	220c      	movs	r2, #12
 8003454:	18ba      	adds	r2, r7, r2
 8003456:	8812      	ldrh	r2, [r2, #0]
 8003458:	430a      	orrs	r2, r1
 800345a:	801a      	strh	r2, [r3, #0]
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 800345c:	683b      	ldr	r3, [r7, #0]
 800345e:	8a59      	ldrh	r1, [r3, #18]
 8003460:	230c      	movs	r3, #12
 8003462:	18fb      	adds	r3, r7, r3
 8003464:	220c      	movs	r2, #12
 8003466:	18ba      	adds	r2, r7, r2
 8003468:	8812      	ldrh	r2, [r2, #0]
 800346a:	430a      	orrs	r2, r1
 800346c:	801a      	strh	r2, [r3, #0]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800346e:	687b      	ldr	r3, [r7, #4]
 8003470:	220c      	movs	r2, #12
 8003472:	18ba      	adds	r2, r7, r2
 8003474:	8812      	ldrh	r2, [r2, #0]
 8003476:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8003478:	687b      	ldr	r3, [r7, #4]
 800347a:	220a      	movs	r2, #10
 800347c:	18ba      	adds	r2, r7, r2
 800347e:	8812      	ldrh	r2, [r2, #0]
 8003480:	831a      	strh	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
 8003482:	683b      	ldr	r3, [r7, #0]
 8003484:	689a      	ldr	r2, [r3, #8]
 8003486:	687b      	ldr	r3, [r7, #4]
 8003488:	635a      	str	r2, [r3, #52]	; 0x34
 
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800348a:	687b      	ldr	r3, [r7, #4]
 800348c:	220e      	movs	r2, #14
 800348e:	18ba      	adds	r2, r7, r2
 8003490:	8812      	ldrh	r2, [r2, #0]
 8003492:	841a      	strh	r2, [r3, #32]
}
 8003494:	46c0      	nop			; (mov r8, r8)
 8003496:	46bd      	mov	sp, r7
 8003498:	b004      	add	sp, #16
 800349a:	bd80      	pop	{r7, pc}
 800349c:	40012c00 	.word	0x40012c00
 80034a0:	40014000 	.word	0x40014000
 80034a4:	40014400 	.word	0x40014400
 80034a8:	40014800 	.word	0x40014800
 80034ac:	fffffeff 	.word	0xfffffeff
 80034b0:	fffffdff 	.word	0xfffffdff

080034b4 <TIM_OC1PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 80034b4:	b580      	push	{r7, lr}
 80034b6:	b084      	sub	sp, #16
 80034b8:	af00      	add	r7, sp, #0
 80034ba:	6078      	str	r0, [r7, #4]
 80034bc:	000a      	movs	r2, r1
 80034be:	1cbb      	adds	r3, r7, #2
 80034c0:	801a      	strh	r2, [r3, #0]
  uint16_t tmpccmr1 = 0;
 80034c2:	230e      	movs	r3, #14
 80034c4:	18fb      	adds	r3, r7, r3
 80034c6:	2200      	movs	r2, #0
 80034c8:	801a      	strh	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  
  tmpccmr1 = TIMx->CCMR1;
 80034ca:	230e      	movs	r3, #14
 80034cc:	18fb      	adds	r3, r7, r3
 80034ce:	687a      	ldr	r2, [r7, #4]
 80034d0:	8b12      	ldrh	r2, [r2, #24]
 80034d2:	801a      	strh	r2, [r3, #0]
  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
 80034d4:	230e      	movs	r3, #14
 80034d6:	18fb      	adds	r3, r7, r3
 80034d8:	220e      	movs	r2, #14
 80034da:	18ba      	adds	r2, r7, r2
 80034dc:	8812      	ldrh	r2, [r2, #0]
 80034de:	2108      	movs	r1, #8
 80034e0:	438a      	bics	r2, r1
 80034e2:	801a      	strh	r2, [r3, #0]
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= TIM_OCPreload;
 80034e4:	230e      	movs	r3, #14
 80034e6:	18fb      	adds	r3, r7, r3
 80034e8:	220e      	movs	r2, #14
 80034ea:	18b9      	adds	r1, r7, r2
 80034ec:	1cba      	adds	r2, r7, #2
 80034ee:	8809      	ldrh	r1, [r1, #0]
 80034f0:	8812      	ldrh	r2, [r2, #0]
 80034f2:	430a      	orrs	r2, r1
 80034f4:	801a      	strh	r2, [r3, #0]
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 80034f6:	687b      	ldr	r3, [r7, #4]
 80034f8:	220e      	movs	r2, #14
 80034fa:	18ba      	adds	r2, r7, r2
 80034fc:	8812      	ldrh	r2, [r2, #0]
 80034fe:	831a      	strh	r2, [r3, #24]
}
 8003500:	46c0      	nop			; (mov r8, r8)
 8003502:	46bd      	mov	sp, r7
 8003504:	b004      	add	sp, #16
 8003506:	bd80      	pop	{r7, pc}

08003508 <TIM_ITConfig>:
  * @param  NewState: new state of the TIM interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
{  
 8003508:	b580      	push	{r7, lr}
 800350a:	b082      	sub	sp, #8
 800350c:	af00      	add	r7, sp, #0
 800350e:	6078      	str	r0, [r7, #4]
 8003510:	0008      	movs	r0, r1
 8003512:	0011      	movs	r1, r2
 8003514:	1cbb      	adds	r3, r7, #2
 8003516:	1c02      	adds	r2, r0, #0
 8003518:	801a      	strh	r2, [r3, #0]
 800351a:	1c7b      	adds	r3, r7, #1
 800351c:	1c0a      	adds	r2, r1, #0
 800351e:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003520:	1c7b      	adds	r3, r7, #1
 8003522:	781b      	ldrb	r3, [r3, #0]
 8003524:	2b00      	cmp	r3, #0
 8003526:	d009      	beq.n	800353c <TIM_ITConfig+0x34>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 8003528:	687b      	ldr	r3, [r7, #4]
 800352a:	899b      	ldrh	r3, [r3, #12]
 800352c:	b29a      	uxth	r2, r3
 800352e:	1cbb      	adds	r3, r7, #2
 8003530:	881b      	ldrh	r3, [r3, #0]
 8003532:	4313      	orrs	r3, r2
 8003534:	b29a      	uxth	r2, r3
 8003536:	687b      	ldr	r3, [r7, #4]
 8003538:	819a      	strh	r2, [r3, #12]
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
  }
}
 800353a:	e00a      	b.n	8003552 <TIM_ITConfig+0x4a>
    TIMx->DIER |= TIM_IT;
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
 800353c:	687b      	ldr	r3, [r7, #4]
 800353e:	899b      	ldrh	r3, [r3, #12]
 8003540:	b29b      	uxth	r3, r3
 8003542:	1cba      	adds	r2, r7, #2
 8003544:	8812      	ldrh	r2, [r2, #0]
 8003546:	43d2      	mvns	r2, r2
 8003548:	b292      	uxth	r2, r2
 800354a:	4013      	ands	r3, r2
 800354c:	b29a      	uxth	r2, r3
 800354e:	687b      	ldr	r3, [r7, #4]
 8003550:	819a      	strh	r2, [r3, #12]
  }
}
 8003552:	46c0      	nop			; (mov r8, r8)
 8003554:	46bd      	mov	sp, r7
 8003556:	b002      	add	sp, #8
 8003558:	bd80      	pop	{r7, pc}
 800355a:	46c0      	nop			; (mov r8, r8)

0800355c <TIM_ClearITPendingBit>:
  * @note   TIM_IT_COM is used only with TIM1, TIM15, TIM16 and TIM17.
  *
  * @retval None
  */
void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 800355c:	b580      	push	{r7, lr}
 800355e:	b082      	sub	sp, #8
 8003560:	af00      	add	r7, sp, #0
 8003562:	6078      	str	r0, [r7, #4]
 8003564:	000a      	movs	r2, r1
 8003566:	1cbb      	adds	r3, r7, #2
 8003568:	801a      	strh	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
   
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 800356a:	1cbb      	adds	r3, r7, #2
 800356c:	881b      	ldrh	r3, [r3, #0]
 800356e:	43db      	mvns	r3, r3
 8003570:	b29a      	uxth	r2, r3
 8003572:	687b      	ldr	r3, [r7, #4]
 8003574:	821a      	strh	r2, [r3, #16]
}
 8003576:	46c0      	nop			; (mov r8, r8)
 8003578:	46bd      	mov	sp, r7
 800357a:	b002      	add	sp, #8
 800357c:	bd80      	pop	{r7, pc}
 800357e:	46c0      	nop			; (mov r8, r8)

08003580 <USART_Init>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8003580:	b580      	push	{r7, lr}
 8003582:	b090      	sub	sp, #64	; 0x40
 8003584:	af00      	add	r7, sp, #0
 8003586:	6078      	str	r0, [r7, #4]
 8003588:	6039      	str	r1, [r7, #0]
  uint32_t divider = 0, apbclock = 0, tmpreg = 0;
 800358a:	2300      	movs	r3, #0
 800358c:	63fb      	str	r3, [r7, #60]	; 0x3c
 800358e:	2300      	movs	r3, #0
 8003590:	63bb      	str	r3, [r7, #56]	; 0x38
 8003592:	2300      	movs	r3, #0
 8003594:	637b      	str	r3, [r7, #52]	; 0x34
  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
  
  /* Disable USART */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 8003596:	687b      	ldr	r3, [r7, #4]
 8003598:	681b      	ldr	r3, [r3, #0]
 800359a:	2201      	movs	r2, #1
 800359c:	4393      	bics	r3, r2
 800359e:	001a      	movs	r2, r3
 80035a0:	687b      	ldr	r3, [r7, #4]
 80035a2:	601a      	str	r2, [r3, #0]
  
  /*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 80035a4:	687b      	ldr	r3, [r7, #4]
 80035a6:	685b      	ldr	r3, [r3, #4]
 80035a8:	637b      	str	r3, [r7, #52]	; 0x34
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 80035aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80035ac:	4a50      	ldr	r2, [pc, #320]	; (80036f0 <USART_Init+0x170>)
 80035ae:	4013      	ands	r3, r2
 80035b0:	637b      	str	r3, [r7, #52]	; 0x34
  
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 80035b2:	683b      	ldr	r3, [r7, #0]
 80035b4:	689b      	ldr	r3, [r3, #8]
 80035b6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80035b8:	4313      	orrs	r3, r2
 80035ba:	637b      	str	r3, [r7, #52]	; 0x34
  
  /* Write to USART CR2 */
  USARTx->CR2 = tmpreg;
 80035bc:	687b      	ldr	r3, [r7, #4]
 80035be:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80035c0:	605a      	str	r2, [r3, #4]
  
  /*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 80035c2:	687b      	ldr	r3, [r7, #4]
 80035c4:	681b      	ldr	r3, [r3, #0]
 80035c6:	637b      	str	r3, [r7, #52]	; 0x34
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 80035c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80035ca:	4a4a      	ldr	r2, [pc, #296]	; (80036f4 <USART_Init+0x174>)
 80035cc:	4013      	ands	r3, r2
 80035ce:	637b      	str	r3, [r7, #52]	; 0x34
  
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80035d0:	683b      	ldr	r3, [r7, #0]
 80035d2:	685a      	ldr	r2, [r3, #4]
 80035d4:	683b      	ldr	r3, [r7, #0]
 80035d6:	68db      	ldr	r3, [r3, #12]
 80035d8:	431a      	orrs	r2, r3
    USART_InitStruct->USART_Mode;
 80035da:	683b      	ldr	r3, [r7, #0]
 80035dc:	691b      	ldr	r3, [r3, #16]
  
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80035de:	4313      	orrs	r3, r2
 80035e0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80035e2:	4313      	orrs	r3, r2
 80035e4:	637b      	str	r3, [r7, #52]	; 0x34
    USART_InitStruct->USART_Mode;
  
  /* Write to USART CR1 */
  USARTx->CR1 = tmpreg;
 80035e6:	687b      	ldr	r3, [r7, #4]
 80035e8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80035ea:	601a      	str	r2, [r3, #0]
  
  /*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 80035ec:	687b      	ldr	r3, [r7, #4]
 80035ee:	689b      	ldr	r3, [r3, #8]
 80035f0:	637b      	str	r3, [r7, #52]	; 0x34
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 80035f2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80035f4:	4a40      	ldr	r2, [pc, #256]	; (80036f8 <USART_Init+0x178>)
 80035f6:	4013      	ands	r3, r2
 80035f8:	637b      	str	r3, [r7, #52]	; 0x34
  
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 80035fa:	683b      	ldr	r3, [r7, #0]
 80035fc:	695b      	ldr	r3, [r3, #20]
 80035fe:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8003600:	4313      	orrs	r3, r2
 8003602:	637b      	str	r3, [r7, #52]	; 0x34
  
  /* Write to USART CR3 */
  USARTx->CR3 = tmpreg;
 8003604:	687b      	ldr	r3, [r7, #4]
 8003606:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8003608:	609a      	str	r2, [r3, #8]
  
  /*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 800360a:	230c      	movs	r3, #12
 800360c:	18fb      	adds	r3, r7, r3
 800360e:	0018      	movs	r0, r3
 8003610:	f7ff fbb6 	bl	8002d80 <RCC_GetClocksFreq>
  
  if (USARTx == USART1)
 8003614:	687b      	ldr	r3, [r7, #4]
 8003616:	4a39      	ldr	r2, [pc, #228]	; (80036fc <USART_Init+0x17c>)
 8003618:	4293      	cmp	r3, r2
 800361a:	d104      	bne.n	8003626 <USART_Init+0xa6>
  {
    apbclock = RCC_ClocksStatus.USART1CLK_Frequency;
 800361c:	230c      	movs	r3, #12
 800361e:	18fb      	adds	r3, r7, r3
 8003620:	699b      	ldr	r3, [r3, #24]
 8003622:	63bb      	str	r3, [r7, #56]	; 0x38
 8003624:	e015      	b.n	8003652 <USART_Init+0xd2>
  }
  else if (USARTx == USART2)
 8003626:	687b      	ldr	r3, [r7, #4]
 8003628:	4a35      	ldr	r2, [pc, #212]	; (8003700 <USART_Init+0x180>)
 800362a:	4293      	cmp	r3, r2
 800362c:	d104      	bne.n	8003638 <USART_Init+0xb8>
  {
    apbclock = RCC_ClocksStatus.USART2CLK_Frequency;
 800362e:	230c      	movs	r3, #12
 8003630:	18fb      	adds	r3, r7, r3
 8003632:	69db      	ldr	r3, [r3, #28]
 8003634:	63bb      	str	r3, [r7, #56]	; 0x38
 8003636:	e00c      	b.n	8003652 <USART_Init+0xd2>
  }
   else if (USARTx == USART3)
 8003638:	687b      	ldr	r3, [r7, #4]
 800363a:	4a32      	ldr	r2, [pc, #200]	; (8003704 <USART_Init+0x184>)
 800363c:	4293      	cmp	r3, r2
 800363e:	d104      	bne.n	800364a <USART_Init+0xca>
  {
    apbclock = RCC_ClocksStatus.USART3CLK_Frequency;
 8003640:	230c      	movs	r3, #12
 8003642:	18fb      	adds	r3, r7, r3
 8003644:	6a1b      	ldr	r3, [r3, #32]
 8003646:	63bb      	str	r3, [r7, #56]	; 0x38
 8003648:	e003      	b.n	8003652 <USART_Init+0xd2>
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK_Frequency;
 800364a:	230c      	movs	r3, #12
 800364c:	18fb      	adds	r3, r7, r3
 800364e:	689b      	ldr	r3, [r3, #8]
 8003650:	63bb      	str	r3, [r7, #56]	; 0x38
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8003652:	687b      	ldr	r3, [r7, #4]
 8003654:	681a      	ldr	r2, [r3, #0]
 8003656:	2380      	movs	r3, #128	; 0x80
 8003658:	021b      	lsls	r3, r3, #8
 800365a:	4013      	ands	r3, r2
 800365c:	d014      	beq.n	8003688 <USART_Init+0x108>
  {
    /* (divider * 10) computing in case Oversampling mode is 8 Samples */
    divider = (uint32_t)((2 * apbclock) / (USART_InitStruct->USART_BaudRate));
 800365e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003660:	005a      	lsls	r2, r3, #1
 8003662:	683b      	ldr	r3, [r7, #0]
 8003664:	681b      	ldr	r3, [r3, #0]
 8003666:	0019      	movs	r1, r3
 8003668:	0010      	movs	r0, r2
 800366a:	f7fc fd57 	bl	800011c <__aeabi_uidiv>
 800366e:	0003      	movs	r3, r0
 8003670:	63fb      	str	r3, [r7, #60]	; 0x3c
    tmpreg  = (uint32_t)((2 * apbclock) % (USART_InitStruct->USART_BaudRate));
 8003672:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003674:	005a      	lsls	r2, r3, #1
 8003676:	683b      	ldr	r3, [r7, #0]
 8003678:	681b      	ldr	r3, [r3, #0]
 800367a:	0019      	movs	r1, r3
 800367c:	0010      	movs	r0, r2
 800367e:	f7fc fdd3 	bl	8000228 <__aeabi_uidivmod>
 8003682:	000b      	movs	r3, r1
 8003684:	637b      	str	r3, [r7, #52]	; 0x34
 8003686:	e010      	b.n	80036aa <USART_Init+0x12a>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* (divider * 10) computing in case Oversampling mode is 16 Samples */
    divider = (uint32_t)((apbclock) / (USART_InitStruct->USART_BaudRate));
 8003688:	683b      	ldr	r3, [r7, #0]
 800368a:	681b      	ldr	r3, [r3, #0]
 800368c:	0019      	movs	r1, r3
 800368e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8003690:	f7fc fd44 	bl	800011c <__aeabi_uidiv>
 8003694:	0003      	movs	r3, r0
 8003696:	63fb      	str	r3, [r7, #60]	; 0x3c
    tmpreg  = (uint32_t)((apbclock) % (USART_InitStruct->USART_BaudRate));
 8003698:	683b      	ldr	r3, [r7, #0]
 800369a:	681a      	ldr	r2, [r3, #0]
 800369c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800369e:	0011      	movs	r1, r2
 80036a0:	0018      	movs	r0, r3
 80036a2:	f7fc fdc1 	bl	8000228 <__aeabi_uidivmod>
 80036a6:	000b      	movs	r3, r1
 80036a8:	637b      	str	r3, [r7, #52]	; 0x34
  }
  
  /* round the divider : if fractional part i greater than 0.5 increment divider */
  if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
 80036aa:	683b      	ldr	r3, [r7, #0]
 80036ac:	681b      	ldr	r3, [r3, #0]
 80036ae:	085a      	lsrs	r2, r3, #1
 80036b0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80036b2:	429a      	cmp	r2, r3
 80036b4:	d802      	bhi.n	80036bc <USART_Init+0x13c>
  {
    divider++;
 80036b6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80036b8:	3301      	adds	r3, #1
 80036ba:	63fb      	str	r3, [r7, #60]	; 0x3c
  } 
  
  /* Implement the divider in case Oversampling mode is 8 Samples */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 80036bc:	687b      	ldr	r3, [r7, #4]
 80036be:	681a      	ldr	r2, [r3, #0]
 80036c0:	2380      	movs	r3, #128	; 0x80
 80036c2:	021b      	lsls	r3, r3, #8
 80036c4:	4013      	ands	r3, r2
 80036c6:	d00a      	beq.n	80036de <USART_Init+0x15e>
  {
    /* get the LSB of divider and shift it to the right by 1 bit */
    tmpreg = (divider & (uint16_t)0x000F) >> 1;
 80036c8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80036ca:	085b      	lsrs	r3, r3, #1
 80036cc:	2207      	movs	r2, #7
 80036ce:	4013      	ands	r3, r2
 80036d0:	637b      	str	r3, [r7, #52]	; 0x34
    
    /* update the divider value */
    divider = (divider & (uint16_t)0xFFF0) | tmpreg;
 80036d2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80036d4:	4a0c      	ldr	r2, [pc, #48]	; (8003708 <USART_Init+0x188>)
 80036d6:	401a      	ands	r2, r3
 80036d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80036da:	4313      	orrs	r3, r2
 80036dc:	63fb      	str	r3, [r7, #60]	; 0x3c
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)divider;
 80036de:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80036e0:	b29a      	uxth	r2, r3
 80036e2:	687b      	ldr	r3, [r7, #4]
 80036e4:	819a      	strh	r2, [r3, #12]
}
 80036e6:	46c0      	nop			; (mov r8, r8)
 80036e8:	46bd      	mov	sp, r7
 80036ea:	b010      	add	sp, #64	; 0x40
 80036ec:	bd80      	pop	{r7, pc}
 80036ee:	46c0      	nop			; (mov r8, r8)
 80036f0:	ffffcfff 	.word	0xffffcfff
 80036f4:	ffffe9f3 	.word	0xffffe9f3
 80036f8:	fffffcff 	.word	0xfffffcff
 80036fc:	40013800 	.word	0x40013800
 8003700:	40004400 	.word	0x40004400
 8003704:	40004800 	.word	0x40004800
 8003708:	0000fff0 	.word	0x0000fff0

0800370c <USART_Cmd>:
  * @param  NewState: new state of the USARTx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 800370c:	b580      	push	{r7, lr}
 800370e:	b082      	sub	sp, #8
 8003710:	af00      	add	r7, sp, #0
 8003712:	6078      	str	r0, [r7, #4]
 8003714:	000a      	movs	r2, r1
 8003716:	1cfb      	adds	r3, r7, #3
 8003718:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800371a:	1cfb      	adds	r3, r7, #3
 800371c:	781b      	ldrb	r3, [r3, #0]
 800371e:	2b00      	cmp	r3, #0
 8003720:	d006      	beq.n	8003730 <USART_Cmd+0x24>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8003722:	687b      	ldr	r3, [r7, #4]
 8003724:	681b      	ldr	r3, [r3, #0]
 8003726:	2201      	movs	r2, #1
 8003728:	431a      	orrs	r2, r3
 800372a:	687b      	ldr	r3, [r7, #4]
 800372c:	601a      	str	r2, [r3, #0]
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
  }
}
 800372e:	e006      	b.n	800373e <USART_Cmd+0x32>
    USARTx->CR1 |= USART_CR1_UE;
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 8003730:	687b      	ldr	r3, [r7, #4]
 8003732:	681b      	ldr	r3, [r3, #0]
 8003734:	2201      	movs	r2, #1
 8003736:	4393      	bics	r3, r2
 8003738:	001a      	movs	r2, r3
 800373a:	687b      	ldr	r3, [r7, #4]
 800373c:	601a      	str	r2, [r3, #0]
  }
}
 800373e:	46c0      	nop			; (mov r8, r8)
 8003740:	46bd      	mov	sp, r7
 8003742:	b002      	add	sp, #8
 8003744:	bd80      	pop	{r7, pc}
 8003746:	46c0      	nop			; (mov r8, r8)

08003748 <USART_SendData>:
  * @note   USART2 is not available for STM32F031 devices.  
  * @param  Data: the data to transmit.
  * @retval None
  */
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
{
 8003748:	b580      	push	{r7, lr}
 800374a:	b082      	sub	sp, #8
 800374c:	af00      	add	r7, sp, #0
 800374e:	6078      	str	r0, [r7, #4]
 8003750:	000a      	movs	r2, r1
 8003752:	1cbb      	adds	r3, r7, #2
 8003754:	801a      	strh	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->TDR = (Data & (uint16_t)0x01FF);
 8003756:	1cbb      	adds	r3, r7, #2
 8003758:	881b      	ldrh	r3, [r3, #0]
 800375a:	05db      	lsls	r3, r3, #23
 800375c:	0ddb      	lsrs	r3, r3, #23
 800375e:	b29a      	uxth	r2, r3
 8003760:	687b      	ldr	r3, [r7, #4]
 8003762:	851a      	strh	r2, [r3, #40]	; 0x28
}
 8003764:	46c0      	nop			; (mov r8, r8)
 8003766:	46bd      	mov	sp, r7
 8003768:	b002      	add	sp, #8
 800376a:	bd80      	pop	{r7, pc}

0800376c <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState)
{
 800376c:	b580      	push	{r7, lr}
 800376e:	b088      	sub	sp, #32
 8003770:	af00      	add	r7, sp, #0
 8003772:	60f8      	str	r0, [r7, #12]
 8003774:	60b9      	str	r1, [r7, #8]
 8003776:	1dfb      	adds	r3, r7, #7
 8003778:	701a      	strb	r2, [r3, #0]
  uint32_t usartreg = 0, itpos = 0, itmask = 0;
 800377a:	2300      	movs	r3, #0
 800377c:	61bb      	str	r3, [r7, #24]
 800377e:	2300      	movs	r3, #0
 8003780:	617b      	str	r3, [r7, #20]
 8003782:	2300      	movs	r3, #0
 8003784:	613b      	str	r3, [r7, #16]
  uint32_t usartxbase = 0;
 8003786:	2300      	movs	r3, #0
 8003788:	61fb      	str	r3, [r7, #28]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CONFIG_IT(USART_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  usartxbase = (uint32_t)USARTx;
 800378a:	68fb      	ldr	r3, [r7, #12]
 800378c:	61fb      	str	r3, [r7, #28]
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
 800378e:	68bb      	ldr	r3, [r7, #8]
 8003790:	121b      	asrs	r3, r3, #8
 8003792:	001a      	movs	r2, r3
 8003794:	23ff      	movs	r3, #255	; 0xff
 8003796:	4013      	ands	r3, r2
 8003798:	61bb      	str	r3, [r7, #24]
  
  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
 800379a:	68bb      	ldr	r3, [r7, #8]
 800379c:	22ff      	movs	r2, #255	; 0xff
 800379e:	4013      	ands	r3, r2
 80037a0:	617b      	str	r3, [r7, #20]
  itmask = (((uint32_t)0x01) << itpos);
 80037a2:	2201      	movs	r2, #1
 80037a4:	697b      	ldr	r3, [r7, #20]
 80037a6:	409a      	lsls	r2, r3
 80037a8:	0013      	movs	r3, r2
 80037aa:	613b      	str	r3, [r7, #16]
  
  if (usartreg == 0x02) /* The IT is in CR2 register */
 80037ac:	69bb      	ldr	r3, [r7, #24]
 80037ae:	2b02      	cmp	r3, #2
 80037b0:	d103      	bne.n	80037ba <USART_ITConfig+0x4e>
  {
    usartxbase += 0x04;
 80037b2:	69fb      	ldr	r3, [r7, #28]
 80037b4:	3304      	adds	r3, #4
 80037b6:	61fb      	str	r3, [r7, #28]
 80037b8:	e005      	b.n	80037c6 <USART_ITConfig+0x5a>
  }
  else if (usartreg == 0x03) /* The IT is in CR3 register */
 80037ba:	69bb      	ldr	r3, [r7, #24]
 80037bc:	2b03      	cmp	r3, #3
 80037be:	d102      	bne.n	80037c6 <USART_ITConfig+0x5a>
  {
    usartxbase += 0x08;
 80037c0:	69fb      	ldr	r3, [r7, #28]
 80037c2:	3308      	adds	r3, #8
 80037c4:	61fb      	str	r3, [r7, #28]
  }
  else /* The IT is in CR1 register */
  {
  }
  if (NewState != DISABLE)
 80037c6:	1dfb      	adds	r3, r7, #7
 80037c8:	781b      	ldrb	r3, [r3, #0]
 80037ca:	2b00      	cmp	r3, #0
 80037cc:	d006      	beq.n	80037dc <USART_ITConfig+0x70>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 80037ce:	69fb      	ldr	r3, [r7, #28]
 80037d0:	69fa      	ldr	r2, [r7, #28]
 80037d2:	6811      	ldr	r1, [r2, #0]
 80037d4:	693a      	ldr	r2, [r7, #16]
 80037d6:	430a      	orrs	r2, r1
 80037d8:	601a      	str	r2, [r3, #0]
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
  }
}
 80037da:	e006      	b.n	80037ea <USART_ITConfig+0x7e>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 80037dc:	69fb      	ldr	r3, [r7, #28]
 80037de:	69fa      	ldr	r2, [r7, #28]
 80037e0:	6812      	ldr	r2, [r2, #0]
 80037e2:	6939      	ldr	r1, [r7, #16]
 80037e4:	43c9      	mvns	r1, r1
 80037e6:	400a      	ands	r2, r1
 80037e8:	601a      	str	r2, [r3, #0]
  }
}
 80037ea:	46c0      	nop			; (mov r8, r8)
 80037ec:	46bd      	mov	sp, r7
 80037ee:	b008      	add	sp, #32
 80037f0:	bd80      	pop	{r7, pc}
 80037f2:	46c0      	nop			; (mov r8, r8)

080037f4 <coolant_init>:

#include "grbl.h"


void coolant_init()
{
 80037f4:	b580      	push	{r7, lr}
 80037f6:	af00      	add	r7, sp, #0
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Pin = 1 << COOLANT_MIST_BIT;
	GPIO_Init(COOLANT_MIST_PORT, &GPIO_InitStructure);
#endif
  coolant_stop();
 80037f8:	f000 f810 	bl	800381c <coolant_stop>
}
 80037fc:	46c0      	nop			; (mov r8, r8)
 80037fe:	46bd      	mov	sp, r7
 8003800:	bd80      	pop	{r7, pc}
 8003802:	46c0      	nop			; (mov r8, r8)

08003804 <coolant_get_state>:


// Returns current coolant output state. Overrides may alter it from programmed state.
uint8_t coolant_get_state()
{
 8003804:	b580      	push	{r7, lr}
 8003806:	b082      	sub	sp, #8
 8003808:	af00      	add	r7, sp, #0
  uint8_t cl_state = COOLANT_STATE_DISABLE;
 800380a:	1dfb      	adds	r3, r7, #7
 800380c:	2200      	movs	r2, #0
 800380e:	701a      	strb	r2, [r3, #0]
    #endif
      cl_state |= COOLANT_STATE_MIST;
    }
  #endif
#endif
  return(cl_state);
 8003810:	1dfb      	adds	r3, r7, #7
 8003812:	781b      	ldrb	r3, [r3, #0]
}
 8003814:	0018      	movs	r0, r3
 8003816:	46bd      	mov	sp, r7
 8003818:	b002      	add	sp, #8
 800381a:	bd80      	pop	{r7, pc}

0800381c <coolant_stop>:


// Directly called by coolant_init(), coolant_set_state(), and mc_reset(), which can be at
// an interrupt-level. No report flag set, but only called by routines that don't need it.
void coolant_stop()
{
 800381c:	b580      	push	{r7, lr}
 800381e:	af00      	add	r7, sp, #0
	GPIO_ResetBits(COOLANT_MIST_PORT, 1 << COOLANT_MIST_BIT);
#endif
    #endif
  #endif
#endif
}
 8003820:	46c0      	nop			; (mov r8, r8)
 8003822:	46bd      	mov	sp, r7
 8003824:	bd80      	pop	{r7, pc}
 8003826:	46c0      	nop			; (mov r8, r8)

08003828 <coolant_set_state>:
// Main program only. Immediately sets flood coolant running state and also mist coolant, 
// if enabled. Also sets a flag to report an update to a coolant state.
// Called by coolant toggle override, parking restore, parking retract, sleep mode, g-code
// parser program end, and g-code parser coolant_sync().
void coolant_set_state(uint8_t mode)
{
 8003828:	b580      	push	{r7, lr}
 800382a:	b082      	sub	sp, #8
 800382c:	af00      	add	r7, sp, #0
 800382e:	0002      	movs	r2, r0
 8003830:	1dfb      	adds	r3, r7, #7
 8003832:	701a      	strb	r2, [r3, #0]
  if (sys.abort) { return; } // Block during abort.  
 8003834:	4b08      	ldr	r3, [pc, #32]	; (8003858 <coolant_set_state+0x30>)
 8003836:	785b      	ldrb	r3, [r3, #1]
 8003838:	2b00      	cmp	r3, #0
 800383a:	d109      	bne.n	8003850 <coolant_set_state+0x28>
  
  if (mode == COOLANT_DISABLE) {
 800383c:	1dfb      	adds	r3, r7, #7
 800383e:	781b      	ldrb	r3, [r3, #0]
 8003840:	2b00      	cmp	r3, #0
 8003842:	d101      	bne.n	8003848 <coolant_set_state+0x20>
  
    coolant_stop(); 
 8003844:	f7ff ffea 	bl	800381c <coolant_stop>
        #endif
      }
    #endif
#endif  
  }
  sys.report_ovr_counter = 0; // Set to report change immediately
 8003848:	4b03      	ldr	r3, [pc, #12]	; (8003858 <coolant_set_state+0x30>)
 800384a:	2200      	movs	r2, #0
 800384c:	72da      	strb	r2, [r3, #11]
 800384e:	e000      	b.n	8003852 <coolant_set_state+0x2a>
// if enabled. Also sets a flag to report an update to a coolant state.
// Called by coolant toggle override, parking restore, parking retract, sleep mode, g-code
// parser program end, and g-code parser coolant_sync().
void coolant_set_state(uint8_t mode)
{
  if (sys.abort) { return; } // Block during abort.  
 8003850:	46c0      	nop			; (mov r8, r8)
      }
    #endif
#endif  
  }
  sys.report_ovr_counter = 0; // Set to report change immediately
}
 8003852:	46bd      	mov	sp, r7
 8003854:	b002      	add	sp, #8
 8003856:	bd80      	pop	{r7, pc}
 8003858:	20000b2c 	.word	0x20000b2c

0800385c <coolant_sync>:


// G-code parser entry-point for setting coolant state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void coolant_sync(uint8_t mode)
{
 800385c:	b580      	push	{r7, lr}
 800385e:	b082      	sub	sp, #8
 8003860:	af00      	add	r7, sp, #0
 8003862:	0002      	movs	r2, r0
 8003864:	1dfb      	adds	r3, r7, #7
 8003866:	701a      	strb	r2, [r3, #0]
  if (sys.state == STATE_CHECK_MODE) { return; }
 8003868:	4b07      	ldr	r3, [pc, #28]	; (8003888 <coolant_sync+0x2c>)
 800386a:	781b      	ldrb	r3, [r3, #0]
 800386c:	2b02      	cmp	r3, #2
 800386e:	d007      	beq.n	8003880 <coolant_sync+0x24>
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.
 8003870:	f004 f834 	bl	80078dc <protocol_buffer_synchronize>
  coolant_set_state(mode);
 8003874:	1dfb      	adds	r3, r7, #7
 8003876:	781b      	ldrb	r3, [r3, #0]
 8003878:	0018      	movs	r0, r3
 800387a:	f7ff ffd5 	bl	8003828 <coolant_set_state>
 800387e:	e000      	b.n	8003882 <coolant_sync+0x26>

// G-code parser entry-point for setting coolant state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void coolant_sync(uint8_t mode)
{
  if (sys.state == STATE_CHECK_MODE) { return; }
 8003880:	46c0      	nop			; (mov r8, r8)
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.
  coolant_set_state(mode);
}
 8003882:	46bd      	mov	sp, r7
 8003884:	b002      	add	sp, #8
 8003886:	bd80      	pop	{r7, pc}
 8003888:	20000b2c 	.word	0x20000b2c

0800388c <eeprom_get_char>:
 *
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
 800388c:	b580      	push	{r7, lr}
 800388e:	b082      	sub	sp, #8
 8003890:	af00      	add	r7, sp, #0
 8003892:	6078      	str	r0, [r7, #4]
	EEAR = addr; // Set EEPROM address register.
	EECR = (1<<EERE); // Start EEPROM read operation.
	return EEDR; // Return the byte read from EEPROM.
#endif
#if defined(WIN32) || defined(STM32F103C8) || defined(STM32F0DISCOVERY)
	return EE_Buffer[addr];
 8003894:	4a03      	ldr	r2, [pc, #12]	; (80038a4 <eeprom_get_char+0x18>)
 8003896:	687b      	ldr	r3, [r7, #4]
 8003898:	18d3      	adds	r3, r2, r3
 800389a:	781b      	ldrb	r3, [r3, #0]
#endif
}
 800389c:	0018      	movs	r0, r3
 800389e:	46bd      	mov	sp, r7
 80038a0:	b002      	add	sp, #8
 80038a2:	bd80      	pop	{r7, pc}
 80038a4:	2000055c 	.word	0x2000055c

080038a8 <eeprom_put_char>:
 *
 *  \param  addr  EEPROM address to write to.
 *  \param  new_value  New EEPROM value.
 */
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
 80038a8:	b580      	push	{r7, lr}
 80038aa:	b082      	sub	sp, #8
 80038ac:	af00      	add	r7, sp, #0
 80038ae:	6078      	str	r0, [r7, #4]
 80038b0:	000a      	movs	r2, r1
 80038b2:	1cfb      	adds	r3, r7, #3
 80038b4:	701a      	strb	r2, [r3, #0]
	}
	
	sei(); // Restore interrupt flag state.
#endif
#if defined(WIN32) || defined(STM32F103C8) || defined(STM32F0DISCOVERY)
	EE_Buffer[addr] = new_value;
 80038b6:	4a05      	ldr	r2, [pc, #20]	; (80038cc <eeprom_put_char+0x24>)
 80038b8:	687b      	ldr	r3, [r7, #4]
 80038ba:	18d3      	adds	r3, r2, r3
 80038bc:	1cfa      	adds	r2, r7, #3
 80038be:	7812      	ldrb	r2, [r2, #0]
 80038c0:	701a      	strb	r2, [r3, #0]
#endif
}
 80038c2:	46c0      	nop			; (mov r8, r8)
 80038c4:	46bd      	mov	sp, r7
 80038c6:	b002      	add	sp, #8
 80038c8:	bd80      	pop	{r7, pc}
 80038ca:	46c0      	nop			; (mov r8, r8)
 80038cc:	2000055c 	.word	0x2000055c

080038d0 <memcpy_to_eeprom_with_checksum>:

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
 80038d0:	b580      	push	{r7, lr}
 80038d2:	b086      	sub	sp, #24
 80038d4:	af00      	add	r7, sp, #0
 80038d6:	60f8      	str	r0, [r7, #12]
 80038d8:	60b9      	str	r1, [r7, #8]
 80038da:	607a      	str	r2, [r7, #4]
  unsigned char checksum = 0;
 80038dc:	2317      	movs	r3, #23
 80038de:	18fb      	adds	r3, r7, r3
 80038e0:	2200      	movs	r2, #0
 80038e2:	701a      	strb	r2, [r3, #0]
  for(; size > 0; size--) { 
 80038e4:	e027      	b.n	8003936 <memcpy_to_eeprom_with_checksum+0x66>
    checksum = (checksum << 1) || (checksum >> 7);
 80038e6:	2317      	movs	r3, #23
 80038e8:	18fb      	adds	r3, r7, r3
 80038ea:	781b      	ldrb	r3, [r3, #0]
 80038ec:	005b      	lsls	r3, r3, #1
 80038ee:	d105      	bne.n	80038fc <memcpy_to_eeprom_with_checksum+0x2c>
 80038f0:	2317      	movs	r3, #23
 80038f2:	18fb      	adds	r3, r7, r3
 80038f4:	781b      	ldrb	r3, [r3, #0]
 80038f6:	b25b      	sxtb	r3, r3
 80038f8:	2b00      	cmp	r3, #0
 80038fa:	da01      	bge.n	8003900 <memcpy_to_eeprom_with_checksum+0x30>
 80038fc:	2201      	movs	r2, #1
 80038fe:	e000      	b.n	8003902 <memcpy_to_eeprom_with_checksum+0x32>
 8003900:	2200      	movs	r2, #0
 8003902:	2317      	movs	r3, #23
 8003904:	18fb      	adds	r3, r7, r3
 8003906:	701a      	strb	r2, [r3, #0]
    checksum += *source;
 8003908:	68bb      	ldr	r3, [r7, #8]
 800390a:	7819      	ldrb	r1, [r3, #0]
 800390c:	2317      	movs	r3, #23
 800390e:	18fb      	adds	r3, r7, r3
 8003910:	2217      	movs	r2, #23
 8003912:	18ba      	adds	r2, r7, r2
 8003914:	7812      	ldrb	r2, [r2, #0]
 8003916:	188a      	adds	r2, r1, r2
 8003918:	701a      	strb	r2, [r3, #0]
    eeprom_put_char(destination++, *(source++)); 
 800391a:	68fa      	ldr	r2, [r7, #12]
 800391c:	1c53      	adds	r3, r2, #1
 800391e:	60fb      	str	r3, [r7, #12]
 8003920:	68bb      	ldr	r3, [r7, #8]
 8003922:	1c59      	adds	r1, r3, #1
 8003924:	60b9      	str	r1, [r7, #8]
 8003926:	781b      	ldrb	r3, [r3, #0]
 8003928:	0019      	movs	r1, r3
 800392a:	0010      	movs	r0, r2
 800392c:	f7ff ffbc 	bl	80038a8 <eeprom_put_char>
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
 8003930:	687b      	ldr	r3, [r7, #4]
 8003932:	3b01      	subs	r3, #1
 8003934:	607b      	str	r3, [r7, #4]
 8003936:	687b      	ldr	r3, [r7, #4]
 8003938:	2b00      	cmp	r3, #0
 800393a:	d1d4      	bne.n	80038e6 <memcpy_to_eeprom_with_checksum+0x16>
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
 800393c:	2317      	movs	r3, #23
 800393e:	18fb      	adds	r3, r7, r3
 8003940:	781a      	ldrb	r2, [r3, #0]
 8003942:	68fb      	ldr	r3, [r7, #12]
 8003944:	0011      	movs	r1, r2
 8003946:	0018      	movs	r0, r3
 8003948:	f7ff ffae 	bl	80038a8 <eeprom_put_char>
#if defined(WIN32) || defined(STM32F103C8) || defined(STM32F0DISCOVERY)
#ifndef NOEEPROMSUPPORT
  eeprom_flush();
#endif
#endif
}
 800394c:	46c0      	nop			; (mov r8, r8)
 800394e:	46bd      	mov	sp, r7
 8003950:	b006      	add	sp, #24
 8003952:	bd80      	pop	{r7, pc}

08003954 <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
 8003954:	b590      	push	{r4, r7, lr}
 8003956:	b087      	sub	sp, #28
 8003958:	af00      	add	r7, sp, #0
 800395a:	60f8      	str	r0, [r7, #12]
 800395c:	60b9      	str	r1, [r7, #8]
 800395e:	607a      	str	r2, [r7, #4]
  unsigned char data, checksum = 0;
 8003960:	2317      	movs	r3, #23
 8003962:	18fb      	adds	r3, r7, r3
 8003964:	2200      	movs	r2, #0
 8003966:	701a      	strb	r2, [r3, #0]
  for(; size > 0; size--) { 
 8003968:	e02e      	b.n	80039c8 <memcpy_from_eeprom_with_checksum+0x74>
    data = eeprom_get_char(source++);
 800396a:	68bb      	ldr	r3, [r7, #8]
 800396c:	1c5a      	adds	r2, r3, #1
 800396e:	60ba      	str	r2, [r7, #8]
 8003970:	2216      	movs	r2, #22
 8003972:	18bc      	adds	r4, r7, r2
 8003974:	0018      	movs	r0, r3
 8003976:	f7ff ff89 	bl	800388c <eeprom_get_char>
 800397a:	0003      	movs	r3, r0
 800397c:	7023      	strb	r3, [r4, #0]
    checksum = (checksum << 1) || (checksum >> 7);
 800397e:	2317      	movs	r3, #23
 8003980:	18fb      	adds	r3, r7, r3
 8003982:	781b      	ldrb	r3, [r3, #0]
 8003984:	005b      	lsls	r3, r3, #1
 8003986:	d105      	bne.n	8003994 <memcpy_from_eeprom_with_checksum+0x40>
 8003988:	2317      	movs	r3, #23
 800398a:	18fb      	adds	r3, r7, r3
 800398c:	781b      	ldrb	r3, [r3, #0]
 800398e:	b25b      	sxtb	r3, r3
 8003990:	2b00      	cmp	r3, #0
 8003992:	da01      	bge.n	8003998 <memcpy_from_eeprom_with_checksum+0x44>
 8003994:	2201      	movs	r2, #1
 8003996:	e000      	b.n	800399a <memcpy_from_eeprom_with_checksum+0x46>
 8003998:	2200      	movs	r2, #0
 800399a:	2317      	movs	r3, #23
 800399c:	18fb      	adds	r3, r7, r3
 800399e:	701a      	strb	r2, [r3, #0]
    checksum += data;    
 80039a0:	2317      	movs	r3, #23
 80039a2:	18fb      	adds	r3, r7, r3
 80039a4:	2217      	movs	r2, #23
 80039a6:	18b9      	adds	r1, r7, r2
 80039a8:	2216      	movs	r2, #22
 80039aa:	18ba      	adds	r2, r7, r2
 80039ac:	7809      	ldrb	r1, [r1, #0]
 80039ae:	7812      	ldrb	r2, [r2, #0]
 80039b0:	188a      	adds	r2, r1, r2
 80039b2:	701a      	strb	r2, [r3, #0]
    *(destination++) = data; 
 80039b4:	68fb      	ldr	r3, [r7, #12]
 80039b6:	1c5a      	adds	r2, r3, #1
 80039b8:	60fa      	str	r2, [r7, #12]
 80039ba:	2216      	movs	r2, #22
 80039bc:	18ba      	adds	r2, r7, r2
 80039be:	7812      	ldrb	r2, [r2, #0]
 80039c0:	701a      	strb	r2, [r3, #0]
#endif
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
 80039c2:	687b      	ldr	r3, [r7, #4]
 80039c4:	3b01      	subs	r3, #1
 80039c6:	607b      	str	r3, [r7, #4]
 80039c8:	687b      	ldr	r3, [r7, #4]
 80039ca:	2b00      	cmp	r3, #0
 80039cc:	d1cd      	bne.n	800396a <memcpy_from_eeprom_with_checksum+0x16>
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
 80039ce:	68bb      	ldr	r3, [r7, #8]
 80039d0:	0018      	movs	r0, r3
 80039d2:	f7ff ff5b 	bl	800388c <eeprom_get_char>
 80039d6:	0003      	movs	r3, r0
 80039d8:	001a      	movs	r2, r3
 80039da:	2317      	movs	r3, #23
 80039dc:	18fb      	adds	r3, r7, r3
 80039de:	781b      	ldrb	r3, [r3, #0]
 80039e0:	1a9b      	subs	r3, r3, r2
 80039e2:	425a      	negs	r2, r3
 80039e4:	4153      	adcs	r3, r2
 80039e6:	b2db      	uxtb	r3, r3
}
 80039e8:	0018      	movs	r0, r3
 80039ea:	46bd      	mov	sp, r7
 80039ec:	b007      	add	sp, #28
 80039ee:	bd90      	pop	{r4, r7, pc}

080039f0 <gc_init>:

#define FAIL(status) return(status);


void gc_init()
{
 80039f0:	b580      	push	{r7, lr}
 80039f2:	af00      	add	r7, sp, #0
  memset(&gc_state, 0, sizeof(parser_state_t));
 80039f4:	4b0a      	ldr	r3, [pc, #40]	; (8003a20 <gc_init+0x30>)
 80039f6:	2244      	movs	r2, #68	; 0x44
 80039f8:	2100      	movs	r1, #0
 80039fa:	0018      	movs	r0, r3
 80039fc:	f008 fb80 	bl	800c100 <memset>

  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) {
 8003a00:	4b07      	ldr	r3, [pc, #28]	; (8003a20 <gc_init+0x30>)
 8003a02:	799b      	ldrb	r3, [r3, #6]
 8003a04:	4a07      	ldr	r2, [pc, #28]	; (8003a24 <gc_init+0x34>)
 8003a06:	0011      	movs	r1, r2
 8003a08:	0018      	movs	r0, r3
 8003a0a:	f005 fd9f 	bl	800954c <settings_read_coord_data>
 8003a0e:	1e03      	subs	r3, r0, #0
 8003a10:	d102      	bne.n	8003a18 <gc_init+0x28>
    report_status_message(STATUS_SETTING_READ_FAIL);
 8003a12:	2007      	movs	r0, #7
 8003a14:	f004 fc94 	bl	8008340 <report_status_message>
  }
}
 8003a18:	46c0      	nop			; (mov r8, r8)
 8003a1a:	46bd      	mov	sp, r7
 8003a1c:	bd80      	pop	{r7, pc}
 8003a1e:	46c0      	nop			; (mov r8, r8)
 8003a20:	2000095c 	.word	0x2000095c
 8003a24:	20000984 	.word	0x20000984

08003a28 <gc_sync_position>:


// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position()
{
 8003a28:	b580      	push	{r7, lr}
 8003a2a:	af00      	add	r7, sp, #0
  system_convert_array_steps_to_mpos(gc_state.position,sys_position);
 8003a2c:	4a04      	ldr	r2, [pc, #16]	; (8003a40 <gc_sync_position+0x18>)
 8003a2e:	4b05      	ldr	r3, [pc, #20]	; (8003a44 <gc_sync_position+0x1c>)
 8003a30:	0011      	movs	r1, r2
 8003a32:	0018      	movs	r0, r3
 8003a34:	f007 ff74 	bl	800b920 <system_convert_array_steps_to_mpos>
}
 8003a38:	46c0      	nop			; (mov r8, r8)
 8003a3a:	46bd      	mov	sp, r7
 8003a3c:	bd80      	pop	{r7, pc}
 8003a3e:	46c0      	nop			; (mov r8, r8)
 8003a40:	20000b50 	.word	0x20000b50
 8003a44:	20000978 	.word	0x20000978

08003a48 <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine
// coordinates, respectively.
uint8_t gc_execute_line(char *line)
{
 8003a48:	b5b0      	push	{r4, r5, r7, lr}
 8003a4a:	b09c      	sub	sp, #112	; 0x70
 8003a4c:	af06      	add	r7, sp, #24
 8003a4e:	6078      	str	r0, [r7, #4]
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
 8003a50:	4bd9      	ldr	r3, [pc, #868]	; (8003db8 <gc_execute_line+0x370>)
 8003a52:	2240      	movs	r2, #64	; 0x40
 8003a54:	2100      	movs	r1, #0
 8003a56:	0018      	movs	r0, r3
 8003a58:	f008 fb52 	bl	800c100 <memset>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
 8003a5c:	4bd6      	ldr	r3, [pc, #856]	; (8003db8 <gc_execute_line+0x370>)
 8003a5e:	2201      	movs	r2, #1
 8003a60:	49d6      	ldr	r1, [pc, #856]	; (8003dbc <gc_execute_line+0x374>)
 8003a62:	189b      	adds	r3, r3, r2
 8003a64:	220b      	movs	r2, #11
 8003a66:	0018      	movs	r0, r3
 8003a68:	f008 fb41 	bl	800c0ee <memcpy>

  uint8_t axis_command = AXIS_COMMAND_NONE;
 8003a6c:	2357      	movs	r3, #87	; 0x57
 8003a6e:	18fb      	adds	r3, r7, r3
 8003a70:	2200      	movs	r2, #0
 8003a72:	701a      	strb	r2, [r3, #0]
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
 8003a74:	2353      	movs	r3, #83	; 0x53
 8003a76:	18fb      	adds	r3, r7, r3
 8003a78:	2200      	movs	r2, #0
 8003a7a:	701a      	strb	r2, [r3, #0]

  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
 8003a7c:	2352      	movs	r3, #82	; 0x52
 8003a7e:	18fb      	adds	r3, r7, r3
 8003a80:	2200      	movs	r2, #0
 8003a82:	701a      	strb	r2, [r3, #0]
  uint8_t ijk_words = 0; // IJK tracking
 8003a84:	2351      	movs	r3, #81	; 0x51
 8003a86:	18fb      	adds	r3, r7, r3
 8003a88:	2200      	movs	r2, #0
 8003a8a:	701a      	strb	r2, [r3, #0]

  // Initialize command and value words and parser flags variables.
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
 8003a8c:	234e      	movs	r3, #78	; 0x4e
 8003a8e:	18fb      	adds	r3, r7, r3
 8003a90:	2200      	movs	r2, #0
 8003a92:	801a      	strh	r2, [r3, #0]
  uint16_t value_words = 0; // Tracks value words.
 8003a94:	234c      	movs	r3, #76	; 0x4c
 8003a96:	18fb      	adds	r3, r7, r3
 8003a98:	2200      	movs	r2, #0
 8003a9a:	801a      	strh	r2, [r3, #0]
  uint8_t gc_parser_flags = GC_PARSER_NONE;
 8003a9c:	234b      	movs	r3, #75	; 0x4b
 8003a9e:	18fb      	adds	r3, r7, r3
 8003aa0:	2200      	movs	r2, #0
 8003aa2:	701a      	strb	r2, [r3, #0]

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
 8003aa4:	687b      	ldr	r3, [r7, #4]
 8003aa6:	781b      	ldrb	r3, [r3, #0]
 8003aa8:	2b24      	cmp	r3, #36	; 0x24
 8003aaa:	d10d      	bne.n	8003ac8 <gc_execute_line+0x80>
						// Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
 8003aac:	234b      	movs	r3, #75	; 0x4b
 8003aae:	18fb      	adds	r3, r7, r3
 8003ab0:	224b      	movs	r2, #75	; 0x4b
 8003ab2:	18ba      	adds	r2, r7, r2
 8003ab4:	7812      	ldrb	r2, [r2, #0]
 8003ab6:	2101      	movs	r1, #1
 8003ab8:	430a      	orrs	r2, r1
 8003aba:	701a      	strb	r2, [r3, #0]
	gc_block.modal.motion = MOTION_MODE_LINEAR;
 8003abc:	4bbe      	ldr	r3, [pc, #760]	; (8003db8 <gc_execute_line+0x370>)
 8003abe:	2201      	movs	r2, #1
 8003ac0:	705a      	strb	r2, [r3, #1]
    gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
 8003ac2:	4bbd      	ldr	r3, [pc, #756]	; (8003db8 <gc_execute_line+0x370>)
 8003ac4:	2200      	movs	r2, #0
 8003ac6:	709a      	strb	r2, [r3, #2]

  uint8_t word_bit; // Bit-value for assigning tracking variables
  uint8_t char_counter;
  char letter;
  float value;
  uint8_t int_value = 0;
 8003ac8:	233e      	movs	r3, #62	; 0x3e
 8003aca:	18fb      	adds	r3, r7, r3
 8003acc:	2200      	movs	r2, #0
 8003ace:	701a      	strb	r2, [r3, #0]
  uint16_t mantissa = 0;
 8003ad0:	2348      	movs	r3, #72	; 0x48
 8003ad2:	18fb      	adds	r3, r7, r3
 8003ad4:	2200      	movs	r2, #0
 8003ad6:	801a      	strh	r2, [r3, #0]
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
 8003ad8:	234b      	movs	r3, #75	; 0x4b
 8003ada:	18fb      	adds	r3, r7, r3
 8003adc:	781b      	ldrb	r3, [r3, #0]
 8003ade:	2201      	movs	r2, #1
 8003ae0:	4013      	ands	r3, r2
 8003ae2:	d005      	beq.n	8003af0 <gc_execute_line+0xa8>
 8003ae4:	2326      	movs	r3, #38	; 0x26
 8003ae6:	18fb      	adds	r3, r7, r3
 8003ae8:	2203      	movs	r2, #3
 8003aea:	701a      	strb	r2, [r3, #0]
 8003aec:	f000 fb82 	bl	80041f4 <gc_execute_line+0x7ac>
  else { char_counter = 0; }
 8003af0:	2326      	movs	r3, #38	; 0x26
 8003af2:	18fb      	adds	r3, r7, r3
 8003af4:	2200      	movs	r2, #0
 8003af6:	701a      	strb	r2, [r3, #0]

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
 8003af8:	f000 fb7c 	bl	80041f4 <gc_execute_line+0x7ac>

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
 8003afc:	2326      	movs	r3, #38	; 0x26
 8003afe:	18fb      	adds	r3, r7, r3
 8003b00:	781b      	ldrb	r3, [r3, #0]
 8003b02:	001a      	movs	r2, r3
 8003b04:	687b      	ldr	r3, [r7, #4]
 8003b06:	189a      	adds	r2, r3, r2
 8003b08:	233d      	movs	r3, #61	; 0x3d
 8003b0a:	18fb      	adds	r3, r7, r3
 8003b0c:	7812      	ldrb	r2, [r2, #0]
 8003b0e:	701a      	strb	r2, [r3, #0]
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
 8003b10:	233d      	movs	r3, #61	; 0x3d
 8003b12:	18fb      	adds	r3, r7, r3
 8003b14:	781b      	ldrb	r3, [r3, #0]
 8003b16:	2b40      	cmp	r3, #64	; 0x40
 8003b18:	d904      	bls.n	8003b24 <gc_execute_line+0xdc>
 8003b1a:	233d      	movs	r3, #61	; 0x3d
 8003b1c:	18fb      	adds	r3, r7, r3
 8003b1e:	781b      	ldrb	r3, [r3, #0]
 8003b20:	2b5a      	cmp	r3, #90	; 0x5a
 8003b22:	d902      	bls.n	8003b2a <gc_execute_line+0xe2>
 8003b24:	2301      	movs	r3, #1
 8003b26:	f001 fca3 	bl	8005470 <gc_execute_line+0x1a28>
    char_counter++;
 8003b2a:	2326      	movs	r3, #38	; 0x26
 8003b2c:	18fb      	adds	r3, r7, r3
 8003b2e:	781b      	ldrb	r3, [r3, #0]
 8003b30:	3301      	adds	r3, #1
 8003b32:	b2da      	uxtb	r2, r3
 8003b34:	2326      	movs	r3, #38	; 0x26
 8003b36:	18fb      	adds	r3, r7, r3
 8003b38:	701a      	strb	r2, [r3, #0]
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
 8003b3a:	2320      	movs	r3, #32
 8003b3c:	18fa      	adds	r2, r7, r3
 8003b3e:	2326      	movs	r3, #38	; 0x26
 8003b40:	18f9      	adds	r1, r7, r3
 8003b42:	687b      	ldr	r3, [r7, #4]
 8003b44:	0018      	movs	r0, r3
 8003b46:	f002 fc11 	bl	800636c <read_float>
 8003b4a:	1e03      	subs	r3, r0, #0
 8003b4c:	d102      	bne.n	8003b54 <gc_execute_line+0x10c>
 8003b4e:	2302      	movs	r3, #2
 8003b50:	f001 fc8e 	bl	8005470 <gc_execute_line+0x1a28>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant,
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later.
    int_value = trunc(value);
 8003b54:	6a3b      	ldr	r3, [r7, #32]
 8003b56:	1c18      	adds	r0, r3, #0
 8003b58:	f7fe fd8e 	bl	8002678 <__aeabi_f2d>
 8003b5c:	0003      	movs	r3, r0
 8003b5e:	000c      	movs	r4, r1
 8003b60:	0018      	movs	r0, r3
 8003b62:	0021      	movs	r1, r4
 8003b64:	f008 fb1a 	bl	800c19c <trunc>
 8003b68:	0002      	movs	r2, r0
 8003b6a:	000b      	movs	r3, r1
 8003b6c:	213e      	movs	r1, #62	; 0x3e
 8003b6e:	187c      	adds	r4, r7, r1
 8003b70:	0010      	movs	r0, r2
 8003b72:	0019      	movs	r1, r3
 8003b74:	f7fc fbee 	bl	8000354 <__aeabi_d2uiz>
 8003b78:	0003      	movs	r3, r0
 8003b7a:	7023      	strb	r3, [r4, #0]
	mantissa = (uint16_t)roundf(100 * (value - int_value)); // Compute mantissa for Gxx.x commands.
 8003b7c:	6a3c      	ldr	r4, [r7, #32]
 8003b7e:	233e      	movs	r3, #62	; 0x3e
 8003b80:	18fb      	adds	r3, r7, r3
 8003b82:	781b      	ldrb	r3, [r3, #0]
 8003b84:	0018      	movs	r0, r3
 8003b86:	f7fd fa17 	bl	8000fb8 <__aeabi_i2f>
 8003b8a:	1c03      	adds	r3, r0, #0
 8003b8c:	1c19      	adds	r1, r3, #0
 8003b8e:	1c20      	adds	r0, r4, #0
 8003b90:	f7fd f852 	bl	8000c38 <__aeabi_fsub>
 8003b94:	1c03      	adds	r3, r0, #0
 8003b96:	498a      	ldr	r1, [pc, #552]	; (8003dc0 <gc_execute_line+0x378>)
 8003b98:	1c18      	adds	r0, r3, #0
 8003b9a:	f7fc ff39 	bl	8000a10 <__aeabi_fmul>
 8003b9e:	1c03      	adds	r3, r0, #0
 8003ba0:	1c18      	adds	r0, r3, #0
 8003ba2:	f008 fbe1 	bl	800c368 <roundf>
 8003ba6:	1c03      	adds	r3, r0, #0
 8003ba8:	2248      	movs	r2, #72	; 0x48
 8003baa:	18bc      	adds	r4, r7, r2
 8003bac:	1c18      	adds	r0, r3, #0
 8003bae:	f7fc fbb9 	bl	8000324 <__aeabi_f2uiz>
 8003bb2:	0003      	movs	r3, r0
 8003bb4:	8023      	strh	r3, [r4, #0]
    // NOTE: Rounding must be used to catch small floating point errors.

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
 8003bb6:	233d      	movs	r3, #61	; 0x3d
 8003bb8:	18fb      	adds	r3, r7, r3
 8003bba:	781b      	ldrb	r3, [r3, #0]
 8003bbc:	2b47      	cmp	r3, #71	; 0x47
 8003bbe:	d003      	beq.n	8003bc8 <gc_execute_line+0x180>
 8003bc0:	2b4d      	cmp	r3, #77	; 0x4d
 8003bc2:	d100      	bne.n	8003bc6 <gc_execute_line+0x17e>
 8003bc4:	e177      	b.n	8003eb6 <gc_execute_line+0x46e>
 8003bc6:	e20a      	b.n	8003fde <gc_execute_line+0x596>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */

      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
 8003bc8:	233e      	movs	r3, #62	; 0x3e
 8003bca:	18fb      	adds	r3, r7, r3
 8003bcc:	781b      	ldrb	r3, [r3, #0]
 8003bce:	2b5e      	cmp	r3, #94	; 0x5e
 8003bd0:	d900      	bls.n	8003bd4 <gc_execute_line+0x18c>
 8003bd2:	e12f      	b.n	8003e34 <gc_execute_line+0x3ec>
 8003bd4:	009a      	lsls	r2, r3, #2
 8003bd6:	4b7b      	ldr	r3, [pc, #492]	; (8003dc4 <gc_execute_line+0x37c>)
 8003bd8:	18d3      	adds	r3, r2, r3
 8003bda:	681b      	ldr	r3, [r3, #0]
 8003bdc:	469f      	mov	pc, r3
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
 8003bde:	2348      	movs	r3, #72	; 0x48
 8003be0:	18fb      	adds	r3, r7, r3
 8003be2:	881b      	ldrh	r3, [r3, #0]
 8003be4:	2b00      	cmp	r3, #0
 8003be6:	d10b      	bne.n	8003c00 <gc_execute_line+0x1b8>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
 8003be8:	2357      	movs	r3, #87	; 0x57
 8003bea:	18fb      	adds	r3, r7, r3
 8003bec:	781b      	ldrb	r3, [r3, #0]
 8003bee:	2b00      	cmp	r3, #0
 8003bf0:	d002      	beq.n	8003bf8 <gc_execute_line+0x1b0>
 8003bf2:	2318      	movs	r3, #24
 8003bf4:	f001 fc3c 	bl	8005470 <gc_execute_line+0x1a28>
              axis_command = AXIS_COMMAND_NON_MODAL;
 8003bf8:	2357      	movs	r3, #87	; 0x57
 8003bfa:	18fb      	adds	r3, r7, r3
 8003bfc:	2201      	movs	r2, #1
 8003bfe:	701a      	strb	r2, [r3, #0]
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
 8003c00:	234a      	movs	r3, #74	; 0x4a
 8003c02:	18fb      	adds	r3, r7, r3
 8003c04:	2200      	movs	r2, #0
 8003c06:	701a      	strb	r2, [r3, #0]
            gc_block.non_modal_command = int_value;
 8003c08:	4b6b      	ldr	r3, [pc, #428]	; (8003db8 <gc_execute_line+0x370>)
 8003c0a:	223e      	movs	r2, #62	; 0x3e
 8003c0c:	18ba      	adds	r2, r7, r2
 8003c0e:	7812      	ldrb	r2, [r2, #0]
 8003c10:	701a      	strb	r2, [r3, #0]
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
 8003c12:	233e      	movs	r3, #62	; 0x3e
 8003c14:	18fb      	adds	r3, r7, r3
 8003c16:	781b      	ldrb	r3, [r3, #0]
 8003c18:	2b1c      	cmp	r3, #28
 8003c1a:	d00a      	beq.n	8003c32 <gc_execute_line+0x1ea>
 8003c1c:	233e      	movs	r3, #62	; 0x3e
 8003c1e:	18fb      	adds	r3, r7, r3
 8003c20:	781b      	ldrb	r3, [r3, #0]
 8003c22:	2b1e      	cmp	r3, #30
 8003c24:	d005      	beq.n	8003c32 <gc_execute_line+0x1ea>
 8003c26:	233e      	movs	r3, #62	; 0x3e
 8003c28:	18fb      	adds	r3, r7, r3
 8003c2a:	781b      	ldrb	r3, [r3, #0]
 8003c2c:	2b5c      	cmp	r3, #92	; 0x5c
 8003c2e:	d000      	beq.n	8003c32 <gc_execute_line+0x1ea>
 8003c30:	e103      	b.n	8003e3a <gc_execute_line+0x3f2>
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
 8003c32:	2348      	movs	r3, #72	; 0x48
 8003c34:	18fb      	adds	r3, r7, r3
 8003c36:	881b      	ldrh	r3, [r3, #0]
 8003c38:	2b00      	cmp	r3, #0
 8003c3a:	d007      	beq.n	8003c4c <gc_execute_line+0x204>
 8003c3c:	2348      	movs	r3, #72	; 0x48
 8003c3e:	18fb      	adds	r3, r7, r3
 8003c40:	881b      	ldrh	r3, [r3, #0]
 8003c42:	2b0a      	cmp	r3, #10
 8003c44:	d002      	beq.n	8003c4c <gc_execute_line+0x204>
 8003c46:	2314      	movs	r3, #20
 8003c48:	f001 fc12 	bl	8005470 <gc_execute_line+0x1a28>
              gc_block.non_modal_command += mantissa;
 8003c4c:	4b5a      	ldr	r3, [pc, #360]	; (8003db8 <gc_execute_line+0x370>)
 8003c4e:	781a      	ldrb	r2, [r3, #0]
 8003c50:	2348      	movs	r3, #72	; 0x48
 8003c52:	18fb      	adds	r3, r7, r3
 8003c54:	881b      	ldrh	r3, [r3, #0]
 8003c56:	b2db      	uxtb	r3, r3
 8003c58:	18d3      	adds	r3, r2, r3
 8003c5a:	b2da      	uxtb	r2, r3
 8003c5c:	4b56      	ldr	r3, [pc, #344]	; (8003db8 <gc_execute_line+0x370>)
 8003c5e:	701a      	strb	r2, [r3, #0]
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
 8003c60:	2348      	movs	r3, #72	; 0x48
 8003c62:	18fb      	adds	r3, r7, r3
 8003c64:	2200      	movs	r2, #0
 8003c66:	801a      	strh	r2, [r3, #0]
            }                
            break;
 8003c68:	e0e7      	b.n	8003e3a <gc_execute_line+0x3f2>
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
 8003c6a:	2357      	movs	r3, #87	; 0x57
 8003c6c:	18fb      	adds	r3, r7, r3
 8003c6e:	781b      	ldrb	r3, [r3, #0]
 8003c70:	2b00      	cmp	r3, #0
 8003c72:	d002      	beq.n	8003c7a <gc_execute_line+0x232>
 8003c74:	2318      	movs	r3, #24
 8003c76:	f001 fbfb 	bl	8005470 <gc_execute_line+0x1a28>
            axis_command = AXIS_COMMAND_MOTION_MODE;
 8003c7a:	2357      	movs	r3, #87	; 0x57
 8003c7c:	18fb      	adds	r3, r7, r3
 8003c7e:	2202      	movs	r2, #2
 8003c80:	701a      	strb	r2, [r3, #0]
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
 8003c82:	234a      	movs	r3, #74	; 0x4a
 8003c84:	18fb      	adds	r3, r7, r3
 8003c86:	2201      	movs	r2, #1
 8003c88:	701a      	strb	r2, [r3, #0]
            gc_block.modal.motion = int_value;
 8003c8a:	4b4b      	ldr	r3, [pc, #300]	; (8003db8 <gc_execute_line+0x370>)
 8003c8c:	223e      	movs	r2, #62	; 0x3e
 8003c8e:	18ba      	adds	r2, r7, r2
 8003c90:	7812      	ldrb	r2, [r2, #0]
 8003c92:	705a      	strb	r2, [r3, #1]
            if (int_value == 38){
 8003c94:	233e      	movs	r3, #62	; 0x3e
 8003c96:	18fb      	adds	r3, r7, r3
 8003c98:	781b      	ldrb	r3, [r3, #0]
 8003c9a:	2b26      	cmp	r3, #38	; 0x26
 8003c9c:	d000      	beq.n	8003ca0 <gc_execute_line+0x258>
 8003c9e:	e0ce      	b.n	8003e3e <gc_execute_line+0x3f6>
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
 8003ca0:	2348      	movs	r3, #72	; 0x48
 8003ca2:	18fb      	adds	r3, r7, r3
 8003ca4:	881b      	ldrh	r3, [r3, #0]
 8003ca6:	2b14      	cmp	r3, #20
 8003ca8:	d011      	beq.n	8003cce <gc_execute_line+0x286>
 8003caa:	2348      	movs	r3, #72	; 0x48
 8003cac:	18fb      	adds	r3, r7, r3
 8003cae:	881b      	ldrh	r3, [r3, #0]
 8003cb0:	2b1e      	cmp	r3, #30
 8003cb2:	d00c      	beq.n	8003cce <gc_execute_line+0x286>
 8003cb4:	2348      	movs	r3, #72	; 0x48
 8003cb6:	18fb      	adds	r3, r7, r3
 8003cb8:	881b      	ldrh	r3, [r3, #0]
 8003cba:	2b28      	cmp	r3, #40	; 0x28
 8003cbc:	d007      	beq.n	8003cce <gc_execute_line+0x286>
 8003cbe:	2348      	movs	r3, #72	; 0x48
 8003cc0:	18fb      	adds	r3, r7, r3
 8003cc2:	881b      	ldrh	r3, [r3, #0]
 8003cc4:	2b32      	cmp	r3, #50	; 0x32
 8003cc6:	d002      	beq.n	8003cce <gc_execute_line+0x286>
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
 8003cc8:	2314      	movs	r3, #20
 8003cca:	f001 fbd1 	bl	8005470 <gc_execute_line+0x1a28>
              }
              gc_block.modal.motion += (mantissa/10)+100;
 8003cce:	4b3a      	ldr	r3, [pc, #232]	; (8003db8 <gc_execute_line+0x370>)
 8003cd0:	785c      	ldrb	r4, [r3, #1]
 8003cd2:	2348      	movs	r3, #72	; 0x48
 8003cd4:	18fb      	adds	r3, r7, r3
 8003cd6:	881b      	ldrh	r3, [r3, #0]
 8003cd8:	210a      	movs	r1, #10
 8003cda:	0018      	movs	r0, r3
 8003cdc:	f7fc fa1e 	bl	800011c <__aeabi_uidiv>
 8003ce0:	0003      	movs	r3, r0
 8003ce2:	b29b      	uxth	r3, r3
 8003ce4:	b2db      	uxtb	r3, r3
 8003ce6:	18e3      	adds	r3, r4, r3
 8003ce8:	b2db      	uxtb	r3, r3
 8003cea:	3364      	adds	r3, #100	; 0x64
 8003cec:	b2da      	uxtb	r2, r3
 8003cee:	4b32      	ldr	r3, [pc, #200]	; (8003db8 <gc_execute_line+0x370>)
 8003cf0:	705a      	strb	r2, [r3, #1]
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
 8003cf2:	2348      	movs	r3, #72	; 0x48
 8003cf4:	18fb      	adds	r3, r7, r3
 8003cf6:	2200      	movs	r2, #0
 8003cf8:	801a      	strh	r2, [r3, #0]
            }  
            break;
 8003cfa:	e0a0      	b.n	8003e3e <gc_execute_line+0x3f6>
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
 8003cfc:	234a      	movs	r3, #74	; 0x4a
 8003cfe:	18fb      	adds	r3, r7, r3
 8003d00:	2202      	movs	r2, #2
 8003d02:	701a      	strb	r2, [r3, #0]
            gc_block.modal.plane_select = int_value - 17;
 8003d04:	233e      	movs	r3, #62	; 0x3e
 8003d06:	18fb      	adds	r3, r7, r3
 8003d08:	781b      	ldrb	r3, [r3, #0]
 8003d0a:	3b11      	subs	r3, #17
 8003d0c:	b2da      	uxtb	r2, r3
 8003d0e:	4b2a      	ldr	r3, [pc, #168]	; (8003db8 <gc_execute_line+0x370>)
 8003d10:	715a      	strb	r2, [r3, #5]
            break;
 8003d12:	e097      	b.n	8003e44 <gc_execute_line+0x3fc>
          case 90: case 91:
            if (mantissa == 0) {
 8003d14:	2348      	movs	r3, #72	; 0x48
 8003d16:	18fb      	adds	r3, r7, r3
 8003d18:	881b      	ldrh	r3, [r3, #0]
 8003d1a:	2b00      	cmp	r3, #0
 8003d1c:	d10b      	bne.n	8003d36 <gc_execute_line+0x2ee>
              word_bit = MODAL_GROUP_G3;
 8003d1e:	234a      	movs	r3, #74	; 0x4a
 8003d20:	18fb      	adds	r3, r7, r3
 8003d22:	2203      	movs	r2, #3
 8003d24:	701a      	strb	r2, [r3, #0]
              gc_block.modal.distance = int_value - 90;
 8003d26:	233e      	movs	r3, #62	; 0x3e
 8003d28:	18fb      	adds	r3, r7, r3
 8003d2a:	781b      	ldrb	r3, [r3, #0]
 8003d2c:	3b5a      	subs	r3, #90	; 0x5a
 8003d2e:	b2da      	uxtb	r2, r3
 8003d30:	4b21      	ldr	r3, [pc, #132]	; (8003db8 <gc_execute_line+0x370>)
 8003d32:	711a      	strb	r2, [r3, #4]
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
 8003d34:	e086      	b.n	8003e44 <gc_execute_line+0x3fc>
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
 8003d36:	234a      	movs	r3, #74	; 0x4a
 8003d38:	18fb      	adds	r3, r7, r3
 8003d3a:	2204      	movs	r2, #4
 8003d3c:	701a      	strb	r2, [r3, #0]
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
 8003d3e:	2348      	movs	r3, #72	; 0x48
 8003d40:	18fb      	adds	r3, r7, r3
 8003d42:	881b      	ldrh	r3, [r3, #0]
 8003d44:	2b0a      	cmp	r3, #10
 8003d46:	d104      	bne.n	8003d52 <gc_execute_line+0x30a>
 8003d48:	233e      	movs	r3, #62	; 0x3e
 8003d4a:	18fb      	adds	r3, r7, r3
 8003d4c:	781b      	ldrb	r3, [r3, #0]
 8003d4e:	2b5a      	cmp	r3, #90	; 0x5a
 8003d50:	d102      	bne.n	8003d58 <gc_execute_line+0x310>
 8003d52:	2314      	movs	r3, #20
 8003d54:	f001 fb8c 	bl	8005470 <gc_execute_line+0x1a28>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
 8003d58:	2348      	movs	r3, #72	; 0x48
 8003d5a:	18fb      	adds	r3, r7, r3
 8003d5c:	2200      	movs	r2, #0
 8003d5e:	801a      	strh	r2, [r3, #0]
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
 8003d60:	e070      	b.n	8003e44 <gc_execute_line+0x3fc>
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
 8003d62:	234a      	movs	r3, #74	; 0x4a
 8003d64:	18fb      	adds	r3, r7, r3
 8003d66:	2205      	movs	r2, #5
 8003d68:	701a      	strb	r2, [r3, #0]
            gc_block.modal.feed_rate = 94 - int_value;
 8003d6a:	233e      	movs	r3, #62	; 0x3e
 8003d6c:	18fb      	adds	r3, r7, r3
 8003d6e:	781b      	ldrb	r3, [r3, #0]
 8003d70:	225e      	movs	r2, #94	; 0x5e
 8003d72:	1ad3      	subs	r3, r2, r3
 8003d74:	b2da      	uxtb	r2, r3
 8003d76:	4b10      	ldr	r3, [pc, #64]	; (8003db8 <gc_execute_line+0x370>)
 8003d78:	709a      	strb	r2, [r3, #2]
            break;
 8003d7a:	e063      	b.n	8003e44 <gc_execute_line+0x3fc>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
 8003d7c:	234a      	movs	r3, #74	; 0x4a
 8003d7e:	18fb      	adds	r3, r7, r3
 8003d80:	2206      	movs	r2, #6
 8003d82:	701a      	strb	r2, [r3, #0]
            gc_block.modal.units = 21 - int_value;
 8003d84:	233e      	movs	r3, #62	; 0x3e
 8003d86:	18fb      	adds	r3, r7, r3
 8003d88:	781b      	ldrb	r3, [r3, #0]
 8003d8a:	2215      	movs	r2, #21
 8003d8c:	1ad3      	subs	r3, r2, r3
 8003d8e:	b2da      	uxtb	r2, r3
 8003d90:	4b09      	ldr	r3, [pc, #36]	; (8003db8 <gc_execute_line+0x370>)
 8003d92:	70da      	strb	r2, [r3, #3]
            break;
 8003d94:	e056      	b.n	8003e44 <gc_execute_line+0x3fc>
          case 40:
            word_bit = MODAL_GROUP_G7;
 8003d96:	234a      	movs	r3, #74	; 0x4a
 8003d98:	18fb      	adds	r3, r7, r3
 8003d9a:	2207      	movs	r2, #7
 8003d9c:	701a      	strb	r2, [r3, #0]
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
 8003d9e:	e051      	b.n	8003e44 <gc_execute_line+0x3fc>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
 8003da0:	234a      	movs	r3, #74	; 0x4a
 8003da2:	18fb      	adds	r3, r7, r3
 8003da4:	2208      	movs	r2, #8
 8003da6:	701a      	strb	r2, [r3, #0]
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
 8003da8:	2357      	movs	r3, #87	; 0x57
 8003daa:	18fb      	adds	r3, r7, r3
 8003dac:	781b      	ldrb	r3, [r3, #0]
 8003dae:	2b00      	cmp	r3, #0
 8003db0:	d00a      	beq.n	8003dc8 <gc_execute_line+0x380>
 8003db2:	2318      	movs	r3, #24
 8003db4:	f001 fb5c 	bl	8005470 <gc_execute_line+0x1a28>
 8003db8:	200009a0 	.word	0x200009a0
 8003dbc:	2000095c 	.word	0x2000095c
 8003dc0:	42c80000 	.word	0x42c80000
 8003dc4:	0800d70c 	.word	0x0800d70c
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
 8003dc8:	2357      	movs	r3, #87	; 0x57
 8003dca:	18fb      	adds	r3, r7, r3
 8003dcc:	2203      	movs	r2, #3
 8003dce:	701a      	strb	r2, [r3, #0]
            if (int_value == 49) { // G49
 8003dd0:	233e      	movs	r3, #62	; 0x3e
 8003dd2:	18fb      	adds	r3, r7, r3
 8003dd4:	781b      	ldrb	r3, [r3, #0]
 8003dd6:	2b31      	cmp	r3, #49	; 0x31
 8003dd8:	d103      	bne.n	8003de2 <gc_execute_line+0x39a>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
 8003dda:	4bd2      	ldr	r3, [pc, #840]	; (8004124 <gc_execute_line+0x6dc>)
 8003ddc:	2200      	movs	r2, #0
 8003dde:	719a      	strb	r2, [r3, #6]
 8003de0:	e00b      	b.n	8003dfa <gc_execute_line+0x3b2>
            } else if (mantissa == 10) { // G43.1
 8003de2:	2348      	movs	r3, #72	; 0x48
 8003de4:	18fb      	adds	r3, r7, r3
 8003de6:	881b      	ldrh	r3, [r3, #0]
 8003de8:	2b0a      	cmp	r3, #10
 8003dea:	d103      	bne.n	8003df4 <gc_execute_line+0x3ac>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
 8003dec:	4bcd      	ldr	r3, [pc, #820]	; (8004124 <gc_execute_line+0x6dc>)
 8003dee:	2201      	movs	r2, #1
 8003df0:	719a      	strb	r2, [r3, #6]
 8003df2:	e002      	b.n	8003dfa <gc_execute_line+0x3b2>
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
 8003df4:	2314      	movs	r3, #20
 8003df6:	f001 fb3b 	bl	8005470 <gc_execute_line+0x1a28>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
 8003dfa:	2348      	movs	r3, #72	; 0x48
 8003dfc:	18fb      	adds	r3, r7, r3
 8003dfe:	2200      	movs	r2, #0
 8003e00:	801a      	strh	r2, [r3, #0]
            break;
 8003e02:	e01f      	b.n	8003e44 <gc_execute_line+0x3fc>
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
 8003e04:	234a      	movs	r3, #74	; 0x4a
 8003e06:	18fb      	adds	r3, r7, r3
 8003e08:	2209      	movs	r2, #9
 8003e0a:	701a      	strb	r2, [r3, #0]
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
 8003e0c:	233e      	movs	r3, #62	; 0x3e
 8003e0e:	18fb      	adds	r3, r7, r3
 8003e10:	781b      	ldrb	r3, [r3, #0]
 8003e12:	3b36      	subs	r3, #54	; 0x36
 8003e14:	b2da      	uxtb	r2, r3
 8003e16:	4bc3      	ldr	r3, [pc, #780]	; (8004124 <gc_execute_line+0x6dc>)
 8003e18:	71da      	strb	r2, [r3, #7]
            break;
 8003e1a:	e013      	b.n	8003e44 <gc_execute_line+0x3fc>
          case 61:
            word_bit = MODAL_GROUP_G13;
 8003e1c:	234a      	movs	r3, #74	; 0x4a
 8003e1e:	18fb      	adds	r3, r7, r3
 8003e20:	220a      	movs	r2, #10
 8003e22:	701a      	strb	r2, [r3, #0]
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
 8003e24:	2348      	movs	r3, #72	; 0x48
 8003e26:	18fb      	adds	r3, r7, r3
 8003e28:	881b      	ldrh	r3, [r3, #0]
 8003e2a:	2b00      	cmp	r3, #0
 8003e2c:	d009      	beq.n	8003e42 <gc_execute_line+0x3fa>
 8003e2e:	2314      	movs	r3, #20
 8003e30:	f001 fb1e 	bl	8005470 <gc_execute_line+0x1a28>
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
 8003e34:	2314      	movs	r3, #20
 8003e36:	f001 fb1b 	bl	8005470 <gc_execute_line+0x1a28>
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
              gc_block.non_modal_command += mantissa;
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }                
            break;
 8003e3a:	46c0      	nop			; (mov r8, r8)
 8003e3c:	e002      	b.n	8003e44 <gc_execute_line+0x3fc>
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
              }
              gc_block.modal.motion += (mantissa/10)+100;
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
 8003e3e:	46c0      	nop			; (mov r8, r8)
 8003e40:	e000      	b.n	8003e44 <gc_execute_line+0x3fc>
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
 8003e42:	46c0      	nop			; (mov r8, r8)
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
 8003e44:	2348      	movs	r3, #72	; 0x48
 8003e46:	18fb      	adds	r3, r7, r3
 8003e48:	881b      	ldrh	r3, [r3, #0]
 8003e4a:	2b00      	cmp	r3, #0
 8003e4c:	d002      	beq.n	8003e54 <gc_execute_line+0x40c>
 8003e4e:	2317      	movs	r3, #23
 8003e50:	f001 fb0e 	bl	8005470 <gc_execute_line+0x1a28>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
 8003e54:	234e      	movs	r3, #78	; 0x4e
 8003e56:	18fb      	adds	r3, r7, r3
 8003e58:	881a      	ldrh	r2, [r3, #0]
 8003e5a:	234a      	movs	r3, #74	; 0x4a
 8003e5c:	18fb      	adds	r3, r7, r3
 8003e5e:	781b      	ldrb	r3, [r3, #0]
 8003e60:	411a      	asrs	r2, r3
 8003e62:	0013      	movs	r3, r2
 8003e64:	2201      	movs	r2, #1
 8003e66:	4013      	ands	r3, r2
 8003e68:	d002      	beq.n	8003e70 <gc_execute_line+0x428>
 8003e6a:	2315      	movs	r3, #21
 8003e6c:	f001 fb00 	bl	8005470 <gc_execute_line+0x1a28>
        command_words |= bit(word_bit);
 8003e70:	234a      	movs	r3, #74	; 0x4a
 8003e72:	18fb      	adds	r3, r7, r3
 8003e74:	781b      	ldrb	r3, [r3, #0]
 8003e76:	2201      	movs	r2, #1
 8003e78:	409a      	lsls	r2, r3
 8003e7a:	0013      	movs	r3, r2
 8003e7c:	b21a      	sxth	r2, r3
 8003e7e:	234e      	movs	r3, #78	; 0x4e
 8003e80:	18fb      	adds	r3, r7, r3
 8003e82:	2100      	movs	r1, #0
 8003e84:	5e5b      	ldrsh	r3, [r3, r1]
 8003e86:	4313      	orrs	r3, r2
 8003e88:	b21a      	sxth	r2, r3
 8003e8a:	234e      	movs	r3, #78	; 0x4e
 8003e8c:	18fb      	adds	r3, r7, r3
 8003e8e:	801a      	strh	r2, [r3, #0]
 8003e90:	2352      	movs	r3, #82	; 0x52
 8003e92:	18fb      	adds	r3, r7, r3
 8003e94:	2252      	movs	r2, #82	; 0x52
 8003e96:	18ba      	adds	r2, r7, r2
 8003e98:	7812      	ldrb	r2, [r2, #0]
 8003e9a:	701a      	strb	r2, [r3, #0]
 8003e9c:	2351      	movs	r3, #81	; 0x51
 8003e9e:	18fb      	adds	r3, r7, r3
 8003ea0:	2251      	movs	r2, #81	; 0x51
 8003ea2:	18ba      	adds	r2, r7, r2
 8003ea4:	7812      	ldrb	r2, [r2, #0]
 8003ea6:	701a      	strb	r2, [r3, #0]
 8003ea8:	234c      	movs	r3, #76	; 0x4c
 8003eaa:	18fb      	adds	r3, r7, r3
 8003eac:	224c      	movs	r2, #76	; 0x4c
 8003eae:	18ba      	adds	r2, r7, r2
 8003eb0:	8812      	ldrh	r2, [r2, #0]
 8003eb2:	801a      	strh	r2, [r3, #0]
        break;
 8003eb4:	e19e      	b.n	80041f4 <gc_execute_line+0x7ac>

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
 8003eb6:	2348      	movs	r3, #72	; 0x48
 8003eb8:	18fb      	adds	r3, r7, r3
 8003eba:	881b      	ldrh	r3, [r3, #0]
 8003ebc:	2b00      	cmp	r3, #0
 8003ebe:	d002      	beq.n	8003ec6 <gc_execute_line+0x47e>
 8003ec0:	2317      	movs	r3, #23
 8003ec2:	f001 fad5 	bl	8005470 <gc_execute_line+0x1a28>
        switch(int_value) {
 8003ec6:	233e      	movs	r3, #62	; 0x3e
 8003ec8:	18fb      	adds	r3, r7, r3
 8003eca:	781b      	ldrb	r3, [r3, #0]
 8003ecc:	2b1e      	cmp	r3, #30
 8003ece:	d84c      	bhi.n	8003f6a <gc_execute_line+0x522>
 8003ed0:	009a      	lsls	r2, r3, #2
 8003ed2:	4b95      	ldr	r3, [pc, #596]	; (8004128 <gc_execute_line+0x6e0>)
 8003ed4:	18d3      	adds	r3, r2, r3
 8003ed6:	681b      	ldr	r3, [r3, #0]
 8003ed8:	469f      	mov	pc, r3
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
 8003eda:	234a      	movs	r3, #74	; 0x4a
 8003edc:	18fb      	adds	r3, r7, r3
 8003ede:	220b      	movs	r2, #11
 8003ee0:	701a      	strb	r2, [r3, #0]
            switch(int_value) {
 8003ee2:	233e      	movs	r3, #62	; 0x3e
 8003ee4:	18fb      	adds	r3, r7, r3
 8003ee6:	781b      	ldrb	r3, [r3, #0]
 8003ee8:	2b00      	cmp	r3, #0
 8003eea:	d002      	beq.n	8003ef2 <gc_execute_line+0x4aa>
 8003eec:	2b01      	cmp	r3, #1
 8003eee:	d00a      	beq.n	8003f06 <gc_execute_line+0x4be>
 8003ef0:	e003      	b.n	8003efa <gc_execute_line+0x4b2>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
 8003ef2:	4b8c      	ldr	r3, [pc, #560]	; (8004124 <gc_execute_line+0x6dc>)
 8003ef4:	2203      	movs	r2, #3
 8003ef6:	721a      	strb	r2, [r3, #8]
 8003ef8:	e006      	b.n	8003f08 <gc_execute_line+0x4c0>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
 8003efa:	4b8a      	ldr	r3, [pc, #552]	; (8004124 <gc_execute_line+0x6dc>)
 8003efc:	223e      	movs	r2, #62	; 0x3e
 8003efe:	18ba      	adds	r2, r7, r2
 8003f00:	7812      	ldrb	r2, [r2, #0]
 8003f02:	721a      	strb	r2, [r3, #8]
            }
            break;
 8003f04:	e034      	b.n	8003f70 <gc_execute_line+0x528>
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
              case 1: break; // Optional stop not supported. Ignore.
 8003f06:	46c0      	nop			; (mov r8, r8)
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
 8003f08:	e032      	b.n	8003f70 <gc_execute_line+0x528>
					case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
 8003f0a:	234a      	movs	r3, #74	; 0x4a
 8003f0c:	18fb      	adds	r3, r7, r3
 8003f0e:	220c      	movs	r2, #12
 8003f10:	701a      	strb	r2, [r3, #0]
            switch(int_value) {
 8003f12:	233e      	movs	r3, #62	; 0x3e
 8003f14:	18fb      	adds	r3, r7, r3
 8003f16:	781b      	ldrb	r3, [r3, #0]
 8003f18:	2b04      	cmp	r3, #4
 8003f1a:	d008      	beq.n	8003f2e <gc_execute_line+0x4e6>
 8003f1c:	2b05      	cmp	r3, #5
 8003f1e:	d00a      	beq.n	8003f36 <gc_execute_line+0x4ee>
 8003f20:	2b03      	cmp	r3, #3
 8003f22:	d000      	beq.n	8003f26 <gc_execute_line+0x4de>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;
 8003f24:	e024      	b.n	8003f70 <gc_execute_line+0x528>
            }
            break;
					case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
 8003f26:	4b7f      	ldr	r3, [pc, #508]	; (8004124 <gc_execute_line+0x6dc>)
 8003f28:	2210      	movs	r2, #16
 8003f2a:	729a      	strb	r2, [r3, #10]
 8003f2c:	e007      	b.n	8003f3e <gc_execute_line+0x4f6>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
 8003f2e:	4b7d      	ldr	r3, [pc, #500]	; (8004124 <gc_execute_line+0x6dc>)
 8003f30:	2220      	movs	r2, #32
 8003f32:	729a      	strb	r2, [r3, #10]
 8003f34:	e003      	b.n	8003f3e <gc_execute_line+0x4f6>
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
 8003f36:	4b7b      	ldr	r3, [pc, #492]	; (8004124 <gc_execute_line+0x6dc>)
 8003f38:	2200      	movs	r2, #0
 8003f3a:	729a      	strb	r2, [r3, #10]
 8003f3c:	46c0      	nop			; (mov r8, r8)
            }
            break;
 8003f3e:	e017      	b.n	8003f70 <gc_execute_line+0x528>
          #ifdef ENABLE_M7
            case 7: case 8: case 9:
          #else
            case 8: case 9:
          #endif
            word_bit = MODAL_GROUP_M8;
 8003f40:	234a      	movs	r3, #74	; 0x4a
 8003f42:	18fb      	adds	r3, r7, r3
 8003f44:	220d      	movs	r2, #13
 8003f46:	701a      	strb	r2, [r3, #0]
            switch(int_value) {
 8003f48:	233e      	movs	r3, #62	; 0x3e
 8003f4a:	18fb      	adds	r3, r7, r3
 8003f4c:	781b      	ldrb	r3, [r3, #0]
 8003f4e:	2b08      	cmp	r3, #8
 8003f50:	d002      	beq.n	8003f58 <gc_execute_line+0x510>
 8003f52:	2b09      	cmp	r3, #9
 8003f54:	d004      	beq.n	8003f60 <gc_execute_line+0x518>
                case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
              #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
            }
            break;
 8003f56:	e00b      	b.n	8003f70 <gc_execute_line+0x528>
            word_bit = MODAL_GROUP_M8;
            switch(int_value) {
              #ifdef ENABLE_M7
                case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
              #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
 8003f58:	4b72      	ldr	r3, [pc, #456]	; (8004124 <gc_execute_line+0x6dc>)
 8003f5a:	2240      	movs	r2, #64	; 0x40
 8003f5c:	725a      	strb	r2, [r3, #9]
 8003f5e:	e003      	b.n	8003f68 <gc_execute_line+0x520>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
 8003f60:	4b70      	ldr	r3, [pc, #448]	; (8004124 <gc_execute_line+0x6dc>)
 8003f62:	2200      	movs	r2, #0
 8003f64:	725a      	strb	r2, [r3, #9]
 8003f66:	46c0      	nop			; (mov r8, r8)
            }
            break;
 8003f68:	e002      	b.n	8003f70 <gc_execute_line+0x528>
						case 56:
							word_bit = MODAL_GROUP_M9;
							gc_block.modal.override = OVERRIDE_PARKING_MOTION;
							break;
					#endif
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
 8003f6a:	2314      	movs	r3, #20
 8003f6c:	f001 fa80 	bl	8005470 <gc_execute_line+0x1a28>
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
 8003f70:	234e      	movs	r3, #78	; 0x4e
 8003f72:	18fb      	adds	r3, r7, r3
 8003f74:	881a      	ldrh	r2, [r3, #0]
 8003f76:	234a      	movs	r3, #74	; 0x4a
 8003f78:	18fb      	adds	r3, r7, r3
 8003f7a:	781b      	ldrb	r3, [r3, #0]
 8003f7c:	411a      	asrs	r2, r3
 8003f7e:	0013      	movs	r3, r2
 8003f80:	2201      	movs	r2, #1
 8003f82:	4013      	ands	r3, r2
 8003f84:	d002      	beq.n	8003f8c <gc_execute_line+0x544>
 8003f86:	2315      	movs	r3, #21
 8003f88:	f001 fa72 	bl	8005470 <gc_execute_line+0x1a28>
        command_words |= bit(word_bit);
 8003f8c:	234a      	movs	r3, #74	; 0x4a
 8003f8e:	18fb      	adds	r3, r7, r3
 8003f90:	781b      	ldrb	r3, [r3, #0]
 8003f92:	2201      	movs	r2, #1
 8003f94:	409a      	lsls	r2, r3
 8003f96:	0013      	movs	r3, r2
 8003f98:	b21a      	sxth	r2, r3
 8003f9a:	234e      	movs	r3, #78	; 0x4e
 8003f9c:	18fb      	adds	r3, r7, r3
 8003f9e:	2100      	movs	r1, #0
 8003fa0:	5e5b      	ldrsh	r3, [r3, r1]
 8003fa2:	4313      	orrs	r3, r2
 8003fa4:	b21a      	sxth	r2, r3
 8003fa6:	234e      	movs	r3, #78	; 0x4e
 8003fa8:	18fb      	adds	r3, r7, r3
 8003faa:	801a      	strh	r2, [r3, #0]
 8003fac:	2357      	movs	r3, #87	; 0x57
 8003fae:	18fb      	adds	r3, r7, r3
 8003fb0:	2257      	movs	r2, #87	; 0x57
 8003fb2:	18ba      	adds	r2, r7, r2
 8003fb4:	7812      	ldrb	r2, [r2, #0]
 8003fb6:	701a      	strb	r2, [r3, #0]
 8003fb8:	2352      	movs	r3, #82	; 0x52
 8003fba:	18fb      	adds	r3, r7, r3
 8003fbc:	2252      	movs	r2, #82	; 0x52
 8003fbe:	18ba      	adds	r2, r7, r2
 8003fc0:	7812      	ldrb	r2, [r2, #0]
 8003fc2:	701a      	strb	r2, [r3, #0]
 8003fc4:	2351      	movs	r3, #81	; 0x51
 8003fc6:	18fb      	adds	r3, r7, r3
 8003fc8:	2251      	movs	r2, #81	; 0x51
 8003fca:	18ba      	adds	r2, r7, r2
 8003fcc:	7812      	ldrb	r2, [r2, #0]
 8003fce:	701a      	strb	r2, [r3, #0]
 8003fd0:	234c      	movs	r3, #76	; 0x4c
 8003fd2:	18fb      	adds	r3, r7, r3
 8003fd4:	224c      	movs	r2, #76	; 0x4c
 8003fd6:	18ba      	adds	r2, r7, r2
 8003fd8:	8812      	ldrh	r2, [r2, #0]
 8003fda:	801a      	strh	r2, [r3, #0]
        break;
 8003fdc:	e10a      	b.n	80041f4 <gc_execute_line+0x7ac>
      default:

        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
 8003fde:	233d      	movs	r3, #61	; 0x3d
 8003fe0:	18fb      	adds	r3, r7, r3
 8003fe2:	781b      	ldrb	r3, [r3, #0]
 8003fe4:	3b46      	subs	r3, #70	; 0x46
 8003fe6:	2b14      	cmp	r3, #20
 8003fe8:	d900      	bls.n	8003fec <gc_execute_line+0x5a4>
 8003fea:	e0c3      	b.n	8004174 <gc_execute_line+0x72c>
 8003fec:	009a      	lsls	r2, r3, #2
 8003fee:	4b4f      	ldr	r3, [pc, #316]	; (800412c <gc_execute_line+0x6e4>)
 8003ff0:	18d3      	adds	r3, r2, r3
 8003ff2:	681b      	ldr	r3, [r3, #0]
 8003ff4:	469f      	mov	pc, r3
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
 8003ff6:	234a      	movs	r3, #74	; 0x4a
 8003ff8:	18fb      	adds	r3, r7, r3
 8003ffa:	2200      	movs	r2, #0
 8003ffc:	701a      	strb	r2, [r3, #0]
 8003ffe:	6a3a      	ldr	r2, [r7, #32]
 8004000:	4b48      	ldr	r3, [pc, #288]	; (8004124 <gc_execute_line+0x6dc>)
 8004002:	60da      	str	r2, [r3, #12]
 8004004:	e0b9      	b.n	800417a <gc_execute_line+0x732>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
 8004006:	234a      	movs	r3, #74	; 0x4a
 8004008:	18fb      	adds	r3, r7, r3
 800400a:	2201      	movs	r2, #1
 800400c:	701a      	strb	r2, [r3, #0]
 800400e:	6a3a      	ldr	r2, [r7, #32]
 8004010:	4b44      	ldr	r3, [pc, #272]	; (8004124 <gc_execute_line+0x6dc>)
 8004012:	611a      	str	r2, [r3, #16]
 8004014:	2351      	movs	r3, #81	; 0x51
 8004016:	18fb      	adds	r3, r7, r3
 8004018:	2251      	movs	r2, #81	; 0x51
 800401a:	18ba      	adds	r2, r7, r2
 800401c:	7812      	ldrb	r2, [r2, #0]
 800401e:	2101      	movs	r1, #1
 8004020:	430a      	orrs	r2, r1
 8004022:	701a      	strb	r2, [r3, #0]
 8004024:	e0a9      	b.n	800417a <gc_execute_line+0x732>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
 8004026:	234a      	movs	r3, #74	; 0x4a
 8004028:	18fb      	adds	r3, r7, r3
 800402a:	2202      	movs	r2, #2
 800402c:	701a      	strb	r2, [r3, #0]
 800402e:	6a3a      	ldr	r2, [r7, #32]
 8004030:	4b3c      	ldr	r3, [pc, #240]	; (8004124 <gc_execute_line+0x6dc>)
 8004032:	615a      	str	r2, [r3, #20]
 8004034:	2351      	movs	r3, #81	; 0x51
 8004036:	18fb      	adds	r3, r7, r3
 8004038:	2251      	movs	r2, #81	; 0x51
 800403a:	18ba      	adds	r2, r7, r2
 800403c:	7812      	ldrb	r2, [r2, #0]
 800403e:	2102      	movs	r1, #2
 8004040:	430a      	orrs	r2, r1
 8004042:	701a      	strb	r2, [r3, #0]
 8004044:	e099      	b.n	800417a <gc_execute_line+0x732>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
 8004046:	234a      	movs	r3, #74	; 0x4a
 8004048:	18fb      	adds	r3, r7, r3
 800404a:	2203      	movs	r2, #3
 800404c:	701a      	strb	r2, [r3, #0]
 800404e:	6a3a      	ldr	r2, [r7, #32]
 8004050:	4b34      	ldr	r3, [pc, #208]	; (8004124 <gc_execute_line+0x6dc>)
 8004052:	619a      	str	r2, [r3, #24]
 8004054:	2351      	movs	r3, #81	; 0x51
 8004056:	18fb      	adds	r3, r7, r3
 8004058:	2251      	movs	r2, #81	; 0x51
 800405a:	18ba      	adds	r2, r7, r2
 800405c:	7812      	ldrb	r2, [r2, #0]
 800405e:	2104      	movs	r1, #4
 8004060:	430a      	orrs	r2, r1
 8004062:	701a      	strb	r2, [r3, #0]
 8004064:	e089      	b.n	800417a <gc_execute_line+0x732>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
 8004066:	234a      	movs	r3, #74	; 0x4a
 8004068:	18fb      	adds	r3, r7, r3
 800406a:	2204      	movs	r2, #4
 800406c:	701a      	strb	r2, [r3, #0]
 800406e:	4b2d      	ldr	r3, [pc, #180]	; (8004124 <gc_execute_line+0x6dc>)
 8004070:	223e      	movs	r2, #62	; 0x3e
 8004072:	18ba      	adds	r2, r7, r2
 8004074:	7812      	ldrb	r2, [r2, #0]
 8004076:	771a      	strb	r2, [r3, #28]
 8004078:	e07f      	b.n	800417a <gc_execute_line+0x732>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
 800407a:	234a      	movs	r3, #74	; 0x4a
 800407c:	18fb      	adds	r3, r7, r3
 800407e:	2205      	movs	r2, #5
 8004080:	701a      	strb	r2, [r3, #0]
 8004082:	6a3b      	ldr	r3, [r7, #32]
 8004084:	1c18      	adds	r0, r3, #0
 8004086:	f7fe faf7 	bl	8002678 <__aeabi_f2d>
 800408a:	0003      	movs	r3, r0
 800408c:	000c      	movs	r4, r1
 800408e:	0018      	movs	r0, r3
 8004090:	0021      	movs	r1, r4
 8004092:	f008 f883 	bl	800c19c <trunc>
 8004096:	0003      	movs	r3, r0
 8004098:	000c      	movs	r4, r1
 800409a:	0018      	movs	r0, r3
 800409c:	0021      	movs	r1, r4
 800409e:	f7fe fab5 	bl	800260c <__aeabi_d2iz>
 80040a2:	0002      	movs	r2, r0
 80040a4:	4b1f      	ldr	r3, [pc, #124]	; (8004124 <gc_execute_line+0x6dc>)
 80040a6:	621a      	str	r2, [r3, #32]
 80040a8:	e067      	b.n	800417a <gc_execute_line+0x732>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
 80040aa:	234a      	movs	r3, #74	; 0x4a
 80040ac:	18fb      	adds	r3, r7, r3
 80040ae:	2206      	movs	r2, #6
 80040b0:	701a      	strb	r2, [r3, #0]
 80040b2:	6a3a      	ldr	r2, [r7, #32]
 80040b4:	4b1b      	ldr	r3, [pc, #108]	; (8004124 <gc_execute_line+0x6dc>)
 80040b6:	625a      	str	r2, [r3, #36]	; 0x24
 80040b8:	e05f      	b.n	800417a <gc_execute_line+0x732>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
 80040ba:	234a      	movs	r3, #74	; 0x4a
 80040bc:	18fb      	adds	r3, r7, r3
 80040be:	2207      	movs	r2, #7
 80040c0:	701a      	strb	r2, [r3, #0]
 80040c2:	6a3a      	ldr	r2, [r7, #32]
 80040c4:	4b17      	ldr	r3, [pc, #92]	; (8004124 <gc_execute_line+0x6dc>)
 80040c6:	629a      	str	r2, [r3, #40]	; 0x28
 80040c8:	e057      	b.n	800417a <gc_execute_line+0x732>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
 80040ca:	234a      	movs	r3, #74	; 0x4a
 80040cc:	18fb      	adds	r3, r7, r3
 80040ce:	2208      	movs	r2, #8
 80040d0:	701a      	strb	r2, [r3, #0]
 80040d2:	6a3a      	ldr	r2, [r7, #32]
 80040d4:	4b13      	ldr	r3, [pc, #76]	; (8004124 <gc_execute_line+0x6dc>)
 80040d6:	62da      	str	r2, [r3, #44]	; 0x2c
 80040d8:	e04f      	b.n	800417a <gc_execute_line+0x732>
          case 'T': word_bit = WORD_T; 
 80040da:	234a      	movs	r3, #74	; 0x4a
 80040dc:	18fb      	adds	r3, r7, r3
 80040de:	2209      	movs	r2, #9
 80040e0:	701a      	strb	r2, [r3, #0]
					  if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
 80040e2:	6a3b      	ldr	r3, [r7, #32]
 80040e4:	4912      	ldr	r1, [pc, #72]	; (8004130 <gc_execute_line+0x6e8>)
 80040e6:	1c18      	adds	r0, r3, #0
 80040e8:	f7fc f908 	bl	80002fc <__aeabi_fcmpgt>
 80040ec:	1e03      	subs	r3, r0, #0
 80040ee:	d002      	beq.n	80040f6 <gc_execute_line+0x6ae>
 80040f0:	2326      	movs	r3, #38	; 0x26
 80040f2:	f001 f9bd 	bl	8005470 <gc_execute_line+0x1a28>
            gc_block.values.t = int_value;
 80040f6:	4b0b      	ldr	r3, [pc, #44]	; (8004124 <gc_execute_line+0x6dc>)
 80040f8:	223e      	movs	r2, #62	; 0x3e
 80040fa:	18ba      	adds	r2, r7, r2
 80040fc:	2130      	movs	r1, #48	; 0x30
 80040fe:	7812      	ldrb	r2, [r2, #0]
 8004100:	545a      	strb	r2, [r3, r1]
						break;
 8004102:	e03a      	b.n	800417a <gc_execute_line+0x732>
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
 8004104:	234a      	movs	r3, #74	; 0x4a
 8004106:	18fb      	adds	r3, r7, r3
 8004108:	220a      	movs	r2, #10
 800410a:	701a      	strb	r2, [r3, #0]
 800410c:	6a3a      	ldr	r2, [r7, #32]
 800410e:	4b05      	ldr	r3, [pc, #20]	; (8004124 <gc_execute_line+0x6dc>)
 8004110:	635a      	str	r2, [r3, #52]	; 0x34
 8004112:	2352      	movs	r3, #82	; 0x52
 8004114:	18fb      	adds	r3, r7, r3
 8004116:	2252      	movs	r2, #82	; 0x52
 8004118:	18ba      	adds	r2, r7, r2
 800411a:	7812      	ldrb	r2, [r2, #0]
 800411c:	2101      	movs	r1, #1
 800411e:	430a      	orrs	r2, r1
 8004120:	701a      	strb	r2, [r3, #0]
 8004122:	e02a      	b.n	800417a <gc_execute_line+0x732>
 8004124:	200009a0 	.word	0x200009a0
 8004128:	0800d888 	.word	0x0800d888
 800412c:	0800d904 	.word	0x0800d904
 8004130:	437f0000 	.word	0x437f0000
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
 8004134:	234a      	movs	r3, #74	; 0x4a
 8004136:	18fb      	adds	r3, r7, r3
 8004138:	220b      	movs	r2, #11
 800413a:	701a      	strb	r2, [r3, #0]
 800413c:	6a3a      	ldr	r2, [r7, #32]
 800413e:	4bca      	ldr	r3, [pc, #808]	; (8004468 <gc_execute_line+0xa20>)
 8004140:	639a      	str	r2, [r3, #56]	; 0x38
 8004142:	2352      	movs	r3, #82	; 0x52
 8004144:	18fb      	adds	r3, r7, r3
 8004146:	2252      	movs	r2, #82	; 0x52
 8004148:	18ba      	adds	r2, r7, r2
 800414a:	7812      	ldrb	r2, [r2, #0]
 800414c:	2102      	movs	r1, #2
 800414e:	430a      	orrs	r2, r1
 8004150:	701a      	strb	r2, [r3, #0]
 8004152:	e012      	b.n	800417a <gc_execute_line+0x732>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
 8004154:	234a      	movs	r3, #74	; 0x4a
 8004156:	18fb      	adds	r3, r7, r3
 8004158:	220c      	movs	r2, #12
 800415a:	701a      	strb	r2, [r3, #0]
 800415c:	6a3a      	ldr	r2, [r7, #32]
 800415e:	4bc2      	ldr	r3, [pc, #776]	; (8004468 <gc_execute_line+0xa20>)
 8004160:	63da      	str	r2, [r3, #60]	; 0x3c
 8004162:	2352      	movs	r3, #82	; 0x52
 8004164:	18fb      	adds	r3, r7, r3
 8004166:	2252      	movs	r2, #82	; 0x52
 8004168:	18ba      	adds	r2, r7, r2
 800416a:	7812      	ldrb	r2, [r2, #0]
 800416c:	2104      	movs	r1, #4
 800416e:	430a      	orrs	r2, r1
 8004170:	701a      	strb	r2, [r3, #0]
 8004172:	e002      	b.n	800417a <gc_execute_line+0x732>
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
 8004174:	2314      	movs	r3, #20
 8004176:	f001 f97b 	bl	8005470 <gc_execute_line+0x1a28>
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
 800417a:	234c      	movs	r3, #76	; 0x4c
 800417c:	18fb      	adds	r3, r7, r3
 800417e:	881a      	ldrh	r2, [r3, #0]
 8004180:	234a      	movs	r3, #74	; 0x4a
 8004182:	18fb      	adds	r3, r7, r3
 8004184:	781b      	ldrb	r3, [r3, #0]
 8004186:	411a      	asrs	r2, r3
 8004188:	0013      	movs	r3, r2
 800418a:	2201      	movs	r2, #1
 800418c:	4013      	ands	r3, r2
 800418e:	d002      	beq.n	8004196 <gc_execute_line+0x74e>
 8004190:	2319      	movs	r3, #25
 8004192:	f001 f96d 	bl	8005470 <gc_execute_line+0x1a28>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
 8004196:	234a      	movs	r3, #74	; 0x4a
 8004198:	18fb      	adds	r3, r7, r3
 800419a:	781b      	ldrb	r3, [r3, #0]
 800419c:	4ab3      	ldr	r2, [pc, #716]	; (800446c <gc_execute_line+0xa24>)
 800419e:	411a      	asrs	r2, r3
 80041a0:	0013      	movs	r3, r2
 80041a2:	2201      	movs	r2, #1
 80041a4:	4013      	ands	r3, r2
 80041a6:	d009      	beq.n	80041bc <gc_execute_line+0x774>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
 80041a8:	6a3b      	ldr	r3, [r7, #32]
 80041aa:	2100      	movs	r1, #0
 80041ac:	1c18      	adds	r0, r3, #0
 80041ae:	f7fc f891 	bl	80002d4 <__aeabi_fcmplt>
 80041b2:	1e03      	subs	r3, r0, #0
 80041b4:	d002      	beq.n	80041bc <gc_execute_line+0x774>
 80041b6:	2304      	movs	r3, #4
 80041b8:	f001 f95a 	bl	8005470 <gc_execute_line+0x1a28>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
 80041bc:	234a      	movs	r3, #74	; 0x4a
 80041be:	18fb      	adds	r3, r7, r3
 80041c0:	781b      	ldrb	r3, [r3, #0]
 80041c2:	2201      	movs	r2, #1
 80041c4:	409a      	lsls	r2, r3
 80041c6:	0013      	movs	r3, r2
 80041c8:	b21a      	sxth	r2, r3
 80041ca:	234c      	movs	r3, #76	; 0x4c
 80041cc:	18fb      	adds	r3, r7, r3
 80041ce:	2100      	movs	r1, #0
 80041d0:	5e5b      	ldrsh	r3, [r3, r1]
 80041d2:	4313      	orrs	r3, r2
 80041d4:	b21a      	sxth	r2, r3
 80041d6:	234c      	movs	r3, #76	; 0x4c
 80041d8:	18fb      	adds	r3, r7, r3
 80041da:	801a      	strh	r2, [r3, #0]
 80041dc:	2357      	movs	r3, #87	; 0x57
 80041de:	18fb      	adds	r3, r7, r3
 80041e0:	2257      	movs	r2, #87	; 0x57
 80041e2:	18ba      	adds	r2, r7, r2
 80041e4:	7812      	ldrb	r2, [r2, #0]
 80041e6:	701a      	strb	r2, [r3, #0]
 80041e8:	234e      	movs	r3, #78	; 0x4e
 80041ea:	18fb      	adds	r3, r7, r3
 80041ec:	224e      	movs	r2, #78	; 0x4e
 80041ee:	18ba      	adds	r2, r7, r2
 80041f0:	8812      	ldrh	r2, [r2, #0]
 80041f2:	801a      	strh	r2, [r3, #0]
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
 80041f4:	2326      	movs	r3, #38	; 0x26
 80041f6:	18fb      	adds	r3, r7, r3
 80041f8:	781b      	ldrb	r3, [r3, #0]
 80041fa:	001a      	movs	r2, r3
 80041fc:	687b      	ldr	r3, [r7, #4]
 80041fe:	189b      	adds	r3, r3, r2
 8004200:	781b      	ldrb	r3, [r3, #0]
 8004202:	2b00      	cmp	r3, #0
 8004204:	d000      	beq.n	8004208 <gc_execute_line+0x7c0>
 8004206:	e479      	b.n	8003afc <gc_execute_line+0xb4>

  // [0. Non-specific/common error-checks and miscellaneous setup]:

  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
 8004208:	2352      	movs	r3, #82	; 0x52
 800420a:	18fb      	adds	r3, r7, r3
 800420c:	781b      	ldrb	r3, [r3, #0]
 800420e:	2b00      	cmp	r3, #0
 8004210:	d008      	beq.n	8004224 <gc_execute_line+0x7dc>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
 8004212:	2357      	movs	r3, #87	; 0x57
 8004214:	18fb      	adds	r3, r7, r3
 8004216:	781b      	ldrb	r3, [r3, #0]
 8004218:	2b00      	cmp	r3, #0
 800421a:	d103      	bne.n	8004224 <gc_execute_line+0x7dc>
 800421c:	2357      	movs	r3, #87	; 0x57
 800421e:	18fb      	adds	r3, r7, r3
 8004220:	2202      	movs	r2, #2
 8004222:	701a      	strb	r2, [r3, #0]
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
 8004224:	234c      	movs	r3, #76	; 0x4c
 8004226:	18fb      	adds	r3, r7, r3
 8004228:	881b      	ldrh	r3, [r3, #0]
 800422a:	2220      	movs	r2, #32
 800422c:	4013      	ands	r3, r2
 800422e:	d007      	beq.n	8004240 <gc_execute_line+0x7f8>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
 8004230:	4b8d      	ldr	r3, [pc, #564]	; (8004468 <gc_execute_line+0xa20>)
 8004232:	6a1b      	ldr	r3, [r3, #32]
 8004234:	4a8e      	ldr	r2, [pc, #568]	; (8004470 <gc_execute_line+0xa28>)
 8004236:	4293      	cmp	r3, r2
 8004238:	dd02      	ble.n	8004240 <gc_execute_line+0x7f8>
 800423a:	231b      	movs	r3, #27
 800423c:	f001 f918 	bl	8005470 <gc_execute_line+0x1a28>
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
 8004240:	234b      	movs	r3, #75	; 0x4b
 8004242:	18fb      	adds	r3, r7, r3
 8004244:	781b      	ldrb	r3, [r3, #0]
 8004246:	2201      	movs	r2, #1
 8004248:	4013      	ands	r3, r2
 800424a:	d017      	beq.n	800427c <gc_execute_line+0x834>
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
 800424c:	234c      	movs	r3, #76	; 0x4c
 800424e:	18fb      	adds	r3, r7, r3
 8004250:	881b      	ldrh	r3, [r3, #0]
 8004252:	2201      	movs	r2, #1
 8004254:	4013      	ands	r3, r2
 8004256:	d102      	bne.n	800425e <gc_execute_line+0x816>
 8004258:	2316      	movs	r3, #22
 800425a:	f001 f909 	bl	8005470 <gc_execute_line+0x1a28>
    if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
 800425e:	4b82      	ldr	r3, [pc, #520]	; (8004468 <gc_execute_line+0xa20>)
 8004260:	78db      	ldrb	r3, [r3, #3]
 8004262:	2b01      	cmp	r3, #1
 8004264:	d141      	bne.n	80042ea <gc_execute_line+0x8a2>
 8004266:	4b80      	ldr	r3, [pc, #512]	; (8004468 <gc_execute_line+0xa20>)
 8004268:	68db      	ldr	r3, [r3, #12]
 800426a:	4982      	ldr	r1, [pc, #520]	; (8004474 <gc_execute_line+0xa2c>)
 800426c:	1c18      	adds	r0, r3, #0
 800426e:	f7fc fbcf 	bl	8000a10 <__aeabi_fmul>
 8004272:	1c03      	adds	r3, r0, #0
 8004274:	1c1a      	adds	r2, r3, #0
 8004276:	4b7c      	ldr	r3, [pc, #496]	; (8004468 <gc_execute_line+0xa20>)
 8004278:	60da      	str	r2, [r3, #12]
 800427a:	e036      	b.n	80042ea <gc_execute_line+0x8a2>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
 800427c:	4b7a      	ldr	r3, [pc, #488]	; (8004468 <gc_execute_line+0xa20>)
 800427e:	789b      	ldrb	r3, [r3, #2]
 8004280:	2b01      	cmp	r3, #1
 8004282:	d115      	bne.n	80042b0 <gc_execute_line+0x868>
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
 8004284:	2357      	movs	r3, #87	; 0x57
 8004286:	18fb      	adds	r3, r7, r3
 8004288:	781b      	ldrb	r3, [r3, #0]
 800428a:	2b02      	cmp	r3, #2
 800428c:	d12d      	bne.n	80042ea <gc_execute_line+0x8a2>
				if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
 800428e:	4b76      	ldr	r3, [pc, #472]	; (8004468 <gc_execute_line+0xa20>)
 8004290:	785b      	ldrb	r3, [r3, #1]
 8004292:	2b50      	cmp	r3, #80	; 0x50
 8004294:	d029      	beq.n	80042ea <gc_execute_line+0x8a2>
 8004296:	4b74      	ldr	r3, [pc, #464]	; (8004468 <gc_execute_line+0xa20>)
 8004298:	785b      	ldrb	r3, [r3, #1]
 800429a:	2b00      	cmp	r3, #0
 800429c:	d025      	beq.n	80042ea <gc_execute_line+0x8a2>
					if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
 800429e:	234c      	movs	r3, #76	; 0x4c
 80042a0:	18fb      	adds	r3, r7, r3
 80042a2:	881b      	ldrh	r3, [r3, #0]
 80042a4:	2201      	movs	r2, #1
 80042a6:	4013      	ands	r3, r2
 80042a8:	d11f      	bne.n	80042ea <gc_execute_line+0x8a2>
 80042aa:	2316      	movs	r3, #22
 80042ac:	f001 f8e0 	bl	8005470 <gc_execute_line+0x1a28>
      // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error
      // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
      // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
    } else { // = G94
      // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
      if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
 80042b0:	4b71      	ldr	r3, [pc, #452]	; (8004478 <gc_execute_line+0xa30>)
 80042b2:	785b      	ldrb	r3, [r3, #1]
 80042b4:	2b00      	cmp	r3, #0
 80042b6:	d118      	bne.n	80042ea <gc_execute_line+0x8a2>
        if (bit_istrue(value_words,bit(WORD_F))) {
 80042b8:	234c      	movs	r3, #76	; 0x4c
 80042ba:	18fb      	adds	r3, r7, r3
 80042bc:	881b      	ldrh	r3, [r3, #0]
 80042be:	2201      	movs	r2, #1
 80042c0:	4013      	ands	r3, r2
 80042c2:	d00e      	beq.n	80042e2 <gc_execute_line+0x89a>
          if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
 80042c4:	4b68      	ldr	r3, [pc, #416]	; (8004468 <gc_execute_line+0xa20>)
 80042c6:	78db      	ldrb	r3, [r3, #3]
 80042c8:	2b01      	cmp	r3, #1
 80042ca:	d10e      	bne.n	80042ea <gc_execute_line+0x8a2>
 80042cc:	4b66      	ldr	r3, [pc, #408]	; (8004468 <gc_execute_line+0xa20>)
 80042ce:	68db      	ldr	r3, [r3, #12]
 80042d0:	4968      	ldr	r1, [pc, #416]	; (8004474 <gc_execute_line+0xa2c>)
 80042d2:	1c18      	adds	r0, r3, #0
 80042d4:	f7fc fb9c 	bl	8000a10 <__aeabi_fmul>
 80042d8:	1c03      	adds	r3, r0, #0
 80042da:	1c1a      	adds	r2, r3, #0
 80042dc:	4b62      	ldr	r3, [pc, #392]	; (8004468 <gc_execute_line+0xa20>)
 80042de:	60da      	str	r2, [r3, #12]
 80042e0:	e003      	b.n	80042ea <gc_execute_line+0x8a2>
        } else {
          gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
 80042e2:	4b65      	ldr	r3, [pc, #404]	; (8004478 <gc_execute_line+0xa30>)
 80042e4:	691a      	ldr	r2, [r3, #16]
 80042e6:	4b60      	ldr	r3, [pc, #384]	; (8004468 <gc_execute_line+0xa20>)
 80042e8:	60da      	str	r2, [r3, #12]
    }
  }
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.

  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
 80042ea:	234c      	movs	r3, #76	; 0x4c
 80042ec:	18fb      	adds	r3, r7, r3
 80042ee:	881a      	ldrh	r2, [r3, #0]
 80042f0:	2380      	movs	r3, #128	; 0x80
 80042f2:	005b      	lsls	r3, r3, #1
 80042f4:	4013      	ands	r3, r2
 80042f6:	d103      	bne.n	8004300 <gc_execute_line+0x8b8>
 80042f8:	4b5f      	ldr	r3, [pc, #380]	; (8004478 <gc_execute_line+0xa30>)
 80042fa:	68da      	ldr	r2, [r3, #12]
 80042fc:	4b5a      	ldr	r3, [pc, #360]	; (8004468 <gc_execute_line+0xa20>)
 80042fe:	62da      	str	r2, [r3, #44]	; 0x2c
			}
		}
	#endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
 8004300:	4b59      	ldr	r3, [pc, #356]	; (8004468 <gc_execute_line+0xa20>)
 8004302:	781b      	ldrb	r3, [r3, #0]
 8004304:	2b04      	cmp	r3, #4
 8004306:	d110      	bne.n	800432a <gc_execute_line+0x8e2>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
 8004308:	234c      	movs	r3, #76	; 0x4c
 800430a:	18fb      	adds	r3, r7, r3
 800430c:	881b      	ldrh	r3, [r3, #0]
 800430e:	2240      	movs	r2, #64	; 0x40
 8004310:	4013      	ands	r3, r2
 8004312:	d102      	bne.n	800431a <gc_execute_line+0x8d2>
 8004314:	231c      	movs	r3, #28
 8004316:	f001 f8ab 	bl	8005470 <gc_execute_line+0x1a28>
    bit_false(value_words,bit(WORD_P));
 800431a:	234c      	movs	r3, #76	; 0x4c
 800431c:	18fb      	adds	r3, r7, r3
 800431e:	224c      	movs	r2, #76	; 0x4c
 8004320:	18ba      	adds	r2, r7, r2
 8004322:	8812      	ldrh	r2, [r2, #0]
 8004324:	2140      	movs	r1, #64	; 0x40
 8004326:	438a      	bics	r2, r1
 8004328:	801a      	strh	r2, [r3, #0]
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
 800432a:	4b4f      	ldr	r3, [pc, #316]	; (8004468 <gc_execute_line+0xa20>)
 800432c:	795b      	ldrb	r3, [r3, #5]
 800432e:	2b00      	cmp	r3, #0
 8004330:	d002      	beq.n	8004338 <gc_execute_line+0x8f0>
 8004332:	2b01      	cmp	r3, #1
 8004334:	d00d      	beq.n	8004352 <gc_execute_line+0x90a>
 8004336:	e019      	b.n	800436c <gc_execute_line+0x924>
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
 8004338:	2356      	movs	r3, #86	; 0x56
 800433a:	18fb      	adds	r3, r7, r3
 800433c:	2200      	movs	r2, #0
 800433e:	701a      	strb	r2, [r3, #0]
      axis_1 = Y_AXIS;
 8004340:	2355      	movs	r3, #85	; 0x55
 8004342:	18fb      	adds	r3, r7, r3
 8004344:	2201      	movs	r2, #1
 8004346:	701a      	strb	r2, [r3, #0]
      axis_linear = Z_AXIS;
 8004348:	2354      	movs	r3, #84	; 0x54
 800434a:	18fb      	adds	r3, r7, r3
 800434c:	2202      	movs	r2, #2
 800434e:	701a      	strb	r2, [r3, #0]
      break;
 8004350:	e018      	b.n	8004384 <gc_execute_line+0x93c>
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
 8004352:	2356      	movs	r3, #86	; 0x56
 8004354:	18fb      	adds	r3, r7, r3
 8004356:	2202      	movs	r2, #2
 8004358:	701a      	strb	r2, [r3, #0]
      axis_1 = X_AXIS;
 800435a:	2355      	movs	r3, #85	; 0x55
 800435c:	18fb      	adds	r3, r7, r3
 800435e:	2200      	movs	r2, #0
 8004360:	701a      	strb	r2, [r3, #0]
      axis_linear = Y_AXIS;
 8004362:	2354      	movs	r3, #84	; 0x54
 8004364:	18fb      	adds	r3, r7, r3
 8004366:	2201      	movs	r2, #1
 8004368:	701a      	strb	r2, [r3, #0]
      break;
 800436a:	e00b      	b.n	8004384 <gc_execute_line+0x93c>
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
 800436c:	2356      	movs	r3, #86	; 0x56
 800436e:	18fb      	adds	r3, r7, r3
 8004370:	2201      	movs	r2, #1
 8004372:	701a      	strb	r2, [r3, #0]
      axis_1 = Z_AXIS;
 8004374:	2355      	movs	r3, #85	; 0x55
 8004376:	18fb      	adds	r3, r7, r3
 8004378:	2202      	movs	r2, #2
 800437a:	701a      	strb	r2, [r3, #0]
      axis_linear = X_AXIS;
 800437c:	2354      	movs	r3, #84	; 0x54
 800437e:	18fb      	adds	r3, r7, r3
 8004380:	2200      	movs	r2, #0
 8004382:	701a      	strb	r2, [r3, #0]
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
 8004384:	4b38      	ldr	r3, [pc, #224]	; (8004468 <gc_execute_line+0xa20>)
 8004386:	78db      	ldrb	r3, [r3, #3]
 8004388:	2b01      	cmp	r3, #1
 800438a:	d134      	bne.n	80043f6 <gc_execute_line+0x9ae>
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 800438c:	2347      	movs	r3, #71	; 0x47
 800438e:	18fb      	adds	r3, r7, r3
 8004390:	2200      	movs	r2, #0
 8004392:	701a      	strb	r2, [r3, #0]
 8004394:	e02a      	b.n	80043ec <gc_execute_line+0x9a4>
      if (bit_istrue(axis_words,bit(idx)) ) {
 8004396:	2352      	movs	r3, #82	; 0x52
 8004398:	18fb      	adds	r3, r7, r3
 800439a:	781a      	ldrb	r2, [r3, #0]
 800439c:	2347      	movs	r3, #71	; 0x47
 800439e:	18fb      	adds	r3, r7, r3
 80043a0:	781b      	ldrb	r3, [r3, #0]
 80043a2:	411a      	asrs	r2, r3
 80043a4:	0013      	movs	r3, r2
 80043a6:	2201      	movs	r2, #1
 80043a8:	4013      	ands	r3, r2
 80043aa:	d018      	beq.n	80043de <gc_execute_line+0x996>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
 80043ac:	2347      	movs	r3, #71	; 0x47
 80043ae:	18fb      	adds	r3, r7, r3
 80043b0:	781c      	ldrb	r4, [r3, #0]
 80043b2:	2347      	movs	r3, #71	; 0x47
 80043b4:	18fb      	adds	r3, r7, r3
 80043b6:	781b      	ldrb	r3, [r3, #0]
 80043b8:	4a2b      	ldr	r2, [pc, #172]	; (8004468 <gc_execute_line+0xa20>)
 80043ba:	330c      	adds	r3, #12
 80043bc:	009b      	lsls	r3, r3, #2
 80043be:	18d3      	adds	r3, r2, r3
 80043c0:	3304      	adds	r3, #4
 80043c2:	681b      	ldr	r3, [r3, #0]
 80043c4:	492b      	ldr	r1, [pc, #172]	; (8004474 <gc_execute_line+0xa2c>)
 80043c6:	1c18      	adds	r0, r3, #0
 80043c8:	f7fc fb22 	bl	8000a10 <__aeabi_fmul>
 80043cc:	1c03      	adds	r3, r0, #0
 80043ce:	1c19      	adds	r1, r3, #0
 80043d0:	4a25      	ldr	r2, [pc, #148]	; (8004468 <gc_execute_line+0xa20>)
 80043d2:	0023      	movs	r3, r4
 80043d4:	330c      	adds	r3, #12
 80043d6:	009b      	lsls	r3, r3, #2
 80043d8:	18d3      	adds	r3, r2, r3
 80043da:	3304      	adds	r3, #4
 80043dc:	6019      	str	r1, [r3, #0]

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 80043de:	2347      	movs	r3, #71	; 0x47
 80043e0:	18fb      	adds	r3, r7, r3
 80043e2:	781a      	ldrb	r2, [r3, #0]
 80043e4:	2347      	movs	r3, #71	; 0x47
 80043e6:	18fb      	adds	r3, r7, r3
 80043e8:	3201      	adds	r2, #1
 80043ea:	701a      	strb	r2, [r3, #0]
 80043ec:	2347      	movs	r3, #71	; 0x47
 80043ee:	18fb      	adds	r3, r7, r3
 80043f0:	781b      	ldrb	r3, [r3, #0]
 80043f2:	2b02      	cmp	r3, #2
 80043f4:	d9cf      	bls.n	8004396 <gc_execute_line+0x94e>
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are.
  // [G43.1 Errors]: Motion command in same line.
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
 80043f6:	2357      	movs	r3, #87	; 0x57
 80043f8:	18fb      	adds	r3, r7, r3
 80043fa:	781b      	ldrb	r3, [r3, #0]
 80043fc:	2b03      	cmp	r3, #3
 80043fe:	d10b      	bne.n	8004418 <gc_execute_line+0x9d0>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
 8004400:	4b19      	ldr	r3, [pc, #100]	; (8004468 <gc_execute_line+0xa20>)
 8004402:	799b      	ldrb	r3, [r3, #6]
 8004404:	2b01      	cmp	r3, #1
 8004406:	d107      	bne.n	8004418 <gc_execute_line+0x9d0>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
 8004408:	2352      	movs	r3, #82	; 0x52
 800440a:	18fb      	adds	r3, r7, r3
 800440c:	781b      	ldrb	r3, [r3, #0]
 800440e:	2b04      	cmp	r3, #4
 8004410:	d002      	beq.n	8004418 <gc_execute_line+0x9d0>
 8004412:	2325      	movs	r3, #37	; 0x25
 8004414:	f001 f82c 	bl	8005470 <gc_execute_line+0x1a28>
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
 8004418:	2314      	movs	r3, #20
 800441a:	18fa      	adds	r2, r7, r3
 800441c:	4b16      	ldr	r3, [pc, #88]	; (8004478 <gc_execute_line+0xa30>)
 800441e:	3328      	adds	r3, #40	; 0x28
 8004420:	cb13      	ldmia	r3!, {r0, r1, r4}
 8004422:	c213      	stmia	r2!, {r0, r1, r4}
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
 8004424:	234e      	movs	r3, #78	; 0x4e
 8004426:	18fb      	adds	r3, r7, r3
 8004428:	881a      	ldrh	r2, [r3, #0]
 800442a:	2380      	movs	r3, #128	; 0x80
 800442c:	009b      	lsls	r3, r3, #2
 800442e:	4013      	ands	r3, r2
 8004430:	d024      	beq.n	800447c <gc_execute_line+0xa34>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
 8004432:	4b0d      	ldr	r3, [pc, #52]	; (8004468 <gc_execute_line+0xa20>)
 8004434:	79db      	ldrb	r3, [r3, #7]
 8004436:	2b06      	cmp	r3, #6
 8004438:	d902      	bls.n	8004440 <gc_execute_line+0x9f8>
 800443a:	231d      	movs	r3, #29
 800443c:	f001 f818 	bl	8005470 <gc_execute_line+0x1a28>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
 8004440:	4b0d      	ldr	r3, [pc, #52]	; (8004478 <gc_execute_line+0xa30>)
 8004442:	799a      	ldrb	r2, [r3, #6]
 8004444:	4b08      	ldr	r3, [pc, #32]	; (8004468 <gc_execute_line+0xa20>)
 8004446:	79db      	ldrb	r3, [r3, #7]
 8004448:	429a      	cmp	r2, r3
 800444a:	d017      	beq.n	800447c <gc_execute_line+0xa34>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
 800444c:	4b06      	ldr	r3, [pc, #24]	; (8004468 <gc_execute_line+0xa20>)
 800444e:	79db      	ldrb	r3, [r3, #7]
 8004450:	2214      	movs	r2, #20
 8004452:	18ba      	adds	r2, r7, r2
 8004454:	0011      	movs	r1, r2
 8004456:	0018      	movs	r0, r3
 8004458:	f005 f878 	bl	800954c <settings_read_coord_data>
 800445c:	1e03      	subs	r3, r0, #0
 800445e:	d10d      	bne.n	800447c <gc_execute_line+0xa34>
 8004460:	2307      	movs	r3, #7
 8004462:	f001 f805 	bl	8005470 <gc_execute_line+0x1a28>
 8004466:	46c0      	nop			; (mov r8, r8)
 8004468:	200009a0 	.word	0x200009a0
 800446c:	00000361 	.word	0x00000361
 8004470:	00989680 	.word	0x00989680
 8004474:	41cb3333 	.word	0x41cb3333
 8004478:	2000095c 	.word	0x2000095c
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets.
  switch (gc_block.non_modal_command) {
 800447c:	4bd3      	ldr	r3, [pc, #844]	; (80047cc <gc_execute_line+0xd84>)
 800447e:	781b      	ldrb	r3, [r3, #0]
 8004480:	2b0a      	cmp	r3, #10
 8004482:	d003      	beq.n	800448c <gc_execute_line+0xa44>
 8004484:	2b5c      	cmp	r3, #92	; 0x5c
 8004486:	d100      	bne.n	800448a <gc_execute_line+0xa42>
 8004488:	e0ea      	b.n	8004660 <gc_execute_line+0xc18>
 800448a:	e16f      	b.n	800476c <gc_execute_line+0xd24>
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
 800448c:	2352      	movs	r3, #82	; 0x52
 800448e:	18fb      	adds	r3, r7, r3
 8004490:	781b      	ldrb	r3, [r3, #0]
 8004492:	2b00      	cmp	r3, #0
 8004494:	d102      	bne.n	800449c <gc_execute_line+0xa54>
 8004496:	231a      	movs	r3, #26
 8004498:	f000 ffea 	bl	8005470 <gc_execute_line+0x1a28>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
 800449c:	234c      	movs	r3, #76	; 0x4c
 800449e:	18fb      	adds	r3, r7, r3
 80044a0:	881b      	ldrh	r3, [r3, #0]
 80044a2:	2250      	movs	r2, #80	; 0x50
 80044a4:	4013      	ands	r3, r2
 80044a6:	d102      	bne.n	80044ae <gc_execute_line+0xa66>
 80044a8:	231c      	movs	r3, #28
 80044aa:	f000 ffe1 	bl	8005470 <gc_execute_line+0x1a28>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
 80044ae:	4bc7      	ldr	r3, [pc, #796]	; (80047cc <gc_execute_line+0xd84>)
 80044b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80044b2:	1c18      	adds	r0, r3, #0
 80044b4:	f7fe f8e0 	bl	8002678 <__aeabi_f2d>
 80044b8:	0003      	movs	r3, r0
 80044ba:	000c      	movs	r4, r1
 80044bc:	0018      	movs	r0, r3
 80044be:	0021      	movs	r1, r4
 80044c0:	f007 fe6c 	bl	800c19c <trunc>
 80044c4:	0002      	movs	r2, r0
 80044c6:	000b      	movs	r3, r1
 80044c8:	2153      	movs	r1, #83	; 0x53
 80044ca:	187c      	adds	r4, r7, r1
 80044cc:	0010      	movs	r0, r2
 80044ce:	0019      	movs	r1, r3
 80044d0:	f7fb ff40 	bl	8000354 <__aeabi_d2uiz>
 80044d4:	0003      	movs	r3, r0
 80044d6:	7023      	strb	r3, [r4, #0]
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
 80044d8:	2353      	movs	r3, #83	; 0x53
 80044da:	18fb      	adds	r3, r7, r3
 80044dc:	781b      	ldrb	r3, [r3, #0]
 80044de:	2b06      	cmp	r3, #6
 80044e0:	d902      	bls.n	80044e8 <gc_execute_line+0xaa0>
 80044e2:	231d      	movs	r3, #29
 80044e4:	f000 ffc4 	bl	8005470 <gc_execute_line+0x1a28>
      if (gc_block.values.l != 20) {
 80044e8:	4bb8      	ldr	r3, [pc, #736]	; (80047cc <gc_execute_line+0xd84>)
 80044ea:	7f1b      	ldrb	r3, [r3, #28]
 80044ec:	2b14      	cmp	r3, #20
 80044ee:	d00f      	beq.n	8004510 <gc_execute_line+0xac8>
        if (gc_block.values.l == 2) {
 80044f0:	4bb6      	ldr	r3, [pc, #728]	; (80047cc <gc_execute_line+0xd84>)
 80044f2:	7f1b      	ldrb	r3, [r3, #28]
 80044f4:	2b02      	cmp	r3, #2
 80044f6:	d108      	bne.n	800450a <gc_execute_line+0xac2>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
 80044f8:	234c      	movs	r3, #76	; 0x4c
 80044fa:	18fb      	adds	r3, r7, r3
 80044fc:	881b      	ldrh	r3, [r3, #0]
 80044fe:	2280      	movs	r2, #128	; 0x80
 8004500:	4013      	ands	r3, r2
 8004502:	d005      	beq.n	8004510 <gc_execute_line+0xac8>
 8004504:	2314      	movs	r3, #20
 8004506:	f000 ffb3 	bl	8005470 <gc_execute_line+0x1a28>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
 800450a:	2314      	movs	r3, #20
 800450c:	f000 ffb0 	bl	8005470 <gc_execute_line+0x1a28>
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
 8004510:	234c      	movs	r3, #76	; 0x4c
 8004512:	18fb      	adds	r3, r7, r3
 8004514:	224c      	movs	r2, #76	; 0x4c
 8004516:	18ba      	adds	r2, r7, r2
 8004518:	8812      	ldrh	r2, [r2, #0]
 800451a:	2150      	movs	r1, #80	; 0x50
 800451c:	438a      	bics	r2, r1
 800451e:	801a      	strh	r2, [r3, #0]

      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
 8004520:	2353      	movs	r3, #83	; 0x53
 8004522:	18fb      	adds	r3, r7, r3
 8004524:	781b      	ldrb	r3, [r3, #0]
 8004526:	2b00      	cmp	r3, #0
 8004528:	d007      	beq.n	800453a <gc_execute_line+0xaf2>
 800452a:	2353      	movs	r3, #83	; 0x53
 800452c:	18fb      	adds	r3, r7, r3
 800452e:	781a      	ldrb	r2, [r3, #0]
 8004530:	2353      	movs	r3, #83	; 0x53
 8004532:	18fb      	adds	r3, r7, r3
 8004534:	3a01      	subs	r2, #1
 8004536:	701a      	strb	r2, [r3, #0]
 8004538:	e004      	b.n	8004544 <gc_execute_line+0xafc>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
 800453a:	2353      	movs	r3, #83	; 0x53
 800453c:	18fb      	adds	r3, r7, r3
 800453e:	4aa3      	ldr	r2, [pc, #652]	; (80047cc <gc_execute_line+0xd84>)
 8004540:	79d2      	ldrb	r2, [r2, #7]
 8004542:	701a      	strb	r2, [r3, #0]
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
 8004544:	4aa2      	ldr	r2, [pc, #648]	; (80047d0 <gc_execute_line+0xd88>)
 8004546:	2353      	movs	r3, #83	; 0x53
 8004548:	18fb      	adds	r3, r7, r3
 800454a:	781b      	ldrb	r3, [r3, #0]
 800454c:	0011      	movs	r1, r2
 800454e:	0018      	movs	r0, r3
 8004550:	f004 fffc 	bl	800954c <settings_read_coord_data>
 8004554:	1e03      	subs	r3, r0, #0
 8004556:	d102      	bne.n	800455e <gc_execute_line+0xb16>
 8004558:	2307      	movs	r3, #7
 800455a:	f000 ff89 	bl	8005470 <gc_execute_line+0x1a28>

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 800455e:	2347      	movs	r3, #71	; 0x47
 8004560:	18fb      	adds	r3, r7, r3
 8004562:	2200      	movs	r2, #0
 8004564:	701a      	strb	r2, [r3, #0]
 8004566:	e075      	b.n	8004654 <gc_execute_line+0xc0c>
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
 8004568:	2352      	movs	r3, #82	; 0x52
 800456a:	18fb      	adds	r3, r7, r3
 800456c:	781a      	ldrb	r2, [r3, #0]
 800456e:	2347      	movs	r3, #71	; 0x47
 8004570:	18fb      	adds	r3, r7, r3
 8004572:	781b      	ldrb	r3, [r3, #0]
 8004574:	411a      	asrs	r2, r3
 8004576:	0013      	movs	r3, r2
 8004578:	2201      	movs	r2, #1
 800457a:	4013      	ands	r3, r2
 800457c:	d063      	beq.n	8004646 <gc_execute_line+0xbfe>
          if (gc_block.values.l == 20) {
 800457e:	4b93      	ldr	r3, [pc, #588]	; (80047cc <gc_execute_line+0xd84>)
 8004580:	7f1b      	ldrb	r3, [r3, #28]
 8004582:	2b14      	cmp	r3, #20
 8004584:	d14d      	bne.n	8004622 <gc_execute_line+0xbda>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
 8004586:	2347      	movs	r3, #71	; 0x47
 8004588:	18fb      	adds	r3, r7, r3
 800458a:	781c      	ldrb	r4, [r3, #0]
 800458c:	2347      	movs	r3, #71	; 0x47
 800458e:	18fb      	adds	r3, r7, r3
 8004590:	781b      	ldrb	r3, [r3, #0]
 8004592:	4a90      	ldr	r2, [pc, #576]	; (80047d4 <gc_execute_line+0xd8c>)
 8004594:	3306      	adds	r3, #6
 8004596:	009b      	lsls	r3, r3, #2
 8004598:	18d3      	adds	r3, r2, r3
 800459a:	3304      	adds	r3, #4
 800459c:	6818      	ldr	r0, [r3, #0]
 800459e:	2347      	movs	r3, #71	; 0x47
 80045a0:	18fb      	adds	r3, r7, r3
 80045a2:	781b      	ldrb	r3, [r3, #0]
 80045a4:	4a8b      	ldr	r2, [pc, #556]	; (80047d4 <gc_execute_line+0xd8c>)
 80045a6:	330c      	adds	r3, #12
 80045a8:	009b      	lsls	r3, r3, #2
 80045aa:	18d3      	adds	r3, r2, r3
 80045ac:	3304      	adds	r3, #4
 80045ae:	681b      	ldr	r3, [r3, #0]
 80045b0:	1c19      	adds	r1, r3, #0
 80045b2:	f7fc fb41 	bl	8000c38 <__aeabi_fsub>
 80045b6:	1c03      	adds	r3, r0, #0
 80045b8:	1c18      	adds	r0, r3, #0
 80045ba:	2347      	movs	r3, #71	; 0x47
 80045bc:	18fb      	adds	r3, r7, r3
 80045be:	781b      	ldrb	r3, [r3, #0]
 80045c0:	4a82      	ldr	r2, [pc, #520]	; (80047cc <gc_execute_line+0xd84>)
 80045c2:	330c      	adds	r3, #12
 80045c4:	009b      	lsls	r3, r3, #2
 80045c6:	18d3      	adds	r3, r2, r3
 80045c8:	3304      	adds	r3, #4
 80045ca:	681b      	ldr	r3, [r3, #0]
 80045cc:	1c19      	adds	r1, r3, #0
 80045ce:	f7fc fb33 	bl	8000c38 <__aeabi_fsub>
 80045d2:	1c03      	adds	r3, r0, #0
 80045d4:	1c19      	adds	r1, r3, #0
 80045d6:	4a7d      	ldr	r2, [pc, #500]	; (80047cc <gc_execute_line+0xd84>)
 80045d8:	1ca3      	adds	r3, r4, #2
 80045da:	009b      	lsls	r3, r3, #2
 80045dc:	18d3      	adds	r3, r2, r3
 80045de:	3308      	adds	r3, #8
 80045e0:	6019      	str	r1, [r3, #0]
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
 80045e2:	2347      	movs	r3, #71	; 0x47
 80045e4:	18fb      	adds	r3, r7, r3
 80045e6:	781b      	ldrb	r3, [r3, #0]
 80045e8:	2b02      	cmp	r3, #2
 80045ea:	d12c      	bne.n	8004646 <gc_execute_line+0xbfe>
 80045ec:	2347      	movs	r3, #71	; 0x47
 80045ee:	18fb      	adds	r3, r7, r3
 80045f0:	781c      	ldrb	r4, [r3, #0]
 80045f2:	2347      	movs	r3, #71	; 0x47
 80045f4:	18fb      	adds	r3, r7, r3
 80045f6:	781b      	ldrb	r3, [r3, #0]
 80045f8:	4a74      	ldr	r2, [pc, #464]	; (80047cc <gc_execute_line+0xd84>)
 80045fa:	3302      	adds	r3, #2
 80045fc:	009b      	lsls	r3, r3, #2
 80045fe:	18d3      	adds	r3, r2, r3
 8004600:	3308      	adds	r3, #8
 8004602:	681a      	ldr	r2, [r3, #0]
 8004604:	4b73      	ldr	r3, [pc, #460]	; (80047d4 <gc_execute_line+0xd8c>)
 8004606:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004608:	1c19      	adds	r1, r3, #0
 800460a:	1c10      	adds	r0, r2, #0
 800460c:	f7fc fb14 	bl	8000c38 <__aeabi_fsub>
 8004610:	1c03      	adds	r3, r0, #0
 8004612:	1c19      	adds	r1, r3, #0
 8004614:	4a6d      	ldr	r2, [pc, #436]	; (80047cc <gc_execute_line+0xd84>)
 8004616:	1ca3      	adds	r3, r4, #2
 8004618:	009b      	lsls	r3, r3, #2
 800461a:	18d3      	adds	r3, r2, r3
 800461c:	3308      	adds	r3, #8
 800461e:	6019      	str	r1, [r3, #0]
 8004620:	e011      	b.n	8004646 <gc_execute_line+0xbfe>
          } else {
            // L2: Update coordinate system axis to programmed value.
            gc_block.values.ijk[idx] = gc_block.values.xyz[idx];
 8004622:	2347      	movs	r3, #71	; 0x47
 8004624:	18fb      	adds	r3, r7, r3
 8004626:	7818      	ldrb	r0, [r3, #0]
 8004628:	2347      	movs	r3, #71	; 0x47
 800462a:	18fb      	adds	r3, r7, r3
 800462c:	781b      	ldrb	r3, [r3, #0]
 800462e:	4a67      	ldr	r2, [pc, #412]	; (80047cc <gc_execute_line+0xd84>)
 8004630:	330c      	adds	r3, #12
 8004632:	009b      	lsls	r3, r3, #2
 8004634:	18d3      	adds	r3, r2, r3
 8004636:	3304      	adds	r3, #4
 8004638:	681a      	ldr	r2, [r3, #0]
 800463a:	4964      	ldr	r1, [pc, #400]	; (80047cc <gc_execute_line+0xd84>)
 800463c:	1c83      	adds	r3, r0, #2
 800463e:	009b      	lsls	r3, r3, #2
 8004640:	18cb      	adds	r3, r1, r3
 8004642:	3308      	adds	r3, #8
 8004644:	601a      	str	r2, [r3, #0]
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 8004646:	2347      	movs	r3, #71	; 0x47
 8004648:	18fb      	adds	r3, r7, r3
 800464a:	781a      	ldrb	r2, [r3, #0]
 800464c:	2347      	movs	r3, #71	; 0x47
 800464e:	18fb      	adds	r3, r7, r3
 8004650:	3201      	adds	r2, #1
 8004652:	701a      	strb	r2, [r3, #0]
 8004654:	2347      	movs	r3, #71	; 0x47
 8004656:	18fb      	adds	r3, r7, r3
 8004658:	781b      	ldrb	r3, [r3, #0]
 800465a:	2b02      	cmp	r3, #2
 800465c:	d984      	bls.n	8004568 <gc_execute_line+0xb20>
            // L2: Update coordinate system axis to programmed value.
            gc_block.values.ijk[idx] = gc_block.values.xyz[idx];
          }
        } // Else, keep current stored value.
      }
      break;
 800465e:	e1ac      	b.n	80049ba <gc_execute_line+0xf72>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
 8004660:	2352      	movs	r3, #82	; 0x52
 8004662:	18fb      	adds	r3, r7, r3
 8004664:	781b      	ldrb	r3, [r3, #0]
 8004666:	2b00      	cmp	r3, #0
 8004668:	d102      	bne.n	8004670 <gc_execute_line+0xc28>
 800466a:	231a      	movs	r3, #26
 800466c:	f000 ff00 	bl	8005470 <gc_execute_line+0x1a28>

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 8004670:	2347      	movs	r3, #71	; 0x47
 8004672:	18fb      	adds	r3, r7, r3
 8004674:	2200      	movs	r2, #0
 8004676:	701a      	strb	r2, [r3, #0]
 8004678:	e072      	b.n	8004760 <gc_execute_line+0xd18>
        if (bit_istrue(axis_words,bit(idx)) ) {
 800467a:	2352      	movs	r3, #82	; 0x52
 800467c:	18fb      	adds	r3, r7, r3
 800467e:	781a      	ldrb	r2, [r3, #0]
 8004680:	2347      	movs	r3, #71	; 0x47
 8004682:	18fb      	adds	r3, r7, r3
 8004684:	781b      	ldrb	r3, [r3, #0]
 8004686:	411a      	asrs	r2, r3
 8004688:	0013      	movs	r3, r2
 800468a:	2201      	movs	r2, #1
 800468c:	4013      	ands	r3, r2
 800468e:	d04d      	beq.n	800472c <gc_execute_line+0xce4>
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
 8004690:	2347      	movs	r3, #71	; 0x47
 8004692:	18fb      	adds	r3, r7, r3
 8004694:	781c      	ldrb	r4, [r3, #0]
 8004696:	2347      	movs	r3, #71	; 0x47
 8004698:	18fb      	adds	r3, r7, r3
 800469a:	781b      	ldrb	r3, [r3, #0]
 800469c:	4a4d      	ldr	r2, [pc, #308]	; (80047d4 <gc_execute_line+0xd8c>)
 800469e:	3306      	adds	r3, #6
 80046a0:	009b      	lsls	r3, r3, #2
 80046a2:	18d3      	adds	r3, r2, r3
 80046a4:	3304      	adds	r3, #4
 80046a6:	6818      	ldr	r0, [r3, #0]
 80046a8:	2347      	movs	r3, #71	; 0x47
 80046aa:	18fb      	adds	r3, r7, r3
 80046ac:	781a      	ldrb	r2, [r3, #0]
 80046ae:	2314      	movs	r3, #20
 80046b0:	18fb      	adds	r3, r7, r3
 80046b2:	0092      	lsls	r2, r2, #2
 80046b4:	58d3      	ldr	r3, [r2, r3]
 80046b6:	1c19      	adds	r1, r3, #0
 80046b8:	f7fc fabe 	bl	8000c38 <__aeabi_fsub>
 80046bc:	1c03      	adds	r3, r0, #0
 80046be:	1c18      	adds	r0, r3, #0
 80046c0:	2347      	movs	r3, #71	; 0x47
 80046c2:	18fb      	adds	r3, r7, r3
 80046c4:	781b      	ldrb	r3, [r3, #0]
 80046c6:	4a41      	ldr	r2, [pc, #260]	; (80047cc <gc_execute_line+0xd84>)
 80046c8:	330c      	adds	r3, #12
 80046ca:	009b      	lsls	r3, r3, #2
 80046cc:	18d3      	adds	r3, r2, r3
 80046ce:	3304      	adds	r3, #4
 80046d0:	681b      	ldr	r3, [r3, #0]
 80046d2:	1c19      	adds	r1, r3, #0
 80046d4:	f7fc fab0 	bl	8000c38 <__aeabi_fsub>
 80046d8:	1c03      	adds	r3, r0, #0
 80046da:	1c19      	adds	r1, r3, #0
 80046dc:	4a3b      	ldr	r2, [pc, #236]	; (80047cc <gc_execute_line+0xd84>)
 80046de:	0023      	movs	r3, r4
 80046e0:	330c      	adds	r3, #12
 80046e2:	009b      	lsls	r3, r3, #2
 80046e4:	18d3      	adds	r3, r2, r3
 80046e6:	3304      	adds	r3, #4
 80046e8:	6019      	str	r1, [r3, #0]
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
 80046ea:	2347      	movs	r3, #71	; 0x47
 80046ec:	18fb      	adds	r3, r7, r3
 80046ee:	781b      	ldrb	r3, [r3, #0]
 80046f0:	2b02      	cmp	r3, #2
 80046f2:	d12e      	bne.n	8004752 <gc_execute_line+0xd0a>
 80046f4:	2347      	movs	r3, #71	; 0x47
 80046f6:	18fb      	adds	r3, r7, r3
 80046f8:	781c      	ldrb	r4, [r3, #0]
 80046fa:	2347      	movs	r3, #71	; 0x47
 80046fc:	18fb      	adds	r3, r7, r3
 80046fe:	781b      	ldrb	r3, [r3, #0]
 8004700:	4a32      	ldr	r2, [pc, #200]	; (80047cc <gc_execute_line+0xd84>)
 8004702:	330c      	adds	r3, #12
 8004704:	009b      	lsls	r3, r3, #2
 8004706:	18d3      	adds	r3, r2, r3
 8004708:	3304      	adds	r3, #4
 800470a:	681a      	ldr	r2, [r3, #0]
 800470c:	4b31      	ldr	r3, [pc, #196]	; (80047d4 <gc_execute_line+0xd8c>)
 800470e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004710:	1c19      	adds	r1, r3, #0
 8004712:	1c10      	adds	r0, r2, #0
 8004714:	f7fc fa90 	bl	8000c38 <__aeabi_fsub>
 8004718:	1c03      	adds	r3, r0, #0
 800471a:	1c19      	adds	r1, r3, #0
 800471c:	4a2b      	ldr	r2, [pc, #172]	; (80047cc <gc_execute_line+0xd84>)
 800471e:	0023      	movs	r3, r4
 8004720:	330c      	adds	r3, #12
 8004722:	009b      	lsls	r3, r3, #2
 8004724:	18d3      	adds	r3, r2, r3
 8004726:	3304      	adds	r3, #4
 8004728:	6019      	str	r1, [r3, #0]
 800472a:	e012      	b.n	8004752 <gc_execute_line+0xd0a>
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
 800472c:	2347      	movs	r3, #71	; 0x47
 800472e:	18fb      	adds	r3, r7, r3
 8004730:	7818      	ldrb	r0, [r3, #0]
 8004732:	2347      	movs	r3, #71	; 0x47
 8004734:	18fb      	adds	r3, r7, r3
 8004736:	781b      	ldrb	r3, [r3, #0]
 8004738:	4a26      	ldr	r2, [pc, #152]	; (80047d4 <gc_execute_line+0xd8c>)
 800473a:	330c      	adds	r3, #12
 800473c:	009b      	lsls	r3, r3, #2
 800473e:	18d3      	adds	r3, r2, r3
 8004740:	3304      	adds	r3, #4
 8004742:	681a      	ldr	r2, [r3, #0]
 8004744:	4921      	ldr	r1, [pc, #132]	; (80047cc <gc_execute_line+0xd84>)
 8004746:	0003      	movs	r3, r0
 8004748:	330c      	adds	r3, #12
 800474a:	009b      	lsls	r3, r3, #2
 800474c:	18cb      	adds	r3, r1, r3
 800474e:	3304      	adds	r3, #4
 8004750:	601a      	str	r2, [r3, #0]
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 8004752:	2347      	movs	r3, #71	; 0x47
 8004754:	18fb      	adds	r3, r7, r3
 8004756:	781a      	ldrb	r2, [r3, #0]
 8004758:	2347      	movs	r3, #71	; 0x47
 800475a:	18fb      	adds	r3, r7, r3
 800475c:	3201      	adds	r2, #1
 800475e:	701a      	strb	r2, [r3, #0]
 8004760:	2347      	movs	r3, #71	; 0x47
 8004762:	18fb      	adds	r3, r7, r3
 8004764:	781b      	ldrb	r3, [r3, #0]
 8004766:	2b02      	cmp	r3, #2
 8004768:	d987      	bls.n	800467a <gc_execute_line+0xc32>
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
        }
      }
      break;
 800476a:	e126      	b.n	80049ba <gc_execute_line+0xf72>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
 800476c:	2357      	movs	r3, #87	; 0x57
 800476e:	18fb      	adds	r3, r7, r3
 8004770:	781b      	ldrb	r3, [r3, #0]
 8004772:	2b03      	cmp	r3, #3
 8004774:	d100      	bne.n	8004778 <gc_execute_line+0xd30>
 8004776:	e0b3      	b.n	80048e0 <gc_execute_line+0xe98>
        if (axis_words) {
 8004778:	2352      	movs	r3, #82	; 0x52
 800477a:	18fb      	adds	r3, r7, r3
 800477c:	781b      	ldrb	r3, [r3, #0]
 800477e:	2b00      	cmp	r3, #0
 8004780:	d100      	bne.n	8004784 <gc_execute_line+0xd3c>
 8004782:	e0ad      	b.n	80048e0 <gc_execute_line+0xe98>
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
 8004784:	2347      	movs	r3, #71	; 0x47
 8004786:	18fb      	adds	r3, r7, r3
 8004788:	2200      	movs	r2, #0
 800478a:	701a      	strb	r2, [r3, #0]
 800478c:	e0a2      	b.n	80048d4 <gc_execute_line+0xe8c>
            if ( bit_isfalse(axis_words,bit(idx)) ) {
 800478e:	2352      	movs	r3, #82	; 0x52
 8004790:	18fb      	adds	r3, r7, r3
 8004792:	781a      	ldrb	r2, [r3, #0]
 8004794:	2347      	movs	r3, #71	; 0x47
 8004796:	18fb      	adds	r3, r7, r3
 8004798:	781b      	ldrb	r3, [r3, #0]
 800479a:	411a      	asrs	r2, r3
 800479c:	0013      	movs	r3, r2
 800479e:	2201      	movs	r2, #1
 80047a0:	4013      	ands	r3, r2
 80047a2:	d119      	bne.n	80047d8 <gc_execute_line+0xd90>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
 80047a4:	2347      	movs	r3, #71	; 0x47
 80047a6:	18fb      	adds	r3, r7, r3
 80047a8:	7818      	ldrb	r0, [r3, #0]
 80047aa:	2347      	movs	r3, #71	; 0x47
 80047ac:	18fb      	adds	r3, r7, r3
 80047ae:	781b      	ldrb	r3, [r3, #0]
 80047b0:	4a08      	ldr	r2, [pc, #32]	; (80047d4 <gc_execute_line+0xd8c>)
 80047b2:	3306      	adds	r3, #6
 80047b4:	009b      	lsls	r3, r3, #2
 80047b6:	18d3      	adds	r3, r2, r3
 80047b8:	3304      	adds	r3, #4
 80047ba:	681a      	ldr	r2, [r3, #0]
 80047bc:	4903      	ldr	r1, [pc, #12]	; (80047cc <gc_execute_line+0xd84>)
 80047be:	0003      	movs	r3, r0
 80047c0:	330c      	adds	r3, #12
 80047c2:	009b      	lsls	r3, r3, #2
 80047c4:	18cb      	adds	r3, r1, r3
 80047c6:	3304      	adds	r3, #4
 80047c8:	601a      	str	r2, [r3, #0]
 80047ca:	e07c      	b.n	80048c6 <gc_execute_line+0xe7e>
 80047cc:	200009a0 	.word	0x200009a0
 80047d0:	200009b0 	.word	0x200009b0
 80047d4:	2000095c 	.word	0x2000095c
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
 80047d8:	4bb1      	ldr	r3, [pc, #708]	; (8004aa0 <gc_execute_line+0x1058>)
 80047da:	781b      	ldrb	r3, [r3, #0]
 80047dc:	2b35      	cmp	r3, #53	; 0x35
 80047de:	d072      	beq.n	80048c6 <gc_execute_line+0xe7e>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
 80047e0:	4baf      	ldr	r3, [pc, #700]	; (8004aa0 <gc_execute_line+0x1058>)
 80047e2:	791b      	ldrb	r3, [r3, #4]
 80047e4:	2b00      	cmp	r3, #0
 80047e6:	d14d      	bne.n	8004884 <gc_execute_line+0xe3c>
                  gc_block.values.xyz[idx] += block_coord_system[idx] + gc_state.coord_offset[idx];
 80047e8:	2347      	movs	r3, #71	; 0x47
 80047ea:	18fb      	adds	r3, r7, r3
 80047ec:	781c      	ldrb	r4, [r3, #0]
 80047ee:	2347      	movs	r3, #71	; 0x47
 80047f0:	18fb      	adds	r3, r7, r3
 80047f2:	781b      	ldrb	r3, [r3, #0]
 80047f4:	4aaa      	ldr	r2, [pc, #680]	; (8004aa0 <gc_execute_line+0x1058>)
 80047f6:	330c      	adds	r3, #12
 80047f8:	009b      	lsls	r3, r3, #2
 80047fa:	18d3      	adds	r3, r2, r3
 80047fc:	3304      	adds	r3, #4
 80047fe:	681d      	ldr	r5, [r3, #0]
 8004800:	2347      	movs	r3, #71	; 0x47
 8004802:	18fb      	adds	r3, r7, r3
 8004804:	781a      	ldrb	r2, [r3, #0]
 8004806:	2314      	movs	r3, #20
 8004808:	18fb      	adds	r3, r7, r3
 800480a:	0092      	lsls	r2, r2, #2
 800480c:	58d0      	ldr	r0, [r2, r3]
 800480e:	2347      	movs	r3, #71	; 0x47
 8004810:	18fb      	adds	r3, r7, r3
 8004812:	781b      	ldrb	r3, [r3, #0]
 8004814:	4aa3      	ldr	r2, [pc, #652]	; (8004aa4 <gc_execute_line+0x105c>)
 8004816:	330c      	adds	r3, #12
 8004818:	009b      	lsls	r3, r3, #2
 800481a:	18d3      	adds	r3, r2, r3
 800481c:	3304      	adds	r3, #4
 800481e:	681b      	ldr	r3, [r3, #0]
 8004820:	1c19      	adds	r1, r3, #0
 8004822:	f7fb fdb5 	bl	8000390 <__aeabi_fadd>
 8004826:	1c03      	adds	r3, r0, #0
 8004828:	1c19      	adds	r1, r3, #0
 800482a:	1c28      	adds	r0, r5, #0
 800482c:	f7fb fdb0 	bl	8000390 <__aeabi_fadd>
 8004830:	1c03      	adds	r3, r0, #0
 8004832:	1c19      	adds	r1, r3, #0
 8004834:	4a9a      	ldr	r2, [pc, #616]	; (8004aa0 <gc_execute_line+0x1058>)
 8004836:	0023      	movs	r3, r4
 8004838:	330c      	adds	r3, #12
 800483a:	009b      	lsls	r3, r3, #2
 800483c:	18d3      	adds	r3, r2, r3
 800483e:	3304      	adds	r3, #4
 8004840:	6019      	str	r1, [r3, #0]
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
 8004842:	2347      	movs	r3, #71	; 0x47
 8004844:	18fb      	adds	r3, r7, r3
 8004846:	781b      	ldrb	r3, [r3, #0]
 8004848:	2b02      	cmp	r3, #2
 800484a:	d13c      	bne.n	80048c6 <gc_execute_line+0xe7e>
 800484c:	2347      	movs	r3, #71	; 0x47
 800484e:	18fb      	adds	r3, r7, r3
 8004850:	781c      	ldrb	r4, [r3, #0]
 8004852:	2347      	movs	r3, #71	; 0x47
 8004854:	18fb      	adds	r3, r7, r3
 8004856:	781b      	ldrb	r3, [r3, #0]
 8004858:	4a91      	ldr	r2, [pc, #580]	; (8004aa0 <gc_execute_line+0x1058>)
 800485a:	330c      	adds	r3, #12
 800485c:	009b      	lsls	r3, r3, #2
 800485e:	18d3      	adds	r3, r2, r3
 8004860:	3304      	adds	r3, #4
 8004862:	681a      	ldr	r2, [r3, #0]
 8004864:	4b8f      	ldr	r3, [pc, #572]	; (8004aa4 <gc_execute_line+0x105c>)
 8004866:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004868:	1c19      	adds	r1, r3, #0
 800486a:	1c10      	adds	r0, r2, #0
 800486c:	f7fb fd90 	bl	8000390 <__aeabi_fadd>
 8004870:	1c03      	adds	r3, r0, #0
 8004872:	1c19      	adds	r1, r3, #0
 8004874:	4a8a      	ldr	r2, [pc, #552]	; (8004aa0 <gc_execute_line+0x1058>)
 8004876:	0023      	movs	r3, r4
 8004878:	330c      	adds	r3, #12
 800487a:	009b      	lsls	r3, r3, #2
 800487c:	18d3      	adds	r3, r2, r3
 800487e:	3304      	adds	r3, #4
 8004880:	6019      	str	r1, [r3, #0]
 8004882:	e020      	b.n	80048c6 <gc_execute_line+0xe7e>
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
 8004884:	2347      	movs	r3, #71	; 0x47
 8004886:	18fb      	adds	r3, r7, r3
 8004888:	781c      	ldrb	r4, [r3, #0]
 800488a:	2347      	movs	r3, #71	; 0x47
 800488c:	18fb      	adds	r3, r7, r3
 800488e:	781b      	ldrb	r3, [r3, #0]
 8004890:	4a83      	ldr	r2, [pc, #524]	; (8004aa0 <gc_execute_line+0x1058>)
 8004892:	330c      	adds	r3, #12
 8004894:	009b      	lsls	r3, r3, #2
 8004896:	18d3      	adds	r3, r2, r3
 8004898:	3304      	adds	r3, #4
 800489a:	6818      	ldr	r0, [r3, #0]
 800489c:	2347      	movs	r3, #71	; 0x47
 800489e:	18fb      	adds	r3, r7, r3
 80048a0:	781b      	ldrb	r3, [r3, #0]
 80048a2:	4a80      	ldr	r2, [pc, #512]	; (8004aa4 <gc_execute_line+0x105c>)
 80048a4:	3306      	adds	r3, #6
 80048a6:	009b      	lsls	r3, r3, #2
 80048a8:	18d3      	adds	r3, r2, r3
 80048aa:	3304      	adds	r3, #4
 80048ac:	681b      	ldr	r3, [r3, #0]
 80048ae:	1c19      	adds	r1, r3, #0
 80048b0:	f7fb fd6e 	bl	8000390 <__aeabi_fadd>
 80048b4:	1c03      	adds	r3, r0, #0
 80048b6:	1c19      	adds	r1, r3, #0
 80048b8:	4a79      	ldr	r2, [pc, #484]	; (8004aa0 <gc_execute_line+0x1058>)
 80048ba:	0023      	movs	r3, r4
 80048bc:	330c      	adds	r3, #12
 80048be:	009b      	lsls	r3, r3, #2
 80048c0:	18d3      	adds	r3, r2, r3
 80048c2:	3304      	adds	r3, #4
 80048c4:	6019      	str	r1, [r3, #0]
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
 80048c6:	2347      	movs	r3, #71	; 0x47
 80048c8:	18fb      	adds	r3, r7, r3
 80048ca:	781a      	ldrb	r2, [r3, #0]
 80048cc:	2347      	movs	r3, #71	; 0x47
 80048ce:	18fb      	adds	r3, r7, r3
 80048d0:	3201      	adds	r2, #1
 80048d2:	701a      	strb	r2, [r3, #0]
 80048d4:	2347      	movs	r3, #71	; 0x47
 80048d6:	18fb      	adds	r3, r7, r3
 80048d8:	781b      	ldrb	r3, [r3, #0]
 80048da:	2b02      	cmp	r3, #2
 80048dc:	d800      	bhi.n	80048e0 <gc_execute_line+0xe98>
 80048de:	e756      	b.n	800478e <gc_execute_line+0xd46>
          }
        }
      }

      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {
 80048e0:	4b6f      	ldr	r3, [pc, #444]	; (8004aa0 <gc_execute_line+0x1058>)
 80048e2:	781b      	ldrb	r3, [r3, #0]
 80048e4:	2b26      	cmp	r3, #38	; 0x26
 80048e6:	d100      	bne.n	80048ea <gc_execute_line+0xea2>
 80048e8:	e064      	b.n	80049b4 <gc_execute_line+0xf6c>
 80048ea:	dc04      	bgt.n	80048f6 <gc_execute_line+0xeae>
 80048ec:	2b1c      	cmp	r3, #28
 80048ee:	d005      	beq.n	80048fc <gc_execute_line+0xeb4>
 80048f0:	2b1e      	cmp	r3, #30
 80048f2:	d003      	beq.n	80048fc <gc_execute_line+0xeb4>
 80048f4:	e061      	b.n	80049ba <gc_execute_line+0xf72>
 80048f6:	2b35      	cmp	r3, #53	; 0x35
 80048f8:	d051      	beq.n	800499e <gc_execute_line+0xf56>
          // [G28.1/30.1 Errors]: Cutter compensation is enabled.
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_RESET_COORDINATE_OFFSET:
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
 80048fa:	e05e      	b.n	80049ba <gc_execute_line+0xf72>
        case NON_MODAL_GO_HOME_0: // G28
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
 80048fc:	4b68      	ldr	r3, [pc, #416]	; (8004aa0 <gc_execute_line+0x1058>)
 80048fe:	781b      	ldrb	r3, [r3, #0]
 8004900:	2b1c      	cmp	r3, #28
 8004902:	d109      	bne.n	8004918 <gc_execute_line+0xed0>
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
 8004904:	4b68      	ldr	r3, [pc, #416]	; (8004aa8 <gc_execute_line+0x1060>)
 8004906:	0019      	movs	r1, r3
 8004908:	2006      	movs	r0, #6
 800490a:	f004 fe1f 	bl	800954c <settings_read_coord_data>
 800490e:	1e03      	subs	r3, r0, #0
 8004910:	d10c      	bne.n	800492c <gc_execute_line+0xee4>
 8004912:	2307      	movs	r3, #7
 8004914:	f000 fdac 	bl	8005470 <gc_execute_line+0x1a28>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
 8004918:	4b63      	ldr	r3, [pc, #396]	; (8004aa8 <gc_execute_line+0x1060>)
 800491a:	0019      	movs	r1, r3
 800491c:	2007      	movs	r0, #7
 800491e:	f004 fe15 	bl	800954c <settings_read_coord_data>
 8004922:	1e03      	subs	r3, r0, #0
 8004924:	d102      	bne.n	800492c <gc_execute_line+0xee4>
 8004926:	2307      	movs	r3, #7
 8004928:	f000 fda2 	bl	8005470 <gc_execute_line+0x1a28>
          }
          if (axis_words) {
 800492c:	2352      	movs	r3, #82	; 0x52
 800492e:	18fb      	adds	r3, r7, r3
 8004930:	781b      	ldrb	r3, [r3, #0]
 8004932:	2b00      	cmp	r3, #0
 8004934:	d02e      	beq.n	8004994 <gc_execute_line+0xf4c>
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
 8004936:	2347      	movs	r3, #71	; 0x47
 8004938:	18fb      	adds	r3, r7, r3
 800493a:	2200      	movs	r2, #0
 800493c:	701a      	strb	r2, [r3, #0]
 800493e:	e023      	b.n	8004988 <gc_execute_line+0xf40>
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
 8004940:	2352      	movs	r3, #82	; 0x52
 8004942:	18fb      	adds	r3, r7, r3
 8004944:	781a      	ldrb	r2, [r3, #0]
 8004946:	2347      	movs	r3, #71	; 0x47
 8004948:	18fb      	adds	r3, r7, r3
 800494a:	781b      	ldrb	r3, [r3, #0]
 800494c:	411a      	asrs	r2, r3
 800494e:	0013      	movs	r3, r2
 8004950:	2201      	movs	r2, #1
 8004952:	4013      	ands	r3, r2
 8004954:	d111      	bne.n	800497a <gc_execute_line+0xf32>
 8004956:	2347      	movs	r3, #71	; 0x47
 8004958:	18fb      	adds	r3, r7, r3
 800495a:	7818      	ldrb	r0, [r3, #0]
 800495c:	2347      	movs	r3, #71	; 0x47
 800495e:	18fb      	adds	r3, r7, r3
 8004960:	781b      	ldrb	r3, [r3, #0]
 8004962:	4a50      	ldr	r2, [pc, #320]	; (8004aa4 <gc_execute_line+0x105c>)
 8004964:	3306      	adds	r3, #6
 8004966:	009b      	lsls	r3, r3, #2
 8004968:	18d3      	adds	r3, r2, r3
 800496a:	3304      	adds	r3, #4
 800496c:	681a      	ldr	r2, [r3, #0]
 800496e:	494c      	ldr	r1, [pc, #304]	; (8004aa0 <gc_execute_line+0x1058>)
 8004970:	1c83      	adds	r3, r0, #2
 8004972:	009b      	lsls	r3, r3, #2
 8004974:	18cb      	adds	r3, r1, r3
 8004976:	3308      	adds	r3, #8
 8004978:	601a      	str	r2, [r3, #0]
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
 800497a:	2347      	movs	r3, #71	; 0x47
 800497c:	18fb      	adds	r3, r7, r3
 800497e:	781a      	ldrb	r2, [r3, #0]
 8004980:	2347      	movs	r3, #71	; 0x47
 8004982:	18fb      	adds	r3, r7, r3
 8004984:	3201      	adds	r2, #1
 8004986:	701a      	strb	r2, [r3, #0]
 8004988:	2347      	movs	r3, #71	; 0x47
 800498a:	18fb      	adds	r3, r7, r3
 800498c:	781b      	ldrb	r3, [r3, #0]
 800498e:	2b02      	cmp	r3, #2
 8004990:	d9d6      	bls.n	8004940 <gc_execute_line+0xef8>
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
          }
          break;
 8004992:	e012      	b.n	80049ba <gc_execute_line+0xf72>
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
 8004994:	2357      	movs	r3, #87	; 0x57
 8004996:	18fb      	adds	r3, r7, r3
 8004998:	2200      	movs	r2, #0
 800499a:	701a      	strb	r2, [r3, #0]
          }
          break;
 800499c:	e00d      	b.n	80049ba <gc_execute_line+0xf72>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
 800499e:	4b40      	ldr	r3, [pc, #256]	; (8004aa0 <gc_execute_line+0x1058>)
 80049a0:	785b      	ldrb	r3, [r3, #1]
 80049a2:	2b00      	cmp	r3, #0
 80049a4:	d008      	beq.n	80049b8 <gc_execute_line+0xf70>
 80049a6:	4b3e      	ldr	r3, [pc, #248]	; (8004aa0 <gc_execute_line+0x1058>)
 80049a8:	785b      	ldrb	r3, [r3, #1]
 80049aa:	2b01      	cmp	r3, #1
 80049ac:	d004      	beq.n	80049b8 <gc_execute_line+0xf70>
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
 80049ae:	231e      	movs	r3, #30
 80049b0:	f000 fd5e 	bl	8005470 <gc_execute_line+0x1a28>
          break;
        case NON_MODAL_SET_HOME_0: // G28.1
        case NON_MODAL_SET_HOME_1: // G30.1
          // [G28.1/30.1 Errors]: Cutter compensation is enabled.
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
 80049b4:	46c0      	nop			; (mov r8, r8)
 80049b6:	e000      	b.n	80049ba <gc_execute_line+0xf72>
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
          }
          break;
 80049b8:	46c0      	nop			; (mov r8, r8)
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
 80049ba:	4b39      	ldr	r3, [pc, #228]	; (8004aa0 <gc_execute_line+0x1058>)
 80049bc:	785b      	ldrb	r3, [r3, #1]
 80049be:	2b50      	cmp	r3, #80	; 0x50
 80049c0:	d108      	bne.n	80049d4 <gc_execute_line+0xf8c>
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
 80049c2:	2352      	movs	r3, #82	; 0x52
 80049c4:	18fb      	adds	r3, r7, r3
 80049c6:	781b      	ldrb	r3, [r3, #0]
 80049c8:	2b00      	cmp	r3, #0
 80049ca:	d100      	bne.n	80049ce <gc_execute_line+0xf86>
 80049cc:	e253      	b.n	8004e76 <gc_execute_line+0x142e>
 80049ce:	231f      	movs	r3, #31
 80049d0:	f000 fd4e 	bl	8005470 <gc_execute_line+0x1a28>

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
 80049d4:	2357      	movs	r3, #87	; 0x57
 80049d6:	18fb      	adds	r3, r7, r3
 80049d8:	781b      	ldrb	r3, [r3, #0]
 80049da:	2b02      	cmp	r3, #2
 80049dc:	d000      	beq.n	80049e0 <gc_execute_line+0xf98>
 80049de:	e24a      	b.n	8004e76 <gc_execute_line+0x142e>

    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
 80049e0:	4b2f      	ldr	r3, [pc, #188]	; (8004aa0 <gc_execute_line+0x1058>)
 80049e2:	785b      	ldrb	r3, [r3, #1]
 80049e4:	2b00      	cmp	r3, #0
 80049e6:	d10a      	bne.n	80049fe <gc_execute_line+0xfb6>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
 80049e8:	2352      	movs	r3, #82	; 0x52
 80049ea:	18fb      	adds	r3, r7, r3
 80049ec:	781b      	ldrb	r3, [r3, #0]
 80049ee:	2b00      	cmp	r3, #0
 80049f0:	d000      	beq.n	80049f4 <gc_execute_line+0xfac>
 80049f2:	e240      	b.n	8004e76 <gc_execute_line+0x142e>
 80049f4:	2357      	movs	r3, #87	; 0x57
 80049f6:	18fb      	adds	r3, r7, r3
 80049f8:	2200      	movs	r2, #0
 80049fa:	701a      	strb	r2, [r3, #0]
 80049fc:	e23b      	b.n	8004e76 <gc_execute_line+0x142e>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0f) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
 80049fe:	4b28      	ldr	r3, [pc, #160]	; (8004aa0 <gc_execute_line+0x1058>)
 8004a00:	68db      	ldr	r3, [r3, #12]
 8004a02:	2100      	movs	r1, #0
 8004a04:	1c18      	adds	r0, r3, #0
 8004a06:	f7fb fc5f 	bl	80002c8 <__aeabi_fcmpeq>
 8004a0a:	1e03      	subs	r3, r0, #0
 8004a0c:	d002      	beq.n	8004a14 <gc_execute_line+0xfcc>
 8004a0e:	2316      	movs	r3, #22
 8004a10:	f000 fd2e 	bl	8005470 <gc_execute_line+0x1a28>

      switch (gc_block.modal.motion) {
 8004a14:	4b22      	ldr	r3, [pc, #136]	; (8004aa0 <gc_execute_line+0x1058>)
 8004a16:	785b      	ldrb	r3, [r3, #1]
 8004a18:	2b8c      	cmp	r3, #140	; 0x8c
 8004a1a:	d100      	bne.n	8004a1e <gc_execute_line+0xfd6>
 8004a1c:	e1f8      	b.n	8004e10 <gc_execute_line+0x13c8>
 8004a1e:	dc06      	bgt.n	8004a2e <gc_execute_line+0xfe6>
 8004a20:	2b02      	cmp	r3, #2
 8004a22:	d018      	beq.n	8004a56 <gc_execute_line+0x100e>
 8004a24:	2b03      	cmp	r3, #3
 8004a26:	d01e      	beq.n	8004a66 <gc_execute_line+0x101e>
 8004a28:	2b01      	cmp	r3, #1
 8004a2a:	d009      	beq.n	8004a40 <gc_execute_line+0xff8>
 8004a2c:	e223      	b.n	8004e76 <gc_execute_line+0x142e>
 8004a2e:	2b8e      	cmp	r3, #142	; 0x8e
 8004a30:	d100      	bne.n	8004a34 <gc_execute_line+0xfec>
 8004a32:	e1ed      	b.n	8004e10 <gc_execute_line+0x13c8>
 8004a34:	da00      	bge.n	8004a38 <gc_execute_line+0xff0>
 8004a36:	e1e3      	b.n	8004e00 <gc_execute_line+0x13b8>
 8004a38:	2b8f      	cmp	r3, #143	; 0x8f
 8004a3a:	d100      	bne.n	8004a3e <gc_execute_line+0xff6>
 8004a3c:	e1e0      	b.n	8004e00 <gc_execute_line+0x13b8>
 8004a3e:	e21a      	b.n	8004e76 <gc_execute_line+0x142e>
        case MOTION_MODE_LINEAR:
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
 8004a40:	2352      	movs	r3, #82	; 0x52
 8004a42:	18fb      	adds	r3, r7, r3
 8004a44:	781b      	ldrb	r3, [r3, #0]
 8004a46:	2b00      	cmp	r3, #0
 8004a48:	d000      	beq.n	8004a4c <gc_execute_line+0x1004>
 8004a4a:	e211      	b.n	8004e70 <gc_execute_line+0x1428>
 8004a4c:	2357      	movs	r3, #87	; 0x57
 8004a4e:	18fb      	adds	r3, r7, r3
 8004a50:	2200      	movs	r2, #0
 8004a52:	701a      	strb	r2, [r3, #0]

          break;
 8004a54:	e20c      	b.n	8004e70 <gc_execute_line+0x1428>
        case MOTION_MODE_CW_ARC: 
          gc_parser_flags |= GC_PARSER_ARC_IS_CLOCKWISE; // No break intentional.
 8004a56:	234b      	movs	r3, #75	; 0x4b
 8004a58:	18fb      	adds	r3, r7, r3
 8004a5a:	224b      	movs	r2, #75	; 0x4b
 8004a5c:	18ba      	adds	r2, r7, r2
 8004a5e:	7812      	ldrb	r2, [r2, #0]
 8004a60:	2104      	movs	r1, #4
 8004a62:	430a      	orrs	r2, r1
 8004a64:	701a      	strb	r2, [r3, #0]
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
 8004a66:	2352      	movs	r3, #82	; 0x52
 8004a68:	18fb      	adds	r3, r7, r3
 8004a6a:	781b      	ldrb	r3, [r3, #0]
 8004a6c:	2b00      	cmp	r3, #0
 8004a6e:	d102      	bne.n	8004a76 <gc_execute_line+0x102e>
 8004a70:	231a      	movs	r3, #26
 8004a72:	f000 fcfd 	bl	8005470 <gc_execute_line+0x1a28>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
 8004a76:	2352      	movs	r3, #82	; 0x52
 8004a78:	18fb      	adds	r3, r7, r3
 8004a7a:	781b      	ldrb	r3, [r3, #0]
 8004a7c:	2256      	movs	r2, #86	; 0x56
 8004a7e:	18ba      	adds	r2, r7, r2
 8004a80:	7812      	ldrb	r2, [r2, #0]
 8004a82:	2101      	movs	r1, #1
 8004a84:	4091      	lsls	r1, r2
 8004a86:	2255      	movs	r2, #85	; 0x55
 8004a88:	18ba      	adds	r2, r7, r2
 8004a8a:	7812      	ldrb	r2, [r2, #0]
 8004a8c:	2001      	movs	r0, #1
 8004a8e:	4090      	lsls	r0, r2
 8004a90:	0002      	movs	r2, r0
 8004a92:	430a      	orrs	r2, r1
 8004a94:	4013      	ands	r3, r2
 8004a96:	d109      	bne.n	8004aac <gc_execute_line+0x1064>
 8004a98:	2320      	movs	r3, #32
 8004a9a:	f000 fce9 	bl	8005470 <gc_execute_line+0x1a28>
 8004a9e:	46c0      	nop			; (mov r8, r8)
 8004aa0:	200009a0 	.word	0x200009a0
 8004aa4:	2000095c 	.word	0x2000095c
 8004aa8:	200009b0 	.word	0x200009b0

          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
 8004aac:	2356      	movs	r3, #86	; 0x56
 8004aae:	18fb      	adds	r3, r7, r3
 8004ab0:	781b      	ldrb	r3, [r3, #0]
 8004ab2:	4ae3      	ldr	r2, [pc, #908]	; (8004e40 <gc_execute_line+0x13f8>)
 8004ab4:	330c      	adds	r3, #12
 8004ab6:	009b      	lsls	r3, r3, #2
 8004ab8:	18d3      	adds	r3, r2, r3
 8004aba:	3304      	adds	r3, #4
 8004abc:	6818      	ldr	r0, [r3, #0]
 8004abe:	2356      	movs	r3, #86	; 0x56
 8004ac0:	18fb      	adds	r3, r7, r3
 8004ac2:	781b      	ldrb	r3, [r3, #0]
 8004ac4:	4adf      	ldr	r2, [pc, #892]	; (8004e44 <gc_execute_line+0x13fc>)
 8004ac6:	3306      	adds	r3, #6
 8004ac8:	009b      	lsls	r3, r3, #2
 8004aca:	18d3      	adds	r3, r2, r3
 8004acc:	3304      	adds	r3, #4
 8004ace:	681b      	ldr	r3, [r3, #0]
 8004ad0:	1c19      	adds	r1, r3, #0
 8004ad2:	f7fc f8b1 	bl	8000c38 <__aeabi_fsub>
 8004ad6:	1c03      	adds	r3, r0, #0
 8004ad8:	63bb      	str	r3, [r7, #56]	; 0x38
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
 8004ada:	2355      	movs	r3, #85	; 0x55
 8004adc:	18fb      	adds	r3, r7, r3
 8004ade:	781b      	ldrb	r3, [r3, #0]
 8004ae0:	4ad7      	ldr	r2, [pc, #860]	; (8004e40 <gc_execute_line+0x13f8>)
 8004ae2:	330c      	adds	r3, #12
 8004ae4:	009b      	lsls	r3, r3, #2
 8004ae6:	18d3      	adds	r3, r2, r3
 8004ae8:	3304      	adds	r3, #4
 8004aea:	6818      	ldr	r0, [r3, #0]
 8004aec:	2355      	movs	r3, #85	; 0x55
 8004aee:	18fb      	adds	r3, r7, r3
 8004af0:	781b      	ldrb	r3, [r3, #0]
 8004af2:	4ad4      	ldr	r2, [pc, #848]	; (8004e44 <gc_execute_line+0x13fc>)
 8004af4:	3306      	adds	r3, #6
 8004af6:	009b      	lsls	r3, r3, #2
 8004af8:	18d3      	adds	r3, r2, r3
 8004afa:	3304      	adds	r3, #4
 8004afc:	681b      	ldr	r3, [r3, #0]
 8004afe:	1c19      	adds	r1, r3, #0
 8004b00:	f7fc f89a 	bl	8000c38 <__aeabi_fsub>
 8004b04:	1c03      	adds	r3, r0, #0
 8004b06:	637b      	str	r3, [r7, #52]	; 0x34

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
 8004b08:	234c      	movs	r3, #76	; 0x4c
 8004b0a:	18fb      	adds	r3, r7, r3
 8004b0c:	881b      	ldrh	r3, [r3, #0]
 8004b0e:	2280      	movs	r2, #128	; 0x80
 8004b10:	4013      	ands	r3, r2
 8004b12:	d100      	bne.n	8004b16 <gc_execute_line+0x10ce>
 8004b14:	e0b8      	b.n	8004c88 <gc_execute_line+0x1240>
            bit_false(value_words,bit(WORD_R));
 8004b16:	234c      	movs	r3, #76	; 0x4c
 8004b18:	18fb      	adds	r3, r7, r3
 8004b1a:	224c      	movs	r2, #76	; 0x4c
 8004b1c:	18ba      	adds	r2, r7, r2
 8004b1e:	8812      	ldrh	r2, [r2, #0]
 8004b20:	2180      	movs	r1, #128	; 0x80
 8004b22:	438a      	bics	r2, r1
 8004b24:	801a      	strh	r2, [r3, #0]
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
 8004b26:	49c8      	ldr	r1, [pc, #800]	; (8004e48 <gc_execute_line+0x1400>)
 8004b28:	4bc8      	ldr	r3, [pc, #800]	; (8004e4c <gc_execute_line+0x1404>)
 8004b2a:	220c      	movs	r2, #12
 8004b2c:	0018      	movs	r0, r3
 8004b2e:	f007 facf 	bl	800c0d0 <memcmp>
 8004b32:	1e03      	subs	r3, r0, #0
 8004b34:	d102      	bne.n	8004b3c <gc_execute_line+0x10f4>
 8004b36:	2321      	movs	r3, #33	; 0x21
 8004b38:	f000 fc9a 	bl	8005470 <gc_execute_line+0x1a28>

            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
 8004b3c:	4bc0      	ldr	r3, [pc, #768]	; (8004e40 <gc_execute_line+0x13f8>)
 8004b3e:	78db      	ldrb	r3, [r3, #3]
 8004b40:	2b01      	cmp	r3, #1
 8004b42:	d109      	bne.n	8004b58 <gc_execute_line+0x1110>
 8004b44:	4bbe      	ldr	r3, [pc, #760]	; (8004e40 <gc_execute_line+0x13f8>)
 8004b46:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004b48:	49c1      	ldr	r1, [pc, #772]	; (8004e50 <gc_execute_line+0x1408>)
 8004b4a:	1c18      	adds	r0, r3, #0
 8004b4c:	f7fb ff60 	bl	8000a10 <__aeabi_fmul>
 8004b50:	1c03      	adds	r3, r0, #0
 8004b52:	1c1a      	adds	r2, r3, #0
 8004b54:	4bba      	ldr	r3, [pc, #744]	; (8004e40 <gc_execute_line+0x13f8>)
 8004b56:	629a      	str	r2, [r3, #40]	; 0x28
                j = (y + (x * h_x2_div_d))/2
            */

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0f * gc_block.values.r*gc_block.values.r - x*x - y*y;
 8004b58:	4bb9      	ldr	r3, [pc, #740]	; (8004e40 <gc_execute_line+0x13f8>)
 8004b5a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004b5c:	2181      	movs	r1, #129	; 0x81
 8004b5e:	05c9      	lsls	r1, r1, #23
 8004b60:	1c18      	adds	r0, r3, #0
 8004b62:	f7fb ff55 	bl	8000a10 <__aeabi_fmul>
 8004b66:	1c03      	adds	r3, r0, #0
 8004b68:	1c1a      	adds	r2, r3, #0
 8004b6a:	4bb5      	ldr	r3, [pc, #724]	; (8004e40 <gc_execute_line+0x13f8>)
 8004b6c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004b6e:	1c19      	adds	r1, r3, #0
 8004b70:	1c10      	adds	r0, r2, #0
 8004b72:	f7fb ff4d 	bl	8000a10 <__aeabi_fmul>
 8004b76:	1c03      	adds	r3, r0, #0
 8004b78:	1c1c      	adds	r4, r3, #0
 8004b7a:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8004b7c:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8004b7e:	f7fb ff47 	bl	8000a10 <__aeabi_fmul>
 8004b82:	1c03      	adds	r3, r0, #0
 8004b84:	1c19      	adds	r1, r3, #0
 8004b86:	1c20      	adds	r0, r4, #0
 8004b88:	f7fc f856 	bl	8000c38 <__aeabi_fsub>
 8004b8c:	1c03      	adds	r3, r0, #0
 8004b8e:	1c1c      	adds	r4, r3, #0
 8004b90:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8004b92:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8004b94:	f7fb ff3c 	bl	8000a10 <__aeabi_fmul>
 8004b98:	1c03      	adds	r3, r0, #0
 8004b9a:	1c19      	adds	r1, r3, #0
 8004b9c:	1c20      	adds	r0, r4, #0
 8004b9e:	f7fc f84b 	bl	8000c38 <__aeabi_fsub>
 8004ba2:	1c03      	adds	r3, r0, #0
 8004ba4:	643b      	str	r3, [r7, #64]	; 0x40

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
 8004ba6:	2100      	movs	r1, #0
 8004ba8:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8004baa:	f7fb fb93 	bl	80002d4 <__aeabi_fcmplt>
 8004bae:	1e03      	subs	r3, r0, #0
 8004bb0:	d002      	beq.n	8004bb8 <gc_execute_line+0x1170>
 8004bb2:	2322      	movs	r3, #34	; 0x22
 8004bb4:	f000 fc5c 	bl	8005470 <gc_execute_line+0x1a28>

            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrtf(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
 8004bb8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8004bba:	1c18      	adds	r0, r3, #0
 8004bbc:	f007 fc34 	bl	800c428 <sqrtf>
 8004bc0:	1c02      	adds	r2, r0, #0
 8004bc2:	2380      	movs	r3, #128	; 0x80
 8004bc4:	061b      	lsls	r3, r3, #24
 8004bc6:	4053      	eors	r3, r2
 8004bc8:	001c      	movs	r4, r3
 8004bca:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004bcc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004bce:	1c11      	adds	r1, r2, #0
 8004bd0:	1c18      	adds	r0, r3, #0
 8004bd2:	f001 fd1d 	bl	8006610 <hypot_f>
 8004bd6:	1c03      	adds	r3, r0, #0
 8004bd8:	1c19      	adds	r1, r3, #0
 8004bda:	1c20      	adds	r0, r4, #0
 8004bdc:	f7fb fd4e 	bl	800067c <__aeabi_fdiv>
 8004be0:	1c03      	adds	r3, r0, #0
 8004be2:	643b      	str	r3, [r7, #64]	; 0x40
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }
 8004be4:	4b96      	ldr	r3, [pc, #600]	; (8004e40 <gc_execute_line+0x13f8>)
 8004be6:	785b      	ldrb	r3, [r3, #1]
 8004be8:	2b03      	cmp	r3, #3
 8004bea:	d104      	bne.n	8004bf6 <gc_execute_line+0x11ae>
 8004bec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8004bee:	2280      	movs	r2, #128	; 0x80
 8004bf0:	0612      	lsls	r2, r2, #24
 8004bf2:	4053      	eors	r3, r2
 8004bf4:	643b      	str	r3, [r7, #64]	; 0x40
            */
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!),
            // even though it is advised against ever generating such circles in a single line of g-code. By
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) {
 8004bf6:	4b92      	ldr	r3, [pc, #584]	; (8004e40 <gc_execute_line+0x13f8>)
 8004bf8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004bfa:	2100      	movs	r1, #0
 8004bfc:	1c18      	adds	r0, r3, #0
 8004bfe:	f7fb fb69 	bl	80002d4 <__aeabi_fcmplt>
 8004c02:	1e03      	subs	r3, r0, #0
 8004c04:	d00b      	beq.n	8004c1e <gc_execute_line+0x11d6>
                h_x2_div_d = -h_x2_div_d;
 8004c06:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8004c08:	2280      	movs	r2, #128	; 0x80
 8004c0a:	0612      	lsls	r2, r2, #24
 8004c0c:	4053      	eors	r3, r2
 8004c0e:	643b      	str	r3, [r7, #64]	; 0x40
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
 8004c10:	4b8b      	ldr	r3, [pc, #556]	; (8004e40 <gc_execute_line+0x13f8>)
 8004c12:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004c14:	2280      	movs	r2, #128	; 0x80
 8004c16:	0612      	lsls	r2, r2, #24
 8004c18:	405a      	eors	r2, r3
 8004c1a:	4b89      	ldr	r3, [pc, #548]	; (8004e40 <gc_execute_line+0x13f8>)
 8004c1c:	629a      	str	r2, [r3, #40]	; 0x28
            }
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5f*(x-(y*h_x2_div_d));
 8004c1e:	2356      	movs	r3, #86	; 0x56
 8004c20:	18fb      	adds	r3, r7, r3
 8004c22:	781c      	ldrb	r4, [r3, #0]
 8004c24:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8004c26:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8004c28:	f7fb fef2 	bl	8000a10 <__aeabi_fmul>
 8004c2c:	1c03      	adds	r3, r0, #0
 8004c2e:	1c19      	adds	r1, r3, #0
 8004c30:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8004c32:	f7fc f801 	bl	8000c38 <__aeabi_fsub>
 8004c36:	1c03      	adds	r3, r0, #0
 8004c38:	21fc      	movs	r1, #252	; 0xfc
 8004c3a:	0589      	lsls	r1, r1, #22
 8004c3c:	1c18      	adds	r0, r3, #0
 8004c3e:	f7fb fee7 	bl	8000a10 <__aeabi_fmul>
 8004c42:	1c03      	adds	r3, r0, #0
 8004c44:	1c19      	adds	r1, r3, #0
 8004c46:	4a7e      	ldr	r2, [pc, #504]	; (8004e40 <gc_execute_line+0x13f8>)
 8004c48:	1ca3      	adds	r3, r4, #2
 8004c4a:	009b      	lsls	r3, r3, #2
 8004c4c:	18d3      	adds	r3, r2, r3
 8004c4e:	3308      	adds	r3, #8
 8004c50:	6019      	str	r1, [r3, #0]
            gc_block.values.ijk[axis_1] = 0.5f*(y+(x*h_x2_div_d));
 8004c52:	2355      	movs	r3, #85	; 0x55
 8004c54:	18fb      	adds	r3, r7, r3
 8004c56:	781c      	ldrb	r4, [r3, #0]
 8004c58:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8004c5a:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8004c5c:	f7fb fed8 	bl	8000a10 <__aeabi_fmul>
 8004c60:	1c03      	adds	r3, r0, #0
 8004c62:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8004c64:	1c18      	adds	r0, r3, #0
 8004c66:	f7fb fb93 	bl	8000390 <__aeabi_fadd>
 8004c6a:	1c03      	adds	r3, r0, #0
 8004c6c:	21fc      	movs	r1, #252	; 0xfc
 8004c6e:	0589      	lsls	r1, r1, #22
 8004c70:	1c18      	adds	r0, r3, #0
 8004c72:	f7fb fecd 	bl	8000a10 <__aeabi_fmul>
 8004c76:	1c03      	adds	r3, r0, #0
 8004c78:	1c19      	adds	r1, r3, #0
 8004c7a:	4a71      	ldr	r2, [pc, #452]	; (8004e40 <gc_execute_line+0x13f8>)
 8004c7c:	1ca3      	adds	r3, r4, #2
 8004c7e:	009b      	lsls	r3, r3, #2
 8004c80:	18d3      	adds	r3, r2, r3
 8004c82:	3308      	adds	r3, #8
 8004c84:	6019      	str	r1, [r3, #0]
            if (delta_r > 0.005f) {
              if (delta_r > 0.5f) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
              if (delta_r > (0.001f*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
            }
          }
          break;
 8004c86:	e0f6      	b.n	8004e76 <gc_execute_line+0x142e>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5f*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5f*(y+(x*h_x2_div_d));

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
 8004c88:	2351      	movs	r3, #81	; 0x51
 8004c8a:	18fb      	adds	r3, r7, r3
 8004c8c:	781b      	ldrb	r3, [r3, #0]
 8004c8e:	2256      	movs	r2, #86	; 0x56
 8004c90:	18ba      	adds	r2, r7, r2
 8004c92:	7812      	ldrb	r2, [r2, #0]
 8004c94:	2101      	movs	r1, #1
 8004c96:	4091      	lsls	r1, r2
 8004c98:	2255      	movs	r2, #85	; 0x55
 8004c9a:	18ba      	adds	r2, r7, r2
 8004c9c:	7812      	ldrb	r2, [r2, #0]
 8004c9e:	2001      	movs	r0, #1
 8004ca0:	4090      	lsls	r0, r2
 8004ca2:	0002      	movs	r2, r0
 8004ca4:	430a      	orrs	r2, r1
 8004ca6:	4013      	ands	r3, r2
 8004ca8:	d102      	bne.n	8004cb0 <gc_execute_line+0x1268>
 8004caa:	2323      	movs	r3, #35	; 0x23
 8004cac:	f000 fbe0 	bl	8005470 <gc_execute_line+0x1a28>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));
 8004cb0:	234c      	movs	r3, #76	; 0x4c
 8004cb2:	18fb      	adds	r3, r7, r3
 8004cb4:	224c      	movs	r2, #76	; 0x4c
 8004cb6:	18ba      	adds	r2, r7, r2
 8004cb8:	8812      	ldrh	r2, [r2, #0]
 8004cba:	210e      	movs	r1, #14
 8004cbc:	438a      	bics	r2, r1
 8004cbe:	801a      	strh	r2, [r3, #0]

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
 8004cc0:	4b5f      	ldr	r3, [pc, #380]	; (8004e40 <gc_execute_line+0x13f8>)
 8004cc2:	78db      	ldrb	r3, [r3, #3]
 8004cc4:	2b01      	cmp	r3, #1
 8004cc6:	d133      	bne.n	8004d30 <gc_execute_line+0x12e8>
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
 8004cc8:	2347      	movs	r3, #71	; 0x47
 8004cca:	18fb      	adds	r3, r7, r3
 8004ccc:	2200      	movs	r2, #0
 8004cce:	701a      	strb	r2, [r3, #0]
 8004cd0:	e029      	b.n	8004d26 <gc_execute_line+0x12de>
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
 8004cd2:	2351      	movs	r3, #81	; 0x51
 8004cd4:	18fb      	adds	r3, r7, r3
 8004cd6:	781a      	ldrb	r2, [r3, #0]
 8004cd8:	2347      	movs	r3, #71	; 0x47
 8004cda:	18fb      	adds	r3, r7, r3
 8004cdc:	781b      	ldrb	r3, [r3, #0]
 8004cde:	411a      	asrs	r2, r3
 8004ce0:	0013      	movs	r3, r2
 8004ce2:	2201      	movs	r2, #1
 8004ce4:	4013      	ands	r3, r2
 8004ce6:	d017      	beq.n	8004d18 <gc_execute_line+0x12d0>
 8004ce8:	2347      	movs	r3, #71	; 0x47
 8004cea:	18fb      	adds	r3, r7, r3
 8004cec:	781c      	ldrb	r4, [r3, #0]
 8004cee:	2347      	movs	r3, #71	; 0x47
 8004cf0:	18fb      	adds	r3, r7, r3
 8004cf2:	781b      	ldrb	r3, [r3, #0]
 8004cf4:	4a52      	ldr	r2, [pc, #328]	; (8004e40 <gc_execute_line+0x13f8>)
 8004cf6:	3302      	adds	r3, #2
 8004cf8:	009b      	lsls	r3, r3, #2
 8004cfa:	18d3      	adds	r3, r2, r3
 8004cfc:	3308      	adds	r3, #8
 8004cfe:	681b      	ldr	r3, [r3, #0]
 8004d00:	4953      	ldr	r1, [pc, #332]	; (8004e50 <gc_execute_line+0x1408>)
 8004d02:	1c18      	adds	r0, r3, #0
 8004d04:	f7fb fe84 	bl	8000a10 <__aeabi_fmul>
 8004d08:	1c03      	adds	r3, r0, #0
 8004d0a:	1c19      	adds	r1, r3, #0
 8004d0c:	4a4c      	ldr	r2, [pc, #304]	; (8004e40 <gc_execute_line+0x13f8>)
 8004d0e:	1ca3      	adds	r3, r4, #2
 8004d10:	009b      	lsls	r3, r3, #2
 8004d12:	18d3      	adds	r3, r2, r3
 8004d14:	3308      	adds	r3, #8
 8004d16:	6019      	str	r1, [r3, #0]
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
 8004d18:	2347      	movs	r3, #71	; 0x47
 8004d1a:	18fb      	adds	r3, r7, r3
 8004d1c:	781a      	ldrb	r2, [r3, #0]
 8004d1e:	2347      	movs	r3, #71	; 0x47
 8004d20:	18fb      	adds	r3, r7, r3
 8004d22:	3201      	adds	r2, #1
 8004d24:	701a      	strb	r2, [r3, #0]
 8004d26:	2347      	movs	r3, #71	; 0x47
 8004d28:	18fb      	adds	r3, r7, r3
 8004d2a:	781b      	ldrb	r3, [r3, #0]
 8004d2c:	2b02      	cmp	r3, #2
 8004d2e:	d9d0      	bls.n	8004cd2 <gc_execute_line+0x128a>
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
 8004d30:	2356      	movs	r3, #86	; 0x56
 8004d32:	18fb      	adds	r3, r7, r3
 8004d34:	781b      	ldrb	r3, [r3, #0]
 8004d36:	4a42      	ldr	r2, [pc, #264]	; (8004e40 <gc_execute_line+0x13f8>)
 8004d38:	3302      	adds	r3, #2
 8004d3a:	009b      	lsls	r3, r3, #2
 8004d3c:	18d3      	adds	r3, r2, r3
 8004d3e:	3308      	adds	r3, #8
 8004d40:	681b      	ldr	r3, [r3, #0]
 8004d42:	1c19      	adds	r1, r3, #0
 8004d44:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8004d46:	f7fb ff77 	bl	8000c38 <__aeabi_fsub>
 8004d4a:	1c03      	adds	r3, r0, #0
 8004d4c:	63bb      	str	r3, [r7, #56]	; 0x38
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
 8004d4e:	2355      	movs	r3, #85	; 0x55
 8004d50:	18fb      	adds	r3, r7, r3
 8004d52:	781b      	ldrb	r3, [r3, #0]
 8004d54:	4a3a      	ldr	r2, [pc, #232]	; (8004e40 <gc_execute_line+0x13f8>)
 8004d56:	3302      	adds	r3, #2
 8004d58:	009b      	lsls	r3, r3, #2
 8004d5a:	18d3      	adds	r3, r2, r3
 8004d5c:	3308      	adds	r3, #8
 8004d5e:	681b      	ldr	r3, [r3, #0]
 8004d60:	1c19      	adds	r1, r3, #0
 8004d62:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8004d64:	f7fb ff68 	bl	8000c38 <__aeabi_fsub>
 8004d68:	1c03      	adds	r3, r0, #0
 8004d6a:	637b      	str	r3, [r7, #52]	; 0x34
            float target_r = hypot_f(x,y);
 8004d6c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004d6e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004d70:	1c11      	adds	r1, r2, #0
 8004d72:	1c18      	adds	r0, r3, #0
 8004d74:	f001 fc4c 	bl	8006610 <hypot_f>
 8004d78:	1c03      	adds	r3, r0, #0
 8004d7a:	633b      	str	r3, [r7, #48]	; 0x30

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);
 8004d7c:	2356      	movs	r3, #86	; 0x56
 8004d7e:	18fb      	adds	r3, r7, r3
 8004d80:	781b      	ldrb	r3, [r3, #0]
 8004d82:	4a2f      	ldr	r2, [pc, #188]	; (8004e40 <gc_execute_line+0x13f8>)
 8004d84:	3302      	adds	r3, #2
 8004d86:	009b      	lsls	r3, r3, #2
 8004d88:	18d3      	adds	r3, r2, r3
 8004d8a:	3308      	adds	r3, #8
 8004d8c:	6818      	ldr	r0, [r3, #0]
 8004d8e:	2355      	movs	r3, #85	; 0x55
 8004d90:	18fb      	adds	r3, r7, r3
 8004d92:	781b      	ldrb	r3, [r3, #0]
 8004d94:	4a2a      	ldr	r2, [pc, #168]	; (8004e40 <gc_execute_line+0x13f8>)
 8004d96:	3302      	adds	r3, #2
 8004d98:	009b      	lsls	r3, r3, #2
 8004d9a:	18d3      	adds	r3, r2, r3
 8004d9c:	3308      	adds	r3, #8
 8004d9e:	681b      	ldr	r3, [r3, #0]
 8004da0:	1c19      	adds	r1, r3, #0
 8004da2:	f001 fc35 	bl	8006610 <hypot_f>
 8004da6:	1c02      	adds	r2, r0, #0
 8004da8:	4b25      	ldr	r3, [pc, #148]	; (8004e40 <gc_execute_line+0x13f8>)
 8004daa:	629a      	str	r2, [r3, #40]	; 0x28

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabsf(target_r-gc_block.values.r);
 8004dac:	4b24      	ldr	r3, [pc, #144]	; (8004e40 <gc_execute_line+0x13f8>)
 8004dae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004db0:	1c19      	adds	r1, r3, #0
 8004db2:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8004db4:	f7fb ff40 	bl	8000c38 <__aeabi_fsub>
 8004db8:	1c03      	adds	r3, r0, #0
 8004dba:	005b      	lsls	r3, r3, #1
 8004dbc:	085b      	lsrs	r3, r3, #1
 8004dbe:	62fb      	str	r3, [r7, #44]	; 0x2c
            if (delta_r > 0.005f) {
 8004dc0:	4924      	ldr	r1, [pc, #144]	; (8004e54 <gc_execute_line+0x140c>)
 8004dc2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8004dc4:	f7fb fa9a 	bl	80002fc <__aeabi_fcmpgt>
 8004dc8:	1e03      	subs	r3, r0, #0
 8004dca:	d100      	bne.n	8004dce <gc_execute_line+0x1386>
              if (delta_r > 0.5f) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
              if (delta_r > (0.001f*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
            }
          }
          break;
 8004dcc:	e053      	b.n	8004e76 <gc_execute_line+0x142e>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabsf(target_r-gc_block.values.r);
            if (delta_r > 0.005f) {
              if (delta_r > 0.5f) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
 8004dce:	21fc      	movs	r1, #252	; 0xfc
 8004dd0:	0589      	lsls	r1, r1, #22
 8004dd2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8004dd4:	f7fb fa92 	bl	80002fc <__aeabi_fcmpgt>
 8004dd8:	1e03      	subs	r3, r0, #0
 8004dda:	d001      	beq.n	8004de0 <gc_execute_line+0x1398>
 8004ddc:	2321      	movs	r3, #33	; 0x21
 8004dde:	e347      	b.n	8005470 <gc_execute_line+0x1a28>
              if (delta_r > (0.001f*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
 8004de0:	4b17      	ldr	r3, [pc, #92]	; (8004e40 <gc_execute_line+0x13f8>)
 8004de2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004de4:	491c      	ldr	r1, [pc, #112]	; (8004e58 <gc_execute_line+0x1410>)
 8004de6:	1c18      	adds	r0, r3, #0
 8004de8:	f7fb fe12 	bl	8000a10 <__aeabi_fmul>
 8004dec:	1c03      	adds	r3, r0, #0
 8004dee:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8004df0:	1c18      	adds	r0, r3, #0
 8004df2:	f7fb fa6f 	bl	80002d4 <__aeabi_fcmplt>
 8004df6:	1e03      	subs	r3, r0, #0
 8004df8:	d100      	bne.n	8004dfc <gc_execute_line+0x13b4>
            }
          }
          break;
 8004dfa:	e03c      	b.n	8004e76 <gc_execute_line+0x142e>

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabsf(target_r-gc_block.values.r);
            if (delta_r > 0.005f) {
              if (delta_r > 0.5f) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
              if (delta_r > (0.001f*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
 8004dfc:	2321      	movs	r3, #33	; 0x21
 8004dfe:	e337      	b.n	8005470 <gc_execute_line+0x1a28>
            }
          }
          break;
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
            gc_parser_flags |= GC_PARSER_PROBE_IS_NO_ERROR; // No break intentional.
 8004e00:	234b      	movs	r3, #75	; 0x4b
 8004e02:	18fb      	adds	r3, r7, r3
 8004e04:	224b      	movs	r2, #75	; 0x4b
 8004e06:	18ba      	adds	r2, r7, r2
 8004e08:	7812      	ldrb	r2, [r2, #0]
 8004e0a:	2110      	movs	r1, #16
 8004e0c:	430a      	orrs	r2, r1
 8004e0e:	701a      	strb	r2, [r3, #0]
        case MOTION_MODE_PROBE_TOWARD: case MOTION_MODE_PROBE_AWAY:
            if ((gc_block.modal.motion == MOTION_MODE_PROBE_AWAY) ||
 8004e10:	4b0b      	ldr	r3, [pc, #44]	; (8004e40 <gc_execute_line+0x13f8>)
 8004e12:	785b      	ldrb	r3, [r3, #1]
 8004e14:	2b8e      	cmp	r3, #142	; 0x8e
 8004e16:	d003      	beq.n	8004e20 <gc_execute_line+0x13d8>
                (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
 8004e18:	4b09      	ldr	r3, [pc, #36]	; (8004e40 <gc_execute_line+0x13f8>)
 8004e1a:	785b      	ldrb	r3, [r3, #1]
          }
          break;
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
            gc_parser_flags |= GC_PARSER_PROBE_IS_NO_ERROR; // No break intentional.
        case MOTION_MODE_PROBE_TOWARD: case MOTION_MODE_PROBE_AWAY:
            if ((gc_block.modal.motion == MOTION_MODE_PROBE_AWAY) ||
 8004e1c:	2b8f      	cmp	r3, #143	; 0x8f
 8004e1e:	d107      	bne.n	8004e30 <gc_execute_line+0x13e8>
                (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
 8004e20:	234b      	movs	r3, #75	; 0x4b
 8004e22:	18fb      	adds	r3, r7, r3
 8004e24:	224b      	movs	r2, #75	; 0x4b
 8004e26:	18ba      	adds	r2, r7, r2
 8004e28:	7812      	ldrb	r2, [r2, #0]
 8004e2a:	2108      	movs	r1, #8
 8004e2c:	430a      	orrs	r2, r1
 8004e2e:	701a      	strb	r2, [r3, #0]
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
 8004e30:	2352      	movs	r3, #82	; 0x52
 8004e32:	18fb      	adds	r3, r7, r3
 8004e34:	781b      	ldrb	r3, [r3, #0]
 8004e36:	2b00      	cmp	r3, #0
 8004e38:	d110      	bne.n	8004e5c <gc_execute_line+0x1414>
 8004e3a:	231a      	movs	r3, #26
 8004e3c:	e318      	b.n	8005470 <gc_execute_line+0x1a28>
 8004e3e:	46c0      	nop			; (mov r8, r8)
 8004e40:	200009a0 	.word	0x200009a0
 8004e44:	2000095c 	.word	0x2000095c
 8004e48:	200009d4 	.word	0x200009d4
 8004e4c:	20000978 	.word	0x20000978
 8004e50:	41cb3333 	.word	0x41cb3333
 8004e54:	3ba3d70a 	.word	0x3ba3d70a
 8004e58:	3a83126f 	.word	0x3a83126f
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
 8004e5c:	49b3      	ldr	r1, [pc, #716]	; (800512c <gc_execute_line+0x16e4>)
 8004e5e:	4bb4      	ldr	r3, [pc, #720]	; (8005130 <gc_execute_line+0x16e8>)
 8004e60:	220c      	movs	r2, #12
 8004e62:	0018      	movs	r0, r3
 8004e64:	f007 f934 	bl	800c0d0 <memcmp>
 8004e68:	1e03      	subs	r3, r0, #0
 8004e6a:	d103      	bne.n	8004e74 <gc_execute_line+0x142c>
 8004e6c:	2321      	movs	r3, #33	; 0x21
 8004e6e:	e2ff      	b.n	8005470 <gc_execute_line+0x1a28>
        case MOTION_MODE_LINEAR:
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }

          break;
 8004e70:	46c0      	nop			; (mov r8, r8)
 8004e72:	e000      	b.n	8004e76 <gc_execute_line+0x142e>
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
          break;
 8004e74:	46c0      	nop			; (mov r8, r8)

  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
 8004e76:	234b      	movs	r3, #75	; 0x4b
 8004e78:	18fb      	adds	r3, r7, r3
 8004e7a:	781b      	ldrb	r3, [r3, #0]
 8004e7c:	2201      	movs	r2, #1
 8004e7e:	4013      	ands	r3, r2
 8004e80:	d008      	beq.n	8004e94 <gc_execute_line+0x144c>
      // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
      bit_false(value_words, (bit(WORD_N) | bit(WORD_F)));
 8004e82:	234c      	movs	r3, #76	; 0x4c
 8004e84:	18fb      	adds	r3, r7, r3
 8004e86:	224c      	movs	r2, #76	; 0x4c
 8004e88:	18ba      	adds	r2, r7, r2
 8004e8a:	8812      	ldrh	r2, [r2, #0]
 8004e8c:	2121      	movs	r1, #33	; 0x21
 8004e8e:	438a      	bics	r2, r1
 8004e90:	801a      	strh	r2, [r3, #0]
 8004e92:	e007      	b.n	8004ea4 <gc_execute_line+0x145c>
  } else {
      bit_false(value_words, (bit(WORD_N) | bit(WORD_F) | bit(WORD_S) | bit(WORD_T))); // Remove single-meaning value words.
 8004e94:	234c      	movs	r3, #76	; 0x4c
 8004e96:	18fb      	adds	r3, r7, r3
 8004e98:	224c      	movs	r2, #76	; 0x4c
 8004e9a:	18ba      	adds	r2, r7, r2
 8004e9c:	8812      	ldrh	r2, [r2, #0]
 8004e9e:	49a5      	ldr	r1, [pc, #660]	; (8005134 <gc_execute_line+0x16ec>)
 8004ea0:	400a      	ands	r2, r1
 8004ea2:	801a      	strh	r2, [r3, #0]
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
 8004ea4:	2357      	movs	r3, #87	; 0x57
 8004ea6:	18fb      	adds	r3, r7, r3
 8004ea8:	781b      	ldrb	r3, [r3, #0]
 8004eaa:	2b00      	cmp	r3, #0
 8004eac:	d007      	beq.n	8004ebe <gc_execute_line+0x1476>
 8004eae:	234c      	movs	r3, #76	; 0x4c
 8004eb0:	18fb      	adds	r3, r7, r3
 8004eb2:	224c      	movs	r2, #76	; 0x4c
 8004eb4:	18ba      	adds	r2, r7, r2
 8004eb6:	8812      	ldrh	r2, [r2, #0]
 8004eb8:	499f      	ldr	r1, [pc, #636]	; (8005138 <gc_execute_line+0x16f0>)
 8004eba:	400a      	ands	r2, r1
 8004ebc:	801a      	strh	r2, [r3, #0]
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
 8004ebe:	234c      	movs	r3, #76	; 0x4c
 8004ec0:	18fb      	adds	r3, r7, r3
 8004ec2:	881b      	ldrh	r3, [r3, #0]
 8004ec4:	2b00      	cmp	r3, #0
 8004ec6:	d001      	beq.n	8004ecc <gc_execute_line+0x1484>
 8004ec8:	2324      	movs	r3, #36	; 0x24
 8004eca:	e2d1      	b.n	8005470 <gc_execute_line+0x1a28>
     need to update the state and execute the block according to the order-of-execution.
  */

  // Initialize planner data struct for motion blocks.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
 8004ecc:	2308      	movs	r3, #8
 8004ece:	18fb      	adds	r3, r7, r3
 8004ed0:	62bb      	str	r3, [r7, #40]	; 0x28
  memset(pl_data,0,sizeof(plan_line_data_t)); // Zero pl_data struct
 8004ed2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004ed4:	220c      	movs	r2, #12
 8004ed6:	2100      	movs	r1, #0
 8004ed8:	0018      	movs	r0, r3
 8004eda:	f007 f911 	bl	800c100 <memset>

                                              // Intercept jog commands and complete error checking for valid jog commands and execute.
                                              // NOTE: G-code parser state is not updated, except the position to ensure sequential jog
                                              // targets are computed correctly. The final parser position after a jog is updated in
                                              // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
 8004ede:	234b      	movs	r3, #75	; 0x4b
 8004ee0:	18fb      	adds	r3, r7, r3
 8004ee2:	781b      	ldrb	r3, [r3, #0]
 8004ee4:	2201      	movs	r2, #1
 8004ee6:	4013      	ands	r3, r2
 8004ee8:	d038      	beq.n	8004f5c <gc_execute_line+0x1514>
      // Only distance and unit modal commands and G53 absolute override command are allowed.
      // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
      if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6 | bit(MODAL_GROUP_G0)))) { FAIL(STATUS_INVALID_JOG_COMMAND) };
 8004eea:	234e      	movs	r3, #78	; 0x4e
 8004eec:	18fb      	adds	r3, r7, r3
 8004eee:	881b      	ldrh	r3, [r3, #0]
 8004ef0:	2249      	movs	r2, #73	; 0x49
 8004ef2:	4393      	bics	r3, r2
 8004ef4:	d001      	beq.n	8004efa <gc_execute_line+0x14b2>
 8004ef6:	2310      	movs	r3, #16
 8004ef8:	e2ba      	b.n	8005470 <gc_execute_line+0x1a28>
      if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
 8004efa:	4b90      	ldr	r3, [pc, #576]	; (800513c <gc_execute_line+0x16f4>)
 8004efc:	781b      	ldrb	r3, [r3, #0]
 8004efe:	2b35      	cmp	r3, #53	; 0x35
 8004f00:	d005      	beq.n	8004f0e <gc_execute_line+0x14c6>
 8004f02:	4b8e      	ldr	r3, [pc, #568]	; (800513c <gc_execute_line+0x16f4>)
 8004f04:	781b      	ldrb	r3, [r3, #0]
 8004f06:	2b00      	cmp	r3, #0
 8004f08:	d001      	beq.n	8004f0e <gc_execute_line+0x14c6>
 8004f0a:	2310      	movs	r3, #16
 8004f0c:	e2b0      	b.n	8005470 <gc_execute_line+0x1a28>

      // Initialize planner data to current spindle and coolant modal state.
      pl_data->spindle_speed = gc_state.spindle_speed;
 8004f0e:	4b8c      	ldr	r3, [pc, #560]	; (8005140 <gc_execute_line+0x16f8>)
 8004f10:	68da      	ldr	r2, [r3, #12]
 8004f12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004f14:	605a      	str	r2, [r3, #4]
      plan_data.condition = (gc_state.modal.spindle | gc_state.modal.coolant);
 8004f16:	4b8a      	ldr	r3, [pc, #552]	; (8005140 <gc_execute_line+0x16f8>)
 8004f18:	7a5a      	ldrb	r2, [r3, #9]
 8004f1a:	4b89      	ldr	r3, [pc, #548]	; (8005140 <gc_execute_line+0x16f8>)
 8004f1c:	7a1b      	ldrb	r3, [r3, #8]
 8004f1e:	4313      	orrs	r3, r2
 8004f20:	b2da      	uxtb	r2, r3
 8004f22:	2308      	movs	r3, #8
 8004f24:	18fb      	adds	r3, r7, r3
 8004f26:	721a      	strb	r2, [r3, #8]

      uint8_t status = jog_execute(&plan_data, &gc_block);
 8004f28:	2327      	movs	r3, #39	; 0x27
 8004f2a:	18fc      	adds	r4, r7, r3
 8004f2c:	4a83      	ldr	r2, [pc, #524]	; (800513c <gc_execute_line+0x16f4>)
 8004f2e:	2308      	movs	r3, #8
 8004f30:	18fb      	adds	r3, r7, r3
 8004f32:	0011      	movs	r1, r2
 8004f34:	0018      	movs	r0, r3
 8004f36:	f000 faaf 	bl	8005498 <jog_execute>
 8004f3a:	0003      	movs	r3, r0
 8004f3c:	7023      	strb	r3, [r4, #0]
      if (status == STATUS_OK) { memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); }
 8004f3e:	2327      	movs	r3, #39	; 0x27
 8004f40:	18fb      	adds	r3, r7, r3
 8004f42:	781b      	ldrb	r3, [r3, #0]
 8004f44:	2b00      	cmp	r3, #0
 8004f46:	d105      	bne.n	8004f54 <gc_execute_line+0x150c>
 8004f48:	4b7d      	ldr	r3, [pc, #500]	; (8005140 <gc_execute_line+0x16f8>)
 8004f4a:	4a7c      	ldr	r2, [pc, #496]	; (800513c <gc_execute_line+0x16f4>)
 8004f4c:	331c      	adds	r3, #28
 8004f4e:	3234      	adds	r2, #52	; 0x34
 8004f50:	ca13      	ldmia	r2!, {r0, r1, r4}
 8004f52:	c313      	stmia	r3!, {r0, r1, r4}
      return(status);
 8004f54:	2327      	movs	r3, #39	; 0x27
 8004f56:	18fb      	adds	r3, r7, r3
 8004f58:	781b      	ldrb	r3, [r3, #0]
 8004f5a:	e289      	b.n	8005470 <gc_execute_line+0x1a28>
  }

  // If in laser mode, setup laser power based on current and past parser conditions.
  if (bit_istrue(settings.flags, BITFLAG_LASER_MODE)) {
 8004f5c:	4b79      	ldr	r3, [pc, #484]	; (8005144 <gc_execute_line+0x16fc>)
 8004f5e:	2248      	movs	r2, #72	; 0x48
 8004f60:	5c9b      	ldrb	r3, [r3, r2]
 8004f62:	001a      	movs	r2, r3
 8004f64:	2302      	movs	r3, #2
 8004f66:	4013      	ands	r3, r2
 8004f68:	d054      	beq.n	8005014 <gc_execute_line+0x15cc>
      if (!((gc_block.modal.motion == MOTION_MODE_LINEAR) || (gc_block.modal.motion == MOTION_MODE_CW_ARC)
 8004f6a:	4b74      	ldr	r3, [pc, #464]	; (800513c <gc_execute_line+0x16f4>)
 8004f6c:	785b      	ldrb	r3, [r3, #1]
 8004f6e:	2b01      	cmp	r3, #1
 8004f70:	d00f      	beq.n	8004f92 <gc_execute_line+0x154a>
 8004f72:	4b72      	ldr	r3, [pc, #456]	; (800513c <gc_execute_line+0x16f4>)
 8004f74:	785b      	ldrb	r3, [r3, #1]
 8004f76:	2b02      	cmp	r3, #2
 8004f78:	d00b      	beq.n	8004f92 <gc_execute_line+0x154a>
          || (gc_block.modal.motion == MOTION_MODE_CCW_ARC))) {
 8004f7a:	4b70      	ldr	r3, [pc, #448]	; (800513c <gc_execute_line+0x16f4>)
 8004f7c:	785b      	ldrb	r3, [r3, #1]
      return(status);
  }

  // If in laser mode, setup laser power based on current and past parser conditions.
  if (bit_istrue(settings.flags, BITFLAG_LASER_MODE)) {
      if (!((gc_block.modal.motion == MOTION_MODE_LINEAR) || (gc_block.modal.motion == MOTION_MODE_CW_ARC)
 8004f7e:	2b03      	cmp	r3, #3
 8004f80:	d007      	beq.n	8004f92 <gc_execute_line+0x154a>
          || (gc_block.modal.motion == MOTION_MODE_CCW_ARC))) {
          gc_parser_flags |= GC_PARSER_LASER_DISABLE;
 8004f82:	234b      	movs	r3, #75	; 0x4b
 8004f84:	18fb      	adds	r3, r7, r3
 8004f86:	224b      	movs	r2, #75	; 0x4b
 8004f88:	18ba      	adds	r2, r7, r2
 8004f8a:	7812      	ldrb	r2, [r2, #0]
 8004f8c:	2140      	movs	r1, #64	; 0x40
 8004f8e:	430a      	orrs	r2, r1
 8004f90:	701a      	strb	r2, [r3, #0]
      }

      // Any motion mode with axis words is allowed to be passed from a spindle speed update. 
      // NOTE: G1 and G0 without axis words sets axis_command to none. G28/30 are intentionally omitted.
      // TODO: Check sync conditions for M3 enabled motions that don't enter the planner. (zero length).
      if (axis_words && (axis_command == AXIS_COMMAND_MOTION_MODE)) {
 8004f92:	2352      	movs	r3, #82	; 0x52
 8004f94:	18fb      	adds	r3, r7, r3
 8004f96:	781b      	ldrb	r3, [r3, #0]
 8004f98:	2b00      	cmp	r3, #0
 8004f9a:	d00e      	beq.n	8004fba <gc_execute_line+0x1572>
 8004f9c:	2357      	movs	r3, #87	; 0x57
 8004f9e:	18fb      	adds	r3, r7, r3
 8004fa0:	781b      	ldrb	r3, [r3, #0]
 8004fa2:	2b02      	cmp	r3, #2
 8004fa4:	d109      	bne.n	8004fba <gc_execute_line+0x1572>
        gc_parser_flags |= GC_PARSER_LASER_ISMOTION;
 8004fa6:	234b      	movs	r3, #75	; 0x4b
 8004fa8:	18fb      	adds	r3, r7, r3
 8004faa:	224b      	movs	r2, #75	; 0x4b
 8004fac:	18ba      	adds	r2, r7, r2
 8004fae:	7812      	ldrb	r2, [r2, #0]
 8004fb0:	2180      	movs	r1, #128	; 0x80
 8004fb2:	4249      	negs	r1, r1
 8004fb4:	430a      	orrs	r2, r1
 8004fb6:	701a      	strb	r2, [r3, #0]
 8004fb8:	e02c      	b.n	8005014 <gc_execute_line+0x15cc>
      }
      else {
        // M3 constant power laser requires planner syncs to update the laser when changing between
        // a G1/2/3 motion mode state and vice versa when there is no motion in the line.
        if (gc_state.modal.spindle == SPINDLE_ENABLE_CW) {
 8004fba:	4b61      	ldr	r3, [pc, #388]	; (8005140 <gc_execute_line+0x16f8>)
 8004fbc:	7a5b      	ldrb	r3, [r3, #9]
 8004fbe:	2b10      	cmp	r3, #16
 8004fc0:	d128      	bne.n	8005014 <gc_execute_line+0x15cc>
          if ((gc_state.modal.motion == MOTION_MODE_LINEAR) || (gc_state.modal.motion == MOTION_MODE_CW_ARC)
 8004fc2:	4b5f      	ldr	r3, [pc, #380]	; (8005140 <gc_execute_line+0x16f8>)
 8004fc4:	781b      	ldrb	r3, [r3, #0]
 8004fc6:	2b01      	cmp	r3, #1
 8004fc8:	d007      	beq.n	8004fda <gc_execute_line+0x1592>
 8004fca:	4b5d      	ldr	r3, [pc, #372]	; (8005140 <gc_execute_line+0x16f8>)
 8004fcc:	781b      	ldrb	r3, [r3, #0]
 8004fce:	2b02      	cmp	r3, #2
 8004fd0:	d003      	beq.n	8004fda <gc_execute_line+0x1592>
            || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
 8004fd2:	4b5b      	ldr	r3, [pc, #364]	; (8005140 <gc_execute_line+0x16f8>)
 8004fd4:	781b      	ldrb	r3, [r3, #0]
 8004fd6:	2b03      	cmp	r3, #3
 8004fd8:	d10e      	bne.n	8004ff8 <gc_execute_line+0x15b0>
            if (bit_istrue(gc_parser_flags, GC_PARSER_LASER_DISABLE)) {
 8004fda:	234b      	movs	r3, #75	; 0x4b
 8004fdc:	18fb      	adds	r3, r7, r3
 8004fde:	781b      	ldrb	r3, [r3, #0]
 8004fe0:	2240      	movs	r2, #64	; 0x40
 8004fe2:	4013      	ands	r3, r2
 8004fe4:	d016      	beq.n	8005014 <gc_execute_line+0x15cc>
              gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC; // Change from G1/2/3 motion mode.
 8004fe6:	234b      	movs	r3, #75	; 0x4b
 8004fe8:	18fb      	adds	r3, r7, r3
 8004fea:	224b      	movs	r2, #75	; 0x4b
 8004fec:	18ba      	adds	r2, r7, r2
 8004fee:	7812      	ldrb	r2, [r2, #0]
 8004ff0:	2120      	movs	r1, #32
 8004ff2:	430a      	orrs	r2, r1
 8004ff4:	701a      	strb	r2, [r3, #0]
        // M3 constant power laser requires planner syncs to update the laser when changing between
        // a G1/2/3 motion mode state and vice versa when there is no motion in the line.
        if (gc_state.modal.spindle == SPINDLE_ENABLE_CW) {
          if ((gc_state.modal.motion == MOTION_MODE_LINEAR) || (gc_state.modal.motion == MOTION_MODE_CW_ARC)
            || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
            if (bit_istrue(gc_parser_flags, GC_PARSER_LASER_DISABLE)) {
 8004ff6:	e00d      	b.n	8005014 <gc_execute_line+0x15cc>
              gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC; // Change from G1/2/3 motion mode.
            }
          }
          else {
            // When changing to a G1 motion mode without axis words from a non-G1/2/3 motion mode.
            if (bit_isfalse(gc_parser_flags, GC_PARSER_LASER_DISABLE)) {
 8004ff8:	234b      	movs	r3, #75	; 0x4b
 8004ffa:	18fb      	adds	r3, r7, r3
 8004ffc:	781b      	ldrb	r3, [r3, #0]
 8004ffe:	2240      	movs	r2, #64	; 0x40
 8005000:	4013      	ands	r3, r2
 8005002:	d107      	bne.n	8005014 <gc_execute_line+0x15cc>
              gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC;
 8005004:	234b      	movs	r3, #75	; 0x4b
 8005006:	18fb      	adds	r3, r7, r3
 8005008:	224b      	movs	r2, #75	; 0x4b
 800500a:	18ba      	adds	r2, r7, r2
 800500c:	7812      	ldrb	r2, [r2, #0]
 800500e:	2120      	movs	r1, #32
 8005010:	430a      	orrs	r2, r1
 8005012:	701a      	strb	r2, [r3, #0]
      }
  }

  // [0. Non-specific/common error-checks and miscellaneous setup]:
  // NOTE: If no line number is present, the value is zero.
  gc_state.line_number = gc_block.values.n;
 8005014:	4b49      	ldr	r3, [pc, #292]	; (800513c <gc_execute_line+0x16f4>)
 8005016:	6a1a      	ldr	r2, [r3, #32]
 8005018:	4b49      	ldr	r3, [pc, #292]	; (8005140 <gc_execute_line+0x16f8>)
 800501a:	619a      	str	r2, [r3, #24]
  #endif

  // [1. Comments feedback ]:  NOT SUPPORTED

  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
 800501c:	4b47      	ldr	r3, [pc, #284]	; (800513c <gc_execute_line+0x16f4>)
 800501e:	789a      	ldrb	r2, [r3, #2]
 8005020:	4b47      	ldr	r3, [pc, #284]	; (8005140 <gc_execute_line+0x16f8>)
 8005022:	705a      	strb	r2, [r3, #1]
  if (gc_state.modal.feed_rate) { pl_data->condition |= PL_COND_FLAG_INVERSE_TIME; } // Set condition flag for planner use.
 8005024:	4b46      	ldr	r3, [pc, #280]	; (8005140 <gc_execute_line+0x16f8>)
 8005026:	785b      	ldrb	r3, [r3, #1]
 8005028:	2b00      	cmp	r3, #0
 800502a:	d006      	beq.n	800503a <gc_execute_line+0x15f2>
 800502c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800502e:	7a1b      	ldrb	r3, [r3, #8]
 8005030:	2208      	movs	r2, #8
 8005032:	4313      	orrs	r3, r2
 8005034:	b2da      	uxtb	r2, r3
 8005036:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005038:	721a      	strb	r2, [r3, #8]

  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
 800503a:	4b40      	ldr	r3, [pc, #256]	; (800513c <gc_execute_line+0x16f4>)
 800503c:	68da      	ldr	r2, [r3, #12]
 800503e:	4b40      	ldr	r3, [pc, #256]	; (8005140 <gc_execute_line+0x16f8>)
 8005040:	611a      	str	r2, [r3, #16]
  pl_data->feed_rate = gc_state.feed_rate; // Record data for planner use.
 8005042:	4b3f      	ldr	r3, [pc, #252]	; (8005140 <gc_execute_line+0x16f8>)
 8005044:	691a      	ldr	r2, [r3, #16]
 8005046:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005048:	601a      	str	r2, [r3, #0]

  // [4. Set spindle speed ]:
  if ((gc_state.spindle_speed != gc_block.values.s) || bit_istrue(gc_parser_flags, GC_PARSER_LASER_FORCE_SYNC)) {
 800504a:	4b3d      	ldr	r3, [pc, #244]	; (8005140 <gc_execute_line+0x16f8>)
 800504c:	68da      	ldr	r2, [r3, #12]
 800504e:	4b3b      	ldr	r3, [pc, #236]	; (800513c <gc_execute_line+0x16f4>)
 8005050:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005052:	1c19      	adds	r1, r3, #0
 8005054:	1c10      	adds	r0, r2, #0
 8005056:	f7fb f937 	bl	80002c8 <__aeabi_fcmpeq>
 800505a:	1e03      	subs	r3, r0, #0
 800505c:	d005      	beq.n	800506a <gc_execute_line+0x1622>
 800505e:	234b      	movs	r3, #75	; 0x4b
 8005060:	18fb      	adds	r3, r7, r3
 8005062:	781b      	ldrb	r3, [r3, #0]
 8005064:	2220      	movs	r2, #32
 8005066:	4013      	ands	r3, r2
 8005068:	d023      	beq.n	80050b2 <gc_execute_line+0x166a>
      if (gc_state.modal.spindle != SPINDLE_DISABLE) {
 800506a:	4b35      	ldr	r3, [pc, #212]	; (8005140 <gc_execute_line+0x16f8>)
 800506c:	7a5b      	ldrb	r3, [r3, #9]
 800506e:	2b00      	cmp	r3, #0
 8005070:	d01b      	beq.n	80050aa <gc_execute_line+0x1662>
#ifdef VARIABLE_SPINDLE
        if (bit_isfalse(gc_parser_flags, GC_PARSER_LASER_ISMOTION)) {
 8005072:	234b      	movs	r3, #75	; 0x4b
 8005074:	18fb      	adds	r3, r7, r3
 8005076:	781b      	ldrb	r3, [r3, #0]
 8005078:	b25b      	sxtb	r3, r3
 800507a:	2b00      	cmp	r3, #0
 800507c:	db15      	blt.n	80050aa <gc_execute_line+0x1662>
          if (bit_istrue(gc_parser_flags, GC_PARSER_LASER_DISABLE)) {
 800507e:	234b      	movs	r3, #75	; 0x4b
 8005080:	18fb      	adds	r3, r7, r3
 8005082:	781b      	ldrb	r3, [r3, #0]
 8005084:	2240      	movs	r2, #64	; 0x40
 8005086:	4013      	ands	r3, r2
 8005088:	d007      	beq.n	800509a <gc_execute_line+0x1652>
            spindle_sync(gc_state.modal.spindle, 0.0);
 800508a:	4b2d      	ldr	r3, [pc, #180]	; (8005140 <gc_execute_line+0x16f8>)
 800508c:	7a5b      	ldrb	r3, [r3, #9]
 800508e:	2200      	movs	r2, #0
 8005090:	1c11      	adds	r1, r2, #0
 8005092:	0018      	movs	r0, r3
 8005094:	f004 fe72 	bl	8009d7c <spindle_sync>
 8005098:	e007      	b.n	80050aa <gc_execute_line+0x1662>
          }
          else { spindle_sync(gc_state.modal.spindle, gc_block.values.s); }
 800509a:	4b29      	ldr	r3, [pc, #164]	; (8005140 <gc_execute_line+0x16f8>)
 800509c:	7a5a      	ldrb	r2, [r3, #9]
 800509e:	4b27      	ldr	r3, [pc, #156]	; (800513c <gc_execute_line+0x16f4>)
 80050a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80050a2:	1c19      	adds	r1, r3, #0
 80050a4:	0010      	movs	r0, r2
 80050a6:	f004 fe69 	bl	8009d7c <spindle_sync>
        }
#else
          spindle_sync(gc_state.modal.spindle, 0.0);
#endif
      }
      gc_state.spindle_speed = gc_block.values.s; // Update spindle speed state.
 80050aa:	4b24      	ldr	r3, [pc, #144]	; (800513c <gc_execute_line+0x16f4>)
 80050ac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80050ae:	4b24      	ldr	r3, [pc, #144]	; (8005140 <gc_execute_line+0x16f8>)
 80050b0:	60da      	str	r2, [r3, #12]
  }
  // NOTE: Pass zero spindle speed for all restricted laser motions.
  if (bit_isfalse(gc_parser_flags, GC_PARSER_LASER_DISABLE)) {
 80050b2:	234b      	movs	r3, #75	; 0x4b
 80050b4:	18fb      	adds	r3, r7, r3
 80050b6:	781b      	ldrb	r3, [r3, #0]
 80050b8:	2240      	movs	r2, #64	; 0x40
 80050ba:	4013      	ands	r3, r2
 80050bc:	d103      	bne.n	80050c6 <gc_execute_line+0x167e>
      pl_data->spindle_speed = gc_state.spindle_speed; // Record data for planner use. 
 80050be:	4b20      	ldr	r3, [pc, #128]	; (8005140 <gc_execute_line+0x16f8>)
 80050c0:	68da      	ldr	r2, [r3, #12]
 80050c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80050c4:	605a      	str	r2, [r3, #4]
  } // else { pl_data->spindle_speed = 0.0; } // Initialized as zero already.

  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
 80050c6:	4b1d      	ldr	r3, [pc, #116]	; (800513c <gc_execute_line+0x16f4>)
 80050c8:	2230      	movs	r2, #48	; 0x30
 80050ca:	5c9a      	ldrb	r2, [r3, r2]
 80050cc:	4b1c      	ldr	r3, [pc, #112]	; (8005140 <gc_execute_line+0x16f8>)
 80050ce:	751a      	strb	r2, [r3, #20]

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
 80050d0:	4b1b      	ldr	r3, [pc, #108]	; (8005140 <gc_execute_line+0x16f8>)
 80050d2:	7a5a      	ldrb	r2, [r3, #9]
 80050d4:	4b19      	ldr	r3, [pc, #100]	; (800513c <gc_execute_line+0x16f4>)
 80050d6:	7a9b      	ldrb	r3, [r3, #10]
 80050d8:	429a      	cmp	r2, r3
 80050da:	d00b      	beq.n	80050f4 <gc_execute_line+0x16ac>
    // Update spindle control and apply spindle speed when enabling it in this block.
    // NOTE: All spindle state changes are synced, even in laser mode. Also, pl_data,
    // rather than gc_state, is used to manage laser state for non-laser motions.
    spindle_sync(gc_block.modal.spindle, pl_data->spindle_speed);
 80050dc:	4b17      	ldr	r3, [pc, #92]	; (800513c <gc_execute_line+0x16f4>)
 80050de:	7a9a      	ldrb	r2, [r3, #10]
 80050e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80050e2:	685b      	ldr	r3, [r3, #4]
 80050e4:	1c19      	adds	r1, r3, #0
 80050e6:	0010      	movs	r0, r2
 80050e8:	f004 fe48 	bl	8009d7c <spindle_sync>
    gc_state.modal.spindle = gc_block.modal.spindle;
 80050ec:	4b13      	ldr	r3, [pc, #76]	; (800513c <gc_execute_line+0x16f4>)
 80050ee:	7a9a      	ldrb	r2, [r3, #10]
 80050f0:	4b13      	ldr	r3, [pc, #76]	; (8005140 <gc_execute_line+0x16f8>)
 80050f2:	725a      	strb	r2, [r3, #9]
  }
  pl_data->condition |= gc_state.modal.spindle; // Set condition flag for planner use.
 80050f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80050f6:	7a1a      	ldrb	r2, [r3, #8]
 80050f8:	4b11      	ldr	r3, [pc, #68]	; (8005140 <gc_execute_line+0x16f8>)
 80050fa:	7a5b      	ldrb	r3, [r3, #9]
 80050fc:	4313      	orrs	r3, r2
 80050fe:	b2da      	uxtb	r2, r3
 8005100:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005102:	721a      	strb	r2, [r3, #8]

  // [8. Coolant control ]:
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
 8005104:	4b0e      	ldr	r3, [pc, #56]	; (8005140 <gc_execute_line+0x16f8>)
 8005106:	7a1a      	ldrb	r2, [r3, #8]
 8005108:	4b0c      	ldr	r3, [pc, #48]	; (800513c <gc_execute_line+0x16f4>)
 800510a:	7a5b      	ldrb	r3, [r3, #9]
 800510c:	429a      	cmp	r2, r3
 800510e:	d023      	beq.n	8005158 <gc_execute_line+0x1710>
    // NOTE: Coolant M-codes are modal. Only one command per line is allowed. But, multiple states
    // can exist at the same time, while coolant disable clears all states.
    coolant_sync(gc_block.modal.coolant);
 8005110:	4b0a      	ldr	r3, [pc, #40]	; (800513c <gc_execute_line+0x16f4>)
 8005112:	7a5b      	ldrb	r3, [r3, #9]
 8005114:	0018      	movs	r0, r3
 8005116:	f7fe fba1 	bl	800385c <coolant_sync>
    if (gc_block.modal.coolant == COOLANT_DISABLE) { gc_state.modal.coolant = COOLANT_DISABLE; }
 800511a:	4b08      	ldr	r3, [pc, #32]	; (800513c <gc_execute_line+0x16f4>)
 800511c:	7a5b      	ldrb	r3, [r3, #9]
 800511e:	2b00      	cmp	r3, #0
 8005120:	d112      	bne.n	8005148 <gc_execute_line+0x1700>
 8005122:	4b07      	ldr	r3, [pc, #28]	; (8005140 <gc_execute_line+0x16f8>)
 8005124:	2200      	movs	r2, #0
 8005126:	721a      	strb	r2, [r3, #8]
 8005128:	e016      	b.n	8005158 <gc_execute_line+0x1710>
 800512a:	46c0      	nop			; (mov r8, r8)
 800512c:	200009d4 	.word	0x200009d4
 8005130:	20000978 	.word	0x20000978
 8005134:	fffffcde 	.word	0xfffffcde
 8005138:	ffffe3ff 	.word	0xffffe3ff
 800513c:	200009a0 	.word	0x200009a0
 8005140:	2000095c 	.word	0x2000095c
 8005144:	20000acc 	.word	0x20000acc
    else { gc_state.modal.coolant |= gc_block.modal.coolant; }
 8005148:	4bcb      	ldr	r3, [pc, #812]	; (8005478 <gc_execute_line+0x1a30>)
 800514a:	7a1a      	ldrb	r2, [r3, #8]
 800514c:	4bcb      	ldr	r3, [pc, #812]	; (800547c <gc_execute_line+0x1a34>)
 800514e:	7a5b      	ldrb	r3, [r3, #9]
 8005150:	4313      	orrs	r3, r2
 8005152:	b2da      	uxtb	r2, r3
 8005154:	4bc8      	ldr	r3, [pc, #800]	; (8005478 <gc_execute_line+0x1a30>)
 8005156:	721a      	strb	r2, [r3, #8]
  }
  pl_data->condition |= gc_state.modal.coolant; // Set condition flag for planner use.
 8005158:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800515a:	7a1a      	ldrb	r2, [r3, #8]
 800515c:	4bc6      	ldr	r3, [pc, #792]	; (8005478 <gc_execute_line+0x1a30>)
 800515e:	7a1b      	ldrb	r3, [r3, #8]
 8005160:	4313      	orrs	r3, r2
 8005162:	b2da      	uxtb	r2, r3
 8005164:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005166:	721a      	strb	r2, [r3, #8]
			mc_override_ctrl_update(gc_state.modal.override);
		}
	#endif
	
  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
 8005168:	4bc4      	ldr	r3, [pc, #784]	; (800547c <gc_execute_line+0x1a34>)
 800516a:	781b      	ldrb	r3, [r3, #0]
 800516c:	2b04      	cmp	r3, #4
 800516e:	d104      	bne.n	800517a <gc_execute_line+0x1732>
 8005170:	4bc2      	ldr	r3, [pc, #776]	; (800547c <gc_execute_line+0x1a34>)
 8005172:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005174:	1c18      	adds	r0, r3, #0
 8005176:	f000 fff7 	bl	8006168 <mc_dwell>

  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;
 800517a:	4bc0      	ldr	r3, [pc, #768]	; (800547c <gc_execute_line+0x1a34>)
 800517c:	795a      	ldrb	r2, [r3, #5]
 800517e:	4bbe      	ldr	r3, [pc, #760]	; (8005478 <gc_execute_line+0x1a30>)
 8005180:	711a      	strb	r2, [r3, #4]

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
 8005182:	4bbe      	ldr	r3, [pc, #760]	; (800547c <gc_execute_line+0x1a34>)
 8005184:	78da      	ldrb	r2, [r3, #3]
 8005186:	4bbc      	ldr	r3, [pc, #752]	; (8005478 <gc_execute_line+0x1a30>)
 8005188:	709a      	strb	r2, [r3, #2]

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
 800518a:	2357      	movs	r3, #87	; 0x57
 800518c:	18fb      	adds	r3, r7, r3
 800518e:	781b      	ldrb	r3, [r3, #0]
 8005190:	2b03      	cmp	r3, #3
 8005192:	d11a      	bne.n	80051ca <gc_execute_line+0x1782>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
 8005194:	4bb9      	ldr	r3, [pc, #740]	; (800547c <gc_execute_line+0x1a34>)
 8005196:	799a      	ldrb	r2, [r3, #6]
 8005198:	4bb7      	ldr	r3, [pc, #732]	; (8005478 <gc_execute_line+0x1a30>)
 800519a:	715a      	strb	r2, [r3, #5]
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_CANCEL) { // G49
 800519c:	4bb6      	ldr	r3, [pc, #728]	; (8005478 <gc_execute_line+0x1a30>)
 800519e:	795b      	ldrb	r3, [r3, #5]
 80051a0:	2b00      	cmp	r3, #0
 80051a2:	d102      	bne.n	80051aa <gc_execute_line+0x1762>
      gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] = 0.0f;
 80051a4:	4bb5      	ldr	r3, [pc, #724]	; (800547c <gc_execute_line+0x1a34>)
 80051a6:	2200      	movs	r2, #0
 80051a8:	63da      	str	r2, [r3, #60]	; 0x3c
    } // else G43.1
    if ( gc_state.tool_length_offset != gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] ) {
 80051aa:	4bb3      	ldr	r3, [pc, #716]	; (8005478 <gc_execute_line+0x1a30>)
 80051ac:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80051ae:	4bb3      	ldr	r3, [pc, #716]	; (800547c <gc_execute_line+0x1a34>)
 80051b0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80051b2:	1c19      	adds	r1, r3, #0
 80051b4:	1c10      	adds	r0, r2, #0
 80051b6:	f7fb f887 	bl	80002c8 <__aeabi_fcmpeq>
 80051ba:	1e03      	subs	r3, r0, #0
 80051bc:	d105      	bne.n	80051ca <gc_execute_line+0x1782>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
 80051be:	4baf      	ldr	r3, [pc, #700]	; (800547c <gc_execute_line+0x1a34>)
 80051c0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80051c2:	4bad      	ldr	r3, [pc, #692]	; (8005478 <gc_execute_line+0x1a30>)
 80051c4:	641a      	str	r2, [r3, #64]	; 0x40
      system_flag_wco_change();
 80051c6:	f006 fb7d 	bl	800b8c4 <system_flag_wco_change>
    }
  }

  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
 80051ca:	4bab      	ldr	r3, [pc, #684]	; (8005478 <gc_execute_line+0x1a30>)
 80051cc:	799a      	ldrb	r2, [r3, #6]
 80051ce:	4bab      	ldr	r3, [pc, #684]	; (800547c <gc_execute_line+0x1a34>)
 80051d0:	79db      	ldrb	r3, [r3, #7]
 80051d2:	429a      	cmp	r2, r3
 80051d4:	d00b      	beq.n	80051ee <gc_execute_line+0x17a6>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
 80051d6:	4ba9      	ldr	r3, [pc, #676]	; (800547c <gc_execute_line+0x1a34>)
 80051d8:	79da      	ldrb	r2, [r3, #7]
 80051da:	4ba7      	ldr	r3, [pc, #668]	; (8005478 <gc_execute_line+0x1a30>)
 80051dc:	719a      	strb	r2, [r3, #6]
    memcpy(gc_state.coord_system,block_coord_system,N_AXIS*sizeof(float));
 80051de:	4ba6      	ldr	r3, [pc, #664]	; (8005478 <gc_execute_line+0x1a30>)
 80051e0:	2214      	movs	r2, #20
 80051e2:	18ba      	adds	r2, r7, r2
 80051e4:	3328      	adds	r3, #40	; 0x28
 80051e6:	ca13      	ldmia	r2!, {r0, r1, r4}
 80051e8:	c313      	stmia	r3!, {r0, r1, r4}
    system_flag_wco_change();
 80051ea:	f006 fb6b 	bl	800b8c4 <system_flag_wco_change>

  // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
  // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.

  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
 80051ee:	4ba3      	ldr	r3, [pc, #652]	; (800547c <gc_execute_line+0x1a34>)
 80051f0:	791a      	ldrb	r2, [r3, #4]
 80051f2:	4ba1      	ldr	r3, [pc, #644]	; (8005478 <gc_execute_line+0x1a30>)
 80051f4:	70da      	strb	r2, [r3, #3]

  // [18. Set retract mode ]: NOT SUPPORTED

  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
 80051f6:	4ba1      	ldr	r3, [pc, #644]	; (800547c <gc_execute_line+0x1a34>)
 80051f8:	781b      	ldrb	r3, [r3, #0]
 80051fa:	2b26      	cmp	r3, #38	; 0x26
 80051fc:	d045      	beq.n	800528a <gc_execute_line+0x1842>
 80051fe:	dc06      	bgt.n	800520e <gc_execute_line+0x17c6>
 8005200:	2b1c      	cmp	r3, #28
 8005202:	d023      	beq.n	800524c <gc_execute_line+0x1804>
 8005204:	2b1e      	cmp	r3, #30
 8005206:	d021      	beq.n	800524c <gc_execute_line+0x1804>
 8005208:	2b0a      	cmp	r3, #10
 800520a:	d007      	beq.n	800521c <gc_execute_line+0x17d4>
 800520c:	e05c      	b.n	80052c8 <gc_execute_line+0x1880>
 800520e:	2b5c      	cmp	r3, #92	; 0x5c
 8005210:	d047      	beq.n	80052a2 <gc_execute_line+0x185a>
 8005212:	2b66      	cmp	r3, #102	; 0x66
 8005214:	d04e      	beq.n	80052b4 <gc_execute_line+0x186c>
 8005216:	2b28      	cmp	r3, #40	; 0x28
 8005218:	d03d      	beq.n	8005296 <gc_execute_line+0x184e>
 800521a:	e055      	b.n	80052c8 <gc_execute_line+0x1880>
    case NON_MODAL_SET_COORDINATE_DATA:
      settings_write_coord_data(coord_select,gc_block.values.ijk);
 800521c:	4a98      	ldr	r2, [pc, #608]	; (8005480 <gc_execute_line+0x1a38>)
 800521e:	2353      	movs	r3, #83	; 0x53
 8005220:	18fb      	adds	r3, r7, r3
 8005222:	781b      	ldrb	r3, [r3, #0]
 8005224:	0011      	movs	r1, r2
 8005226:	0018      	movs	r0, r3
 8005228:	f004 f83a 	bl	80092a0 <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) {
 800522c:	4b92      	ldr	r3, [pc, #584]	; (8005478 <gc_execute_line+0x1a30>)
 800522e:	799b      	ldrb	r3, [r3, #6]
 8005230:	2253      	movs	r2, #83	; 0x53
 8005232:	18ba      	adds	r2, r7, r2
 8005234:	7812      	ldrb	r2, [r2, #0]
 8005236:	429a      	cmp	r2, r3
 8005238:	d145      	bne.n	80052c6 <gc_execute_line+0x187e>
        memcpy(gc_state.coord_system,gc_block.values.ijk,N_AXIS*sizeof(float));
 800523a:	4b8f      	ldr	r3, [pc, #572]	; (8005478 <gc_execute_line+0x1a30>)
 800523c:	4a8f      	ldr	r2, [pc, #572]	; (800547c <gc_execute_line+0x1a34>)
 800523e:	3328      	adds	r3, #40	; 0x28
 8005240:	3210      	adds	r2, #16
 8005242:	ca13      	ldmia	r2!, {r0, r1, r4}
 8005244:	c313      	stmia	r3!, {r0, r1, r4}
        system_flag_wco_change();
 8005246:	f006 fb3d 	bl	800b8c4 <system_flag_wco_change>
      }
      break;
 800524a:	e03c      	b.n	80052c6 <gc_execute_line+0x187e>
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1:
      // Move to intermediate position before going home. Obeys current coordinate system and offsets
      // and absolute and incremental modes.
      pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
 800524c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800524e:	7a1b      	ldrb	r3, [r3, #8]
 8005250:	2201      	movs	r2, #1
 8005252:	4313      	orrs	r3, r2
 8005254:	b2da      	uxtb	r2, r3
 8005256:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005258:	721a      	strb	r2, [r3, #8]
      if (axis_command) { mc_line(gc_block.values.xyz, pl_data); }
 800525a:	2357      	movs	r3, #87	; 0x57
 800525c:	18fb      	adds	r3, r7, r3
 800525e:	781b      	ldrb	r3, [r3, #0]
 8005260:	2b00      	cmp	r3, #0
 8005262:	d005      	beq.n	8005270 <gc_execute_line+0x1828>
 8005264:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8005266:	4b87      	ldr	r3, [pc, #540]	; (8005484 <gc_execute_line+0x1a3c>)
 8005268:	0011      	movs	r1, r2
 800526a:	0018      	movs	r0, r3
 800526c:	f000 fcc6 	bl	8005bfc <mc_line>
      mc_line(gc_block.values.ijk, pl_data);
 8005270:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8005272:	4b83      	ldr	r3, [pc, #524]	; (8005480 <gc_execute_line+0x1a38>)
 8005274:	0011      	movs	r1, r2
 8005276:	0018      	movs	r0, r3
 8005278:	f000 fcc0 	bl	8005bfc <mc_line>
      memcpy(gc_state.position, gc_block.values.ijk, N_AXIS*sizeof(float));
 800527c:	4b7e      	ldr	r3, [pc, #504]	; (8005478 <gc_execute_line+0x1a30>)
 800527e:	4a7f      	ldr	r2, [pc, #508]	; (800547c <gc_execute_line+0x1a34>)
 8005280:	331c      	adds	r3, #28
 8005282:	3210      	adds	r2, #16
 8005284:	ca13      	ldmia	r2!, {r0, r1, r4}
 8005286:	c313      	stmia	r3!, {r0, r1, r4}
      break;
 8005288:	e01e      	b.n	80052c8 <gc_execute_line+0x1880>
    case NON_MODAL_SET_HOME_0:
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
 800528a:	4b7f      	ldr	r3, [pc, #508]	; (8005488 <gc_execute_line+0x1a40>)
 800528c:	0019      	movs	r1, r3
 800528e:	2006      	movs	r0, #6
 8005290:	f004 f806 	bl	80092a0 <settings_write_coord_data>
      break;
 8005294:	e018      	b.n	80052c8 <gc_execute_line+0x1880>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
 8005296:	4b7c      	ldr	r3, [pc, #496]	; (8005488 <gc_execute_line+0x1a40>)
 8005298:	0019      	movs	r1, r3
 800529a:	2007      	movs	r0, #7
 800529c:	f004 f800 	bl	80092a0 <settings_write_coord_data>
      break;
 80052a0:	e012      	b.n	80052c8 <gc_execute_line+0x1880>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
 80052a2:	4b75      	ldr	r3, [pc, #468]	; (8005478 <gc_execute_line+0x1a30>)
 80052a4:	4a75      	ldr	r2, [pc, #468]	; (800547c <gc_execute_line+0x1a34>)
 80052a6:	3334      	adds	r3, #52	; 0x34
 80052a8:	3234      	adds	r2, #52	; 0x34
 80052aa:	ca13      	ldmia	r2!, {r0, r1, r4}
 80052ac:	c313      	stmia	r3!, {r0, r1, r4}
      system_flag_wco_change();
 80052ae:	f006 fb09 	bl	800b8c4 <system_flag_wco_change>
      break;
 80052b2:	e009      	b.n	80052c8 <gc_execute_line+0x1880>
    case NON_MODAL_RESET_COORDINATE_OFFSET:
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
 80052b4:	4b75      	ldr	r3, [pc, #468]	; (800548c <gc_execute_line+0x1a44>)
 80052b6:	220c      	movs	r2, #12
 80052b8:	2100      	movs	r1, #0
 80052ba:	0018      	movs	r0, r3
 80052bc:	f006 ff20 	bl	800c100 <memset>
      system_flag_wco_change();
 80052c0:	f006 fb00 	bl	800b8c4 <system_flag_wco_change>
      break;
 80052c4:	e000      	b.n	80052c8 <gc_execute_line+0x1880>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) {
        memcpy(gc_state.coord_system,gc_block.values.ijk,N_AXIS*sizeof(float));
        system_flag_wco_change();
      }
      break;
 80052c6:	46c0      	nop			; (mov r8, r8)


  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
 80052c8:	4b6c      	ldr	r3, [pc, #432]	; (800547c <gc_execute_line+0x1a34>)
 80052ca:	785a      	ldrb	r2, [r3, #1]
 80052cc:	4b6a      	ldr	r3, [pc, #424]	; (8005478 <gc_execute_line+0x1a30>)
 80052ce:	701a      	strb	r2, [r3, #0]
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
 80052d0:	4b69      	ldr	r3, [pc, #420]	; (8005478 <gc_execute_line+0x1a30>)
 80052d2:	781b      	ldrb	r3, [r3, #0]
 80052d4:	2b50      	cmp	r3, #80	; 0x50
 80052d6:	d100      	bne.n	80052da <gc_execute_line+0x1892>
 80052d8:	e074      	b.n	80053c4 <gc_execute_line+0x197c>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
 80052da:	2357      	movs	r3, #87	; 0x57
 80052dc:	18fb      	adds	r3, r7, r3
 80052de:	781b      	ldrb	r3, [r3, #0]
 80052e0:	2b02      	cmp	r3, #2
 80052e2:	d16f      	bne.n	80053c4 <gc_execute_line+0x197c>
      uint8_t gc_update_pos = GC_UPDATE_POS_TARGET;
 80052e4:	233f      	movs	r3, #63	; 0x3f
 80052e6:	18fb      	adds	r3, r7, r3
 80052e8:	2200      	movs	r2, #0
 80052ea:	701a      	strb	r2, [r3, #0]
      if (gc_state.modal.motion == MOTION_MODE_LINEAR) {
 80052ec:	4b62      	ldr	r3, [pc, #392]	; (8005478 <gc_execute_line+0x1a30>)
 80052ee:	781b      	ldrb	r3, [r3, #0]
 80052f0:	2b01      	cmp	r3, #1
 80052f2:	d106      	bne.n	8005302 <gc_execute_line+0x18ba>
        mc_line(gc_block.values.xyz, pl_data);
 80052f4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80052f6:	4b63      	ldr	r3, [pc, #396]	; (8005484 <gc_execute_line+0x1a3c>)
 80052f8:	0011      	movs	r1, r2
 80052fa:	0018      	movs	r0, r3
 80052fc:	f000 fc7e 	bl	8005bfc <mc_line>
 8005300:	e04d      	b.n	800539e <gc_execute_line+0x1956>
      } else if (gc_state.modal.motion == MOTION_MODE_SEEK) {
 8005302:	4b5d      	ldr	r3, [pc, #372]	; (8005478 <gc_execute_line+0x1a30>)
 8005304:	781b      	ldrb	r3, [r3, #0]
 8005306:	2b00      	cmp	r3, #0
 8005308:	d10d      	bne.n	8005326 <gc_execute_line+0x18de>
        pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
 800530a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800530c:	7a1b      	ldrb	r3, [r3, #8]
 800530e:	2201      	movs	r2, #1
 8005310:	4313      	orrs	r3, r2
 8005312:	b2da      	uxtb	r2, r3
 8005314:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005316:	721a      	strb	r2, [r3, #8]
        mc_line(gc_block.values.xyz, pl_data);
 8005318:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800531a:	4b5a      	ldr	r3, [pc, #360]	; (8005484 <gc_execute_line+0x1a3c>)
 800531c:	0011      	movs	r1, r2
 800531e:	0018      	movs	r0, r3
 8005320:	f000 fc6c 	bl	8005bfc <mc_line>
 8005324:	e03b      	b.n	800539e <gc_execute_line+0x1956>
      } else if ((gc_state.modal.motion == MOTION_MODE_CW_ARC) || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
 8005326:	4b54      	ldr	r3, [pc, #336]	; (8005478 <gc_execute_line+0x1a30>)
 8005328:	781b      	ldrb	r3, [r3, #0]
 800532a:	2b02      	cmp	r3, #2
 800532c:	d003      	beq.n	8005336 <gc_execute_line+0x18ee>
 800532e:	4b52      	ldr	r3, [pc, #328]	; (8005478 <gc_execute_line+0x1a30>)
 8005330:	781b      	ldrb	r3, [r3, #0]
 8005332:	2b03      	cmp	r3, #3
 8005334:	d120      	bne.n	8005378 <gc_execute_line+0x1930>
          mc_arc(gc_block.values.xyz, pl_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
 8005336:	4b51      	ldr	r3, [pc, #324]	; (800547c <gc_execute_line+0x1a34>)
 8005338:	6a9b      	ldr	r3, [r3, #40]	; 0x28
              axis_0, axis_1, axis_linear, bit_istrue(gc_parser_flags, GC_PARSER_ARC_IS_CLOCKWISE));
 800533a:	224b      	movs	r2, #75	; 0x4b
 800533c:	18ba      	adds	r2, r7, r2
 800533e:	7812      	ldrb	r2, [r2, #0]
 8005340:	2104      	movs	r1, #4
 8005342:	400a      	ands	r2, r1
        mc_line(gc_block.values.xyz, pl_data);
      } else if (gc_state.modal.motion == MOTION_MODE_SEEK) {
        pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
        mc_line(gc_block.values.xyz, pl_data);
      } else if ((gc_state.modal.motion == MOTION_MODE_CW_ARC) || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
          mc_arc(gc_block.values.xyz, pl_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
 8005344:	1e51      	subs	r1, r2, #1
 8005346:	418a      	sbcs	r2, r1
 8005348:	b2d2      	uxtb	r2, r2
 800534a:	4d4d      	ldr	r5, [pc, #308]	; (8005480 <gc_execute_line+0x1a38>)
 800534c:	4c4e      	ldr	r4, [pc, #312]	; (8005488 <gc_execute_line+0x1a40>)
 800534e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8005350:	484c      	ldr	r0, [pc, #304]	; (8005484 <gc_execute_line+0x1a3c>)
 8005352:	9204      	str	r2, [sp, #16]
 8005354:	2254      	movs	r2, #84	; 0x54
 8005356:	18ba      	adds	r2, r7, r2
 8005358:	7812      	ldrb	r2, [r2, #0]
 800535a:	9203      	str	r2, [sp, #12]
 800535c:	2255      	movs	r2, #85	; 0x55
 800535e:	18ba      	adds	r2, r7, r2
 8005360:	7812      	ldrb	r2, [r2, #0]
 8005362:	9202      	str	r2, [sp, #8]
 8005364:	2256      	movs	r2, #86	; 0x56
 8005366:	18ba      	adds	r2, r7, r2
 8005368:	7812      	ldrb	r2, [r2, #0]
 800536a:	9201      	str	r2, [sp, #4]
 800536c:	9300      	str	r3, [sp, #0]
 800536e:	002b      	movs	r3, r5
 8005370:	0022      	movs	r2, r4
 8005372:	f000 fc8f 	bl	8005c94 <mc_arc>
 8005376:	e012      	b.n	800539e <gc_execute_line+0x1956>
              axis_0, axis_1, axis_linear, bit_istrue(gc_parser_flags, GC_PARSER_ARC_IS_CLOCKWISE));
      } else {
        // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
        // upon a successful probing cycle, the machine position and the returned value should be the same.
        #ifndef ALLOW_FEED_OVERRIDE_DURING_PROBE_CYCLES
          pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
 8005378:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800537a:	7a1b      	ldrb	r3, [r3, #8]
 800537c:	2204      	movs	r2, #4
 800537e:	4313      	orrs	r3, r2
 8005380:	b2da      	uxtb	r2, r3
 8005382:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005384:	721a      	strb	r2, [r3, #8]
        #endif
        gc_update_pos = mc_probe_cycle(gc_block.values.xyz, pl_data, gc_parser_flags);
 8005386:	233f      	movs	r3, #63	; 0x3f
 8005388:	18fc      	adds	r4, r7, r3
 800538a:	234b      	movs	r3, #75	; 0x4b
 800538c:	18fb      	adds	r3, r7, r3
 800538e:	781a      	ldrb	r2, [r3, #0]
 8005390:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8005392:	4b3c      	ldr	r3, [pc, #240]	; (8005484 <gc_execute_line+0x1a3c>)
 8005394:	0018      	movs	r0, r3
 8005396:	f000 ff1f 	bl	80061d8 <mc_probe_cycle>
 800539a:	0003      	movs	r3, r0
 800539c:	7023      	strb	r3, [r4, #0]
    }  
     
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      if (gc_update_pos == GC_UPDATE_POS_TARGET) {
 800539e:	233f      	movs	r3, #63	; 0x3f
 80053a0:	18fb      	adds	r3, r7, r3
 80053a2:	781b      	ldrb	r3, [r3, #0]
 80053a4:	2b00      	cmp	r3, #0
 80053a6:	d106      	bne.n	80053b6 <gc_execute_line+0x196e>
        memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
 80053a8:	4b33      	ldr	r3, [pc, #204]	; (8005478 <gc_execute_line+0x1a30>)
 80053aa:	4a34      	ldr	r2, [pc, #208]	; (800547c <gc_execute_line+0x1a34>)
 80053ac:	331c      	adds	r3, #28
 80053ae:	3234      	adds	r2, #52	; 0x34
 80053b0:	ca13      	ldmia	r2!, {r0, r1, r4}
 80053b2:	c313      	stmia	r3!, {r0, r1, r4}
 80053b4:	e006      	b.n	80053c4 <gc_execute_line+0x197c>
      } else if (gc_update_pos == GC_UPDATE_POS_SYSTEM) {
 80053b6:	233f      	movs	r3, #63	; 0x3f
 80053b8:	18fb      	adds	r3, r7, r3
 80053ba:	781b      	ldrb	r3, [r3, #0]
 80053bc:	2b01      	cmp	r3, #1
 80053be:	d101      	bne.n	80053c4 <gc_execute_line+0x197c>
        gc_sync_position(); // gc_state.position[] = sys_position
 80053c0:	f7fe fb32 	bl	8003a28 <gc_sync_position>
  }

  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
 80053c4:	4b2d      	ldr	r3, [pc, #180]	; (800547c <gc_execute_line+0x1a34>)
 80053c6:	7a1a      	ldrb	r2, [r3, #8]
 80053c8:	4b2b      	ldr	r3, [pc, #172]	; (8005478 <gc_execute_line+0x1a30>)
 80053ca:	71da      	strb	r2, [r3, #7]
  if (gc_state.modal.program_flow) {
 80053cc:	4b2a      	ldr	r3, [pc, #168]	; (8005478 <gc_execute_line+0x1a30>)
 80053ce:	79db      	ldrb	r3, [r3, #7]
 80053d0:	2b00      	cmp	r3, #0
 80053d2:	d04c      	beq.n	800546e <gc_execute_line+0x1a26>
    protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
 80053d4:	f002 fa82 	bl	80078dc <protocol_buffer_synchronize>
    if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
 80053d8:	4b27      	ldr	r3, [pc, #156]	; (8005478 <gc_execute_line+0x1a30>)
 80053da:	79db      	ldrb	r3, [r3, #7]
 80053dc:	2b03      	cmp	r3, #3
 80053de:	d109      	bne.n	80053f4 <gc_execute_line+0x19ac>
      if (sys.state != STATE_CHECK_MODE) {
 80053e0:	4b2b      	ldr	r3, [pc, #172]	; (8005490 <gc_execute_line+0x1a48>)
 80053e2:	781b      	ldrb	r3, [r3, #0]
 80053e4:	2b02      	cmp	r3, #2
 80053e6:	d03f      	beq.n	8005468 <gc_execute_line+0x1a20>
        system_set_exec_state_flag(EXEC_FEED_HOLD); // Use feed hold for program pause.
 80053e8:	2008      	movs	r0, #8
 80053ea:	f006 fb03 	bl	800b9f4 <system_set_exec_state_flag>
        protocol_execute_realtime(); // Execute suspend.
 80053ee:	f002 fa99 	bl	8007924 <protocol_execute_realtime>
 80053f2:	e039      	b.n	8005468 <gc_execute_line+0x1a20>
    } else { // == PROGRAM_FLOW_COMPLETED
      // Upon program complete, only a subset of g-codes reset to certain defaults, according to
      // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
      // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
      // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
      gc_state.modal.motion = MOTION_MODE_LINEAR;
 80053f4:	4b20      	ldr	r3, [pc, #128]	; (8005478 <gc_execute_line+0x1a30>)
 80053f6:	2201      	movs	r2, #1
 80053f8:	701a      	strb	r2, [r3, #0]
      gc_state.modal.plane_select = PLANE_SELECT_XY;
 80053fa:	4b1f      	ldr	r3, [pc, #124]	; (8005478 <gc_execute_line+0x1a30>)
 80053fc:	2200      	movs	r2, #0
 80053fe:	711a      	strb	r2, [r3, #4]
      gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
 8005400:	4b1d      	ldr	r3, [pc, #116]	; (8005478 <gc_execute_line+0x1a30>)
 8005402:	2200      	movs	r2, #0
 8005404:	70da      	strb	r2, [r3, #3]
      gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
 8005406:	4b1c      	ldr	r3, [pc, #112]	; (8005478 <gc_execute_line+0x1a30>)
 8005408:	2200      	movs	r2, #0
 800540a:	705a      	strb	r2, [r3, #1]
      // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
      gc_state.modal.coord_select = 0; // G54
 800540c:	4b1a      	ldr	r3, [pc, #104]	; (8005478 <gc_execute_line+0x1a30>)
 800540e:	2200      	movs	r2, #0
 8005410:	719a      	strb	r2, [r3, #6]
      gc_state.modal.spindle = SPINDLE_DISABLE;
 8005412:	4b19      	ldr	r3, [pc, #100]	; (8005478 <gc_execute_line+0x1a30>)
 8005414:	2200      	movs	r2, #0
 8005416:	725a      	strb	r2, [r3, #9]
      gc_state.modal.coolant = COOLANT_DISABLE;
 8005418:	4b17      	ldr	r3, [pc, #92]	; (8005478 <gc_execute_line+0x1a30>)
 800541a:	2200      	movs	r2, #0
 800541c:	721a      	strb	r2, [r3, #8]
					gc_state.modal.override = OVERRIDE_PARKING_MOTION;
				#endif
			#endif
			
      #ifdef RESTORE_OVERRIDES_AFTER_PROGRAM_END
        sys.f_override = DEFAULT_FEED_OVERRIDE;
 800541e:	4b1c      	ldr	r3, [pc, #112]	; (8005490 <gc_execute_line+0x1a48>)
 8005420:	2264      	movs	r2, #100	; 0x64
 8005422:	71da      	strb	r2, [r3, #7]
        sys.r_override = DEFAULT_RAPID_OVERRIDE;
 8005424:	4b1a      	ldr	r3, [pc, #104]	; (8005490 <gc_execute_line+0x1a48>)
 8005426:	2264      	movs	r2, #100	; 0x64
 8005428:	721a      	strb	r2, [r3, #8]
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
 800542a:	4b19      	ldr	r3, [pc, #100]	; (8005490 <gc_execute_line+0x1a48>)
 800542c:	2264      	movs	r2, #100	; 0x64
 800542e:	725a      	strb	r2, [r3, #9]
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
 8005430:	4b17      	ldr	r3, [pc, #92]	; (8005490 <gc_execute_line+0x1a48>)
 8005432:	781b      	ldrb	r3, [r3, #0]
 8005434:	2b02      	cmp	r3, #2
 8005436:	d014      	beq.n	8005462 <gc_execute_line+0x1a1a>
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
 8005438:	4b0f      	ldr	r3, [pc, #60]	; (8005478 <gc_execute_line+0x1a30>)
 800543a:	799b      	ldrb	r3, [r3, #6]
 800543c:	4a15      	ldr	r2, [pc, #84]	; (8005494 <gc_execute_line+0x1a4c>)
 800543e:	0011      	movs	r1, r2
 8005440:	0018      	movs	r0, r3
 8005442:	f004 f883 	bl	800954c <settings_read_coord_data>
 8005446:	1e03      	subs	r3, r0, #0
 8005448:	d101      	bne.n	800544e <gc_execute_line+0x1a06>
 800544a:	2307      	movs	r3, #7
 800544c:	e010      	b.n	8005470 <gc_execute_line+0x1a28>
        system_flag_wco_change(); // Set to refresh immediately just in case something altered.
 800544e:	f006 fa39 	bl	800b8c4 <system_flag_wco_change>
        spindle_set_state(SPINDLE_DISABLE,0.0f);
 8005452:	2300      	movs	r3, #0
 8005454:	1c19      	adds	r1, r3, #0
 8005456:	2000      	movs	r0, #0
 8005458:	f004 fc46 	bl	8009ce8 <spindle_set_state>
        coolant_set_state(COOLANT_DISABLE);
 800545c:	2000      	movs	r0, #0
 800545e:	f7fe f9e3 	bl	8003828 <coolant_set_state>
      }
      report_feedback_message(MESSAGE_PROGRAM_END);
 8005462:	2008      	movs	r0, #8
 8005464:	f002 ffaa 	bl	80083bc <report_feedback_message>
    }
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
 8005468:	4b03      	ldr	r3, [pc, #12]	; (8005478 <gc_execute_line+0x1a30>)
 800546a:	2200      	movs	r2, #0
 800546c:	71da      	strb	r2, [r3, #7]
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
 800546e:	2300      	movs	r3, #0
}
 8005470:	0018      	movs	r0, r3
 8005472:	46bd      	mov	sp, r7
 8005474:	b016      	add	sp, #88	; 0x58
 8005476:	bdb0      	pop	{r4, r5, r7, pc}
 8005478:	2000095c 	.word	0x2000095c
 800547c:	200009a0 	.word	0x200009a0
 8005480:	200009b0 	.word	0x200009b0
 8005484:	200009d4 	.word	0x200009d4
 8005488:	20000978 	.word	0x20000978
 800548c:	20000990 	.word	0x20000990
 8005490:	20000b2c 	.word	0x20000b2c
 8005494:	20000984 	.word	0x20000984

08005498 <jog_execute>:
#include "grbl.h"


// Sets up valid jog motion received from g-code parser, checks for soft-limits, and executes the jog.
uint8_t jog_execute(plan_line_data_t *pl_data, parser_block_t *gc_block)
{
 8005498:	b580      	push	{r7, lr}
 800549a:	b082      	sub	sp, #8
 800549c:	af00      	add	r7, sp, #0
 800549e:	6078      	str	r0, [r7, #4]
 80054a0:	6039      	str	r1, [r7, #0]
  // Initialize planner data struct for jogging motions.
  // NOTE: Spindle and coolant are allowed to fully function with overrides during a jog.
  pl_data->feed_rate = gc_block->values.f;
 80054a2:	683b      	ldr	r3, [r7, #0]
 80054a4:	68da      	ldr	r2, [r3, #12]
 80054a6:	687b      	ldr	r3, [r7, #4]
 80054a8:	601a      	str	r2, [r3, #0]
  pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
 80054aa:	687b      	ldr	r3, [r7, #4]
 80054ac:	7a1b      	ldrb	r3, [r3, #8]
 80054ae:	2204      	movs	r2, #4
 80054b0:	4313      	orrs	r3, r2
 80054b2:	b2da      	uxtb	r2, r3
 80054b4:	687b      	ldr	r3, [r7, #4]
 80054b6:	721a      	strb	r2, [r3, #8]
#ifdef USE_LINE_NUMBERS
  pl_data->line_number = gc_block->values.n;
#endif

  if (bit_istrue(settings.flags, BITFLAG_SOFT_LIMIT_ENABLE)) {
 80054b8:	4b15      	ldr	r3, [pc, #84]	; (8005510 <jog_execute+0x78>)
 80054ba:	2248      	movs	r2, #72	; 0x48
 80054bc:	5c9b      	ldrb	r3, [r3, r2]
 80054be:	001a      	movs	r2, r3
 80054c0:	2320      	movs	r3, #32
 80054c2:	4013      	ands	r3, r2
 80054c4:	d008      	beq.n	80054d8 <jog_execute+0x40>
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
 80054c6:	683b      	ldr	r3, [r7, #0]
 80054c8:	3334      	adds	r3, #52	; 0x34
 80054ca:	0018      	movs	r0, r3
 80054cc:	f006 fa52 	bl	800b974 <system_check_travel_limits>
 80054d0:	1e03      	subs	r3, r0, #0
 80054d2:	d001      	beq.n	80054d8 <jog_execute+0x40>
 80054d4:	230f      	movs	r3, #15
 80054d6:	e016      	b.n	8005506 <jog_execute+0x6e>
  }

  // Valid jog command. Plan, set state, and execute.
  mc_line(gc_block->values.xyz, pl_data);
 80054d8:	683b      	ldr	r3, [r7, #0]
 80054da:	3334      	adds	r3, #52	; 0x34
 80054dc:	687a      	ldr	r2, [r7, #4]
 80054de:	0011      	movs	r1, r2
 80054e0:	0018      	movs	r0, r3
 80054e2:	f000 fb8b 	bl	8005bfc <mc_line>
  if (sys.state == STATE_IDLE) {
 80054e6:	4b0b      	ldr	r3, [pc, #44]	; (8005514 <jog_execute+0x7c>)
 80054e8:	781b      	ldrb	r3, [r3, #0]
 80054ea:	2b00      	cmp	r3, #0
 80054ec:	d10a      	bne.n	8005504 <jog_execute+0x6c>
    if (plan_get_current_block() != NULL) { // Check if there is a block to execute.
 80054ee:	f001 fb45 	bl	8006b7c <plan_get_current_block>
 80054f2:	1e03      	subs	r3, r0, #0
 80054f4:	d006      	beq.n	8005504 <jog_execute+0x6c>
      sys.state = STATE_JOG;
 80054f6:	4b07      	ldr	r3, [pc, #28]	; (8005514 <jog_execute+0x7c>)
 80054f8:	2220      	movs	r2, #32
 80054fa:	701a      	strb	r2, [r3, #0]
      st_prep_buffer();
 80054fc:	f005 f85a 	bl	800a5b4 <st_prep_buffer>
      st_wake_up();  // NOTE: Manual start. No state machine required.
 8005500:	f004 fc86 	bl	8009e10 <st_wake_up>
    }
  }

  return(STATUS_OK);
 8005504:	2300      	movs	r3, #0
}
 8005506:	0018      	movs	r0, r3
 8005508:	46bd      	mov	sp, r7
 800550a:	b002      	add	sp, #8
 800550c:	bd80      	pop	{r7, pc}
 800550e:	46c0      	nop			; (mov r8, r8)
 8005510:	20000acc 	.word	0x20000acc
 8005514:	20000b2c 	.word	0x20000b2c

08005518 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8005518:	b580      	push	{r7, lr}
 800551a:	b082      	sub	sp, #8
 800551c:	af00      	add	r7, sp, #0
 800551e:	0002      	movs	r2, r0
 8005520:	1dfb      	adds	r3, r7, #7
 8005522:	701a      	strb	r2, [r3, #0]
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 8005524:	4a07      	ldr	r2, [pc, #28]	; (8005544 <NVIC_DisableIRQ+0x2c>)
 8005526:	1dfb      	adds	r3, r7, #7
 8005528:	781b      	ldrb	r3, [r3, #0]
 800552a:	0019      	movs	r1, r3
 800552c:	231f      	movs	r3, #31
 800552e:	400b      	ands	r3, r1
 8005530:	2101      	movs	r1, #1
 8005532:	4099      	lsls	r1, r3
 8005534:	000b      	movs	r3, r1
 8005536:	0019      	movs	r1, r3
 8005538:	2380      	movs	r3, #128	; 0x80
 800553a:	50d1      	str	r1, [r2, r3]
}
 800553c:	46c0      	nop			; (mov r8, r8)
 800553e:	46bd      	mov	sp, r7
 8005540:	b002      	add	sp, #8
 8005542:	bd80      	pop	{r7, pc}
 8005544:	e000e100 	.word	0xe000e100

08005548 <limits_init>:
#ifndef HOMING_AXIS_LOCATE_SCALAR
  #define HOMING_AXIS_LOCATE_SCALAR  5.0f // Must be > 1 to ensure limit switch is cleared.
#endif

void limits_init()
{
 8005548:	b580      	push	{r7, lr}
 800554a:	b086      	sub	sp, #24
 800554c:	af00      	add	r7, sp, #0
	}
#endif
#ifdef STM32F0DISCOVERY
	GPIO_InitTypeDef GPIO_InitStructure;
	//RCC_APB2PeriphClockCmd(RCC_LIMIT_PORT | RCC_APB2Periph_AFIO, ENABLE);
	RCC_AHBPeriphClockCmd(RCC_LIMIT_PORT, ENABLE);
 800554e:	2380      	movs	r3, #128	; 0x80
 8005550:	02db      	lsls	r3, r3, #11
 8005552:	2101      	movs	r1, #1
 8005554:	0018      	movs	r0, r3
 8005556:	f7fd fd7b 	bl	8003050 <RCC_AHBPeriphClockCmd>
	/* Enable SYSCFG's APB interface clock */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 800555a:	2101      	movs	r1, #1
 800555c:	2001      	movs	r0, #1
 800555e:	f7fd fd97 	bl	8003090 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8005562:	2310      	movs	r3, #16
 8005564:	18fb      	adds	r3, r7, r3
 8005566:	2203      	movs	r2, #3
 8005568:	715a      	strb	r2, [r3, #5]
	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; // From STM32F103C8 Input Pull-Up
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 800556a:	2310      	movs	r3, #16
 800556c:	18fb      	adds	r3, r7, r3
 800556e:	2200      	movs	r2, #0
 8005570:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8005572:	2310      	movs	r3, #16
 8005574:	18fb      	adds	r3, r7, r3
 8005576:	2201      	movs	r2, #1
 8005578:	71da      	strb	r2, [r3, #7]
	GPIO_InitStructure.GPIO_Pin = LIMIT_MASK;
 800557a:	2310      	movs	r3, #16
 800557c:	18fb      	adds	r3, r7, r3
 800557e:	22e0      	movs	r2, #224	; 0xe0
 8005580:	0152      	lsls	r2, r2, #5
 8005582:	601a      	str	r2, [r3, #0]
	GPIO_Init(LIMIT_PORT, &GPIO_InitStructure);
 8005584:	2310      	movs	r3, #16
 8005586:	18fb      	adds	r3, r7, r3
 8005588:	4a20      	ldr	r2, [pc, #128]	; (800560c <limits_init+0xc4>)
 800558a:	0019      	movs	r1, r3
 800558c:	0010      	movs	r0, r2
 800558e:	f7fd f9e1 	bl	8002954 <GPIO_Init>

	if (bit_istrue(settings.flags, BITFLAG_HARD_LIMIT_ENABLE))
 8005592:	4b1f      	ldr	r3, [pc, #124]	; (8005610 <limits_init+0xc8>)
 8005594:	2248      	movs	r2, #72	; 0x48
 8005596:	5c9b      	ldrb	r3, [r3, r2]
 8005598:	001a      	movs	r2, r3
 800559a:	2308      	movs	r3, #8
 800559c:	4013      	ands	r3, r2
 800559e:	d02f      	beq.n	8005600 <limits_init+0xb8>
	{
		SYSCFG_EXTILineConfig(GPIO_LIMIT_PORT, X_LIMIT_BIT);
 80055a0:	210a      	movs	r1, #10
 80055a2:	2001      	movs	r0, #1
 80055a4:	f7fd fd94 	bl	80030d0 <SYSCFG_EXTILineConfig>
		SYSCFG_EXTILineConfig(GPIO_LIMIT_PORT, Y_LIMIT_BIT);
 80055a8:	210b      	movs	r1, #11
 80055aa:	2001      	movs	r0, #1
 80055ac:	f7fd fd90 	bl	80030d0 <SYSCFG_EXTILineConfig>
		SYSCFG_EXTILineConfig(GPIO_LIMIT_PORT, Z_LIMIT_BIT);
 80055b0:	210c      	movs	r1, #12
 80055b2:	2001      	movs	r0, #1
 80055b4:	f7fd fd8c 	bl	80030d0 <SYSCFG_EXTILineConfig>

		EXTI_InitTypeDef EXTI_InitStructure;
		EXTI_InitStructure.EXTI_Line = LIMIT_MASK;    //
 80055b8:	2308      	movs	r3, #8
 80055ba:	18fb      	adds	r3, r7, r3
 80055bc:	22e0      	movs	r2, #224	; 0xe0
 80055be:	0152      	lsls	r2, r2, #5
 80055c0:	601a      	str	r2, [r3, #0]
		EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; //Interrupt mode, optional values for the interrupt EXTI_Mode_Interrupt and event EXTI_Mode_Event.
 80055c2:	2308      	movs	r3, #8
 80055c4:	18fb      	adds	r3, r7, r3
 80055c6:	2200      	movs	r2, #0
 80055c8:	711a      	strb	r2, [r3, #4]
		EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; //Trigger mode, can be a falling edge trigger EXTI_Trigger_Falling, the rising edge triggered EXTI_Trigger_Rising, or any level (rising edge and falling edge trigger EXTI_Trigger_Rising_Falling)
 80055ca:	2308      	movs	r3, #8
 80055cc:	18fb      	adds	r3, r7, r3
 80055ce:	220c      	movs	r2, #12
 80055d0:	715a      	strb	r2, [r3, #5]
		EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 80055d2:	2308      	movs	r3, #8
 80055d4:	18fb      	adds	r3, r7, r3
 80055d6:	2201      	movs	r2, #1
 80055d8:	719a      	strb	r2, [r3, #6]
		EXTI_Init(&EXTI_InitStructure);
 80055da:	2308      	movs	r3, #8
 80055dc:	18fb      	adds	r3, r7, r3
 80055de:	0018      	movs	r0, r3
 80055e0:	f7fd f948 	bl	8002874 <EXTI_Init>

		NVIC_InitTypeDef NVIC_InitStructure;
		NVIC_InitStructure.NVIC_IRQChannel = EXTI4_15_IRQn; //Enable keypad external interrupt channel
 80055e4:	1d3b      	adds	r3, r7, #4
 80055e6:	2207      	movs	r2, #7
 80055e8:	701a      	strb	r2, [r3, #0]
		//NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //Priority 2,
		//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //Sub priority 2
		NVIC_InitStructure.NVIC_IRQChannelPriority = 0x02; // Priority 2
 80055ea:	1d3b      	adds	r3, r7, #4
 80055ec:	2202      	movs	r2, #2
 80055ee:	705a      	strb	r2, [r3, #1]
		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //Enable external interrupt channel
 80055f0:	1d3b      	adds	r3, r7, #4
 80055f2:	2201      	movs	r2, #1
 80055f4:	709a      	strb	r2, [r3, #2]
		NVIC_Init(&NVIC_InitStructure);
 80055f6:	1d3b      	adds	r3, r7, #4
 80055f8:	0018      	movs	r0, r3
 80055fa:	f7fd faa9 	bl	8002b50 <NVIC_Init>
	else
	{
		limits_disable();
	}
#endif
}
 80055fe:	e001      	b.n	8005604 <limits_init+0xbc>
		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //Enable external interrupt channel
		NVIC_Init(&NVIC_InitStructure);
	}
	else
	{
		limits_disable();
 8005600:	f000 f808 	bl	8005614 <limits_disable>
	}
#endif
}
 8005604:	46c0      	nop			; (mov r8, r8)
 8005606:	46bd      	mov	sp, r7
 8005608:	b006      	add	sp, #24
 800560a:	bd80      	pop	{r7, pc}
 800560c:	48000400 	.word	0x48000400
 8005610:	20000acc 	.word	0x20000acc

08005614 <limits_disable>:


// Disables hard limits.
void limits_disable()
{
 8005614:	b580      	push	{r7, lr}
 8005616:	af00      	add	r7, sp, #0
#endif
#ifdef STM32F103C8
  NVIC_DisableIRQ(EXTI15_10_IRQn);
#endif
#ifdef STM32F0DISCOVERY
  NVIC_DisableIRQ(EXTI4_15_IRQn);
 8005618:	2007      	movs	r0, #7
 800561a:	f7ff ff7d 	bl	8005518 <NVIC_DisableIRQ>
#endif
}
 800561e:	46c0      	nop			; (mov r8, r8)
 8005620:	46bd      	mov	sp, r7
 8005622:	bd80      	pop	{r7, pc}

08005624 <limits_get_state>:

// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
 8005624:	b590      	push	{r4, r7, lr}
 8005626:	b083      	sub	sp, #12
 8005628:	af00      	add	r7, sp, #0
  uint8_t limit_state = 0;
 800562a:	1dfb      	adds	r3, r7, #7
 800562c:	2200      	movs	r2, #0
 800562e:	701a      	strb	r2, [r3, #0]
#endif
#if defined(STM32F103C8)
  uint16_t pin = GPIO_ReadInputData(LIMIT_PIN);
#endif
#if defined(STM32F0DISCOVERY)
  uint16_t pin = GPIO_ReadInputData(LIMIT_PIN);
 8005630:	1d3c      	adds	r4, r7, #4
 8005632:	4b21      	ldr	r3, [pc, #132]	; (80056b8 <limits_get_state+0x94>)
 8005634:	0018      	movs	r0, r3
 8005636:	f7fd fa25 	bl	8002a84 <GPIO_ReadInputData>
 800563a:	0003      	movs	r3, r0
 800563c:	8023      	strh	r3, [r4, #0]
#endif
  #ifdef INVERT_LIMIT_PIN_MASK
    pin ^= INVERT_LIMIT_PIN_MASK;
  #endif
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
 800563e:	4b1f      	ldr	r3, [pc, #124]	; (80056bc <limits_get_state+0x98>)
 8005640:	2248      	movs	r2, #72	; 0x48
 8005642:	5c9b      	ldrb	r3, [r3, r2]
 8005644:	001a      	movs	r2, r3
 8005646:	2340      	movs	r3, #64	; 0x40
 8005648:	4013      	ands	r3, r2
 800564a:	d106      	bne.n	800565a <limits_get_state+0x36>
 800564c:	1d3b      	adds	r3, r7, #4
 800564e:	1d3a      	adds	r2, r7, #4
 8005650:	8812      	ldrh	r2, [r2, #0]
 8005652:	21e0      	movs	r1, #224	; 0xe0
 8005654:	0149      	lsls	r1, r1, #5
 8005656:	404a      	eors	r2, r1
 8005658:	801a      	strh	r2, [r3, #0]
  if (pin) {
 800565a:	1d3b      	adds	r3, r7, #4
 800565c:	881b      	ldrh	r3, [r3, #0]
 800565e:	2b00      	cmp	r3, #0
 8005660:	d024      	beq.n	80056ac <limits_get_state+0x88>
    uint8_t idx;
    for (idx=0; idx<N_AXIS; idx++) {
 8005662:	1cfb      	adds	r3, r7, #3
 8005664:	2200      	movs	r2, #0
 8005666:	701a      	strb	r2, [r3, #0]
 8005668:	e01c      	b.n	80056a4 <limits_get_state+0x80>
      if (pin & limit_pin_mask[idx]) { limit_state |= (1 << idx); }
 800566a:	1cfb      	adds	r3, r7, #3
 800566c:	781a      	ldrb	r2, [r3, #0]
 800566e:	4b14      	ldr	r3, [pc, #80]	; (80056c0 <limits_get_state+0x9c>)
 8005670:	0052      	lsls	r2, r2, #1
 8005672:	5ad3      	ldrh	r3, [r2, r3]
 8005674:	1d3a      	adds	r2, r7, #4
 8005676:	8812      	ldrh	r2, [r2, #0]
 8005678:	4013      	ands	r3, r2
 800567a:	b29b      	uxth	r3, r3
 800567c:	2b00      	cmp	r3, #0
 800567e:	d00c      	beq.n	800569a <limits_get_state+0x76>
 8005680:	1cfb      	adds	r3, r7, #3
 8005682:	781b      	ldrb	r3, [r3, #0]
 8005684:	2201      	movs	r2, #1
 8005686:	409a      	lsls	r2, r3
 8005688:	0013      	movs	r3, r2
 800568a:	b25a      	sxtb	r2, r3
 800568c:	1dfb      	adds	r3, r7, #7
 800568e:	781b      	ldrb	r3, [r3, #0]
 8005690:	b25b      	sxtb	r3, r3
 8005692:	4313      	orrs	r3, r2
 8005694:	b25a      	sxtb	r2, r3
 8005696:	1dfb      	adds	r3, r7, #7
 8005698:	701a      	strb	r2, [r3, #0]
    pin ^= INVERT_LIMIT_PIN_MASK;
  #endif
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
  if (pin) {
    uint8_t idx;
    for (idx=0; idx<N_AXIS; idx++) {
 800569a:	1cfb      	adds	r3, r7, #3
 800569c:	781a      	ldrb	r2, [r3, #0]
 800569e:	1cfb      	adds	r3, r7, #3
 80056a0:	3201      	adds	r2, #1
 80056a2:	701a      	strb	r2, [r3, #0]
 80056a4:	1cfb      	adds	r3, r7, #3
 80056a6:	781b      	ldrb	r3, [r3, #0]
 80056a8:	2b02      	cmp	r3, #2
 80056aa:	d9de      	bls.n	800566a <limits_get_state+0x46>
      if (pin & limit_pin_mask[idx]) { limit_state |= (1 << idx); }
    }
  }
#endif
  return(limit_state);
 80056ac:	1dfb      	adds	r3, r7, #7
 80056ae:	781b      	ldrb	r3, [r3, #0]
}
 80056b0:	0018      	movs	r0, r3
 80056b2:	46bd      	mov	sp, r7
 80056b4:	b003      	add	sp, #12
 80056b6:	bd90      	pop	{r4, r7, pc}
 80056b8:	48000400 	.word	0x48000400
 80056bc:	20000acc 	.word	0x20000acc
 80056c0:	0800da90 	.word	0x0800da90

080056c4 <limits_go_home>:
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask)
{
 80056c4:	b590      	push	{r4, r7, lr}
 80056c6:	b093      	sub	sp, #76	; 0x4c
 80056c8:	af00      	add	r7, sp, #0
 80056ca:	0002      	movs	r2, r0
 80056cc:	1dfb      	adds	r3, r7, #7
 80056ce:	701a      	strb	r2, [r3, #0]
  if (sys.abort) { return; } // Block if system reset has been issued.
 80056d0:	4bd1      	ldr	r3, [pc, #836]	; (8005a18 <limits_go_home+0x354>)
 80056d2:	785b      	ldrb	r3, [r3, #1]
 80056d4:	2b00      	cmp	r3, #0
 80056d6:	d000      	beq.n	80056da <limits_go_home+0x16>
 80056d8:	e255      	b.n	8005b86 <limits_go_home+0x4c2>

  // Initialize plan data struct for homing motion. Spindle and coolant are disabled.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
 80056da:	2318      	movs	r3, #24
 80056dc:	18fb      	adds	r3, r7, r3
 80056de:	62bb      	str	r3, [r7, #40]	; 0x28
  memset(pl_data,0,sizeof(plan_line_data_t));
 80056e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80056e2:	220c      	movs	r2, #12
 80056e4:	2100      	movs	r1, #0
 80056e6:	0018      	movs	r0, r3
 80056e8:	f006 fd0a 	bl	800c100 <memset>
  pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
 80056ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80056ee:	2206      	movs	r2, #6
 80056f0:	721a      	strb	r2, [r3, #8]
  #ifdef USE_LINE_NUMBERS
    pl_data->line_number = HOMING_CYCLE_LINE_NUMBER;
  #endif

  // Initialize variables used for homing computations.
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
 80056f2:	2347      	movs	r3, #71	; 0x47
 80056f4:	18fb      	adds	r3, r7, r3
 80056f6:	2203      	movs	r2, #3
 80056f8:	701a      	strb	r2, [r3, #0]
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0f;
 80056fa:	2300      	movs	r3, #0
 80056fc:	643b      	str	r3, [r7, #64]	; 0x40
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 80056fe:	233f      	movs	r3, #63	; 0x3f
 8005700:	18fb      	adds	r3, r7, r3
 8005702:	2200      	movs	r2, #0
 8005704:	701a      	strb	r2, [r3, #0]
 8005706:	e042      	b.n	800578e <limits_go_home+0xca>
    // Initialize step pin masks
    step_pin[idx] = step_pin_mask[idx];
 8005708:	233f      	movs	r3, #63	; 0x3f
 800570a:	18fb      	adds	r3, r7, r3
 800570c:	781b      	ldrb	r3, [r3, #0]
 800570e:	223f      	movs	r2, #63	; 0x3f
 8005710:	18ba      	adds	r2, r7, r2
 8005712:	7811      	ldrb	r1, [r2, #0]
 8005714:	4ac1      	ldr	r2, [pc, #772]	; (8005a1c <limits_go_home+0x358>)
 8005716:	0049      	lsls	r1, r1, #1
 8005718:	5a8a      	ldrh	r2, [r1, r2]
 800571a:	b2d1      	uxtb	r1, r2
 800571c:	2214      	movs	r2, #20
 800571e:	18ba      	adds	r2, r7, r2
 8005720:	54d1      	strb	r1, [r2, r3]
    #ifdef COREXY
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (step_pin_mask[X_AXIS]| step_pin_mask[Y_AXIS]); }
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) {
 8005722:	1dfb      	adds	r3, r7, #7
 8005724:	781a      	ldrb	r2, [r3, #0]
 8005726:	233f      	movs	r3, #63	; 0x3f
 8005728:	18fb      	adds	r3, r7, r3
 800572a:	781b      	ldrb	r3, [r3, #0]
 800572c:	411a      	asrs	r2, r3
 800572e:	0013      	movs	r3, r2
 8005730:	2201      	movs	r2, #1
 8005732:	4013      	ands	r3, r2
 8005734:	d024      	beq.n	8005780 <limits_go_home+0xbc>
      // Set target based on max_travel setting. Ensure homing switches engaged with search scalar.
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
 8005736:	233f      	movs	r3, #63	; 0x3f
 8005738:	18fb      	adds	r3, r7, r3
 800573a:	781b      	ldrb	r3, [r3, #0]
 800573c:	4ab8      	ldr	r2, [pc, #736]	; (8005a20 <limits_go_home+0x35c>)
 800573e:	3308      	adds	r3, #8
 8005740:	009b      	lsls	r3, r3, #2
 8005742:	18d3      	adds	r3, r2, r3
 8005744:	3304      	adds	r3, #4
 8005746:	681b      	ldr	r3, [r3, #0]
 8005748:	49b6      	ldr	r1, [pc, #728]	; (8005a24 <limits_go_home+0x360>)
 800574a:	1c18      	adds	r0, r3, #0
 800574c:	f7fb f960 	bl	8000a10 <__aeabi_fmul>
 8005750:	1c03      	adds	r3, r0, #0
 8005752:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8005754:	1c18      	adds	r0, r3, #0
 8005756:	f7fa fdbd 	bl	80002d4 <__aeabi_fcmplt>
 800575a:	1e03      	subs	r3, r0, #0
 800575c:	d001      	beq.n	8005762 <limits_go_home+0x9e>
 800575e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005760:	e00d      	b.n	800577e <limits_go_home+0xba>
 8005762:	233f      	movs	r3, #63	; 0x3f
 8005764:	18fb      	adds	r3, r7, r3
 8005766:	781b      	ldrb	r3, [r3, #0]
 8005768:	4aad      	ldr	r2, [pc, #692]	; (8005a20 <limits_go_home+0x35c>)
 800576a:	3308      	adds	r3, #8
 800576c:	009b      	lsls	r3, r3, #2
 800576e:	18d3      	adds	r3, r2, r3
 8005770:	3304      	adds	r3, #4
 8005772:	681b      	ldr	r3, [r3, #0]
 8005774:	49ab      	ldr	r1, [pc, #684]	; (8005a24 <limits_go_home+0x360>)
 8005776:	1c18      	adds	r0, r3, #0
 8005778:	f7fb f94a 	bl	8000a10 <__aeabi_fmul>
 800577c:	1c03      	adds	r3, r0, #0
 800577e:	643b      	str	r3, [r7, #64]	; 0x40
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0f;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 8005780:	233f      	movs	r3, #63	; 0x3f
 8005782:	18fb      	adds	r3, r7, r3
 8005784:	781a      	ldrb	r2, [r3, #0]
 8005786:	233f      	movs	r3, #63	; 0x3f
 8005788:	18fb      	adds	r3, r7, r3
 800578a:	3201      	adds	r2, #1
 800578c:	701a      	strb	r2, [r3, #0]
 800578e:	233f      	movs	r3, #63	; 0x3f
 8005790:	18fb      	adds	r3, r7, r3
 8005792:	781b      	ldrb	r3, [r3, #0]
 8005794:	2b02      	cmp	r3, #2
 8005796:	d9b7      	bls.n	8005708 <limits_go_home+0x44>
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }

  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
 8005798:	2301      	movs	r3, #1
 800579a:	63bb      	str	r3, [r7, #56]	; 0x38
  float homing_rate = settings.homing_seek_rate;
 800579c:	4ba0      	ldr	r3, [pc, #640]	; (8005a20 <limits_go_home+0x35c>)
 800579e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80057a0:	637b      	str	r3, [r7, #52]	; 0x34

  uint8_t limit_state, axislock, n_active_axis;
  do {

    system_convert_array_steps_to_mpos(target,sys_position);
 80057a2:	4aa1      	ldr	r2, [pc, #644]	; (8005a28 <limits_go_home+0x364>)
 80057a4:	2308      	movs	r3, #8
 80057a6:	18fb      	adds	r3, r7, r3
 80057a8:	0011      	movs	r1, r2
 80057aa:	0018      	movs	r0, r3
 80057ac:	f006 f8b8 	bl	800b920 <system_convert_array_steps_to_mpos>

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
 80057b0:	2333      	movs	r3, #51	; 0x33
 80057b2:	18fb      	adds	r3, r7, r3
 80057b4:	2200      	movs	r2, #0
 80057b6:	701a      	strb	r2, [r3, #0]
    n_active_axis = 0;
 80057b8:	2332      	movs	r3, #50	; 0x32
 80057ba:	18fb      	adds	r3, r7, r3
 80057bc:	2200      	movs	r2, #0
 80057be:	701a      	strb	r2, [r3, #0]
    for (idx=0; idx<N_AXIS; idx++) {
 80057c0:	233f      	movs	r3, #63	; 0x3f
 80057c2:	18fb      	adds	r3, r7, r3
 80057c4:	2200      	movs	r2, #0
 80057c6:	701a      	strb	r2, [r3, #0]
 80057c8:	e066      	b.n	8005898 <limits_go_home+0x1d4>
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) {
 80057ca:	1dfb      	adds	r3, r7, #7
 80057cc:	781a      	ldrb	r2, [r3, #0]
 80057ce:	233f      	movs	r3, #63	; 0x3f
 80057d0:	18fb      	adds	r3, r7, r3
 80057d2:	781b      	ldrb	r3, [r3, #0]
 80057d4:	411a      	asrs	r2, r3
 80057d6:	0013      	movs	r3, r2
 80057d8:	2201      	movs	r2, #1
 80057da:	4013      	ands	r3, r2
 80057dc:	d055      	beq.n	800588a <limits_go_home+0x1c6>
        n_active_axis++;
 80057de:	2332      	movs	r3, #50	; 0x32
 80057e0:	18fb      	adds	r3, r7, r3
 80057e2:	781a      	ldrb	r2, [r3, #0]
 80057e4:	2332      	movs	r3, #50	; 0x32
 80057e6:	18fb      	adds	r3, r7, r3
 80057e8:	3201      	adds	r2, #1
 80057ea:	701a      	strb	r2, [r3, #0]
            sys_position[A_MOTOR] = sys_position[B_MOTOR] = axis_position;
          } else {
            sys_position[Z_AXIS] = 0;
          }
        #else
          sys_position[idx] = 0;
 80057ec:	233f      	movs	r3, #63	; 0x3f
 80057ee:	18fb      	adds	r3, r7, r3
 80057f0:	781a      	ldrb	r2, [r3, #0]
 80057f2:	4b8d      	ldr	r3, [pc, #564]	; (8005a28 <limits_go_home+0x364>)
 80057f4:	0092      	lsls	r2, r2, #2
 80057f6:	2100      	movs	r1, #0
 80057f8:	50d1      	str	r1, [r2, r3]
        #endif
        // Set target direction based on cycle mask and homing cycle approach state.
        // NOTE: This happens to compile smaller than any other implementation tried.
        if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
 80057fa:	4b89      	ldr	r3, [pc, #548]	; (8005a20 <limits_go_home+0x35c>)
 80057fc:	2249      	movs	r2, #73	; 0x49
 80057fe:	5c9b      	ldrb	r3, [r3, r2]
 8005800:	001a      	movs	r2, r3
 8005802:	233f      	movs	r3, #63	; 0x3f
 8005804:	18fb      	adds	r3, r7, r3
 8005806:	781b      	ldrb	r3, [r3, #0]
 8005808:	411a      	asrs	r2, r3
 800580a:	0013      	movs	r3, r2
 800580c:	2201      	movs	r2, #1
 800580e:	4013      	ands	r3, r2
 8005810:	d017      	beq.n	8005842 <limits_go_home+0x17e>
          if (approach) { target[idx] = -max_travel; }
 8005812:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005814:	2b00      	cmp	r3, #0
 8005816:	d00b      	beq.n	8005830 <limits_go_home+0x16c>
 8005818:	233f      	movs	r3, #63	; 0x3f
 800581a:	18fb      	adds	r3, r7, r3
 800581c:	781a      	ldrb	r2, [r3, #0]
 800581e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005820:	2180      	movs	r1, #128	; 0x80
 8005822:	0609      	lsls	r1, r1, #24
 8005824:	4059      	eors	r1, r3
 8005826:	2308      	movs	r3, #8
 8005828:	18fb      	adds	r3, r7, r3
 800582a:	0092      	lsls	r2, r2, #2
 800582c:	50d1      	str	r1, [r2, r3]
 800582e:	e01f      	b.n	8005870 <limits_go_home+0x1ac>
          else { target[idx] = max_travel; }
 8005830:	233f      	movs	r3, #63	; 0x3f
 8005832:	18fb      	adds	r3, r7, r3
 8005834:	781a      	ldrb	r2, [r3, #0]
 8005836:	2308      	movs	r3, #8
 8005838:	18fb      	adds	r3, r7, r3
 800583a:	0092      	lsls	r2, r2, #2
 800583c:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800583e:	50d1      	str	r1, [r2, r3]
 8005840:	e016      	b.n	8005870 <limits_go_home+0x1ac>
        } else {
          if (approach) { target[idx] = max_travel; }
 8005842:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005844:	2b00      	cmp	r3, #0
 8005846:	d008      	beq.n	800585a <limits_go_home+0x196>
 8005848:	233f      	movs	r3, #63	; 0x3f
 800584a:	18fb      	adds	r3, r7, r3
 800584c:	781a      	ldrb	r2, [r3, #0]
 800584e:	2308      	movs	r3, #8
 8005850:	18fb      	adds	r3, r7, r3
 8005852:	0092      	lsls	r2, r2, #2
 8005854:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8005856:	50d1      	str	r1, [r2, r3]
 8005858:	e00a      	b.n	8005870 <limits_go_home+0x1ac>
          else { target[idx] = -max_travel; }
 800585a:	233f      	movs	r3, #63	; 0x3f
 800585c:	18fb      	adds	r3, r7, r3
 800585e:	781a      	ldrb	r2, [r3, #0]
 8005860:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8005862:	2180      	movs	r1, #128	; 0x80
 8005864:	0609      	lsls	r1, r1, #24
 8005866:	4059      	eors	r1, r3
 8005868:	2308      	movs	r3, #8
 800586a:	18fb      	adds	r3, r7, r3
 800586c:	0092      	lsls	r2, r2, #2
 800586e:	50d1      	str	r1, [r2, r3]
        }
        // Apply axislock to the step port pins active in this cycle.
        axislock |= step_pin[idx];
 8005870:	233f      	movs	r3, #63	; 0x3f
 8005872:	18fb      	adds	r3, r7, r3
 8005874:	781b      	ldrb	r3, [r3, #0]
 8005876:	2214      	movs	r2, #20
 8005878:	18ba      	adds	r2, r7, r2
 800587a:	5cd1      	ldrb	r1, [r2, r3]
 800587c:	2333      	movs	r3, #51	; 0x33
 800587e:	18fb      	adds	r3, r7, r3
 8005880:	2233      	movs	r2, #51	; 0x33
 8005882:	18ba      	adds	r2, r7, r2
 8005884:	7812      	ldrb	r2, [r2, #0]
 8005886:	430a      	orrs	r2, r1
 8005888:	701a      	strb	r2, [r3, #0]
    system_convert_array_steps_to_mpos(target,sys_position);

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    n_active_axis = 0;
    for (idx=0; idx<N_AXIS; idx++) {
 800588a:	233f      	movs	r3, #63	; 0x3f
 800588c:	18fb      	adds	r3, r7, r3
 800588e:	781a      	ldrb	r2, [r3, #0]
 8005890:	233f      	movs	r3, #63	; 0x3f
 8005892:	18fb      	adds	r3, r7, r3
 8005894:	3201      	adds	r2, #1
 8005896:	701a      	strb	r2, [r3, #0]
 8005898:	233f      	movs	r3, #63	; 0x3f
 800589a:	18fb      	adds	r3, r7, r3
 800589c:	781b      	ldrb	r3, [r3, #0]
 800589e:	2b02      	cmp	r3, #2
 80058a0:	d993      	bls.n	80057ca <limits_go_home+0x106>
        // Apply axislock to the step port pins active in this cycle.
        axislock |= step_pin[idx];
      }

    }
    homing_rate *= sqrtf(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
 80058a2:	2332      	movs	r3, #50	; 0x32
 80058a4:	18fb      	adds	r3, r7, r3
 80058a6:	781b      	ldrb	r3, [r3, #0]
 80058a8:	0018      	movs	r0, r3
 80058aa:	f7fb fbcd 	bl	8001048 <__aeabi_ui2f>
 80058ae:	1c03      	adds	r3, r0, #0
 80058b0:	1c18      	adds	r0, r3, #0
 80058b2:	f006 fdb9 	bl	800c428 <sqrtf>
 80058b6:	1c03      	adds	r3, r0, #0
 80058b8:	1c19      	adds	r1, r3, #0
 80058ba:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80058bc:	f7fb f8a8 	bl	8000a10 <__aeabi_fmul>
 80058c0:	1c03      	adds	r3, r0, #0
 80058c2:	637b      	str	r3, [r7, #52]	; 0x34
    sys.homing_axis_lock = axislock;
 80058c4:	4b54      	ldr	r3, [pc, #336]	; (8005a18 <limits_go_home+0x354>)
 80058c6:	2233      	movs	r2, #51	; 0x33
 80058c8:	18ba      	adds	r2, r7, r2
 80058ca:	7812      	ldrb	r2, [r2, #0]
 80058cc:	719a      	strb	r2, [r3, #6]

    // Perform homing cycle. Planner buffer should be empty, as required to initiate the homing cycle.
    pl_data->feed_rate = homing_rate; // Set current homing rate.
 80058ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80058d0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80058d2:	601a      	str	r2, [r3, #0]
    plan_buffer_line(target, pl_data); // Bypass mc_line(). Directly plan homing motion.
 80058d4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80058d6:	2308      	movs	r3, #8
 80058d8:	18fb      	adds	r3, r7, r3
 80058da:	0011      	movs	r1, r2
 80058dc:	0018      	movs	r0, r3
 80058de:	f001 fa67 	bl	8006db0 <plan_buffer_line>

    sys.step_control = STEP_CONTROL_EXECUTE_SYS_MOTION; // Set to execute homing motion and clear existing flags.
 80058e2:	4b4d      	ldr	r3, [pc, #308]	; (8005a18 <limits_go_home+0x354>)
 80058e4:	2204      	movs	r2, #4
 80058e6:	711a      	strb	r2, [r3, #4]
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
 80058e8:	f004 fe64 	bl	800a5b4 <st_prep_buffer>
    st_wake_up(); // Initiate motion
 80058ec:	f004 fa90 	bl	8009e10 <st_wake_up>
    do {
      if (approach) {
 80058f0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80058f2:	2b00      	cmp	r3, #0
 80058f4:	d045      	beq.n	8005982 <limits_go_home+0x2be>
        // Check limit state. Lock out cycle axes when they change.
        limit_state = limits_get_state();
 80058f6:	2327      	movs	r3, #39	; 0x27
 80058f8:	18fc      	adds	r4, r7, r3
 80058fa:	f7ff fe93 	bl	8005624 <limits_get_state>
 80058fe:	0003      	movs	r3, r0
 8005900:	7023      	strb	r3, [r4, #0]
        for (idx=0; idx<N_AXIS; idx++) {
 8005902:	233f      	movs	r3, #63	; 0x3f
 8005904:	18fb      	adds	r3, r7, r3
 8005906:	2200      	movs	r2, #0
 8005908:	701a      	strb	r2, [r3, #0]
 800590a:	e030      	b.n	800596e <limits_go_home+0x2aa>
          if (axislock & step_pin[idx]) {
 800590c:	233f      	movs	r3, #63	; 0x3f
 800590e:	18fb      	adds	r3, r7, r3
 8005910:	781b      	ldrb	r3, [r3, #0]
 8005912:	2214      	movs	r2, #20
 8005914:	18ba      	adds	r2, r7, r2
 8005916:	5cd3      	ldrb	r3, [r2, r3]
 8005918:	2233      	movs	r2, #51	; 0x33
 800591a:	18ba      	adds	r2, r7, r2
 800591c:	7812      	ldrb	r2, [r2, #0]
 800591e:	4013      	ands	r3, r2
 8005920:	b2db      	uxtb	r3, r3
 8005922:	2b00      	cmp	r3, #0
 8005924:	d01c      	beq.n	8005960 <limits_go_home+0x29c>
            if (limit_state & (1 << idx)) {
 8005926:	2327      	movs	r3, #39	; 0x27
 8005928:	18fb      	adds	r3, r7, r3
 800592a:	781a      	ldrb	r2, [r3, #0]
 800592c:	233f      	movs	r3, #63	; 0x3f
 800592e:	18fb      	adds	r3, r7, r3
 8005930:	781b      	ldrb	r3, [r3, #0]
 8005932:	411a      	asrs	r2, r3
 8005934:	0013      	movs	r3, r2
 8005936:	2201      	movs	r2, #1
 8005938:	4013      	ands	r3, r2
 800593a:	d011      	beq.n	8005960 <limits_go_home+0x29c>
              #ifdef COREXY
                if (idx==Z_AXIS) { axislock &= ~(step_pin[Z_AXIS]); }
                else { axislock &= ~(step_pin[A_MOTOR]|step_pin[B_MOTOR]); }
              #else
                axislock &= ~(step_pin[idx]);
 800593c:	233f      	movs	r3, #63	; 0x3f
 800593e:	18fb      	adds	r3, r7, r3
 8005940:	781b      	ldrb	r3, [r3, #0]
 8005942:	2214      	movs	r2, #20
 8005944:	18ba      	adds	r2, r7, r2
 8005946:	5cd3      	ldrb	r3, [r2, r3]
 8005948:	b25b      	sxtb	r3, r3
 800594a:	43db      	mvns	r3, r3
 800594c:	b25b      	sxtb	r3, r3
 800594e:	2233      	movs	r2, #51	; 0x33
 8005950:	18ba      	adds	r2, r7, r2
 8005952:	7812      	ldrb	r2, [r2, #0]
 8005954:	b252      	sxtb	r2, r2
 8005956:	4013      	ands	r3, r2
 8005958:	b25a      	sxtb	r2, r3
 800595a:	2333      	movs	r3, #51	; 0x33
 800595c:	18fb      	adds	r3, r7, r3
 800595e:	701a      	strb	r2, [r3, #0]
    st_wake_up(); // Initiate motion
    do {
      if (approach) {
        // Check limit state. Lock out cycle axes when they change.
        limit_state = limits_get_state();
        for (idx=0; idx<N_AXIS; idx++) {
 8005960:	233f      	movs	r3, #63	; 0x3f
 8005962:	18fb      	adds	r3, r7, r3
 8005964:	781a      	ldrb	r2, [r3, #0]
 8005966:	233f      	movs	r3, #63	; 0x3f
 8005968:	18fb      	adds	r3, r7, r3
 800596a:	3201      	adds	r2, #1
 800596c:	701a      	strb	r2, [r3, #0]
 800596e:	233f      	movs	r3, #63	; 0x3f
 8005970:	18fb      	adds	r3, r7, r3
 8005972:	781b      	ldrb	r3, [r3, #0]
 8005974:	2b02      	cmp	r3, #2
 8005976:	d9c9      	bls.n	800590c <limits_go_home+0x248>
                axislock &= ~(step_pin[idx]);
              #endif
            }
          }
        }
        sys.homing_axis_lock = axislock;
 8005978:	4b27      	ldr	r3, [pc, #156]	; (8005a18 <limits_go_home+0x354>)
 800597a:	2233      	movs	r2, #51	; 0x33
 800597c:	18ba      	adds	r2, r7, r2
 800597e:	7812      	ldrb	r2, [r2, #0]
 8005980:	719a      	strb	r2, [r3, #6]
      }

      st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
 8005982:	f004 fe17 	bl	800a5b4 <st_prep_buffer>

      // Exit routines: No time to run protocol_execute_realtime() in this loop.
      if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
 8005986:	4b29      	ldr	r3, [pc, #164]	; (8005a2c <limits_go_home+0x368>)
 8005988:	781b      	ldrb	r3, [r3, #0]
 800598a:	b2db      	uxtb	r3, r3
 800598c:	001a      	movs	r2, r3
 800598e:	2334      	movs	r3, #52	; 0x34
 8005990:	4013      	ands	r3, r2
 8005992:	d04f      	beq.n	8005a34 <limits_go_home+0x370>
        uint8_t rt_exec = sys_rt_exec_state;
 8005994:	2326      	movs	r3, #38	; 0x26
 8005996:	18fb      	adds	r3, r7, r3
 8005998:	4a24      	ldr	r2, [pc, #144]	; (8005a2c <limits_go_home+0x368>)
 800599a:	7812      	ldrb	r2, [r2, #0]
 800599c:	701a      	strb	r2, [r3, #0]
        // Homing failure condition: Reset issued during cycle.
        if (rt_exec & EXEC_RESET) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
 800599e:	2326      	movs	r3, #38	; 0x26
 80059a0:	18fb      	adds	r3, r7, r3
 80059a2:	781b      	ldrb	r3, [r3, #0]
 80059a4:	2210      	movs	r2, #16
 80059a6:	4013      	ands	r3, r2
 80059a8:	d002      	beq.n	80059b0 <limits_go_home+0x2ec>
 80059aa:	2006      	movs	r0, #6
 80059ac:	f006 f856 	bl	800ba5c <system_set_exec_alarm>
        // Homing failure condition: Safety door was opened.
        if (rt_exec & EXEC_SAFETY_DOOR) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_DOOR); }
 80059b0:	2326      	movs	r3, #38	; 0x26
 80059b2:	18fb      	adds	r3, r7, r3
 80059b4:	781b      	ldrb	r3, [r3, #0]
 80059b6:	2220      	movs	r2, #32
 80059b8:	4013      	ands	r3, r2
 80059ba:	d002      	beq.n	80059c2 <limits_go_home+0x2fe>
 80059bc:	2007      	movs	r0, #7
 80059be:	f006 f84d 	bl	800ba5c <system_set_exec_alarm>
        // Homing failure condition: Limit switch still engaged after pull-off motion
        if (!approach && (limits_get_state() & cycle_mask)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_PULLOFF); }
 80059c2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80059c4:	2b00      	cmp	r3, #0
 80059c6:	d10c      	bne.n	80059e2 <limits_go_home+0x31e>
 80059c8:	f7ff fe2c 	bl	8005624 <limits_get_state>
 80059cc:	0003      	movs	r3, r0
 80059ce:	001a      	movs	r2, r3
 80059d0:	1dfb      	adds	r3, r7, #7
 80059d2:	781b      	ldrb	r3, [r3, #0]
 80059d4:	4013      	ands	r3, r2
 80059d6:	b2db      	uxtb	r3, r3
 80059d8:	2b00      	cmp	r3, #0
 80059da:	d002      	beq.n	80059e2 <limits_go_home+0x31e>
 80059dc:	2008      	movs	r0, #8
 80059de:	f006 f83d 	bl	800ba5c <system_set_exec_alarm>
        // Homing failure condition: Limit switch not found during approach.
        if (approach && (rt_exec & EXEC_CYCLE_STOP)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_APPROACH); }
 80059e2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80059e4:	2b00      	cmp	r3, #0
 80059e6:	d008      	beq.n	80059fa <limits_go_home+0x336>
 80059e8:	2326      	movs	r3, #38	; 0x26
 80059ea:	18fb      	adds	r3, r7, r3
 80059ec:	781b      	ldrb	r3, [r3, #0]
 80059ee:	2204      	movs	r2, #4
 80059f0:	4013      	ands	r3, r2
 80059f2:	d002      	beq.n	80059fa <limits_go_home+0x336>
 80059f4:	2009      	movs	r0, #9
 80059f6:	f006 f831 	bl	800ba5c <system_set_exec_alarm>
        if (sys_rt_exec_alarm) {
 80059fa:	4b0d      	ldr	r3, [pc, #52]	; (8005a30 <limits_go_home+0x36c>)
 80059fc:	781b      	ldrb	r3, [r3, #0]
 80059fe:	b2db      	uxtb	r3, r3
 8005a00:	2b00      	cmp	r3, #0
 8005a02:	d004      	beq.n	8005a0e <limits_go_home+0x34a>
          mc_reset(); // Stop motors, if they are running.
 8005a04:	f000 fc7a 	bl	80062fc <mc_reset>
          protocol_execute_realtime();
 8005a08:	f001 ff8c 	bl	8007924 <protocol_execute_realtime>
          return;
 8005a0c:	e0bc      	b.n	8005b88 <limits_go_home+0x4c4>
        } else {
          // Pull-off motion complete. Disable CYCLE_STOP from executing.
          system_clear_exec_state_flag(EXEC_CYCLE_STOP);
 8005a0e:	2004      	movs	r0, #4
 8005a10:	f006 f808 	bl	800ba24 <system_clear_exec_state_flag>
          break;
 8005a14:	e017      	b.n	8005a46 <limits_go_home+0x382>
 8005a16:	46c0      	nop			; (mov r8, r8)
 8005a18:	20000b2c 	.word	0x20000b2c
 8005a1c:	0800da80 	.word	0x0800da80
 8005a20:	20000acc 	.word	0x20000acc
 8005a24:	bfc00000 	.word	0xbfc00000
 8005a28:	20000b50 	.word	0x20000b50
 8005a2c:	20000b41 	.word	0x20000b41
 8005a30:	20000b5c 	.word	0x20000b5c
        }
      }

    } while (STEP_MASK & axislock);
 8005a34:	2333      	movs	r3, #51	; 0x33
 8005a36:	18fb      	adds	r3, r7, r3
 8005a38:	781b      	ldrb	r3, [r3, #0]
 8005a3a:	2207      	movs	r2, #7
 8005a3c:	4013      	ands	r3, r2
 8005a3e:	b2db      	uxtb	r3, r3
 8005a40:	2b00      	cmp	r3, #0
 8005a42:	d000      	beq.n	8005a46 <limits_go_home+0x382>
 8005a44:	e754      	b.n	80058f0 <limits_go_home+0x22c>

    st_reset(); // Immediately force kill steppers and reset step segment buffer.
 8005a46:	f004 fca5 	bl	800a394 <st_reset>
    delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
 8005a4a:	4b51      	ldr	r3, [pc, #324]	; (8005b90 <limits_go_home+0x4cc>)
 8005a4c:	2254      	movs	r2, #84	; 0x54
 8005a4e:	5a9b      	ldrh	r3, [r3, r2]
 8005a50:	0018      	movs	r0, r3
 8005a52:	f000 fdc7 	bl	80065e4 <delay_ms>

    // Reverse direction and reset homing rate for locate cycle(s).
    approach = !approach;
 8005a56:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005a58:	425a      	negs	r2, r3
 8005a5a:	4153      	adcs	r3, r2
 8005a5c:	b2db      	uxtb	r3, r3
 8005a5e:	63bb      	str	r3, [r7, #56]	; 0x38

    // After first cycle, homing enters locating phase. Shorten search to pull-off distance.
    if (approach) {
 8005a60:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005a62:	2b00      	cmp	r3, #0
 8005a64:	d00b      	beq.n	8005a7e <limits_go_home+0x3ba>
      max_travel = settings.homing_pulloff*HOMING_AXIS_LOCATE_SCALAR;
 8005a66:	4b4a      	ldr	r3, [pc, #296]	; (8005b90 <limits_go_home+0x4cc>)
 8005a68:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005a6a:	494a      	ldr	r1, [pc, #296]	; (8005b94 <limits_go_home+0x4d0>)
 8005a6c:	1c18      	adds	r0, r3, #0
 8005a6e:	f7fa ffcf 	bl	8000a10 <__aeabi_fmul>
 8005a72:	1c03      	adds	r3, r0, #0
 8005a74:	643b      	str	r3, [r7, #64]	; 0x40
      homing_rate = settings.homing_feed_rate;
 8005a76:	4b46      	ldr	r3, [pc, #280]	; (8005b90 <limits_go_home+0x4cc>)
 8005a78:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8005a7a:	637b      	str	r3, [r7, #52]	; 0x34
 8005a7c:	e005      	b.n	8005a8a <limits_go_home+0x3c6>
    } else {
      max_travel = settings.homing_pulloff;
 8005a7e:	4b44      	ldr	r3, [pc, #272]	; (8005b90 <limits_go_home+0x4cc>)
 8005a80:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005a82:	643b      	str	r3, [r7, #64]	; 0x40
      homing_rate = settings.homing_seek_rate;
 8005a84:	4b42      	ldr	r3, [pc, #264]	; (8005b90 <limits_go_home+0x4cc>)
 8005a86:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005a88:	637b      	str	r3, [r7, #52]	; 0x34
    }

  } while (n_cycle-- > 0);
 8005a8a:	2347      	movs	r3, #71	; 0x47
 8005a8c:	18fb      	adds	r3, r7, r3
 8005a8e:	781b      	ldrb	r3, [r3, #0]
 8005a90:	2247      	movs	r2, #71	; 0x47
 8005a92:	18ba      	adds	r2, r7, r2
 8005a94:	1e59      	subs	r1, r3, #1
 8005a96:	7011      	strb	r1, [r2, #0]
 8005a98:	2b00      	cmp	r3, #0
 8005a9a:	d000      	beq.n	8005a9e <limits_go_home+0x3da>
 8005a9c:	e681      	b.n	80057a2 <limits_go_home+0xde>
  // set up pull-off maneuver from axes limit switches that have been homed. This provides
  // some initial clearance off the switches and should also help prevent them from falsely
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
 8005a9e:	233f      	movs	r3, #63	; 0x3f
 8005aa0:	18fb      	adds	r3, r7, r3
 8005aa2:	2200      	movs	r2, #0
 8005aa4:	701a      	strb	r2, [r3, #0]
 8005aa6:	e065      	b.n	8005b74 <limits_go_home+0x4b0>
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
 8005aa8:	1dfb      	adds	r3, r7, #7
 8005aaa:	781a      	ldrb	r2, [r3, #0]
 8005aac:	233f      	movs	r3, #63	; 0x3f
 8005aae:	18fb      	adds	r3, r7, r3
 8005ab0:	781b      	ldrb	r3, [r3, #0]
 8005ab2:	411a      	asrs	r2, r3
 8005ab4:	0013      	movs	r3, r2
 8005ab6:	2201      	movs	r2, #1
 8005ab8:	4013      	ands	r3, r2
 8005aba:	d054      	beq.n	8005b66 <limits_go_home+0x4a2>
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
 8005abc:	4b34      	ldr	r3, [pc, #208]	; (8005b90 <limits_go_home+0x4cc>)
 8005abe:	2249      	movs	r2, #73	; 0x49
 8005ac0:	5c9b      	ldrb	r3, [r3, r2]
 8005ac2:	001a      	movs	r2, r3
 8005ac4:	233f      	movs	r3, #63	; 0x3f
 8005ac6:	18fb      	adds	r3, r7, r3
 8005ac8:	781b      	ldrb	r3, [r3, #0]
 8005aca:	411a      	asrs	r2, r3
 8005acc:	0013      	movs	r3, r2
 8005ace:	2201      	movs	r2, #1
 8005ad0:	4013      	ands	r3, r2
 8005ad2:	d026      	beq.n	8005b22 <limits_go_home+0x45e>
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
 8005ad4:	233f      	movs	r3, #63	; 0x3f
 8005ad6:	18fb      	adds	r3, r7, r3
 8005ad8:	781b      	ldrb	r3, [r3, #0]
 8005ada:	4a2d      	ldr	r2, [pc, #180]	; (8005b90 <limits_go_home+0x4cc>)
 8005adc:	3308      	adds	r3, #8
 8005ade:	009b      	lsls	r3, r3, #2
 8005ae0:	18d3      	adds	r3, r2, r3
 8005ae2:	3304      	adds	r3, #4
 8005ae4:	681a      	ldr	r2, [r3, #0]
 8005ae6:	4b2a      	ldr	r3, [pc, #168]	; (8005b90 <limits_go_home+0x4cc>)
 8005ae8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005aea:	1c19      	adds	r1, r3, #0
 8005aec:	1c10      	adds	r0, r2, #0
 8005aee:	f7fa fc4f 	bl	8000390 <__aeabi_fadd>
 8005af2:	1c03      	adds	r3, r0, #0
 8005af4:	1c18      	adds	r0, r3, #0
 8005af6:	233f      	movs	r3, #63	; 0x3f
 8005af8:	18fb      	adds	r3, r7, r3
 8005afa:	781a      	ldrb	r2, [r3, #0]
 8005afc:	4b24      	ldr	r3, [pc, #144]	; (8005b90 <limits_go_home+0x4cc>)
 8005afe:	0092      	lsls	r2, r2, #2
 8005b00:	58d3      	ldr	r3, [r2, r3]
 8005b02:	1c19      	adds	r1, r3, #0
 8005b04:	f7fa ff84 	bl	8000a10 <__aeabi_fmul>
 8005b08:	1c03      	adds	r3, r0, #0
 8005b0a:	1c18      	adds	r0, r3, #0
 8005b0c:	f7fc fdb4 	bl	8002678 <__aeabi_f2d>
 8005b10:	0003      	movs	r3, r0
 8005b12:	000c      	movs	r4, r1
 8005b14:	0018      	movs	r0, r3
 8005b16:	0021      	movs	r1, r4
 8005b18:	f006 fafa 	bl	800c110 <lround>
 8005b1c:	0003      	movs	r3, r0
 8005b1e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005b20:	e01a      	b.n	8005b58 <limits_go_home+0x494>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
 8005b22:	4b1b      	ldr	r3, [pc, #108]	; (8005b90 <limits_go_home+0x4cc>)
 8005b24:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005b26:	2280      	movs	r2, #128	; 0x80
 8005b28:	0612      	lsls	r2, r2, #24
 8005b2a:	405a      	eors	r2, r3
 8005b2c:	0010      	movs	r0, r2
 8005b2e:	233f      	movs	r3, #63	; 0x3f
 8005b30:	18fb      	adds	r3, r7, r3
 8005b32:	781a      	ldrb	r2, [r3, #0]
 8005b34:	4b16      	ldr	r3, [pc, #88]	; (8005b90 <limits_go_home+0x4cc>)
 8005b36:	0092      	lsls	r2, r2, #2
 8005b38:	58d3      	ldr	r3, [r2, r3]
 8005b3a:	1c19      	adds	r1, r3, #0
 8005b3c:	f7fa ff68 	bl	8000a10 <__aeabi_fmul>
 8005b40:	1c03      	adds	r3, r0, #0
 8005b42:	1c18      	adds	r0, r3, #0
 8005b44:	f7fc fd98 	bl	8002678 <__aeabi_f2d>
 8005b48:	0003      	movs	r3, r0
 8005b4a:	000c      	movs	r4, r1
 8005b4c:	0018      	movs	r0, r3
 8005b4e:	0021      	movs	r1, r4
 8005b50:	f006 fade 	bl	800c110 <lround>
 8005b54:	0003      	movs	r3, r0
 8005b56:	62fb      	str	r3, [r7, #44]	; 0x2c
          sys_position[B_MOTOR] = off_axis_position - set_axis_position;
        } else {
          sys_position[idx] = set_axis_position;
        }
      #else
        sys_position[idx] = set_axis_position;
 8005b58:	233f      	movs	r3, #63	; 0x3f
 8005b5a:	18fb      	adds	r3, r7, r3
 8005b5c:	781a      	ldrb	r2, [r3, #0]
 8005b5e:	4b0e      	ldr	r3, [pc, #56]	; (8005b98 <limits_go_home+0x4d4>)
 8005b60:	0092      	lsls	r2, r2, #2
 8005b62:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8005b64:	50d1      	str	r1, [r2, r3]
  // set up pull-off maneuver from axes limit switches that have been homed. This provides
  // some initial clearance off the switches and should also help prevent them from falsely
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
 8005b66:	233f      	movs	r3, #63	; 0x3f
 8005b68:	18fb      	adds	r3, r7, r3
 8005b6a:	781a      	ldrb	r2, [r3, #0]
 8005b6c:	233f      	movs	r3, #63	; 0x3f
 8005b6e:	18fb      	adds	r3, r7, r3
 8005b70:	3201      	adds	r2, #1
 8005b72:	701a      	strb	r2, [r3, #0]
 8005b74:	233f      	movs	r3, #63	; 0x3f
 8005b76:	18fb      	adds	r3, r7, r3
 8005b78:	781b      	ldrb	r3, [r3, #0]
 8005b7a:	2b02      	cmp	r3, #2
 8005b7c:	d994      	bls.n	8005aa8 <limits_go_home+0x3e4>
        sys_position[idx] = set_axis_position;
      #endif

    }
  }
  sys.step_control = STEP_CONTROL_NORMAL_OP; // Return step control to normal operation.
 8005b7e:	4b07      	ldr	r3, [pc, #28]	; (8005b9c <limits_go_home+0x4d8>)
 8005b80:	2200      	movs	r2, #0
 8005b82:	711a      	strb	r2, [r3, #4]
 8005b84:	e000      	b.n	8005b88 <limits_go_home+0x4c4>
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask)
{
  if (sys.abort) { return; } // Block if system reset has been issued.
 8005b86:	46c0      	nop			; (mov r8, r8)
      #endif

    }
  }
  sys.step_control = STEP_CONTROL_NORMAL_OP; // Return step control to normal operation.
}
 8005b88:	46bd      	mov	sp, r7
 8005b8a:	b013      	add	sp, #76	; 0x4c
 8005b8c:	bd90      	pop	{r4, r7, pc}
 8005b8e:	46c0      	nop			; (mov r8, r8)
 8005b90:	20000acc 	.word	0x20000acc
 8005b94:	40a00000 	.word	0x40a00000
 8005b98:	20000b50 	.word	0x20000b50
 8005b9c:	20000b2c 	.word	0x20000b2c

08005ba0 <limits_soft_check>:

// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
// NOTE: Used by jogging to limit travel within soft-limit volume.
void limits_soft_check(float *target)
{
 8005ba0:	b580      	push	{r7, lr}
 8005ba2:	b082      	sub	sp, #8
 8005ba4:	af00      	add	r7, sp, #0
 8005ba6:	6078      	str	r0, [r7, #4]
  if (system_check_travel_limits(target)) {
 8005ba8:	687b      	ldr	r3, [r7, #4]
 8005baa:	0018      	movs	r0, r3
 8005bac:	f005 fee2 	bl	800b974 <system_check_travel_limits>
 8005bb0:	1e03      	subs	r3, r0, #0
 8005bb2:	d01d      	beq.n	8005bf0 <limits_soft_check+0x50>
    sys.soft_limit = true;
 8005bb4:	4b10      	ldr	r3, [pc, #64]	; (8005bf8 <limits_soft_check+0x58>)
 8005bb6:	2201      	movs	r2, #1
 8005bb8:	70da      	strb	r2, [r3, #3]
    // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
 8005bba:	4b0f      	ldr	r3, [pc, #60]	; (8005bf8 <limits_soft_check+0x58>)
 8005bbc:	781b      	ldrb	r3, [r3, #0]
 8005bbe:	2b08      	cmp	r3, #8
 8005bc0:	d10c      	bne.n	8005bdc <limits_soft_check+0x3c>
      system_set_exec_state_flag(EXEC_FEED_HOLD);
 8005bc2:	2008      	movs	r0, #8
 8005bc4:	f005 ff16 	bl	800b9f4 <system_set_exec_state_flag>
      do {
        protocol_execute_realtime();
 8005bc8:	f001 feac 	bl	8007924 <protocol_execute_realtime>
        if (sys.abort) { return; }
 8005bcc:	4b0a      	ldr	r3, [pc, #40]	; (8005bf8 <limits_soft_check+0x58>)
 8005bce:	785b      	ldrb	r3, [r3, #1]
 8005bd0:	2b00      	cmp	r3, #0
 8005bd2:	d10c      	bne.n	8005bee <limits_soft_check+0x4e>
      } while ( sys.state != STATE_IDLE );
 8005bd4:	4b08      	ldr	r3, [pc, #32]	; (8005bf8 <limits_soft_check+0x58>)
 8005bd6:	781b      	ldrb	r3, [r3, #0]
 8005bd8:	2b00      	cmp	r3, #0
 8005bda:	d1f5      	bne.n	8005bc8 <limits_soft_check+0x28>
    }
    mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
 8005bdc:	f000 fb8e 	bl	80062fc <mc_reset>
    system_set_exec_alarm(EXEC_ALARM_SOFT_LIMIT); // Indicate soft limit critical event
 8005be0:	2002      	movs	r0, #2
 8005be2:	f005 ff3b 	bl	800ba5c <system_set_exec_alarm>
    protocol_execute_realtime(); // Execute to enter critical event loop and system abort
 8005be6:	f001 fe9d 	bl	8007924 <protocol_execute_realtime>
    return;
 8005bea:	46c0      	nop			; (mov r8, r8)
 8005bec:	e000      	b.n	8005bf0 <limits_soft_check+0x50>
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
      system_set_exec_state_flag(EXEC_FEED_HOLD);
      do {
        protocol_execute_realtime();
        if (sys.abort) { return; }
 8005bee:	46c0      	nop			; (mov r8, r8)
    mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    system_set_exec_alarm(EXEC_ALARM_SOFT_LIMIT); // Indicate soft limit critical event
    protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    return;
  }
}
 8005bf0:	46bd      	mov	sp, r7
 8005bf2:	b002      	add	sp, #8
 8005bf4:	bd80      	pop	{r7, pc}
 8005bf6:	46c0      	nop			; (mov r8, r8)
 8005bf8:	20000b2c 	.word	0x20000b2c

08005bfc <mc_line>:
// NOTE: This is the primary gateway to the grbl planner. All line motions, including arc line
// segments, must pass through this routine before being passed to the planner. The seperation of
// mc_line and plan_buffer_line is done primarily to place non-planner-type functions from being
// in the planner and to let backlash compensation or canned cycle integration simple and direct.
void mc_line(float *target, plan_line_data_t *pl_data)
{
 8005bfc:	b580      	push	{r7, lr}
 8005bfe:	b082      	sub	sp, #8
 8005c00:	af00      	add	r7, sp, #0
 8005c02:	6078      	str	r0, [r7, #4]
 8005c04:	6039      	str	r1, [r7, #0]
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
 8005c06:	4b21      	ldr	r3, [pc, #132]	; (8005c8c <mc_line+0x90>)
 8005c08:	2248      	movs	r2, #72	; 0x48
 8005c0a:	5c9b      	ldrb	r3, [r3, r2]
 8005c0c:	001a      	movs	r2, r3
 8005c0e:	2320      	movs	r3, #32
 8005c10:	4013      	ands	r3, r2
 8005c12:	d007      	beq.n	8005c24 <mc_line+0x28>
    // NOTE: Block jog state. Jogging is a special case and soft limits are handled independently.
    if (sys.state != STATE_JOG) { limits_soft_check(target); }
 8005c14:	4b1e      	ldr	r3, [pc, #120]	; (8005c90 <mc_line+0x94>)
 8005c16:	781b      	ldrb	r3, [r3, #0]
 8005c18:	2b20      	cmp	r3, #32
 8005c1a:	d003      	beq.n	8005c24 <mc_line+0x28>
 8005c1c:	687b      	ldr	r3, [r7, #4]
 8005c1e:	0018      	movs	r0, r3
 8005c20:	f7ff ffbe 	bl	8005ba0 <limits_soft_check>
  }

  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
 8005c24:	4b1a      	ldr	r3, [pc, #104]	; (8005c90 <mc_line+0x94>)
 8005c26:	781b      	ldrb	r3, [r3, #0]
 8005c28:	2b02      	cmp	r3, #2
 8005c2a:	d029      	beq.n	8005c80 <mc_line+0x84>
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot.
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
 8005c2c:	f001 fe7a 	bl	8007924 <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail, if system abort.
 8005c30:	4b17      	ldr	r3, [pc, #92]	; (8005c90 <mc_line+0x94>)
 8005c32:	785b      	ldrb	r3, [r3, #1]
 8005c34:	2b00      	cmp	r3, #0
 8005c36:	d125      	bne.n	8005c84 <mc_line+0x88>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
 8005c38:	f000 ffe0 	bl	8006bfc <plan_check_full_buffer>
 8005c3c:	1e03      	subs	r3, r0, #0
 8005c3e:	d002      	beq.n	8005c46 <mc_line+0x4a>
 8005c40:	f001 fe64 	bl	800790c <protocol_auto_cycle_start>
    else { break; }
  } while (1);
 8005c44:	e7f2      	b.n	8005c2c <mc_line+0x30>
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    if (sys.abort) { return; } // Bail, if system abort.
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
    else { break; }
 8005c46:	46c0      	nop			; (mov r8, r8)
  } while (1);

  // Plan and queue motion into planner buffer
	if (plan_buffer_line(target, pl_data) == PLAN_EMPTY_BLOCK) {
 8005c48:	683a      	ldr	r2, [r7, #0]
 8005c4a:	687b      	ldr	r3, [r7, #4]
 8005c4c:	0011      	movs	r1, r2
 8005c4e:	0018      	movs	r0, r3
 8005c50:	f001 f8ae 	bl	8006db0 <plan_buffer_line>
 8005c54:	1e03      	subs	r3, r0, #0
 8005c56:	d116      	bne.n	8005c86 <mc_line+0x8a>
		if (bit_istrue(settings.flags, BITFLAG_LASER_MODE)) {
 8005c58:	4b0c      	ldr	r3, [pc, #48]	; (8005c8c <mc_line+0x90>)
 8005c5a:	2248      	movs	r2, #72	; 0x48
 8005c5c:	5c9b      	ldrb	r3, [r3, r2]
 8005c5e:	001a      	movs	r2, r3
 8005c60:	2302      	movs	r3, #2
 8005c62:	4013      	ands	r3, r2
 8005c64:	d00f      	beq.n	8005c86 <mc_line+0x8a>
			// Correctly set spindle state, if there is a coincident position passed. Forces a buffer
			// sync while in M3 laser mode only.
			if (pl_data->condition & PL_COND_FLAG_SPINDLE_CW) {
 8005c66:	683b      	ldr	r3, [r7, #0]
 8005c68:	7a1b      	ldrb	r3, [r3, #8]
 8005c6a:	001a      	movs	r2, r3
 8005c6c:	2310      	movs	r3, #16
 8005c6e:	4013      	ands	r3, r2
 8005c70:	d009      	beq.n	8005c86 <mc_line+0x8a>
				spindle_sync(PL_COND_FLAG_SPINDLE_CW, pl_data->spindle_speed);
 8005c72:	683b      	ldr	r3, [r7, #0]
 8005c74:	685b      	ldr	r3, [r3, #4]
 8005c76:	1c19      	adds	r1, r3, #0
 8005c78:	2010      	movs	r0, #16
 8005c7a:	f004 f87f 	bl	8009d7c <spindle_sync>
 8005c7e:	e002      	b.n	8005c86 <mc_line+0x8a>
    // NOTE: Block jog state. Jogging is a special case and soft limits are handled independently.
    if (sys.state != STATE_JOG) { limits_soft_check(target); }
  }

  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
 8005c80:	46c0      	nop			; (mov r8, r8)
 8005c82:	e000      	b.n	8005c86 <mc_line+0x8a>

  // If the buffer is full: good! That means we are well ahead of the robot.
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    if (sys.abort) { return; } // Bail, if system abort.
 8005c84:	46c0      	nop			; (mov r8, r8)
			if (pl_data->condition & PL_COND_FLAG_SPINDLE_CW) {
				spindle_sync(PL_COND_FLAG_SPINDLE_CW, pl_data->spindle_speed);
			}
		}
	}
}
 8005c86:	46bd      	mov	sp, r7
 8005c88:	b002      	add	sp, #8
 8005c8a:	bd80      	pop	{r7, pc}
 8005c8c:	20000acc 	.word	0x20000acc
 8005c90:	20000b2c 	.word	0x20000b2c

08005c94 <mc_arc>:
// The arc is approximated by generating a huge number of tiny, linear segments. The chordal tolerance
// of each segment is configured in settings.arc_tolerance, which is defined to be the maximum normal
// distance from segment to the circle when the end points both lie on the circle.
void mc_arc(float *target, plan_line_data_t *pl_data, float *position, float *offset, float radius,
  uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
{
 8005c94:	b5b0      	push	{r4, r5, r7, lr}
 8005c96:	b094      	sub	sp, #80	; 0x50
 8005c98:	af00      	add	r7, sp, #0
 8005c9a:	60f8      	str	r0, [r7, #12]
 8005c9c:	60b9      	str	r1, [r7, #8]
 8005c9e:	607a      	str	r2, [r7, #4]
 8005ca0:	603b      	str	r3, [r7, #0]
  float center_axis0 = position[axis_0] + offset[axis_0];
 8005ca2:	2364      	movs	r3, #100	; 0x64
 8005ca4:	18fb      	adds	r3, r7, r3
 8005ca6:	781b      	ldrb	r3, [r3, #0]
 8005ca8:	009b      	lsls	r3, r3, #2
 8005caa:	687a      	ldr	r2, [r7, #4]
 8005cac:	18d3      	adds	r3, r2, r3
 8005cae:	6818      	ldr	r0, [r3, #0]
 8005cb0:	2364      	movs	r3, #100	; 0x64
 8005cb2:	18fb      	adds	r3, r7, r3
 8005cb4:	781b      	ldrb	r3, [r3, #0]
 8005cb6:	009b      	lsls	r3, r3, #2
 8005cb8:	683a      	ldr	r2, [r7, #0]
 8005cba:	18d3      	adds	r3, r2, r3
 8005cbc:	681b      	ldr	r3, [r3, #0]
 8005cbe:	1c19      	adds	r1, r3, #0
 8005cc0:	f7fa fb66 	bl	8000390 <__aeabi_fadd>
 8005cc4:	1c03      	adds	r3, r0, #0
 8005cc6:	63fb      	str	r3, [r7, #60]	; 0x3c
  float center_axis1 = position[axis_1] + offset[axis_1];
 8005cc8:	2368      	movs	r3, #104	; 0x68
 8005cca:	18fb      	adds	r3, r7, r3
 8005ccc:	781b      	ldrb	r3, [r3, #0]
 8005cce:	009b      	lsls	r3, r3, #2
 8005cd0:	687a      	ldr	r2, [r7, #4]
 8005cd2:	18d3      	adds	r3, r2, r3
 8005cd4:	6818      	ldr	r0, [r3, #0]
 8005cd6:	2368      	movs	r3, #104	; 0x68
 8005cd8:	18fb      	adds	r3, r7, r3
 8005cda:	781b      	ldrb	r3, [r3, #0]
 8005cdc:	009b      	lsls	r3, r3, #2
 8005cde:	683a      	ldr	r2, [r7, #0]
 8005ce0:	18d3      	adds	r3, r2, r3
 8005ce2:	681b      	ldr	r3, [r3, #0]
 8005ce4:	1c19      	adds	r1, r3, #0
 8005ce6:	f7fa fb53 	bl	8000390 <__aeabi_fadd>
 8005cea:	1c03      	adds	r3, r0, #0
 8005cec:	63bb      	str	r3, [r7, #56]	; 0x38
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
 8005cee:	2364      	movs	r3, #100	; 0x64
 8005cf0:	18fb      	adds	r3, r7, r3
 8005cf2:	781b      	ldrb	r3, [r3, #0]
 8005cf4:	009b      	lsls	r3, r3, #2
 8005cf6:	683a      	ldr	r2, [r7, #0]
 8005cf8:	18d3      	adds	r3, r2, r3
 8005cfa:	681b      	ldr	r3, [r3, #0]
 8005cfc:	2280      	movs	r2, #128	; 0x80
 8005cfe:	0612      	lsls	r2, r2, #24
 8005d00:	4053      	eors	r3, r2
 8005d02:	64fb      	str	r3, [r7, #76]	; 0x4c
  float r_axis1 = -offset[axis_1];
 8005d04:	2368      	movs	r3, #104	; 0x68
 8005d06:	18fb      	adds	r3, r7, r3
 8005d08:	781b      	ldrb	r3, [r3, #0]
 8005d0a:	009b      	lsls	r3, r3, #2
 8005d0c:	683a      	ldr	r2, [r7, #0]
 8005d0e:	18d3      	adds	r3, r2, r3
 8005d10:	681b      	ldr	r3, [r3, #0]
 8005d12:	2280      	movs	r2, #128	; 0x80
 8005d14:	0612      	lsls	r2, r2, #24
 8005d16:	4053      	eors	r3, r2
 8005d18:	64bb      	str	r3, [r7, #72]	; 0x48
  float rt_axis0 = target[axis_0] - center_axis0;
 8005d1a:	2364      	movs	r3, #100	; 0x64
 8005d1c:	18fb      	adds	r3, r7, r3
 8005d1e:	781b      	ldrb	r3, [r3, #0]
 8005d20:	009b      	lsls	r3, r3, #2
 8005d22:	68fa      	ldr	r2, [r7, #12]
 8005d24:	18d3      	adds	r3, r2, r3
 8005d26:	681b      	ldr	r3, [r3, #0]
 8005d28:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8005d2a:	1c18      	adds	r0, r3, #0
 8005d2c:	f7fa ff84 	bl	8000c38 <__aeabi_fsub>
 8005d30:	1c03      	adds	r3, r0, #0
 8005d32:	637b      	str	r3, [r7, #52]	; 0x34
  float rt_axis1 = target[axis_1] - center_axis1;
 8005d34:	2368      	movs	r3, #104	; 0x68
 8005d36:	18fb      	adds	r3, r7, r3
 8005d38:	781b      	ldrb	r3, [r3, #0]
 8005d3a:	009b      	lsls	r3, r3, #2
 8005d3c:	68fa      	ldr	r2, [r7, #12]
 8005d3e:	18d3      	adds	r3, r2, r3
 8005d40:	681b      	ldr	r3, [r3, #0]
 8005d42:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8005d44:	1c18      	adds	r0, r3, #0
 8005d46:	f7fa ff77 	bl	8000c38 <__aeabi_fsub>
 8005d4a:	1c03      	adds	r3, r0, #0
 8005d4c:	633b      	str	r3, [r7, #48]	; 0x30

  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2f(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
 8005d4e:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8005d50:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8005d52:	f7fa fe5d 	bl	8000a10 <__aeabi_fmul>
 8005d56:	1c03      	adds	r3, r0, #0
 8005d58:	1c1c      	adds	r4, r3, #0
 8005d5a:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8005d5c:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8005d5e:	f7fa fe57 	bl	8000a10 <__aeabi_fmul>
 8005d62:	1c03      	adds	r3, r0, #0
 8005d64:	1c19      	adds	r1, r3, #0
 8005d66:	1c20      	adds	r0, r4, #0
 8005d68:	f7fa ff66 	bl	8000c38 <__aeabi_fsub>
 8005d6c:	1c03      	adds	r3, r0, #0
 8005d6e:	1c1c      	adds	r4, r3, #0
 8005d70:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8005d72:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8005d74:	f7fa fe4c 	bl	8000a10 <__aeabi_fmul>
 8005d78:	1c03      	adds	r3, r0, #0
 8005d7a:	1c1d      	adds	r5, r3, #0
 8005d7c:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8005d7e:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8005d80:	f7fa fe46 	bl	8000a10 <__aeabi_fmul>
 8005d84:	1c03      	adds	r3, r0, #0
 8005d86:	1c19      	adds	r1, r3, #0
 8005d88:	1c28      	adds	r0, r5, #0
 8005d8a:	f7fa fb01 	bl	8000390 <__aeabi_fadd>
 8005d8e:	1c03      	adds	r3, r0, #0
 8005d90:	1c19      	adds	r1, r3, #0
 8005d92:	1c20      	adds	r0, r4, #0
 8005d94:	f006 fb44 	bl	800c420 <atan2f>
 8005d98:	1c03      	adds	r3, r0, #0
 8005d9a:	647b      	str	r3, [r7, #68]	; 0x44
  if (is_clockwise_arc) { // Correct atan2 output per direction
 8005d9c:	2370      	movs	r3, #112	; 0x70
 8005d9e:	18fb      	adds	r3, r7, r3
 8005da0:	781b      	ldrb	r3, [r3, #0]
 8005da2:	2b00      	cmp	r3, #0
 8005da4:	d018      	beq.n	8005dd8 <mc_arc+0x144>
    if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel -= 2*M_PI; }
 8005da6:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8005da8:	f7fc fc66 	bl	8002678 <__aeabi_f2d>
 8005dac:	4ae4      	ldr	r2, [pc, #912]	; (8006140 <mc_arc+0x4ac>)
 8005dae:	4be5      	ldr	r3, [pc, #916]	; (8006144 <mc_arc+0x4b0>)
 8005db0:	f7fa fa74 	bl	800029c <__aeabi_dcmpge>
 8005db4:	1e03      	subs	r3, r0, #0
 8005db6:	d027      	beq.n	8005e08 <mc_arc+0x174>
 8005db8:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8005dba:	f7fc fc5d 	bl	8002678 <__aeabi_f2d>
 8005dbe:	4ae2      	ldr	r2, [pc, #904]	; (8006148 <mc_arc+0x4b4>)
 8005dc0:	4be2      	ldr	r3, [pc, #904]	; (800614c <mc_arc+0x4b8>)
 8005dc2:	f7fc f8cf 	bl	8001f64 <__aeabi_dsub>
 8005dc6:	0003      	movs	r3, r0
 8005dc8:	000c      	movs	r4, r1
 8005dca:	0018      	movs	r0, r3
 8005dcc:	0021      	movs	r1, r4
 8005dce:	f7fc fca7 	bl	8002720 <__aeabi_d2f>
 8005dd2:	1c03      	adds	r3, r0, #0
 8005dd4:	647b      	str	r3, [r7, #68]	; 0x44
 8005dd6:	e017      	b.n	8005e08 <mc_arc+0x174>
  } else {
    if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel += 2*M_PI; }
 8005dd8:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8005dda:	f7fc fc4d 	bl	8002678 <__aeabi_f2d>
 8005dde:	4ad8      	ldr	r2, [pc, #864]	; (8006140 <mc_arc+0x4ac>)
 8005de0:	4bdb      	ldr	r3, [pc, #876]	; (8006150 <mc_arc+0x4bc>)
 8005de2:	f7fa fa47 	bl	8000274 <__aeabi_dcmple>
 8005de6:	1e03      	subs	r3, r0, #0
 8005de8:	d00e      	beq.n	8005e08 <mc_arc+0x174>
 8005dea:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8005dec:	f7fc fc44 	bl	8002678 <__aeabi_f2d>
 8005df0:	4ad5      	ldr	r2, [pc, #852]	; (8006148 <mc_arc+0x4b4>)
 8005df2:	4bd6      	ldr	r3, [pc, #856]	; (800614c <mc_arc+0x4b8>)
 8005df4:	f7fb f966 	bl	80010c4 <__aeabi_dadd>
 8005df8:	0003      	movs	r3, r0
 8005dfa:	000c      	movs	r4, r1
 8005dfc:	0018      	movs	r0, r3
 8005dfe:	0021      	movs	r1, r4
 8005e00:	f7fc fc8e 	bl	8002720 <__aeabi_d2f>
 8005e04:	1c03      	adds	r3, r0, #0
 8005e06:	647b      	str	r3, [r7, #68]	; 0x44

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = (uint16_t)floorf(fabsf(0.5f*angular_travel*radius) /
 8005e08:	21fc      	movs	r1, #252	; 0xfc
 8005e0a:	0589      	lsls	r1, r1, #22
 8005e0c:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8005e0e:	f7fa fdff 	bl	8000a10 <__aeabi_fmul>
 8005e12:	1c03      	adds	r3, r0, #0
 8005e14:	6e39      	ldr	r1, [r7, #96]	; 0x60
 8005e16:	1c18      	adds	r0, r3, #0
 8005e18:	f7fa fdfa 	bl	8000a10 <__aeabi_fmul>
 8005e1c:	1c03      	adds	r3, r0, #0
 8005e1e:	005b      	lsls	r3, r3, #1
 8005e20:	085c      	lsrs	r4, r3, #1
                          sqrtf(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
 8005e22:	4bcc      	ldr	r3, [pc, #816]	; (8006154 <mc_arc+0x4c0>)
 8005e24:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 8005e26:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8005e28:	1c19      	adds	r1, r3, #0
 8005e2a:	1c18      	adds	r0, r3, #0
 8005e2c:	f7fa fab0 	bl	8000390 <__aeabi_fadd>
 8005e30:	1c03      	adds	r3, r0, #0
 8005e32:	1c1a      	adds	r2, r3, #0
 8005e34:	4bc7      	ldr	r3, [pc, #796]	; (8006154 <mc_arc+0x4c0>)
 8005e36:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8005e38:	1c19      	adds	r1, r3, #0
 8005e3a:	1c10      	adds	r0, r2, #0
 8005e3c:	f7fa fefc 	bl	8000c38 <__aeabi_fsub>
 8005e40:	1c03      	adds	r3, r0, #0
 8005e42:	1c19      	adds	r1, r3, #0
 8005e44:	1c28      	adds	r0, r5, #0
 8005e46:	f7fa fde3 	bl	8000a10 <__aeabi_fmul>
 8005e4a:	1c03      	adds	r3, r0, #0
 8005e4c:	1c18      	adds	r0, r3, #0
 8005e4e:	f006 faeb 	bl	800c428 <sqrtf>
 8005e52:	1c03      	adds	r3, r0, #0

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = (uint16_t)floorf(fabsf(0.5f*angular_travel*radius) /
 8005e54:	1c19      	adds	r1, r3, #0
 8005e56:	1c20      	adds	r0, r4, #0
 8005e58:	f7fa fc10 	bl	800067c <__aeabi_fdiv>
 8005e5c:	1c03      	adds	r3, r0, #0
 8005e5e:	1c18      	adds	r0, r3, #0
 8005e60:	f006 fa42 	bl	800c2e8 <floorf>
 8005e64:	1c03      	adds	r3, r0, #0
 8005e66:	222e      	movs	r2, #46	; 0x2e
 8005e68:	18bc      	adds	r4, r7, r2
 8005e6a:	1c18      	adds	r0, r3, #0
 8005e6c:	f7fa fa5a 	bl	8000324 <__aeabi_f2uiz>
 8005e70:	0003      	movs	r3, r0
 8005e72:	8023      	strh	r3, [r4, #0]
                          sqrtf(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );

  if (segments) {
 8005e74:	232e      	movs	r3, #46	; 0x2e
 8005e76:	18fb      	adds	r3, r7, r3
 8005e78:	881b      	ldrh	r3, [r3, #0]
 8005e7a:	2b00      	cmp	r3, #0
 8005e7c:	d100      	bne.n	8005e80 <mc_arc+0x1ec>
 8005e7e:	e158      	b.n	8006132 <mc_arc+0x49e>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of
    // all segments.
    if (pl_data->condition & PL_COND_FLAG_INVERSE_TIME) { 
 8005e80:	68bb      	ldr	r3, [r7, #8]
 8005e82:	7a1b      	ldrb	r3, [r3, #8]
 8005e84:	001a      	movs	r2, r3
 8005e86:	2308      	movs	r3, #8
 8005e88:	4013      	ands	r3, r2
 8005e8a:	d017      	beq.n	8005ebc <mc_arc+0x228>
      pl_data->feed_rate *= segments; 
 8005e8c:	68bb      	ldr	r3, [r7, #8]
 8005e8e:	681c      	ldr	r4, [r3, #0]
 8005e90:	232e      	movs	r3, #46	; 0x2e
 8005e92:	18fb      	adds	r3, r7, r3
 8005e94:	881b      	ldrh	r3, [r3, #0]
 8005e96:	0018      	movs	r0, r3
 8005e98:	f7fb f88e 	bl	8000fb8 <__aeabi_i2f>
 8005e9c:	1c03      	adds	r3, r0, #0
 8005e9e:	1c19      	adds	r1, r3, #0
 8005ea0:	1c20      	adds	r0, r4, #0
 8005ea2:	f7fa fdb5 	bl	8000a10 <__aeabi_fmul>
 8005ea6:	1c03      	adds	r3, r0, #0
 8005ea8:	1c1a      	adds	r2, r3, #0
 8005eaa:	68bb      	ldr	r3, [r7, #8]
 8005eac:	601a      	str	r2, [r3, #0]
      bit_false(pl_data->condition,PL_COND_FLAG_INVERSE_TIME); // Force as feed absolute mode over arc segments.
 8005eae:	68bb      	ldr	r3, [r7, #8]
 8005eb0:	7a1b      	ldrb	r3, [r3, #8]
 8005eb2:	2208      	movs	r2, #8
 8005eb4:	4393      	bics	r3, r2
 8005eb6:	b2da      	uxtb	r2, r3
 8005eb8:	68bb      	ldr	r3, [r7, #8]
 8005eba:	721a      	strb	r2, [r3, #8]
    }
    
    float theta_per_segment = angular_travel/segments;
 8005ebc:	232e      	movs	r3, #46	; 0x2e
 8005ebe:	18fb      	adds	r3, r7, r3
 8005ec0:	881b      	ldrh	r3, [r3, #0]
 8005ec2:	0018      	movs	r0, r3
 8005ec4:	f7fb f878 	bl	8000fb8 <__aeabi_i2f>
 8005ec8:	1c03      	adds	r3, r0, #0
 8005eca:	1c19      	adds	r1, r3, #0
 8005ecc:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8005ece:	f7fa fbd5 	bl	800067c <__aeabi_fdiv>
 8005ed2:	1c03      	adds	r3, r0, #0
 8005ed4:	62bb      	str	r3, [r7, #40]	; 0x28
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
 8005ed6:	236c      	movs	r3, #108	; 0x6c
 8005ed8:	18fb      	adds	r3, r7, r3
 8005eda:	781b      	ldrb	r3, [r3, #0]
 8005edc:	009b      	lsls	r3, r3, #2
 8005ede:	68fa      	ldr	r2, [r7, #12]
 8005ee0:	18d3      	adds	r3, r2, r3
 8005ee2:	6818      	ldr	r0, [r3, #0]
 8005ee4:	236c      	movs	r3, #108	; 0x6c
 8005ee6:	18fb      	adds	r3, r7, r3
 8005ee8:	781b      	ldrb	r3, [r3, #0]
 8005eea:	009b      	lsls	r3, r3, #2
 8005eec:	687a      	ldr	r2, [r7, #4]
 8005eee:	18d3      	adds	r3, r2, r3
 8005ef0:	681b      	ldr	r3, [r3, #0]
 8005ef2:	1c19      	adds	r1, r3, #0
 8005ef4:	f7fa fea0 	bl	8000c38 <__aeabi_fsub>
 8005ef8:	1c03      	adds	r3, r0, #0
 8005efa:	1c1c      	adds	r4, r3, #0
 8005efc:	232e      	movs	r3, #46	; 0x2e
 8005efe:	18fb      	adds	r3, r7, r3
 8005f00:	881b      	ldrh	r3, [r3, #0]
 8005f02:	0018      	movs	r0, r3
 8005f04:	f7fb f858 	bl	8000fb8 <__aeabi_i2f>
 8005f08:	1c03      	adds	r3, r0, #0
 8005f0a:	1c19      	adds	r1, r3, #0
 8005f0c:	1c20      	adds	r0, r4, #0
 8005f0e:	f7fa fbb5 	bl	800067c <__aeabi_fdiv>
 8005f12:	1c03      	adds	r3, r0, #0
 8005f14:	627b      	str	r3, [r7, #36]	; 0x24
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead.
       This is important when there are successive arc motions.
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0f - theta_per_segment*theta_per_segment;
 8005f16:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8005f18:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8005f1a:	f7fa fd79 	bl	8000a10 <__aeabi_fmul>
 8005f1e:	1c03      	adds	r3, r0, #0
 8005f20:	1c19      	adds	r1, r3, #0
 8005f22:	2080      	movs	r0, #128	; 0x80
 8005f24:	05c0      	lsls	r0, r0, #23
 8005f26:	f7fa fe87 	bl	8000c38 <__aeabi_fsub>
 8005f2a:	1c03      	adds	r3, r0, #0
 8005f2c:	623b      	str	r3, [r7, #32]
    float sin_T = theta_per_segment*0.16666667f*(cos_T + 4.0f);
 8005f2e:	498a      	ldr	r1, [pc, #552]	; (8006158 <mc_arc+0x4c4>)
 8005f30:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8005f32:	f7fa fd6d 	bl	8000a10 <__aeabi_fmul>
 8005f36:	1c03      	adds	r3, r0, #0
 8005f38:	1c1c      	adds	r4, r3, #0
 8005f3a:	2181      	movs	r1, #129	; 0x81
 8005f3c:	05c9      	lsls	r1, r1, #23
 8005f3e:	6a38      	ldr	r0, [r7, #32]
 8005f40:	f7fa fa26 	bl	8000390 <__aeabi_fadd>
 8005f44:	1c03      	adds	r3, r0, #0
 8005f46:	1c19      	adds	r1, r3, #0
 8005f48:	1c20      	adds	r0, r4, #0
 8005f4a:	f7fa fd61 	bl	8000a10 <__aeabi_fmul>
 8005f4e:	1c03      	adds	r3, r0, #0
 8005f50:	61fb      	str	r3, [r7, #28]
    cos_T *= 0.5;
 8005f52:	21fc      	movs	r1, #252	; 0xfc
 8005f54:	0589      	lsls	r1, r1, #22
 8005f56:	6a38      	ldr	r0, [r7, #32]
 8005f58:	f7fa fd5a 	bl	8000a10 <__aeabi_fmul>
 8005f5c:	1c03      	adds	r3, r0, #0
 8005f5e:	623b      	str	r3, [r7, #32]

    float sin_Ti;
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
 8005f60:	2341      	movs	r3, #65	; 0x41
 8005f62:	18fb      	adds	r3, r7, r3
 8005f64:	2200      	movs	r2, #0
 8005f66:	701a      	strb	r2, [r3, #0]

    for (i = 1; i<segments; i++) { // Increment (segments-1).
 8005f68:	2342      	movs	r3, #66	; 0x42
 8005f6a:	18fb      	adds	r3, r7, r3
 8005f6c:	2201      	movs	r2, #1
 8005f6e:	801a      	strh	r2, [r3, #0]
 8005f70:	e0d6      	b.n	8006120 <mc_arc+0x48c>

      if (count < N_ARC_CORRECTION) {
 8005f72:	2341      	movs	r3, #65	; 0x41
 8005f74:	18fb      	adds	r3, r7, r3
 8005f76:	781b      	ldrb	r3, [r3, #0]
 8005f78:	2b0b      	cmp	r3, #11
 8005f7a:	d82b      	bhi.n	8005fd4 <mc_arc+0x340>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
 8005f7c:	69f9      	ldr	r1, [r7, #28]
 8005f7e:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8005f80:	f7fa fd46 	bl	8000a10 <__aeabi_fmul>
 8005f84:	1c03      	adds	r3, r0, #0
 8005f86:	1c1c      	adds	r4, r3, #0
 8005f88:	6a39      	ldr	r1, [r7, #32]
 8005f8a:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8005f8c:	f7fa fd40 	bl	8000a10 <__aeabi_fmul>
 8005f90:	1c03      	adds	r3, r0, #0
 8005f92:	1c19      	adds	r1, r3, #0
 8005f94:	1c20      	adds	r0, r4, #0
 8005f96:	f7fa f9fb 	bl	8000390 <__aeabi_fadd>
 8005f9a:	1c03      	adds	r3, r0, #0
 8005f9c:	61bb      	str	r3, [r7, #24]
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
 8005f9e:	6a39      	ldr	r1, [r7, #32]
 8005fa0:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8005fa2:	f7fa fd35 	bl	8000a10 <__aeabi_fmul>
 8005fa6:	1c03      	adds	r3, r0, #0
 8005fa8:	1c1c      	adds	r4, r3, #0
 8005faa:	69f9      	ldr	r1, [r7, #28]
 8005fac:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8005fae:	f7fa fd2f 	bl	8000a10 <__aeabi_fmul>
 8005fb2:	1c03      	adds	r3, r0, #0
 8005fb4:	1c19      	adds	r1, r3, #0
 8005fb6:	1c20      	adds	r0, r4, #0
 8005fb8:	f7fa fe3e 	bl	8000c38 <__aeabi_fsub>
 8005fbc:	1c03      	adds	r3, r0, #0
 8005fbe:	64fb      	str	r3, [r7, #76]	; 0x4c
        r_axis1 = r_axisi;
 8005fc0:	69bb      	ldr	r3, [r7, #24]
 8005fc2:	64bb      	str	r3, [r7, #72]	; 0x48
        count++;
 8005fc4:	2341      	movs	r3, #65	; 0x41
 8005fc6:	18fb      	adds	r3, r7, r3
 8005fc8:	781a      	ldrb	r2, [r3, #0]
 8005fca:	2341      	movs	r3, #65	; 0x41
 8005fcc:	18fb      	adds	r3, r7, r3
 8005fce:	3201      	adds	r2, #1
 8005fd0:	701a      	strb	r2, [r3, #0]
 8005fd2:	e069      	b.n	80060a8 <mc_arc+0x414>
      } else {
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cosf(i*theta_per_segment);
 8005fd4:	2342      	movs	r3, #66	; 0x42
 8005fd6:	18fb      	adds	r3, r7, r3
 8005fd8:	881b      	ldrh	r3, [r3, #0]
 8005fda:	0018      	movs	r0, r3
 8005fdc:	f7fa ffec 	bl	8000fb8 <__aeabi_i2f>
 8005fe0:	1c03      	adds	r3, r0, #0
 8005fe2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8005fe4:	1c18      	adds	r0, r3, #0
 8005fe6:	f7fa fd13 	bl	8000a10 <__aeabi_fmul>
 8005fea:	1c03      	adds	r3, r0, #0
 8005fec:	1c18      	adds	r0, r3, #0
 8005fee:	f006 f945 	bl	800c27c <cosf>
 8005ff2:	1c03      	adds	r3, r0, #0
 8005ff4:	617b      	str	r3, [r7, #20]
        sin_Ti = sinf(i*theta_per_segment);
 8005ff6:	2342      	movs	r3, #66	; 0x42
 8005ff8:	18fb      	adds	r3, r7, r3
 8005ffa:	881b      	ldrh	r3, [r3, #0]
 8005ffc:	0018      	movs	r0, r3
 8005ffe:	f7fa ffdb 	bl	8000fb8 <__aeabi_i2f>
 8006002:	1c03      	adds	r3, r0, #0
 8006004:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8006006:	1c18      	adds	r0, r3, #0
 8006008:	f7fa fd02 	bl	8000a10 <__aeabi_fmul>
 800600c:	1c03      	adds	r3, r0, #0
 800600e:	1c18      	adds	r0, r3, #0
 8006010:	f006 f9ce 	bl	800c3b0 <sinf>
 8006014:	1c03      	adds	r3, r0, #0
 8006016:	613b      	str	r3, [r7, #16]
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
 8006018:	2364      	movs	r3, #100	; 0x64
 800601a:	18fb      	adds	r3, r7, r3
 800601c:	781b      	ldrb	r3, [r3, #0]
 800601e:	009b      	lsls	r3, r3, #2
 8006020:	683a      	ldr	r2, [r7, #0]
 8006022:	18d3      	adds	r3, r2, r3
 8006024:	681b      	ldr	r3, [r3, #0]
 8006026:	2280      	movs	r2, #128	; 0x80
 8006028:	0612      	lsls	r2, r2, #24
 800602a:	4053      	eors	r3, r2
 800602c:	6979      	ldr	r1, [r7, #20]
 800602e:	1c18      	adds	r0, r3, #0
 8006030:	f7fa fcee 	bl	8000a10 <__aeabi_fmul>
 8006034:	1c03      	adds	r3, r0, #0
 8006036:	1c1c      	adds	r4, r3, #0
 8006038:	2368      	movs	r3, #104	; 0x68
 800603a:	18fb      	adds	r3, r7, r3
 800603c:	781b      	ldrb	r3, [r3, #0]
 800603e:	009b      	lsls	r3, r3, #2
 8006040:	683a      	ldr	r2, [r7, #0]
 8006042:	18d3      	adds	r3, r2, r3
 8006044:	681b      	ldr	r3, [r3, #0]
 8006046:	6939      	ldr	r1, [r7, #16]
 8006048:	1c18      	adds	r0, r3, #0
 800604a:	f7fa fce1 	bl	8000a10 <__aeabi_fmul>
 800604e:	1c03      	adds	r3, r0, #0
 8006050:	1c19      	adds	r1, r3, #0
 8006052:	1c20      	adds	r0, r4, #0
 8006054:	f7fa f99c 	bl	8000390 <__aeabi_fadd>
 8006058:	1c03      	adds	r3, r0, #0
 800605a:	64fb      	str	r3, [r7, #76]	; 0x4c
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
 800605c:	2364      	movs	r3, #100	; 0x64
 800605e:	18fb      	adds	r3, r7, r3
 8006060:	781b      	ldrb	r3, [r3, #0]
 8006062:	009b      	lsls	r3, r3, #2
 8006064:	683a      	ldr	r2, [r7, #0]
 8006066:	18d3      	adds	r3, r2, r3
 8006068:	681b      	ldr	r3, [r3, #0]
 800606a:	2280      	movs	r2, #128	; 0x80
 800606c:	0612      	lsls	r2, r2, #24
 800606e:	4053      	eors	r3, r2
 8006070:	6939      	ldr	r1, [r7, #16]
 8006072:	1c18      	adds	r0, r3, #0
 8006074:	f7fa fccc 	bl	8000a10 <__aeabi_fmul>
 8006078:	1c03      	adds	r3, r0, #0
 800607a:	1c1c      	adds	r4, r3, #0
 800607c:	2368      	movs	r3, #104	; 0x68
 800607e:	18fb      	adds	r3, r7, r3
 8006080:	781b      	ldrb	r3, [r3, #0]
 8006082:	009b      	lsls	r3, r3, #2
 8006084:	683a      	ldr	r2, [r7, #0]
 8006086:	18d3      	adds	r3, r2, r3
 8006088:	681b      	ldr	r3, [r3, #0]
 800608a:	6979      	ldr	r1, [r7, #20]
 800608c:	1c18      	adds	r0, r3, #0
 800608e:	f7fa fcbf 	bl	8000a10 <__aeabi_fmul>
 8006092:	1c03      	adds	r3, r0, #0
 8006094:	1c19      	adds	r1, r3, #0
 8006096:	1c20      	adds	r0, r4, #0
 8006098:	f7fa fdce 	bl	8000c38 <__aeabi_fsub>
 800609c:	1c03      	adds	r3, r0, #0
 800609e:	64bb      	str	r3, [r7, #72]	; 0x48
        count = 0;
 80060a0:	2341      	movs	r3, #65	; 0x41
 80060a2:	18fb      	adds	r3, r7, r3
 80060a4:	2200      	movs	r2, #0
 80060a6:	701a      	strb	r2, [r3, #0]
      }

      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
 80060a8:	2364      	movs	r3, #100	; 0x64
 80060aa:	18fb      	adds	r3, r7, r3
 80060ac:	781b      	ldrb	r3, [r3, #0]
 80060ae:	009b      	lsls	r3, r3, #2
 80060b0:	687a      	ldr	r2, [r7, #4]
 80060b2:	18d4      	adds	r4, r2, r3
 80060b4:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80060b6:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80060b8:	f7fa f96a 	bl	8000390 <__aeabi_fadd>
 80060bc:	1c03      	adds	r3, r0, #0
 80060be:	6023      	str	r3, [r4, #0]
      position[axis_1] = center_axis1 + r_axis1;
 80060c0:	2368      	movs	r3, #104	; 0x68
 80060c2:	18fb      	adds	r3, r7, r3
 80060c4:	781b      	ldrb	r3, [r3, #0]
 80060c6:	009b      	lsls	r3, r3, #2
 80060c8:	687a      	ldr	r2, [r7, #4]
 80060ca:	18d4      	adds	r4, r2, r3
 80060cc:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 80060ce:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80060d0:	f7fa f95e 	bl	8000390 <__aeabi_fadd>
 80060d4:	1c03      	adds	r3, r0, #0
 80060d6:	6023      	str	r3, [r4, #0]
      position[axis_linear] += linear_per_segment;
 80060d8:	236c      	movs	r3, #108	; 0x6c
 80060da:	18fb      	adds	r3, r7, r3
 80060dc:	781b      	ldrb	r3, [r3, #0]
 80060de:	009b      	lsls	r3, r3, #2
 80060e0:	687a      	ldr	r2, [r7, #4]
 80060e2:	18d4      	adds	r4, r2, r3
 80060e4:	236c      	movs	r3, #108	; 0x6c
 80060e6:	18fb      	adds	r3, r7, r3
 80060e8:	781b      	ldrb	r3, [r3, #0]
 80060ea:	009b      	lsls	r3, r3, #2
 80060ec:	687a      	ldr	r2, [r7, #4]
 80060ee:	18d3      	adds	r3, r2, r3
 80060f0:	681b      	ldr	r3, [r3, #0]
 80060f2:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80060f4:	1c18      	adds	r0, r3, #0
 80060f6:	f7fa f94b 	bl	8000390 <__aeabi_fadd>
 80060fa:	1c03      	adds	r3, r0, #0
 80060fc:	6023      	str	r3, [r4, #0]

      mc_line(position, pl_data);
 80060fe:	68ba      	ldr	r2, [r7, #8]
 8006100:	687b      	ldr	r3, [r7, #4]
 8006102:	0011      	movs	r1, r2
 8006104:	0018      	movs	r0, r3
 8006106:	f7ff fd79 	bl	8005bfc <mc_line>

      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
 800610a:	4b14      	ldr	r3, [pc, #80]	; (800615c <mc_arc+0x4c8>)
 800610c:	785b      	ldrb	r3, [r3, #1]
 800610e:	2b00      	cmp	r3, #0
 8006110:	d126      	bne.n	8006160 <mc_arc+0x4cc>
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;

    for (i = 1; i<segments; i++) { // Increment (segments-1).
 8006112:	2342      	movs	r3, #66	; 0x42
 8006114:	18fb      	adds	r3, r7, r3
 8006116:	881a      	ldrh	r2, [r3, #0]
 8006118:	2342      	movs	r3, #66	; 0x42
 800611a:	18fb      	adds	r3, r7, r3
 800611c:	3201      	adds	r2, #1
 800611e:	801a      	strh	r2, [r3, #0]
 8006120:	2342      	movs	r3, #66	; 0x42
 8006122:	18fa      	adds	r2, r7, r3
 8006124:	232e      	movs	r3, #46	; 0x2e
 8006126:	18fb      	adds	r3, r7, r3
 8006128:	8812      	ldrh	r2, [r2, #0]
 800612a:	881b      	ldrh	r3, [r3, #0]
 800612c:	429a      	cmp	r2, r3
 800612e:	d200      	bcs.n	8006132 <mc_arc+0x49e>
 8006130:	e71f      	b.n	8005f72 <mc_arc+0x2de>
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    }
  }
  // Ensure last segment arrives at target location.
  mc_line(target, pl_data);
 8006132:	68ba      	ldr	r2, [r7, #8]
 8006134:	68fb      	ldr	r3, [r7, #12]
 8006136:	0011      	movs	r1, r2
 8006138:	0018      	movs	r0, r3
 800613a:	f7ff fd5f 	bl	8005bfc <mc_line>
 800613e:	e010      	b.n	8006162 <mc_arc+0x4ce>
 8006140:	a0b5ed8d 	.word	0xa0b5ed8d
 8006144:	bea0c6f7 	.word	0xbea0c6f7
 8006148:	54442d18 	.word	0x54442d18
 800614c:	401921fb 	.word	0x401921fb
 8006150:	3ea0c6f7 	.word	0x3ea0c6f7
 8006154:	20000acc 	.word	0x20000acc
 8006158:	3e2aaaab 	.word	0x3e2aaaab
 800615c:	20000b2c 	.word	0x20000b2c
      position[axis_linear] += linear_per_segment;

      mc_line(position, pl_data);

      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
 8006160:	46c0      	nop			; (mov r8, r8)
    }
  }
  // Ensure last segment arrives at target location.
  mc_line(target, pl_data);
}
 8006162:	46bd      	mov	sp, r7
 8006164:	b014      	add	sp, #80	; 0x50
 8006166:	bdb0      	pop	{r4, r5, r7, pc}

08006168 <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds)
{
 8006168:	b580      	push	{r7, lr}
 800616a:	b082      	sub	sp, #8
 800616c:	af00      	add	r7, sp, #0
 800616e:	6078      	str	r0, [r7, #4]
  if (sys.state == STATE_CHECK_MODE) { return; }
 8006170:	4b07      	ldr	r3, [pc, #28]	; (8006190 <mc_dwell+0x28>)
 8006172:	781b      	ldrb	r3, [r3, #0]
 8006174:	2b02      	cmp	r3, #2
 8006176:	d007      	beq.n	8006188 <mc_dwell+0x20>
  protocol_buffer_synchronize();
 8006178:	f001 fbb0 	bl	80078dc <protocol_buffer_synchronize>
  delay_sec(seconds, DELAY_MODE_DWELL);
 800617c:	687b      	ldr	r3, [r7, #4]
 800617e:	2100      	movs	r1, #0
 8006180:	1c18      	adds	r0, r3, #0
 8006182:	f000 f9ed 	bl	8006560 <delay_sec>
 8006186:	e000      	b.n	800618a <mc_dwell+0x22>


// Execute dwell in seconds.
void mc_dwell(float seconds)
{
  if (sys.state == STATE_CHECK_MODE) { return; }
 8006188:	46c0      	nop			; (mov r8, r8)
  protocol_buffer_synchronize();
  delay_sec(seconds, DELAY_MODE_DWELL);
}
 800618a:	46bd      	mov	sp, r7
 800618c:	b002      	add	sp, #8
 800618e:	bd80      	pop	{r7, pc}
 8006190:	20000b2c 	.word	0x20000b2c

08006194 <mc_homing_cycle>:

// Perform homing cycle to locate and set machine zero. Only '$H' executes this command.
// NOTE: There should be no motions in the buffer and Grbl must be in an idle state before
// executing the homing cycle. This prevents incorrect buffered plans after homing.
void mc_homing_cycle(uint8_t cycle_mask)
{
 8006194:	b580      	push	{r7, lr}
 8006196:	b082      	sub	sp, #8
 8006198:	af00      	add	r7, sp, #0
 800619a:	0002      	movs	r2, r0
 800619c:	1dfb      	adds	r3, r7, #7
 800619e:	701a      	strb	r2, [r3, #0]
      system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT);
      return;
    }
  #endif

  limits_disable(); // Disable hard limits pin change register for cycle duration
 80061a0:	f7ff fa38 	bl	8005614 <limits_disable>
    if (cycle_mask) { limits_go_home(cycle_mask); } // Perform homing cycle based on mask.
    else
  #endif
  {
    // Search to engage all axes limit switches at faster homing seek rate.
    limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
 80061a4:	2004      	movs	r0, #4
 80061a6:	f7ff fa8d 	bl	80056c4 <limits_go_home>
    #ifdef HOMING_CYCLE_1
      limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
 80061aa:	2003      	movs	r0, #3
 80061ac:	f7ff fa8a 	bl	80056c4 <limits_go_home>
    #ifdef HOMING_CYCLE_2
      limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
    #endif
  }

  protocol_execute_realtime(); // Check for reset and set system abort.
 80061b0:	f001 fbb8 	bl	8007924 <protocol_execute_realtime>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
 80061b4:	4b07      	ldr	r3, [pc, #28]	; (80061d4 <mc_homing_cycle+0x40>)
 80061b6:	785b      	ldrb	r3, [r3, #1]
 80061b8:	2b00      	cmp	r3, #0
 80061ba:	d106      	bne.n	80061ca <mc_homing_cycle+0x36>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Sync gcode parser and planner positions to homed position.
  gc_sync_position();
 80061bc:	f7fd fc34 	bl	8003a28 <gc_sync_position>
  plan_sync_position();
 80061c0:	f001 f818 	bl	80071f4 <plan_sync_position>

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
 80061c4:	f7ff f9c0 	bl	8005548 <limits_init>
 80061c8:	e000      	b.n	80061cc <mc_homing_cycle+0x38>
      limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
    #endif
  }

  protocol_execute_realtime(); // Check for reset and set system abort.
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
 80061ca:	46c0      	nop			; (mov r8, r8)
  gc_sync_position();
  plan_sync_position();

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
}
 80061cc:	46bd      	mov	sp, r7
 80061ce:	b002      	add	sp, #8
 80061d0:	bd80      	pop	{r7, pc}
 80061d2:	46c0      	nop			; (mov r8, r8)
 80061d4:	20000b2c 	.word	0x20000b2c

080061d8 <mc_probe_cycle>:


// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
 80061d8:	b590      	push	{r4, r7, lr}
 80061da:	b087      	sub	sp, #28
 80061dc:	af00      	add	r7, sp, #0
 80061de:	60f8      	str	r0, [r7, #12]
 80061e0:	60b9      	str	r1, [r7, #8]
 80061e2:	1dfb      	adds	r3, r7, #7
 80061e4:	701a      	strb	r2, [r3, #0]
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
 80061e6:	4b41      	ldr	r3, [pc, #260]	; (80062ec <mc_probe_cycle+0x114>)
 80061e8:	781b      	ldrb	r3, [r3, #0]
 80061ea:	2b02      	cmp	r3, #2
 80061ec:	d101      	bne.n	80061f2 <mc_probe_cycle+0x1a>
 80061ee:	2300      	movs	r3, #0
 80061f0:	e077      	b.n	80062e2 <mc_probe_cycle+0x10a>

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
 80061f2:	f001 fb73 	bl	80078dc <protocol_buffer_synchronize>
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
 80061f6:	4b3d      	ldr	r3, [pc, #244]	; (80062ec <mc_probe_cycle+0x114>)
 80061f8:	785b      	ldrb	r3, [r3, #1]
 80061fa:	2b00      	cmp	r3, #0
 80061fc:	d001      	beq.n	8006202 <mc_probe_cycle+0x2a>
 80061fe:	2302      	movs	r3, #2
 8006200:	e06f      	b.n	80062e2 <mc_probe_cycle+0x10a>

  // Initialize probing control variables
  uint8_t is_probe_away = bit_istrue(parser_flags, GC_PARSER_PROBE_IS_AWAY);
 8006202:	1dfb      	adds	r3, r7, #7
 8006204:	781b      	ldrb	r3, [r3, #0]
 8006206:	2208      	movs	r2, #8
 8006208:	4013      	ands	r3, r2
 800620a:	1e5a      	subs	r2, r3, #1
 800620c:	4193      	sbcs	r3, r2
 800620e:	b2da      	uxtb	r2, r3
 8006210:	2317      	movs	r3, #23
 8006212:	18fb      	adds	r3, r7, r3
 8006214:	701a      	strb	r2, [r3, #0]
  uint8_t is_no_error = bit_istrue(parser_flags, GC_PARSER_PROBE_IS_NO_ERROR);
 8006216:	1dfb      	adds	r3, r7, #7
 8006218:	781b      	ldrb	r3, [r3, #0]
 800621a:	2210      	movs	r2, #16
 800621c:	4013      	ands	r3, r2
 800621e:	1e5a      	subs	r2, r3, #1
 8006220:	4193      	sbcs	r3, r2
 8006222:	b2da      	uxtb	r2, r3
 8006224:	2316      	movs	r3, #22
 8006226:	18fb      	adds	r3, r7, r3
 8006228:	701a      	strb	r2, [r3, #0]
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.
 800622a:	4b30      	ldr	r3, [pc, #192]	; (80062ec <mc_probe_cycle+0x114>)
 800622c:	2200      	movs	r2, #0
 800622e:	715a      	strb	r2, [r3, #5]
  probe_configure_invert_mask(is_probe_away);
 8006230:	2317      	movs	r3, #23
 8006232:	18fb      	adds	r3, r7, r3
 8006234:	781b      	ldrb	r3, [r3, #0]
 8006236:	0018      	movs	r0, r3
 8006238:	f001 f9c6 	bl	80075c8 <probe_configure_invert_mask>

  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
 800623c:	f001 f9e8 	bl	8007610 <probe_get_state>
 8006240:	1e03      	subs	r3, r0, #0
 8006242:	d009      	beq.n	8006258 <mc_probe_cycle+0x80>
    system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_INITIAL);
 8006244:	2004      	movs	r0, #4
 8006246:	f005 fc09 	bl	800ba5c <system_set_exec_alarm>
    protocol_execute_realtime();
 800624a:	f001 fb6b 	bl	8007924 <protocol_execute_realtime>
    probe_configure_invert_mask(false); // Re-initialize invert mask before returning.
 800624e:	2000      	movs	r0, #0
 8006250:	f001 f9ba 	bl	80075c8 <probe_configure_invert_mask>
    return(GC_PROBE_FAIL_INIT); // Nothing else to do but bail.
 8006254:	2302      	movs	r3, #2
 8006256:	e044      	b.n	80062e2 <mc_probe_cycle+0x10a>
  }

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  mc_line(target, pl_data);
 8006258:	68ba      	ldr	r2, [r7, #8]
 800625a:	68fb      	ldr	r3, [r7, #12]
 800625c:	0011      	movs	r1, r2
 800625e:	0018      	movs	r0, r3
 8006260:	f7ff fccc 	bl	8005bfc <mc_line>

  // Activate the probing state monitor in the stepper module.
  sys_probe_state = PROBE_ACTIVE;
 8006264:	4b22      	ldr	r3, [pc, #136]	; (80062f0 <mc_probe_cycle+0x118>)
 8006266:	2201      	movs	r2, #1
 8006268:	701a      	strb	r2, [r3, #0]

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
 800626a:	2002      	movs	r0, #2
 800626c:	f005 fbc2 	bl	800b9f4 <system_set_exec_state_flag>
  do {
    protocol_execute_realtime();
 8006270:	f001 fb58 	bl	8007924 <protocol_execute_realtime>
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
 8006274:	4b1d      	ldr	r3, [pc, #116]	; (80062ec <mc_probe_cycle+0x114>)
 8006276:	785b      	ldrb	r3, [r3, #1]
 8006278:	2b00      	cmp	r3, #0
 800627a:	d001      	beq.n	8006280 <mc_probe_cycle+0xa8>
 800627c:	2302      	movs	r3, #2
 800627e:	e030      	b.n	80062e2 <mc_probe_cycle+0x10a>
  } while (sys.state != STATE_IDLE);
 8006280:	4b1a      	ldr	r3, [pc, #104]	; (80062ec <mc_probe_cycle+0x114>)
 8006282:	781b      	ldrb	r3, [r3, #0]
 8006284:	2b00      	cmp	r3, #0
 8006286:	d1f3      	bne.n	8006270 <mc_probe_cycle+0x98>

  // Probing cycle complete!

  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys_probe_state == PROBE_ACTIVE) {
 8006288:	4b19      	ldr	r3, [pc, #100]	; (80062f0 <mc_probe_cycle+0x118>)
 800628a:	781b      	ldrb	r3, [r3, #0]
 800628c:	b2db      	uxtb	r3, r3
 800628e:	2b01      	cmp	r3, #1
 8006290:	d10d      	bne.n	80062ae <mc_probe_cycle+0xd6>
    if (is_no_error) { memcpy(sys_probe_position, sys_position, sizeof(sys_position)); }
 8006292:	2316      	movs	r3, #22
 8006294:	18fb      	adds	r3, r7, r3
 8006296:	781b      	ldrb	r3, [r3, #0]
 8006298:	2b00      	cmp	r3, #0
 800629a:	d004      	beq.n	80062a6 <mc_probe_cycle+0xce>
 800629c:	4b15      	ldr	r3, [pc, #84]	; (80062f4 <mc_probe_cycle+0x11c>)
 800629e:	4a16      	ldr	r2, [pc, #88]	; (80062f8 <mc_probe_cycle+0x120>)
 80062a0:	ca13      	ldmia	r2!, {r0, r1, r4}
 80062a2:	c313      	stmia	r3!, {r0, r1, r4}
 80062a4:	e006      	b.n	80062b4 <mc_probe_cycle+0xdc>
    else { system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_CONTACT); }
 80062a6:	2005      	movs	r0, #5
 80062a8:	f005 fbd8 	bl	800ba5c <system_set_exec_alarm>
 80062ac:	e002      	b.n	80062b4 <mc_probe_cycle+0xdc>
  } else {
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
 80062ae:	4b0f      	ldr	r3, [pc, #60]	; (80062ec <mc_probe_cycle+0x114>)
 80062b0:	2201      	movs	r2, #1
 80062b2:	715a      	strb	r2, [r3, #5]
  }
  sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
 80062b4:	4b0e      	ldr	r3, [pc, #56]	; (80062f0 <mc_probe_cycle+0x118>)
 80062b6:	2200      	movs	r2, #0
 80062b8:	701a      	strb	r2, [r3, #0]
  probe_configure_invert_mask(false); // Re-initialize invert mask.
 80062ba:	2000      	movs	r0, #0
 80062bc:	f001 f984 	bl	80075c8 <probe_configure_invert_mask>
  protocol_execute_realtime();   // Check and execute run-time commands
 80062c0:	f001 fb30 	bl	8007924 <protocol_execute_realtime>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reset step segment buffer.
 80062c4:	f004 f866 	bl	800a394 <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
 80062c8:	f000 fbf4 	bl	8006ab4 <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
 80062cc:	f000 ff92 	bl	80071f4 <plan_sync_position>

  #ifdef MESSAGE_PROBE_COORDINATES
    // All done! Output the probe position as message.
    report_probe_parameters();
 80062d0:	f002 fa48 	bl	8008764 <report_probe_parameters>
  #endif

  if (sys.probe_succeeded) { return(GC_PROBE_FOUND); } // Successful probe cycle.
 80062d4:	4b05      	ldr	r3, [pc, #20]	; (80062ec <mc_probe_cycle+0x114>)
 80062d6:	795b      	ldrb	r3, [r3, #5]
 80062d8:	2b00      	cmp	r3, #0
 80062da:	d001      	beq.n	80062e0 <mc_probe_cycle+0x108>
 80062dc:	2301      	movs	r3, #1
 80062de:	e000      	b.n	80062e2 <mc_probe_cycle+0x10a>
  else { return(GC_PROBE_FAIL_END); } // Failed to trigger probe within travel. With or without error.
 80062e0:	2300      	movs	r3, #0
}
 80062e2:	0018      	movs	r0, r3
 80062e4:	46bd      	mov	sp, r7
 80062e6:	b007      	add	sp, #28
 80062e8:	bd90      	pop	{r4, r7, pc}
 80062ea:	46c0      	nop			; (mov r8, r8)
 80062ec:	20000b2c 	.word	0x20000b2c
 80062f0:	20000b42 	.word	0x20000b42
 80062f4:	20000b44 	.word	0x20000b44
 80062f8:	20000b50 	.word	0x20000b50

080062fc <mc_reset>:
// active processes in the system. This also checks if a system reset is issued while Grbl
// is in a motion state. If so, kills the steppers and sets the system alarm to flag position
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
 80062fc:	b580      	push	{r7, lr}
 80062fe:	af00      	add	r7, sp, #0
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
 8006300:	4b17      	ldr	r3, [pc, #92]	; (8006360 <mc_reset+0x64>)
 8006302:	781b      	ldrb	r3, [r3, #0]
 8006304:	b2db      	uxtb	r3, r3
 8006306:	001a      	movs	r2, r3
 8006308:	2310      	movs	r3, #16
 800630a:	4013      	ands	r3, r2
 800630c:	d124      	bne.n	8006358 <mc_reset+0x5c>
    system_set_exec_state_flag(EXEC_RESET);
 800630e:	2010      	movs	r0, #16
 8006310:	f005 fb70 	bl	800b9f4 <system_set_exec_state_flag>

    // Kill spindle and coolant.
    spindle_stop();
 8006314:	f003 fc3e 	bl	8009b94 <spindle_stop>
    coolant_stop();
 8006318:	f7fd fa80 	bl	800381c <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)) ||
 800631c:	4b11      	ldr	r3, [pc, #68]	; (8006364 <mc_reset+0x68>)
 800631e:	781b      	ldrb	r3, [r3, #0]
 8006320:	001a      	movs	r2, r3
 8006322:	232c      	movs	r3, #44	; 0x2c
 8006324:	4013      	ands	r3, r2
 8006326:	d105      	bne.n	8006334 <mc_reset+0x38>
    		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
 8006328:	4b0e      	ldr	r3, [pc, #56]	; (8006364 <mc_reset+0x68>)
 800632a:	791b      	ldrb	r3, [r3, #4]
 800632c:	001a      	movs	r2, r3
 800632e:	2306      	movs	r3, #6
 8006330:	4013      	ands	r3, r2

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)) ||
 8006332:	d011      	beq.n	8006358 <mc_reset+0x5c>
    		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
      if (sys.state == STATE_HOMING) {
 8006334:	4b0b      	ldr	r3, [pc, #44]	; (8006364 <mc_reset+0x68>)
 8006336:	781b      	ldrb	r3, [r3, #0]
 8006338:	2b04      	cmp	r3, #4
 800633a:	d108      	bne.n	800634e <mc_reset+0x52>
        if (!sys_rt_exec_alarm) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
 800633c:	4b0a      	ldr	r3, [pc, #40]	; (8006368 <mc_reset+0x6c>)
 800633e:	781b      	ldrb	r3, [r3, #0]
 8006340:	b2db      	uxtb	r3, r3
 8006342:	2b00      	cmp	r3, #0
 8006344:	d106      	bne.n	8006354 <mc_reset+0x58>
 8006346:	2006      	movs	r0, #6
 8006348:	f005 fb88 	bl	800ba5c <system_set_exec_alarm>
 800634c:	e002      	b.n	8006354 <mc_reset+0x58>
      }
      else { system_set_exec_alarm(EXEC_ALARM_ABORT_CYCLE); }
 800634e:	2003      	movs	r0, #3
 8006350:	f005 fb84 	bl	800ba5c <system_set_exec_alarm>
      st_go_idle(); // Force kill steppers. Position has likely been lost.
 8006354:	f003 fd80 	bl	8009e58 <st_go_idle>
    }
  }
}
 8006358:	46c0      	nop			; (mov r8, r8)
 800635a:	46bd      	mov	sp, r7
 800635c:	bd80      	pop	{r7, pc}
 800635e:	46c0      	nop			; (mov r8, r8)
 8006360:	20000b41 	.word	0x20000b41
 8006364:	20000b2c 	.word	0x20000b2c
 8006368:	20000b5c 	.word	0x20000b5c

0800636c <read_float>:
// CNC applications, the typical decimal value is expected to be in the range of E0 to E-4.
// Scientific notation is officially not supported by g-code, and the 'E' character may
// be a g-code word on some CNC systems. So, 'E' notation will not be recognized.
// NOTE: Thanks to Radu-Eosif Mihailescu for identifying the issues with using strtod().
uint8_t read_float(char *line, uint8_t *char_counter, float *float_ptr)
{
 800636c:	b580      	push	{r7, lr}
 800636e:	b08c      	sub	sp, #48	; 0x30
 8006370:	af00      	add	r7, sp, #0
 8006372:	60f8      	str	r0, [r7, #12]
 8006374:	60b9      	str	r1, [r7, #8]
 8006376:	607a      	str	r2, [r7, #4]
  char *ptr = line + *char_counter;
 8006378:	68bb      	ldr	r3, [r7, #8]
 800637a:	781b      	ldrb	r3, [r3, #0]
 800637c:	001a      	movs	r2, r3
 800637e:	68fb      	ldr	r3, [r7, #12]
 8006380:	189b      	adds	r3, r3, r2
 8006382:	62fb      	str	r3, [r7, #44]	; 0x2c
  unsigned char c;

  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
 8006384:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006386:	1c5a      	adds	r2, r3, #1
 8006388:	62fa      	str	r2, [r7, #44]	; 0x2c
 800638a:	222b      	movs	r2, #43	; 0x2b
 800638c:	18ba      	adds	r2, r7, r2
 800638e:	781b      	ldrb	r3, [r3, #0]
 8006390:	7013      	strb	r3, [r2, #0]

  // Capture initial positive/minus character
  bool isnegative = false;
 8006392:	2300      	movs	r3, #0
 8006394:	627b      	str	r3, [r7, #36]	; 0x24
  if (c == '-') {
 8006396:	232b      	movs	r3, #43	; 0x2b
 8006398:	18fb      	adds	r3, r7, r3
 800639a:	781b      	ldrb	r3, [r3, #0]
 800639c:	2b2d      	cmp	r3, #45	; 0x2d
 800639e:	d109      	bne.n	80063b4 <read_float+0x48>
    isnegative = true;
 80063a0:	2301      	movs	r3, #1
 80063a2:	627b      	str	r3, [r7, #36]	; 0x24
    c = *ptr++;
 80063a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80063a6:	1c5a      	adds	r2, r3, #1
 80063a8:	62fa      	str	r2, [r7, #44]	; 0x2c
 80063aa:	222b      	movs	r2, #43	; 0x2b
 80063ac:	18ba      	adds	r2, r7, r2
 80063ae:	781b      	ldrb	r3, [r3, #0]
 80063b0:	7013      	strb	r3, [r2, #0]
 80063b2:	e00b      	b.n	80063cc <read_float+0x60>
  } else if (c == '+') {
 80063b4:	232b      	movs	r3, #43	; 0x2b
 80063b6:	18fb      	adds	r3, r7, r3
 80063b8:	781b      	ldrb	r3, [r3, #0]
 80063ba:	2b2b      	cmp	r3, #43	; 0x2b
 80063bc:	d106      	bne.n	80063cc <read_float+0x60>
    c = *ptr++;
 80063be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80063c0:	1c5a      	adds	r2, r3, #1
 80063c2:	62fa      	str	r2, [r7, #44]	; 0x2c
 80063c4:	222b      	movs	r2, #43	; 0x2b
 80063c6:	18ba      	adds	r2, r7, r2
 80063c8:	781b      	ldrb	r3, [r3, #0]
 80063ca:	7013      	strb	r3, [r2, #0]
  }

  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
 80063cc:	2300      	movs	r3, #0
 80063ce:	623b      	str	r3, [r7, #32]
  int8_t exp = 0;
 80063d0:	231f      	movs	r3, #31
 80063d2:	18fb      	adds	r3, r7, r3
 80063d4:	2200      	movs	r2, #0
 80063d6:	701a      	strb	r2, [r3, #0]
  uint8_t ndigit = 0;
 80063d8:	231e      	movs	r3, #30
 80063da:	18fb      	adds	r3, r7, r3
 80063dc:	2200      	movs	r2, #0
 80063de:	701a      	strb	r2, [r3, #0]
  bool isdecimal = false;
 80063e0:	2300      	movs	r3, #0
 80063e2:	61bb      	str	r3, [r7, #24]
  while(1) {
    c -= '0';
 80063e4:	232b      	movs	r3, #43	; 0x2b
 80063e6:	18fb      	adds	r3, r7, r3
 80063e8:	222b      	movs	r2, #43	; 0x2b
 80063ea:	18ba      	adds	r2, r7, r2
 80063ec:	7812      	ldrb	r2, [r2, #0]
 80063ee:	3a30      	subs	r2, #48	; 0x30
 80063f0:	701a      	strb	r2, [r3, #0]
    if (c <= 9) {
 80063f2:	232b      	movs	r3, #43	; 0x2b
 80063f4:	18fb      	adds	r3, r7, r3
 80063f6:	781b      	ldrb	r3, [r3, #0]
 80063f8:	2b09      	cmp	r3, #9
 80063fa:	d831      	bhi.n	8006460 <read_float+0xf4>
      ndigit++;
 80063fc:	231e      	movs	r3, #30
 80063fe:	18fb      	adds	r3, r7, r3
 8006400:	781a      	ldrb	r2, [r3, #0]
 8006402:	231e      	movs	r3, #30
 8006404:	18fb      	adds	r3, r7, r3
 8006406:	3201      	adds	r2, #1
 8006408:	701a      	strb	r2, [r3, #0]
      if (ndigit <= MAX_INT_DIGITS) {
 800640a:	231e      	movs	r3, #30
 800640c:	18fb      	adds	r3, r7, r3
 800640e:	781b      	ldrb	r3, [r3, #0]
 8006410:	2b08      	cmp	r3, #8
 8006412:	d817      	bhi.n	8006444 <read_float+0xd8>
        if (isdecimal) { exp--; }
 8006414:	69bb      	ldr	r3, [r7, #24]
 8006416:	2b00      	cmp	r3, #0
 8006418:	d009      	beq.n	800642e <read_float+0xc2>
 800641a:	231f      	movs	r3, #31
 800641c:	18fb      	adds	r3, r7, r3
 800641e:	781b      	ldrb	r3, [r3, #0]
 8006420:	b25b      	sxtb	r3, r3
 8006422:	b2db      	uxtb	r3, r3
 8006424:	3b01      	subs	r3, #1
 8006426:	b2da      	uxtb	r2, r3
 8006428:	231f      	movs	r3, #31
 800642a:	18fb      	adds	r3, r7, r3
 800642c:	701a      	strb	r2, [r3, #0]
        intval = (((intval << 2) + intval) << 1) + c; // intval*10 + c
 800642e:	6a3b      	ldr	r3, [r7, #32]
 8006430:	009a      	lsls	r2, r3, #2
 8006432:	6a3b      	ldr	r3, [r7, #32]
 8006434:	18d3      	adds	r3, r2, r3
 8006436:	005a      	lsls	r2, r3, #1
 8006438:	232b      	movs	r3, #43	; 0x2b
 800643a:	18fb      	adds	r3, r7, r3
 800643c:	781b      	ldrb	r3, [r3, #0]
 800643e:	18d3      	adds	r3, r2, r3
 8006440:	623b      	str	r3, [r7, #32]
 8006442:	e017      	b.n	8006474 <read_float+0x108>
      } else {
        if (!(isdecimal)) { exp++; }  // Drop overflow digits
 8006444:	69bb      	ldr	r3, [r7, #24]
 8006446:	2b00      	cmp	r3, #0
 8006448:	d114      	bne.n	8006474 <read_float+0x108>
 800644a:	231f      	movs	r3, #31
 800644c:	18fb      	adds	r3, r7, r3
 800644e:	781b      	ldrb	r3, [r3, #0]
 8006450:	b25b      	sxtb	r3, r3
 8006452:	b2db      	uxtb	r3, r3
 8006454:	3301      	adds	r3, #1
 8006456:	b2da      	uxtb	r2, r3
 8006458:	231f      	movs	r3, #31
 800645a:	18fb      	adds	r3, r7, r3
 800645c:	701a      	strb	r2, [r3, #0]
 800645e:	e009      	b.n	8006474 <read_float+0x108>
      }
    } else if (c == (('.'-'0') & 0xff)  &&  !(isdecimal)) {
 8006460:	232b      	movs	r3, #43	; 0x2b
 8006462:	18fb      	adds	r3, r7, r3
 8006464:	781b      	ldrb	r3, [r3, #0]
 8006466:	2bfe      	cmp	r3, #254	; 0xfe
 8006468:	d10c      	bne.n	8006484 <read_float+0x118>
 800646a:	69bb      	ldr	r3, [r7, #24]
 800646c:	2b00      	cmp	r3, #0
 800646e:	d109      	bne.n	8006484 <read_float+0x118>
      isdecimal = true;
 8006470:	2301      	movs	r3, #1
 8006472:	61bb      	str	r3, [r7, #24]
    } else {
      break;
    }
    c = *ptr++;
 8006474:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006476:	1c5a      	adds	r2, r3, #1
 8006478:	62fa      	str	r2, [r7, #44]	; 0x2c
 800647a:	222b      	movs	r2, #43	; 0x2b
 800647c:	18ba      	adds	r2, r7, r2
 800647e:	781b      	ldrb	r3, [r3, #0]
 8006480:	7013      	strb	r3, [r2, #0]
  }
 8006482:	e7af      	b.n	80063e4 <read_float+0x78>

  // Return if no digits have been read.
  if (!ndigit) { return(false); };
 8006484:	231e      	movs	r3, #30
 8006486:	18fb      	adds	r3, r7, r3
 8006488:	781b      	ldrb	r3, [r3, #0]
 800648a:	2b00      	cmp	r3, #0
 800648c:	d101      	bne.n	8006492 <read_float+0x126>
 800648e:	2300      	movs	r3, #0
 8006490:	e05b      	b.n	800654a <read_float+0x1de>

  // Convert integer into floating point.
  float fval;
  fval = (float)intval;
 8006492:	6a38      	ldr	r0, [r7, #32]
 8006494:	f7fa fdd8 	bl	8001048 <__aeabi_ui2f>
 8006498:	1c03      	adds	r3, r0, #0
 800649a:	617b      	str	r3, [r7, #20]

  // Apply decimal. Should perform no more than two floating point multiplications for the
  // expected range of E0 to E-4.
  if (fval != 0) {
 800649c:	2100      	movs	r1, #0
 800649e:	6978      	ldr	r0, [r7, #20]
 80064a0:	f7f9 ff12 	bl	80002c8 <__aeabi_fcmpeq>
 80064a4:	1e03      	subs	r3, r0, #0
 80064a6:	d13a      	bne.n	800651e <read_float+0x1b2>
    while (exp <= -2) {
 80064a8:	e00d      	b.n	80064c6 <read_float+0x15a>
      fval *= 0.01f;
 80064aa:	492a      	ldr	r1, [pc, #168]	; (8006554 <read_float+0x1e8>)
 80064ac:	6978      	ldr	r0, [r7, #20]
 80064ae:	f7fa faaf 	bl	8000a10 <__aeabi_fmul>
 80064b2:	1c03      	adds	r3, r0, #0
 80064b4:	617b      	str	r3, [r7, #20]
      exp += 2;
 80064b6:	231f      	movs	r3, #31
 80064b8:	18fb      	adds	r3, r7, r3
 80064ba:	781b      	ldrb	r3, [r3, #0]
 80064bc:	3302      	adds	r3, #2
 80064be:	b2da      	uxtb	r2, r3
 80064c0:	231f      	movs	r3, #31
 80064c2:	18fb      	adds	r3, r7, r3
 80064c4:	701a      	strb	r2, [r3, #0]
  fval = (float)intval;

  // Apply decimal. Should perform no more than two floating point multiplications for the
  // expected range of E0 to E-4.
  if (fval != 0) {
    while (exp <= -2) {
 80064c6:	231f      	movs	r3, #31
 80064c8:	18fb      	adds	r3, r7, r3
 80064ca:	781b      	ldrb	r3, [r3, #0]
 80064cc:	b25b      	sxtb	r3, r3
 80064ce:	3301      	adds	r3, #1
 80064d0:	dbeb      	blt.n	80064aa <read_float+0x13e>
      fval *= 0.01f;
      exp += 2;
    }
    if (exp < 0) {
 80064d2:	231f      	movs	r3, #31
 80064d4:	18fb      	adds	r3, r7, r3
 80064d6:	781b      	ldrb	r3, [r3, #0]
 80064d8:	2b7f      	cmp	r3, #127	; 0x7f
 80064da:	d906      	bls.n	80064ea <read_float+0x17e>
      fval *= 0.1f;
 80064dc:	491e      	ldr	r1, [pc, #120]	; (8006558 <read_float+0x1ec>)
 80064de:	6978      	ldr	r0, [r7, #20]
 80064e0:	f7fa fa96 	bl	8000a10 <__aeabi_fmul>
 80064e4:	1c03      	adds	r3, r0, #0
 80064e6:	617b      	str	r3, [r7, #20]
 80064e8:	e019      	b.n	800651e <read_float+0x1b2>
    } else if (exp > 0) {
 80064ea:	231f      	movs	r3, #31
 80064ec:	18fb      	adds	r3, r7, r3
 80064ee:	781b      	ldrb	r3, [r3, #0]
 80064f0:	b25b      	sxtb	r3, r3
 80064f2:	2b00      	cmp	r3, #0
 80064f4:	dd13      	ble.n	800651e <read_float+0x1b2>
      do {
        fval *= 10.0f;
 80064f6:	4919      	ldr	r1, [pc, #100]	; (800655c <read_float+0x1f0>)
 80064f8:	6978      	ldr	r0, [r7, #20]
 80064fa:	f7fa fa89 	bl	8000a10 <__aeabi_fmul>
 80064fe:	1c03      	adds	r3, r0, #0
 8006500:	617b      	str	r3, [r7, #20]
      } while (--exp > 0);
 8006502:	231f      	movs	r3, #31
 8006504:	18fb      	adds	r3, r7, r3
 8006506:	781b      	ldrb	r3, [r3, #0]
 8006508:	3b01      	subs	r3, #1
 800650a:	b2da      	uxtb	r2, r3
 800650c:	231f      	movs	r3, #31
 800650e:	18fb      	adds	r3, r7, r3
 8006510:	701a      	strb	r2, [r3, #0]
 8006512:	231f      	movs	r3, #31
 8006514:	18fb      	adds	r3, r7, r3
 8006516:	781b      	ldrb	r3, [r3, #0]
 8006518:	b25b      	sxtb	r3, r3
 800651a:	2b00      	cmp	r3, #0
 800651c:	dceb      	bgt.n	80064f6 <read_float+0x18a>
    }
  }

  // Assign floating point value with correct sign.
  if (isnegative) {
 800651e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006520:	2b00      	cmp	r3, #0
 8006522:	d006      	beq.n	8006532 <read_float+0x1c6>
    *float_ptr = -fval;
 8006524:	697b      	ldr	r3, [r7, #20]
 8006526:	2280      	movs	r2, #128	; 0x80
 8006528:	0612      	lsls	r2, r2, #24
 800652a:	405a      	eors	r2, r3
 800652c:	687b      	ldr	r3, [r7, #4]
 800652e:	601a      	str	r2, [r3, #0]
 8006530:	e002      	b.n	8006538 <read_float+0x1cc>
  } else {
    *float_ptr = fval;
 8006532:	687b      	ldr	r3, [r7, #4]
 8006534:	697a      	ldr	r2, [r7, #20]
 8006536:	601a      	str	r2, [r3, #0]
  }

  *char_counter = ptr - line - 1; // Set char_counter to next statement
 8006538:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800653a:	68fb      	ldr	r3, [r7, #12]
 800653c:	1ad3      	subs	r3, r2, r3
 800653e:	b2db      	uxtb	r3, r3
 8006540:	3b01      	subs	r3, #1
 8006542:	b2da      	uxtb	r2, r3
 8006544:	68bb      	ldr	r3, [r7, #8]
 8006546:	701a      	strb	r2, [r3, #0]

  return(true);
 8006548:	2301      	movs	r3, #1
}
 800654a:	0018      	movs	r0, r3
 800654c:	46bd      	mov	sp, r7
 800654e:	b00c      	add	sp, #48	; 0x30
 8006550:	bd80      	pop	{r7, pc}
 8006552:	46c0      	nop			; (mov r8, r8)
 8006554:	3c23d70a 	.word	0x3c23d70a
 8006558:	3dcccccd 	.word	0x3dcccccd
 800655c:	41200000 	.word	0x41200000

08006560 <delay_sec>:


// Non-blocking delay function used for general operation and suspend features.
void delay_sec(float seconds, uint8_t mode)
{
 8006560:	b590      	push	{r4, r7, lr}
 8006562:	b085      	sub	sp, #20
 8006564:	af00      	add	r7, sp, #0
 8006566:	6078      	str	r0, [r7, #4]
 8006568:	000a      	movs	r2, r1
 800656a:	1cfb      	adds	r3, r7, #3
 800656c:	701a      	strb	r2, [r3, #0]
	uint16_t i = (uint16_t)ceilf(1000 / DWELL_TIME_STEP*seconds);
 800656e:	491b      	ldr	r1, [pc, #108]	; (80065dc <delay_sec+0x7c>)
 8006570:	6878      	ldr	r0, [r7, #4]
 8006572:	f7fa fa4d 	bl	8000a10 <__aeabi_fmul>
 8006576:	1c03      	adds	r3, r0, #0
 8006578:	1c18      	adds	r0, r3, #0
 800657a:	f005 fe3f 	bl	800c1fc <ceilf>
 800657e:	1c03      	adds	r3, r0, #0
 8006580:	220e      	movs	r2, #14
 8006582:	18bc      	adds	r4, r7, r2
 8006584:	1c18      	adds	r0, r3, #0
 8006586:	f7f9 fecd 	bl	8000324 <__aeabi_f2uiz>
 800658a:	0003      	movs	r3, r0
 800658c:	8023      	strh	r3, [r4, #0]
	while (i-- > 0) {
 800658e:	e015      	b.n	80065bc <delay_sec+0x5c>
		if (sys.abort) { return; }
 8006590:	4b13      	ldr	r3, [pc, #76]	; (80065e0 <delay_sec+0x80>)
 8006592:	785b      	ldrb	r3, [r3, #1]
 8006594:	2b00      	cmp	r3, #0
 8006596:	d11b      	bne.n	80065d0 <delay_sec+0x70>
		if (mode == DELAY_MODE_DWELL) {
 8006598:	1cfb      	adds	r3, r7, #3
 800659a:	781b      	ldrb	r3, [r3, #0]
 800659c:	2b00      	cmp	r3, #0
 800659e:	d102      	bne.n	80065a6 <delay_sec+0x46>
			protocol_execute_realtime();
 80065a0:	f001 f9c0 	bl	8007924 <protocol_execute_realtime>
 80065a4:	e007      	b.n	80065b6 <delay_sec+0x56>
		} else { // DELAY_MODE_SYS_SUSPEND
		  // Execute rt_system() only to avoid nesting suspend loops.
		  protocol_exec_rt_system();
 80065a6:	f001 f9cd 	bl	8007944 <protocol_exec_rt_system>
		  if (sys.suspend & SUSPEND_RESTART_RETRACT) { return; } // Bail, if safety door reopens.
 80065aa:	4b0d      	ldr	r3, [pc, #52]	; (80065e0 <delay_sec+0x80>)
 80065ac:	789b      	ldrb	r3, [r3, #2]
 80065ae:	001a      	movs	r2, r3
 80065b0:	2302      	movs	r3, #2
 80065b2:	4013      	ands	r3, r2
 80065b4:	d10e      	bne.n	80065d4 <delay_sec+0x74>
		}
		_delay_ms(DWELL_TIME_STEP); // Delay DWELL_TIME_STEP increment
 80065b6:	2032      	movs	r0, #50	; 0x32
 80065b8:	f005 fbda 	bl	800bd70 <_delay_ms>

// Non-blocking delay function used for general operation and suspend features.
void delay_sec(float seconds, uint8_t mode)
{
	uint16_t i = (uint16_t)ceilf(1000 / DWELL_TIME_STEP*seconds);
	while (i-- > 0) {
 80065bc:	230e      	movs	r3, #14
 80065be:	18fb      	adds	r3, r7, r3
 80065c0:	881b      	ldrh	r3, [r3, #0]
 80065c2:	220e      	movs	r2, #14
 80065c4:	18ba      	adds	r2, r7, r2
 80065c6:	1e59      	subs	r1, r3, #1
 80065c8:	8011      	strh	r1, [r2, #0]
 80065ca:	2b00      	cmp	r3, #0
 80065cc:	d1e0      	bne.n	8006590 <delay_sec+0x30>
 80065ce:	e002      	b.n	80065d6 <delay_sec+0x76>
		if (sys.abort) { return; }
 80065d0:	46c0      	nop			; (mov r8, r8)
 80065d2:	e000      	b.n	80065d6 <delay_sec+0x76>
		if (mode == DELAY_MODE_DWELL) {
			protocol_execute_realtime();
		} else { // DELAY_MODE_SYS_SUSPEND
		  // Execute rt_system() only to avoid nesting suspend loops.
		  protocol_exec_rt_system();
		  if (sys.suspend & SUSPEND_RESTART_RETRACT) { return; } // Bail, if safety door reopens.
 80065d4:	46c0      	nop			; (mov r8, r8)
		}
		_delay_ms(DWELL_TIME_STEP); // Delay DWELL_TIME_STEP increment
	}
}
 80065d6:	46bd      	mov	sp, r7
 80065d8:	b005      	add	sp, #20
 80065da:	bd90      	pop	{r4, r7, pc}
 80065dc:	41a00000 	.word	0x41a00000
 80065e0:	20000b2c 	.word	0x20000b2c

080065e4 <delay_ms>:


// Delays variable defined milliseconds. Compiler compatibility fix for _delay_ms(),
// which only accepts constants in future compiler releases.
void delay_ms(uint16_t ms)
{
 80065e4:	b580      	push	{r7, lr}
 80065e6:	b082      	sub	sp, #8
 80065e8:	af00      	add	r7, sp, #0
 80065ea:	0002      	movs	r2, r0
 80065ec:	1dbb      	adds	r3, r7, #6
 80065ee:	801a      	strh	r2, [r3, #0]
  while ( ms-- ) { _delay_ms(1); }
 80065f0:	e002      	b.n	80065f8 <delay_ms+0x14>
 80065f2:	2001      	movs	r0, #1
 80065f4:	f005 fbbc 	bl	800bd70 <_delay_ms>
 80065f8:	1dbb      	adds	r3, r7, #6
 80065fa:	881b      	ldrh	r3, [r3, #0]
 80065fc:	1dba      	adds	r2, r7, #6
 80065fe:	1e59      	subs	r1, r3, #1
 8006600:	8011      	strh	r1, [r2, #0]
 8006602:	2b00      	cmp	r3, #0
 8006604:	d1f5      	bne.n	80065f2 <delay_ms+0xe>
}
 8006606:	46c0      	nop			; (mov r8, r8)
 8006608:	46bd      	mov	sp, r7
 800660a:	b002      	add	sp, #8
 800660c:	bd80      	pop	{r7, pc}
 800660e:	46c0      	nop			; (mov r8, r8)

08006610 <hypot_f>:


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrtf(x*x + y*y)); }
 8006610:	b590      	push	{r4, r7, lr}
 8006612:	b083      	sub	sp, #12
 8006614:	af00      	add	r7, sp, #0
 8006616:	6078      	str	r0, [r7, #4]
 8006618:	6039      	str	r1, [r7, #0]
 800661a:	6879      	ldr	r1, [r7, #4]
 800661c:	6878      	ldr	r0, [r7, #4]
 800661e:	f7fa f9f7 	bl	8000a10 <__aeabi_fmul>
 8006622:	1c03      	adds	r3, r0, #0
 8006624:	1c1c      	adds	r4, r3, #0
 8006626:	6839      	ldr	r1, [r7, #0]
 8006628:	6838      	ldr	r0, [r7, #0]
 800662a:	f7fa f9f1 	bl	8000a10 <__aeabi_fmul>
 800662e:	1c03      	adds	r3, r0, #0
 8006630:	1c19      	adds	r1, r3, #0
 8006632:	1c20      	adds	r0, r4, #0
 8006634:	f7f9 feac 	bl	8000390 <__aeabi_fadd>
 8006638:	1c03      	adds	r3, r0, #0
 800663a:	1c18      	adds	r0, r3, #0
 800663c:	f005 fef4 	bl	800c428 <sqrtf>
 8006640:	1c03      	adds	r3, r0, #0
 8006642:	1c18      	adds	r0, r3, #0
 8006644:	46bd      	mov	sp, r7
 8006646:	b003      	add	sp, #12
 8006648:	bd90      	pop	{r4, r7, pc}
 800664a:	46c0      	nop			; (mov r8, r8)

0800664c <convert_delta_vector_to_unit_vector>:


float convert_delta_vector_to_unit_vector(float *vector)
{
 800664c:	b590      	push	{r4, r7, lr}
 800664e:	b087      	sub	sp, #28
 8006650:	af00      	add	r7, sp, #0
 8006652:	6078      	str	r0, [r7, #4]
  uint8_t idx;
  float magnitude = 0.0f;
 8006654:	2300      	movs	r3, #0
 8006656:	613b      	str	r3, [r7, #16]
  for (idx=0; idx<N_AXIS; idx++) {
 8006658:	2317      	movs	r3, #23
 800665a:	18fb      	adds	r3, r7, r3
 800665c:	2200      	movs	r2, #0
 800665e:	701a      	strb	r2, [r3, #0]
 8006660:	e02b      	b.n	80066ba <convert_delta_vector_to_unit_vector+0x6e>
    if (vector[idx] != 0.0f) {
 8006662:	2317      	movs	r3, #23
 8006664:	18fb      	adds	r3, r7, r3
 8006666:	781b      	ldrb	r3, [r3, #0]
 8006668:	009b      	lsls	r3, r3, #2
 800666a:	687a      	ldr	r2, [r7, #4]
 800666c:	18d3      	adds	r3, r2, r3
 800666e:	681b      	ldr	r3, [r3, #0]
 8006670:	2100      	movs	r1, #0
 8006672:	1c18      	adds	r0, r3, #0
 8006674:	f7f9 fe28 	bl	80002c8 <__aeabi_fcmpeq>
 8006678:	1e03      	subs	r3, r0, #0
 800667a:	d117      	bne.n	80066ac <convert_delta_vector_to_unit_vector+0x60>
      magnitude += vector[idx]*vector[idx];
 800667c:	2317      	movs	r3, #23
 800667e:	18fb      	adds	r3, r7, r3
 8006680:	781b      	ldrb	r3, [r3, #0]
 8006682:	009b      	lsls	r3, r3, #2
 8006684:	687a      	ldr	r2, [r7, #4]
 8006686:	18d3      	adds	r3, r2, r3
 8006688:	6818      	ldr	r0, [r3, #0]
 800668a:	2317      	movs	r3, #23
 800668c:	18fb      	adds	r3, r7, r3
 800668e:	781b      	ldrb	r3, [r3, #0]
 8006690:	009b      	lsls	r3, r3, #2
 8006692:	687a      	ldr	r2, [r7, #4]
 8006694:	18d3      	adds	r3, r2, r3
 8006696:	681b      	ldr	r3, [r3, #0]
 8006698:	1c19      	adds	r1, r3, #0
 800669a:	f7fa f9b9 	bl	8000a10 <__aeabi_fmul>
 800669e:	1c03      	adds	r3, r0, #0
 80066a0:	1c19      	adds	r1, r3, #0
 80066a2:	6938      	ldr	r0, [r7, #16]
 80066a4:	f7f9 fe74 	bl	8000390 <__aeabi_fadd>
 80066a8:	1c03      	adds	r3, r0, #0
 80066aa:	613b      	str	r3, [r7, #16]

float convert_delta_vector_to_unit_vector(float *vector)
{
  uint8_t idx;
  float magnitude = 0.0f;
  for (idx=0; idx<N_AXIS; idx++) {
 80066ac:	2317      	movs	r3, #23
 80066ae:	18fb      	adds	r3, r7, r3
 80066b0:	781a      	ldrb	r2, [r3, #0]
 80066b2:	2317      	movs	r3, #23
 80066b4:	18fb      	adds	r3, r7, r3
 80066b6:	3201      	adds	r2, #1
 80066b8:	701a      	strb	r2, [r3, #0]
 80066ba:	2317      	movs	r3, #23
 80066bc:	18fb      	adds	r3, r7, r3
 80066be:	781b      	ldrb	r3, [r3, #0]
 80066c0:	2b02      	cmp	r3, #2
 80066c2:	d9ce      	bls.n	8006662 <convert_delta_vector_to_unit_vector+0x16>
    if (vector[idx] != 0.0f) {
      magnitude += vector[idx]*vector[idx];
    }
  }
  magnitude = sqrtf(magnitude);
 80066c4:	693b      	ldr	r3, [r7, #16]
 80066c6:	1c18      	adds	r0, r3, #0
 80066c8:	f005 feae 	bl	800c428 <sqrtf>
 80066cc:	1c03      	adds	r3, r0, #0
 80066ce:	613b      	str	r3, [r7, #16]
  float inv_magnitude = 1.0f/magnitude;
 80066d0:	6939      	ldr	r1, [r7, #16]
 80066d2:	20fe      	movs	r0, #254	; 0xfe
 80066d4:	0580      	lsls	r0, r0, #22
 80066d6:	f7f9 ffd1 	bl	800067c <__aeabi_fdiv>
 80066da:	1c03      	adds	r3, r0, #0
 80066dc:	60fb      	str	r3, [r7, #12]
  for (idx=0; idx<N_AXIS; idx++) { vector[idx] *= inv_magnitude; }
 80066de:	2317      	movs	r3, #23
 80066e0:	18fb      	adds	r3, r7, r3
 80066e2:	2200      	movs	r2, #0
 80066e4:	701a      	strb	r2, [r3, #0]
 80066e6:	e019      	b.n	800671c <convert_delta_vector_to_unit_vector+0xd0>
 80066e8:	2317      	movs	r3, #23
 80066ea:	18fb      	adds	r3, r7, r3
 80066ec:	781b      	ldrb	r3, [r3, #0]
 80066ee:	009b      	lsls	r3, r3, #2
 80066f0:	687a      	ldr	r2, [r7, #4]
 80066f2:	18d4      	adds	r4, r2, r3
 80066f4:	2317      	movs	r3, #23
 80066f6:	18fb      	adds	r3, r7, r3
 80066f8:	781b      	ldrb	r3, [r3, #0]
 80066fa:	009b      	lsls	r3, r3, #2
 80066fc:	687a      	ldr	r2, [r7, #4]
 80066fe:	18d3      	adds	r3, r2, r3
 8006700:	681b      	ldr	r3, [r3, #0]
 8006702:	68f9      	ldr	r1, [r7, #12]
 8006704:	1c18      	adds	r0, r3, #0
 8006706:	f7fa f983 	bl	8000a10 <__aeabi_fmul>
 800670a:	1c03      	adds	r3, r0, #0
 800670c:	6023      	str	r3, [r4, #0]
 800670e:	2317      	movs	r3, #23
 8006710:	18fb      	adds	r3, r7, r3
 8006712:	781a      	ldrb	r2, [r3, #0]
 8006714:	2317      	movs	r3, #23
 8006716:	18fb      	adds	r3, r7, r3
 8006718:	3201      	adds	r2, #1
 800671a:	701a      	strb	r2, [r3, #0]
 800671c:	2317      	movs	r3, #23
 800671e:	18fb      	adds	r3, r7, r3
 8006720:	781b      	ldrb	r3, [r3, #0]
 8006722:	2b02      	cmp	r3, #2
 8006724:	d9e0      	bls.n	80066e8 <convert_delta_vector_to_unit_vector+0x9c>
  return(magnitude);
 8006726:	693b      	ldr	r3, [r7, #16]
}
 8006728:	1c18      	adds	r0, r3, #0
 800672a:	46bd      	mov	sp, r7
 800672c:	b007      	add	sp, #28
 800672e:	bd90      	pop	{r4, r7, pc}

08006730 <limit_value_by_axis_maximum>:


float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
 8006730:	b580      	push	{r7, lr}
 8006732:	b084      	sub	sp, #16
 8006734:	af00      	add	r7, sp, #0
 8006736:	6078      	str	r0, [r7, #4]
 8006738:	6039      	str	r1, [r7, #0]
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
 800673a:	4b2b      	ldr	r3, [pc, #172]	; (80067e8 <limit_value_by_axis_maximum+0xb8>)
 800673c:	60bb      	str	r3, [r7, #8]
  for (idx=0; idx<N_AXIS; idx++) {
 800673e:	230f      	movs	r3, #15
 8006740:	18fb      	adds	r3, r7, r3
 8006742:	2200      	movs	r2, #0
 8006744:	701a      	strb	r2, [r3, #0]
 8006746:	e044      	b.n	80067d2 <limit_value_by_axis_maximum+0xa2>
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
 8006748:	230f      	movs	r3, #15
 800674a:	18fb      	adds	r3, r7, r3
 800674c:	781b      	ldrb	r3, [r3, #0]
 800674e:	009b      	lsls	r3, r3, #2
 8006750:	683a      	ldr	r2, [r7, #0]
 8006752:	18d3      	adds	r3, r2, r3
 8006754:	681b      	ldr	r3, [r3, #0]
 8006756:	2100      	movs	r1, #0
 8006758:	1c18      	adds	r0, r3, #0
 800675a:	f7f9 fdb5 	bl	80002c8 <__aeabi_fcmpeq>
 800675e:	1e03      	subs	r3, r0, #0
 8006760:	d130      	bne.n	80067c4 <limit_value_by_axis_maximum+0x94>
      limit_value = min(limit_value,fabsf(max_value[idx]/unit_vec[idx]));
 8006762:	230f      	movs	r3, #15
 8006764:	18fb      	adds	r3, r7, r3
 8006766:	781b      	ldrb	r3, [r3, #0]
 8006768:	009b      	lsls	r3, r3, #2
 800676a:	687a      	ldr	r2, [r7, #4]
 800676c:	18d3      	adds	r3, r2, r3
 800676e:	6818      	ldr	r0, [r3, #0]
 8006770:	230f      	movs	r3, #15
 8006772:	18fb      	adds	r3, r7, r3
 8006774:	781b      	ldrb	r3, [r3, #0]
 8006776:	009b      	lsls	r3, r3, #2
 8006778:	683a      	ldr	r2, [r7, #0]
 800677a:	18d3      	adds	r3, r2, r3
 800677c:	681b      	ldr	r3, [r3, #0]
 800677e:	1c19      	adds	r1, r3, #0
 8006780:	f7f9 ff7c 	bl	800067c <__aeabi_fdiv>
 8006784:	1c03      	adds	r3, r0, #0
 8006786:	005b      	lsls	r3, r3, #1
 8006788:	085b      	lsrs	r3, r3, #1
 800678a:	68b9      	ldr	r1, [r7, #8]
 800678c:	1c18      	adds	r0, r3, #0
 800678e:	f7f9 fdb5 	bl	80002fc <__aeabi_fcmpgt>
 8006792:	1e03      	subs	r3, r0, #0
 8006794:	d001      	beq.n	800679a <limit_value_by_axis_maximum+0x6a>
 8006796:	68bb      	ldr	r3, [r7, #8]
 8006798:	e013      	b.n	80067c2 <limit_value_by_axis_maximum+0x92>
 800679a:	230f      	movs	r3, #15
 800679c:	18fb      	adds	r3, r7, r3
 800679e:	781b      	ldrb	r3, [r3, #0]
 80067a0:	009b      	lsls	r3, r3, #2
 80067a2:	687a      	ldr	r2, [r7, #4]
 80067a4:	18d3      	adds	r3, r2, r3
 80067a6:	6818      	ldr	r0, [r3, #0]
 80067a8:	230f      	movs	r3, #15
 80067aa:	18fb      	adds	r3, r7, r3
 80067ac:	781b      	ldrb	r3, [r3, #0]
 80067ae:	009b      	lsls	r3, r3, #2
 80067b0:	683a      	ldr	r2, [r7, #0]
 80067b2:	18d3      	adds	r3, r2, r3
 80067b4:	681b      	ldr	r3, [r3, #0]
 80067b6:	1c19      	adds	r1, r3, #0
 80067b8:	f7f9 ff60 	bl	800067c <__aeabi_fdiv>
 80067bc:	1c03      	adds	r3, r0, #0
 80067be:	005b      	lsls	r3, r3, #1
 80067c0:	085b      	lsrs	r3, r3, #1
 80067c2:	60bb      	str	r3, [r7, #8]

float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
  for (idx=0; idx<N_AXIS; idx++) {
 80067c4:	230f      	movs	r3, #15
 80067c6:	18fb      	adds	r3, r7, r3
 80067c8:	781a      	ldrb	r2, [r3, #0]
 80067ca:	230f      	movs	r3, #15
 80067cc:	18fb      	adds	r3, r7, r3
 80067ce:	3201      	adds	r2, #1
 80067d0:	701a      	strb	r2, [r3, #0]
 80067d2:	230f      	movs	r3, #15
 80067d4:	18fb      	adds	r3, r7, r3
 80067d6:	781b      	ldrb	r3, [r3, #0]
 80067d8:	2b02      	cmp	r3, #2
 80067da:	d9b5      	bls.n	8006748 <limit_value_by_axis_maximum+0x18>
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
      limit_value = min(limit_value,fabsf(max_value[idx]/unit_vec[idx]));
    }
  }
  return(limit_value);
 80067dc:	68bb      	ldr	r3, [r7, #8]
}
 80067de:	1c18      	adds	r0, r3, #0
 80067e0:	46bd      	mov	sp, r7
 80067e2:	b004      	add	sp, #16
 80067e4:	bd80      	pop	{r7, pc}
 80067e6:	46c0      	nop			; (mov r8, r8)
 80067e8:	7f7fffff 	.word	0x7f7fffff

080067ec <plan_next_block_index>:
static planner_t pl;


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index)
{
 80067ec:	b580      	push	{r7, lr}
 80067ee:	b082      	sub	sp, #8
 80067f0:	af00      	add	r7, sp, #0
 80067f2:	0002      	movs	r2, r0
 80067f4:	1dfb      	adds	r3, r7, #7
 80067f6:	701a      	strb	r2, [r3, #0]
  block_index++;
 80067f8:	1dfb      	adds	r3, r7, #7
 80067fa:	781a      	ldrb	r2, [r3, #0]
 80067fc:	1dfb      	adds	r3, r7, #7
 80067fe:	3201      	adds	r2, #1
 8006800:	701a      	strb	r2, [r3, #0]
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
 8006802:	1dfb      	adds	r3, r7, #7
 8006804:	781b      	ldrb	r3, [r3, #0]
 8006806:	2b10      	cmp	r3, #16
 8006808:	d102      	bne.n	8006810 <plan_next_block_index+0x24>
 800680a:	1dfb      	adds	r3, r7, #7
 800680c:	2200      	movs	r2, #0
 800680e:	701a      	strb	r2, [r3, #0]
  return(block_index);
 8006810:	1dfb      	adds	r3, r7, #7
 8006812:	781b      	ldrb	r3, [r3, #0]
}
 8006814:	0018      	movs	r0, r3
 8006816:	46bd      	mov	sp, r7
 8006818:	b002      	add	sp, #8
 800681a:	bd80      	pop	{r7, pc}

0800681c <plan_prev_block_index>:


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index)
{
 800681c:	b580      	push	{r7, lr}
 800681e:	b082      	sub	sp, #8
 8006820:	af00      	add	r7, sp, #0
 8006822:	0002      	movs	r2, r0
 8006824:	1dfb      	adds	r3, r7, #7
 8006826:	701a      	strb	r2, [r3, #0]
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
 8006828:	1dfb      	adds	r3, r7, #7
 800682a:	781b      	ldrb	r3, [r3, #0]
 800682c:	2b00      	cmp	r3, #0
 800682e:	d102      	bne.n	8006836 <plan_prev_block_index+0x1a>
 8006830:	1dfb      	adds	r3, r7, #7
 8006832:	2210      	movs	r2, #16
 8006834:	701a      	strb	r2, [r3, #0]
  block_index--;
 8006836:	1dfb      	adds	r3, r7, #7
 8006838:	781a      	ldrb	r2, [r3, #0]
 800683a:	1dfb      	adds	r3, r7, #7
 800683c:	3a01      	subs	r2, #1
 800683e:	701a      	strb	r2, [r3, #0]
  return(block_index);
 8006840:	1dfb      	adds	r3, r7, #7
 8006842:	781b      	ldrb	r3, [r3, #0]
}
 8006844:	0018      	movs	r0, r3
 8006846:	46bd      	mov	sp, r7
 8006848:	b002      	add	sp, #8
 800684a:	bd80      	pop	{r7, pc}

0800684c <planner_recalculate>:
  to compute an optimal plan, so select carefully. The Arduino 328p memory is already maxed out, but future
  ARM versions should have enough memory and speed for look-ahead blocks numbering up to a hundred or more.

*/
static void planner_recalculate()
{
 800684c:	b590      	push	{r4, r7, lr}
 800684e:	b085      	sub	sp, #20
 8006850:	af00      	add	r7, sp, #0
  // Initialize block index to the last block in the planner buffer.
  uint8_t block_index = plan_prev_block_index(block_buffer_head);
 8006852:	4b94      	ldr	r3, [pc, #592]	; (8006aa4 <planner_recalculate+0x258>)
 8006854:	781b      	ldrb	r3, [r3, #0]
 8006856:	220f      	movs	r2, #15
 8006858:	18bc      	adds	r4, r7, r2
 800685a:	0018      	movs	r0, r3
 800685c:	f7ff ffde 	bl	800681c <plan_prev_block_index>
 8006860:	0003      	movs	r3, r0
 8006862:	7023      	strb	r3, [r4, #0]

  // Bail. Can't do anything with one only one plan-able block.
  if (block_index == block_buffer_planned) { return; }
 8006864:	4b90      	ldr	r3, [pc, #576]	; (8006aa8 <planner_recalculate+0x25c>)
 8006866:	781b      	ldrb	r3, [r3, #0]
 8006868:	220f      	movs	r2, #15
 800686a:	18ba      	adds	r2, r7, r2
 800686c:	7812      	ldrb	r2, [r2, #0]
 800686e:	429a      	cmp	r2, r3
 8006870:	d100      	bne.n	8006874 <planner_recalculate+0x28>
 8006872:	e112      	b.n	8006a9a <planner_recalculate+0x24e>
  // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
  // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
  // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
  float entry_speed_sqr;
  plan_block_t *next;
  plan_block_t *current = &block_buffer[block_index];
 8006874:	230f      	movs	r3, #15
 8006876:	18fb      	adds	r3, r7, r3
 8006878:	781b      	ldrb	r3, [r3, #0]
 800687a:	2234      	movs	r2, #52	; 0x34
 800687c:	435a      	muls	r2, r3
 800687e:	4b8b      	ldr	r3, [pc, #556]	; (8006aac <planner_recalculate+0x260>)
 8006880:	18d3      	adds	r3, r2, r3
 8006882:	607b      	str	r3, [r7, #4]

  // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
 8006884:	687b      	ldr	r3, [r7, #4]
 8006886:	699c      	ldr	r4, [r3, #24]
 8006888:	687b      	ldr	r3, [r7, #4]
 800688a:	69db      	ldr	r3, [r3, #28]
 800688c:	1c19      	adds	r1, r3, #0
 800688e:	1c18      	adds	r0, r3, #0
 8006890:	f7f9 fd7e 	bl	8000390 <__aeabi_fadd>
 8006894:	1c03      	adds	r3, r0, #0
 8006896:	1c1a      	adds	r2, r3, #0
 8006898:	687b      	ldr	r3, [r7, #4]
 800689a:	6a1b      	ldr	r3, [r3, #32]
 800689c:	1c19      	adds	r1, r3, #0
 800689e:	1c10      	adds	r0, r2, #0
 80068a0:	f7fa f8b6 	bl	8000a10 <__aeabi_fmul>
 80068a4:	1c03      	adds	r3, r0, #0
 80068a6:	1c19      	adds	r1, r3, #0
 80068a8:	1c20      	adds	r0, r4, #0
 80068aa:	f7f9 fd13 	bl	80002d4 <__aeabi_fcmplt>
 80068ae:	1e03      	subs	r3, r0, #0
 80068b0:	d002      	beq.n	80068b8 <planner_recalculate+0x6c>
 80068b2:	687b      	ldr	r3, [r7, #4]
 80068b4:	699a      	ldr	r2, [r3, #24]
 80068b6:	e00f      	b.n	80068d8 <planner_recalculate+0x8c>
 80068b8:	687b      	ldr	r3, [r7, #4]
 80068ba:	69db      	ldr	r3, [r3, #28]
 80068bc:	1c19      	adds	r1, r3, #0
 80068be:	1c18      	adds	r0, r3, #0
 80068c0:	f7f9 fd66 	bl	8000390 <__aeabi_fadd>
 80068c4:	1c03      	adds	r3, r0, #0
 80068c6:	1c1a      	adds	r2, r3, #0
 80068c8:	687b      	ldr	r3, [r7, #4]
 80068ca:	6a1b      	ldr	r3, [r3, #32]
 80068cc:	1c19      	adds	r1, r3, #0
 80068ce:	1c10      	adds	r0, r2, #0
 80068d0:	f7fa f89e 	bl	8000a10 <__aeabi_fmul>
 80068d4:	1c03      	adds	r3, r0, #0
 80068d6:	1c1a      	adds	r2, r3, #0
 80068d8:	687b      	ldr	r3, [r7, #4]
 80068da:	615a      	str	r2, [r3, #20]

  block_index = plan_prev_block_index(block_index);
 80068dc:	230f      	movs	r3, #15
 80068de:	18fc      	adds	r4, r7, r3
 80068e0:	230f      	movs	r3, #15
 80068e2:	18fb      	adds	r3, r7, r3
 80068e4:	781b      	ldrb	r3, [r3, #0]
 80068e6:	0018      	movs	r0, r3
 80068e8:	f7ff ff98 	bl	800681c <plan_prev_block_index>
 80068ec:	0003      	movs	r3, r0
 80068ee:	7023      	strb	r3, [r4, #0]
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
 80068f0:	4b6d      	ldr	r3, [pc, #436]	; (8006aa8 <planner_recalculate+0x25c>)
 80068f2:	781b      	ldrb	r3, [r3, #0]
 80068f4:	220f      	movs	r2, #15
 80068f6:	18ba      	adds	r2, r7, r2
 80068f8:	7812      	ldrb	r2, [r2, #0]
 80068fa:	429a      	cmp	r2, r3
 80068fc:	d158      	bne.n	80069b0 <planner_recalculate+0x164>
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
 80068fe:	4b6c      	ldr	r3, [pc, #432]	; (8006ab0 <planner_recalculate+0x264>)
 8006900:	781b      	ldrb	r3, [r3, #0]
 8006902:	220f      	movs	r2, #15
 8006904:	18ba      	adds	r2, r7, r2
 8006906:	7812      	ldrb	r2, [r2, #0]
 8006908:	429a      	cmp	r2, r3
 800690a:	d158      	bne.n	80069be <planner_recalculate+0x172>
 800690c:	f003 fe16 	bl	800a53c <st_update_plan_block_parameters>
 8006910:	e055      	b.n	80069be <planner_recalculate+0x172>
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) {
      next = current;
 8006912:	687b      	ldr	r3, [r7, #4]
 8006914:	60bb      	str	r3, [r7, #8]
      current = &block_buffer[block_index];
 8006916:	230f      	movs	r3, #15
 8006918:	18fb      	adds	r3, r7, r3
 800691a:	781b      	ldrb	r3, [r3, #0]
 800691c:	2234      	movs	r2, #52	; 0x34
 800691e:	435a      	muls	r2, r3
 8006920:	4b62      	ldr	r3, [pc, #392]	; (8006aac <planner_recalculate+0x260>)
 8006922:	18d3      	adds	r3, r2, r3
 8006924:	607b      	str	r3, [r7, #4]
      block_index = plan_prev_block_index(block_index);
 8006926:	230f      	movs	r3, #15
 8006928:	18fc      	adds	r4, r7, r3
 800692a:	230f      	movs	r3, #15
 800692c:	18fb      	adds	r3, r7, r3
 800692e:	781b      	ldrb	r3, [r3, #0]
 8006930:	0018      	movs	r0, r3
 8006932:	f7ff ff73 	bl	800681c <plan_prev_block_index>
 8006936:	0003      	movs	r3, r0
 8006938:	7023      	strb	r3, [r4, #0]

      // Check if next block is the tail block(=planned block). If so, update current stepper parameters.
      if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
 800693a:	4b5d      	ldr	r3, [pc, #372]	; (8006ab0 <planner_recalculate+0x264>)
 800693c:	781b      	ldrb	r3, [r3, #0]
 800693e:	220f      	movs	r2, #15
 8006940:	18ba      	adds	r2, r7, r2
 8006942:	7812      	ldrb	r2, [r2, #0]
 8006944:	429a      	cmp	r2, r3
 8006946:	d101      	bne.n	800694c <planner_recalculate+0x100>
 8006948:	f003 fdf8 	bl	800a53c <st_update_plan_block_parameters>

      // Compute maximum entry speed decelerating over the current block from its exit speed.
      if (current->entry_speed_sqr != current->max_entry_speed_sqr) {
 800694c:	687b      	ldr	r3, [r7, #4]
 800694e:	695a      	ldr	r2, [r3, #20]
 8006950:	687b      	ldr	r3, [r7, #4]
 8006952:	699b      	ldr	r3, [r3, #24]
 8006954:	1c19      	adds	r1, r3, #0
 8006956:	1c10      	adds	r0, r2, #0
 8006958:	f7f9 fcb6 	bl	80002c8 <__aeabi_fcmpeq>
 800695c:	1e03      	subs	r3, r0, #0
 800695e:	d000      	beq.n	8006962 <planner_recalculate+0x116>
 8006960:	e026      	b.n	80069b0 <planner_recalculate+0x164>
        entry_speed_sqr = next->entry_speed_sqr + 2*current->acceleration*current->millimeters;
 8006962:	68bb      	ldr	r3, [r7, #8]
 8006964:	695c      	ldr	r4, [r3, #20]
 8006966:	687b      	ldr	r3, [r7, #4]
 8006968:	69db      	ldr	r3, [r3, #28]
 800696a:	1c19      	adds	r1, r3, #0
 800696c:	1c18      	adds	r0, r3, #0
 800696e:	f7f9 fd0f 	bl	8000390 <__aeabi_fadd>
 8006972:	1c03      	adds	r3, r0, #0
 8006974:	1c1a      	adds	r2, r3, #0
 8006976:	687b      	ldr	r3, [r7, #4]
 8006978:	6a1b      	ldr	r3, [r3, #32]
 800697a:	1c19      	adds	r1, r3, #0
 800697c:	1c10      	adds	r0, r2, #0
 800697e:	f7fa f847 	bl	8000a10 <__aeabi_fmul>
 8006982:	1c03      	adds	r3, r0, #0
 8006984:	1c19      	adds	r1, r3, #0
 8006986:	1c20      	adds	r0, r4, #0
 8006988:	f7f9 fd02 	bl	8000390 <__aeabi_fadd>
 800698c:	1c03      	adds	r3, r0, #0
 800698e:	603b      	str	r3, [r7, #0]
        if (entry_speed_sqr < current->max_entry_speed_sqr) {
 8006990:	687b      	ldr	r3, [r7, #4]
 8006992:	699b      	ldr	r3, [r3, #24]
 8006994:	6839      	ldr	r1, [r7, #0]
 8006996:	1c18      	adds	r0, r3, #0
 8006998:	f7f9 fcb0 	bl	80002fc <__aeabi_fcmpgt>
 800699c:	1e03      	subs	r3, r0, #0
 800699e:	d003      	beq.n	80069a8 <planner_recalculate+0x15c>
          current->entry_speed_sqr = entry_speed_sqr;
 80069a0:	687b      	ldr	r3, [r7, #4]
 80069a2:	683a      	ldr	r2, [r7, #0]
 80069a4:	615a      	str	r2, [r3, #20]
 80069a6:	e003      	b.n	80069b0 <planner_recalculate+0x164>
        } else {
          current->entry_speed_sqr = current->max_entry_speed_sqr;
 80069a8:	687b      	ldr	r3, [r7, #4]
 80069aa:	699a      	ldr	r2, [r3, #24]
 80069ac:	687b      	ldr	r3, [r7, #4]
 80069ae:	615a      	str	r2, [r3, #20]
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) {
 80069b0:	4b3d      	ldr	r3, [pc, #244]	; (8006aa8 <planner_recalculate+0x25c>)
 80069b2:	781b      	ldrb	r3, [r3, #0]
 80069b4:	220f      	movs	r2, #15
 80069b6:	18ba      	adds	r2, r7, r2
 80069b8:	7812      	ldrb	r2, [r2, #0]
 80069ba:	429a      	cmp	r2, r3
 80069bc:	d1a9      	bne.n	8006912 <planner_recalculate+0xc6>
    }
  }

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
 80069be:	4b3a      	ldr	r3, [pc, #232]	; (8006aa8 <planner_recalculate+0x25c>)
 80069c0:	781b      	ldrb	r3, [r3, #0]
 80069c2:	001a      	movs	r2, r3
 80069c4:	2334      	movs	r3, #52	; 0x34
 80069c6:	435a      	muls	r2, r3
 80069c8:	4b38      	ldr	r3, [pc, #224]	; (8006aac <planner_recalculate+0x260>)
 80069ca:	18d3      	adds	r3, r2, r3
 80069cc:	60bb      	str	r3, [r7, #8]
  block_index = plan_next_block_index(block_buffer_planned);
 80069ce:	4b36      	ldr	r3, [pc, #216]	; (8006aa8 <planner_recalculate+0x25c>)
 80069d0:	781b      	ldrb	r3, [r3, #0]
 80069d2:	220f      	movs	r2, #15
 80069d4:	18bc      	adds	r4, r7, r2
 80069d6:	0018      	movs	r0, r3
 80069d8:	f7ff ff08 	bl	80067ec <plan_next_block_index>
 80069dc:	0003      	movs	r3, r0
 80069de:	7023      	strb	r3, [r4, #0]
  while (block_index != block_buffer_head) {
 80069e0:	e053      	b.n	8006a8a <planner_recalculate+0x23e>
    current = next;
 80069e2:	68bb      	ldr	r3, [r7, #8]
 80069e4:	607b      	str	r3, [r7, #4]
    next = &block_buffer[block_index];
 80069e6:	230f      	movs	r3, #15
 80069e8:	18fb      	adds	r3, r7, r3
 80069ea:	781b      	ldrb	r3, [r3, #0]
 80069ec:	2234      	movs	r2, #52	; 0x34
 80069ee:	435a      	muls	r2, r3
 80069f0:	4b2e      	ldr	r3, [pc, #184]	; (8006aac <planner_recalculate+0x260>)
 80069f2:	18d3      	adds	r3, r2, r3
 80069f4:	60bb      	str	r3, [r7, #8]

    // Any acceleration detected in the forward pass automatically moves the optimal planned
    // pointer forward, since everything before this is all optimal. In other words, nothing
    // can improve the plan from the buffer tail to the planned pointer by logic.
    if (current->entry_speed_sqr < next->entry_speed_sqr) {
 80069f6:	687b      	ldr	r3, [r7, #4]
 80069f8:	695a      	ldr	r2, [r3, #20]
 80069fa:	68bb      	ldr	r3, [r7, #8]
 80069fc:	695b      	ldr	r3, [r3, #20]
 80069fe:	1c19      	adds	r1, r3, #0
 8006a00:	1c10      	adds	r0, r2, #0
 8006a02:	f7f9 fc67 	bl	80002d4 <__aeabi_fcmplt>
 8006a06:	1e03      	subs	r3, r0, #0
 8006a08:	d026      	beq.n	8006a58 <planner_recalculate+0x20c>
      entry_speed_sqr = current->entry_speed_sqr + 2*current->acceleration*current->millimeters;
 8006a0a:	687b      	ldr	r3, [r7, #4]
 8006a0c:	695c      	ldr	r4, [r3, #20]
 8006a0e:	687b      	ldr	r3, [r7, #4]
 8006a10:	69db      	ldr	r3, [r3, #28]
 8006a12:	1c19      	adds	r1, r3, #0
 8006a14:	1c18      	adds	r0, r3, #0
 8006a16:	f7f9 fcbb 	bl	8000390 <__aeabi_fadd>
 8006a1a:	1c03      	adds	r3, r0, #0
 8006a1c:	1c1a      	adds	r2, r3, #0
 8006a1e:	687b      	ldr	r3, [r7, #4]
 8006a20:	6a1b      	ldr	r3, [r3, #32]
 8006a22:	1c19      	adds	r1, r3, #0
 8006a24:	1c10      	adds	r0, r2, #0
 8006a26:	f7f9 fff3 	bl	8000a10 <__aeabi_fmul>
 8006a2a:	1c03      	adds	r3, r0, #0
 8006a2c:	1c19      	adds	r1, r3, #0
 8006a2e:	1c20      	adds	r0, r4, #0
 8006a30:	f7f9 fcae 	bl	8000390 <__aeabi_fadd>
 8006a34:	1c03      	adds	r3, r0, #0
 8006a36:	603b      	str	r3, [r7, #0]
      // If true, current block is full-acceleration and we can move the planned pointer forward.
      if (entry_speed_sqr < next->entry_speed_sqr) {
 8006a38:	68bb      	ldr	r3, [r7, #8]
 8006a3a:	695b      	ldr	r3, [r3, #20]
 8006a3c:	6839      	ldr	r1, [r7, #0]
 8006a3e:	1c18      	adds	r0, r3, #0
 8006a40:	f7f9 fc5c 	bl	80002fc <__aeabi_fcmpgt>
 8006a44:	1e03      	subs	r3, r0, #0
 8006a46:	d007      	beq.n	8006a58 <planner_recalculate+0x20c>
        next->entry_speed_sqr = entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
 8006a48:	68bb      	ldr	r3, [r7, #8]
 8006a4a:	683a      	ldr	r2, [r7, #0]
 8006a4c:	615a      	str	r2, [r3, #20]
        block_buffer_planned = block_index; // Set optimal plan pointer.
 8006a4e:	4b16      	ldr	r3, [pc, #88]	; (8006aa8 <planner_recalculate+0x25c>)
 8006a50:	220f      	movs	r2, #15
 8006a52:	18ba      	adds	r2, r7, r2
 8006a54:	7812      	ldrb	r2, [r2, #0]
 8006a56:	701a      	strb	r2, [r3, #0]

    // Any block set at its maximum entry speed also creates an optimal plan up to this
    // point in the buffer. When the plan is bracketed by either the beginning of the
    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
    if (next->entry_speed_sqr == next->max_entry_speed_sqr) { block_buffer_planned = block_index; }
 8006a58:	68bb      	ldr	r3, [r7, #8]
 8006a5a:	695a      	ldr	r2, [r3, #20]
 8006a5c:	68bb      	ldr	r3, [r7, #8]
 8006a5e:	699b      	ldr	r3, [r3, #24]
 8006a60:	1c19      	adds	r1, r3, #0
 8006a62:	1c10      	adds	r0, r2, #0
 8006a64:	f7f9 fc30 	bl	80002c8 <__aeabi_fcmpeq>
 8006a68:	1e03      	subs	r3, r0, #0
 8006a6a:	d004      	beq.n	8006a76 <planner_recalculate+0x22a>
 8006a6c:	4b0e      	ldr	r3, [pc, #56]	; (8006aa8 <planner_recalculate+0x25c>)
 8006a6e:	220f      	movs	r2, #15
 8006a70:	18ba      	adds	r2, r7, r2
 8006a72:	7812      	ldrb	r2, [r2, #0]
 8006a74:	701a      	strb	r2, [r3, #0]
    block_index = plan_next_block_index( block_index );
 8006a76:	230f      	movs	r3, #15
 8006a78:	18fc      	adds	r4, r7, r3
 8006a7a:	230f      	movs	r3, #15
 8006a7c:	18fb      	adds	r3, r7, r3
 8006a7e:	781b      	ldrb	r3, [r3, #0]
 8006a80:	0018      	movs	r0, r3
 8006a82:	f7ff feb3 	bl	80067ec <plan_next_block_index>
 8006a86:	0003      	movs	r3, r0
 8006a88:	7023      	strb	r3, [r4, #0]

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned);
  while (block_index != block_buffer_head) {
 8006a8a:	4b06      	ldr	r3, [pc, #24]	; (8006aa4 <planner_recalculate+0x258>)
 8006a8c:	781b      	ldrb	r3, [r3, #0]
 8006a8e:	220f      	movs	r2, #15
 8006a90:	18ba      	adds	r2, r7, r2
 8006a92:	7812      	ldrb	r2, [r2, #0]
 8006a94:	429a      	cmp	r2, r3
 8006a96:	d1a4      	bne.n	80069e2 <planner_recalculate+0x196>
 8006a98:	e000      	b.n	8006a9c <planner_recalculate+0x250>
{
  // Initialize block index to the last block in the planner buffer.
  uint8_t block_index = plan_prev_block_index(block_buffer_head);

  // Bail. Can't do anything with one only one plan-able block.
  if (block_index == block_buffer_planned) { return; }
 8006a9a:	46c0      	nop			; (mov r8, r8)
    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
    if (next->entry_speed_sqr == next->max_entry_speed_sqr) { block_buffer_planned = block_index; }
    block_index = plan_next_block_index( block_index );
  }
}
 8006a9c:	46bd      	mov	sp, r7
 8006a9e:	b005      	add	sp, #20
 8006aa0:	bd90      	pop	{r4, r7, pc}
 8006aa2:	46c0      	nop			; (mov r8, r8)
 8006aa4:	200003d9 	.word	0x200003d9
 8006aa8:	200003db 	.word	0x200003db
 8006aac:	20000098 	.word	0x20000098
 8006ab0:	200003d8 	.word	0x200003d8

08006ab4 <plan_reset>:


void plan_reset()
{
 8006ab4:	b580      	push	{r7, lr}
 8006ab6:	af00      	add	r7, sp, #0
  memset(&pl, 0, sizeof(planner_t)); // Clear planner struct
 8006ab8:	4b05      	ldr	r3, [pc, #20]	; (8006ad0 <plan_reset+0x1c>)
 8006aba:	221c      	movs	r2, #28
 8006abc:	2100      	movs	r1, #0
 8006abe:	0018      	movs	r0, r3
 8006ac0:	f005 fb1e 	bl	800c100 <memset>
  plan_reset_buffer();
 8006ac4:	f000 f806 	bl	8006ad4 <plan_reset_buffer>
}
 8006ac8:	46c0      	nop			; (mov r8, r8)
 8006aca:	46bd      	mov	sp, r7
 8006acc:	bd80      	pop	{r7, pc}
 8006ace:	46c0      	nop			; (mov r8, r8)
 8006ad0:	200003dc 	.word	0x200003dc

08006ad4 <plan_reset_buffer>:


void plan_reset_buffer()
{
 8006ad4:	b580      	push	{r7, lr}
 8006ad6:	af00      	add	r7, sp, #0
  block_buffer_tail = 0;
 8006ad8:	4b07      	ldr	r3, [pc, #28]	; (8006af8 <plan_reset_buffer+0x24>)
 8006ada:	2200      	movs	r2, #0
 8006adc:	701a      	strb	r2, [r3, #0]
  block_buffer_head = 0; // Empty = tail
 8006ade:	4b07      	ldr	r3, [pc, #28]	; (8006afc <plan_reset_buffer+0x28>)
 8006ae0:	2200      	movs	r2, #0
 8006ae2:	701a      	strb	r2, [r3, #0]
  next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
 8006ae4:	4b06      	ldr	r3, [pc, #24]	; (8006b00 <plan_reset_buffer+0x2c>)
 8006ae6:	2201      	movs	r2, #1
 8006ae8:	701a      	strb	r2, [r3, #0]
  block_buffer_planned = 0; // = block_buffer_tail;
 8006aea:	4b06      	ldr	r3, [pc, #24]	; (8006b04 <plan_reset_buffer+0x30>)
 8006aec:	2200      	movs	r2, #0
 8006aee:	701a      	strb	r2, [r3, #0]
}
 8006af0:	46c0      	nop			; (mov r8, r8)
 8006af2:	46bd      	mov	sp, r7
 8006af4:	bd80      	pop	{r7, pc}
 8006af6:	46c0      	nop			; (mov r8, r8)
 8006af8:	200003d8 	.word	0x200003d8
 8006afc:	200003d9 	.word	0x200003d9
 8006b00:	200003da 	.word	0x200003da
 8006b04:	200003db 	.word	0x200003db

08006b08 <plan_discard_current_block>:


void plan_discard_current_block()
{
 8006b08:	b590      	push	{r4, r7, lr}
 8006b0a:	b083      	sub	sp, #12
 8006b0c:	af00      	add	r7, sp, #0
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
 8006b0e:	4b10      	ldr	r3, [pc, #64]	; (8006b50 <plan_discard_current_block+0x48>)
 8006b10:	781a      	ldrb	r2, [r3, #0]
 8006b12:	4b10      	ldr	r3, [pc, #64]	; (8006b54 <plan_discard_current_block+0x4c>)
 8006b14:	781b      	ldrb	r3, [r3, #0]
 8006b16:	429a      	cmp	r2, r3
 8006b18:	d015      	beq.n	8006b46 <plan_discard_current_block+0x3e>
    uint8_t block_index = plan_next_block_index( block_buffer_tail );
 8006b1a:	4b0e      	ldr	r3, [pc, #56]	; (8006b54 <plan_discard_current_block+0x4c>)
 8006b1c:	781b      	ldrb	r3, [r3, #0]
 8006b1e:	1dfc      	adds	r4, r7, #7
 8006b20:	0018      	movs	r0, r3
 8006b22:	f7ff fe63 	bl	80067ec <plan_next_block_index>
 8006b26:	0003      	movs	r3, r0
 8006b28:	7023      	strb	r3, [r4, #0]
    // Push block_buffer_planned pointer, if encountered.
    if (block_buffer_tail == block_buffer_planned) { block_buffer_planned = block_index; }
 8006b2a:	4b0a      	ldr	r3, [pc, #40]	; (8006b54 <plan_discard_current_block+0x4c>)
 8006b2c:	781a      	ldrb	r2, [r3, #0]
 8006b2e:	4b0a      	ldr	r3, [pc, #40]	; (8006b58 <plan_discard_current_block+0x50>)
 8006b30:	781b      	ldrb	r3, [r3, #0]
 8006b32:	429a      	cmp	r2, r3
 8006b34:	d103      	bne.n	8006b3e <plan_discard_current_block+0x36>
 8006b36:	4b08      	ldr	r3, [pc, #32]	; (8006b58 <plan_discard_current_block+0x50>)
 8006b38:	1dfa      	adds	r2, r7, #7
 8006b3a:	7812      	ldrb	r2, [r2, #0]
 8006b3c:	701a      	strb	r2, [r3, #0]
    block_buffer_tail = block_index;
 8006b3e:	4b05      	ldr	r3, [pc, #20]	; (8006b54 <plan_discard_current_block+0x4c>)
 8006b40:	1dfa      	adds	r2, r7, #7
 8006b42:	7812      	ldrb	r2, [r2, #0]
 8006b44:	701a      	strb	r2, [r3, #0]
  }
}
 8006b46:	46c0      	nop			; (mov r8, r8)
 8006b48:	46bd      	mov	sp, r7
 8006b4a:	b003      	add	sp, #12
 8006b4c:	bd90      	pop	{r4, r7, pc}
 8006b4e:	46c0      	nop			; (mov r8, r8)
 8006b50:	200003d9 	.word	0x200003d9
 8006b54:	200003d8 	.word	0x200003d8
 8006b58:	200003db 	.word	0x200003db

08006b5c <plan_get_system_motion_block>:


// Returns address of planner buffer block used by system motions. Called by segment generator.
plan_block_t *plan_get_system_motion_block()
{
 8006b5c:	b580      	push	{r7, lr}
 8006b5e:	af00      	add	r7, sp, #0
  return(&block_buffer[block_buffer_head]);
 8006b60:	4b04      	ldr	r3, [pc, #16]	; (8006b74 <plan_get_system_motion_block+0x18>)
 8006b62:	781b      	ldrb	r3, [r3, #0]
 8006b64:	001a      	movs	r2, r3
 8006b66:	2334      	movs	r3, #52	; 0x34
 8006b68:	435a      	muls	r2, r3
 8006b6a:	4b03      	ldr	r3, [pc, #12]	; (8006b78 <plan_get_system_motion_block+0x1c>)
 8006b6c:	18d3      	adds	r3, r2, r3
}
 8006b6e:	0018      	movs	r0, r3
 8006b70:	46bd      	mov	sp, r7
 8006b72:	bd80      	pop	{r7, pc}
 8006b74:	200003d9 	.word	0x200003d9
 8006b78:	20000098 	.word	0x20000098

08006b7c <plan_get_current_block>:


// Returns address of first planner block, if available. Called by various main program functions.
plan_block_t *plan_get_current_block()
{
 8006b7c:	b580      	push	{r7, lr}
 8006b7e:	af00      	add	r7, sp, #0
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty
 8006b80:	4b08      	ldr	r3, [pc, #32]	; (8006ba4 <plan_get_current_block+0x28>)
 8006b82:	781a      	ldrb	r2, [r3, #0]
 8006b84:	4b08      	ldr	r3, [pc, #32]	; (8006ba8 <plan_get_current_block+0x2c>)
 8006b86:	781b      	ldrb	r3, [r3, #0]
 8006b88:	429a      	cmp	r2, r3
 8006b8a:	d101      	bne.n	8006b90 <plan_get_current_block+0x14>
 8006b8c:	2300      	movs	r3, #0
 8006b8e:	e006      	b.n	8006b9e <plan_get_current_block+0x22>
  return(&block_buffer[block_buffer_tail]);
 8006b90:	4b05      	ldr	r3, [pc, #20]	; (8006ba8 <plan_get_current_block+0x2c>)
 8006b92:	781b      	ldrb	r3, [r3, #0]
 8006b94:	001a      	movs	r2, r3
 8006b96:	2334      	movs	r3, #52	; 0x34
 8006b98:	435a      	muls	r2, r3
 8006b9a:	4b04      	ldr	r3, [pc, #16]	; (8006bac <plan_get_current_block+0x30>)
 8006b9c:	18d3      	adds	r3, r2, r3
}
 8006b9e:	0018      	movs	r0, r3
 8006ba0:	46bd      	mov	sp, r7
 8006ba2:	bd80      	pop	{r7, pc}
 8006ba4:	200003d9 	.word	0x200003d9
 8006ba8:	200003d8 	.word	0x200003d8
 8006bac:	20000098 	.word	0x20000098

08006bb0 <plan_get_exec_block_exit_speed_sqr>:


float plan_get_exec_block_exit_speed_sqr()
{
 8006bb0:	b590      	push	{r4, r7, lr}
 8006bb2:	b083      	sub	sp, #12
 8006bb4:	af00      	add	r7, sp, #0
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
 8006bb6:	4b0e      	ldr	r3, [pc, #56]	; (8006bf0 <plan_get_exec_block_exit_speed_sqr+0x40>)
 8006bb8:	781b      	ldrb	r3, [r3, #0]
 8006bba:	1dfc      	adds	r4, r7, #7
 8006bbc:	0018      	movs	r0, r3
 8006bbe:	f7ff fe15 	bl	80067ec <plan_next_block_index>
 8006bc2:	0003      	movs	r3, r0
 8006bc4:	7023      	strb	r3, [r4, #0]
  if (block_index == block_buffer_head) { return( 0.0 ); }
 8006bc6:	4b0b      	ldr	r3, [pc, #44]	; (8006bf4 <plan_get_exec_block_exit_speed_sqr+0x44>)
 8006bc8:	781b      	ldrb	r3, [r3, #0]
 8006bca:	1dfa      	adds	r2, r7, #7
 8006bcc:	7812      	ldrb	r2, [r2, #0]
 8006bce:	429a      	cmp	r2, r3
 8006bd0:	d101      	bne.n	8006bd6 <plan_get_exec_block_exit_speed_sqr+0x26>
 8006bd2:	2300      	movs	r3, #0
 8006bd4:	e007      	b.n	8006be6 <plan_get_exec_block_exit_speed_sqr+0x36>
  return( block_buffer[block_index].entry_speed_sqr );
 8006bd6:	1dfb      	adds	r3, r7, #7
 8006bd8:	781b      	ldrb	r3, [r3, #0]
 8006bda:	4a07      	ldr	r2, [pc, #28]	; (8006bf8 <plan_get_exec_block_exit_speed_sqr+0x48>)
 8006bdc:	2134      	movs	r1, #52	; 0x34
 8006bde:	434b      	muls	r3, r1
 8006be0:	18d3      	adds	r3, r2, r3
 8006be2:	3314      	adds	r3, #20
 8006be4:	681b      	ldr	r3, [r3, #0]
}
 8006be6:	1c18      	adds	r0, r3, #0
 8006be8:	46bd      	mov	sp, r7
 8006bea:	b003      	add	sp, #12
 8006bec:	bd90      	pop	{r4, r7, pc}
 8006bee:	46c0      	nop			; (mov r8, r8)
 8006bf0:	200003d8 	.word	0x200003d8
 8006bf4:	200003d9 	.word	0x200003d9
 8006bf8:	20000098 	.word	0x20000098

08006bfc <plan_check_full_buffer>:


// Returns the availability status of the block ring buffer. True, if full.
uint8_t plan_check_full_buffer()
{
 8006bfc:	b580      	push	{r7, lr}
 8006bfe:	af00      	add	r7, sp, #0
  if (block_buffer_tail == next_buffer_head) { return(true); }
 8006c00:	4b05      	ldr	r3, [pc, #20]	; (8006c18 <plan_check_full_buffer+0x1c>)
 8006c02:	781a      	ldrb	r2, [r3, #0]
 8006c04:	4b05      	ldr	r3, [pc, #20]	; (8006c1c <plan_check_full_buffer+0x20>)
 8006c06:	781b      	ldrb	r3, [r3, #0]
 8006c08:	429a      	cmp	r2, r3
 8006c0a:	d101      	bne.n	8006c10 <plan_check_full_buffer+0x14>
 8006c0c:	2301      	movs	r3, #1
 8006c0e:	e000      	b.n	8006c12 <plan_check_full_buffer+0x16>
  return(false);
 8006c10:	2300      	movs	r3, #0
}
 8006c12:	0018      	movs	r0, r3
 8006c14:	46bd      	mov	sp, r7
 8006c16:	bd80      	pop	{r7, pc}
 8006c18:	200003d8 	.word	0x200003d8
 8006c1c:	200003da 	.word	0x200003da

08006c20 <plan_compute_profile_nominal_speed>:


// Computes and returns block nominal speed based on running condition and override values.
// NOTE: All system motion commands, such as homing/parking, are not subject to overrides.
float plan_compute_profile_nominal_speed(plan_block_t *block)
{
 8006c20:	b580      	push	{r7, lr}
 8006c22:	b084      	sub	sp, #16
 8006c24:	af00      	add	r7, sp, #0
 8006c26:	6078      	str	r0, [r7, #4]
  float nominal_speed = block->programmed_rate;
 8006c28:	687b      	ldr	r3, [r7, #4]
 8006c2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006c2c:	60fb      	str	r3, [r7, #12]
  if (block->condition & PL_COND_FLAG_RAPID_MOTION) { nominal_speed *= (0.01f*sys.r_override); }
 8006c2e:	687b      	ldr	r3, [r7, #4]
 8006c30:	7c5b      	ldrb	r3, [r3, #17]
 8006c32:	001a      	movs	r2, r3
 8006c34:	2301      	movs	r3, #1
 8006c36:	4013      	ands	r3, r2
 8006c38:	d011      	beq.n	8006c5e <plan_compute_profile_nominal_speed+0x3e>
 8006c3a:	4b21      	ldr	r3, [pc, #132]	; (8006cc0 <plan_compute_profile_nominal_speed+0xa0>)
 8006c3c:	7a1b      	ldrb	r3, [r3, #8]
 8006c3e:	0018      	movs	r0, r3
 8006c40:	f7fa f9ba 	bl	8000fb8 <__aeabi_i2f>
 8006c44:	1c03      	adds	r3, r0, #0
 8006c46:	491f      	ldr	r1, [pc, #124]	; (8006cc4 <plan_compute_profile_nominal_speed+0xa4>)
 8006c48:	1c18      	adds	r0, r3, #0
 8006c4a:	f7f9 fee1 	bl	8000a10 <__aeabi_fmul>
 8006c4e:	1c03      	adds	r3, r0, #0
 8006c50:	1c19      	adds	r1, r3, #0
 8006c52:	68f8      	ldr	r0, [r7, #12]
 8006c54:	f7f9 fedc 	bl	8000a10 <__aeabi_fmul>
 8006c58:	1c03      	adds	r3, r0, #0
 8006c5a:	60fb      	str	r3, [r7, #12]
 8006c5c:	e021      	b.n	8006ca2 <plan_compute_profile_nominal_speed+0x82>
  else {
    if (!(block->condition & PL_COND_FLAG_NO_FEED_OVERRIDE)) { nominal_speed *= (0.01f*sys.f_override); }
 8006c5e:	687b      	ldr	r3, [r7, #4]
 8006c60:	7c5b      	ldrb	r3, [r3, #17]
 8006c62:	001a      	movs	r2, r3
 8006c64:	2304      	movs	r3, #4
 8006c66:	4013      	ands	r3, r2
 8006c68:	d110      	bne.n	8006c8c <plan_compute_profile_nominal_speed+0x6c>
 8006c6a:	4b15      	ldr	r3, [pc, #84]	; (8006cc0 <plan_compute_profile_nominal_speed+0xa0>)
 8006c6c:	79db      	ldrb	r3, [r3, #7]
 8006c6e:	0018      	movs	r0, r3
 8006c70:	f7fa f9a2 	bl	8000fb8 <__aeabi_i2f>
 8006c74:	1c03      	adds	r3, r0, #0
 8006c76:	4913      	ldr	r1, [pc, #76]	; (8006cc4 <plan_compute_profile_nominal_speed+0xa4>)
 8006c78:	1c18      	adds	r0, r3, #0
 8006c7a:	f7f9 fec9 	bl	8000a10 <__aeabi_fmul>
 8006c7e:	1c03      	adds	r3, r0, #0
 8006c80:	1c19      	adds	r1, r3, #0
 8006c82:	68f8      	ldr	r0, [r7, #12]
 8006c84:	f7f9 fec4 	bl	8000a10 <__aeabi_fmul>
 8006c88:	1c03      	adds	r3, r0, #0
 8006c8a:	60fb      	str	r3, [r7, #12]
    if (nominal_speed > block->rapid_rate) { nominal_speed = block->rapid_rate; }
 8006c8c:	687b      	ldr	r3, [r7, #4]
 8006c8e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006c90:	68f9      	ldr	r1, [r7, #12]
 8006c92:	1c18      	adds	r0, r3, #0
 8006c94:	f7f9 fb1e 	bl	80002d4 <__aeabi_fcmplt>
 8006c98:	1e03      	subs	r3, r0, #0
 8006c9a:	d002      	beq.n	8006ca2 <plan_compute_profile_nominal_speed+0x82>
 8006c9c:	687b      	ldr	r3, [r7, #4]
 8006c9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006ca0:	60fb      	str	r3, [r7, #12]
  }
  if (nominal_speed > MINIMUM_FEED_RATE) { return(nominal_speed); }
 8006ca2:	21fe      	movs	r1, #254	; 0xfe
 8006ca4:	0589      	lsls	r1, r1, #22
 8006ca6:	68f8      	ldr	r0, [r7, #12]
 8006ca8:	f7f9 fb28 	bl	80002fc <__aeabi_fcmpgt>
 8006cac:	1e03      	subs	r3, r0, #0
 8006cae:	d001      	beq.n	8006cb4 <plan_compute_profile_nominal_speed+0x94>
 8006cb0:	68fb      	ldr	r3, [r7, #12]
 8006cb2:	e001      	b.n	8006cb8 <plan_compute_profile_nominal_speed+0x98>
  return(MINIMUM_FEED_RATE);
 8006cb4:	23fe      	movs	r3, #254	; 0xfe
 8006cb6:	059b      	lsls	r3, r3, #22
}
 8006cb8:	1c18      	adds	r0, r3, #0
 8006cba:	46bd      	mov	sp, r7
 8006cbc:	b004      	add	sp, #16
 8006cbe:	bd80      	pop	{r7, pc}
 8006cc0:	20000b2c 	.word	0x20000b2c
 8006cc4:	3c23d70a 	.word	0x3c23d70a

08006cc8 <plan_compute_profile_parameters>:


// Computes and updates the max entry speed (sqr) of the block, based on the minimum of the junction's
// previous and current nominal speeds and max junction speed.
static void plan_compute_profile_parameters(plan_block_t *block, float nominal_speed, float prev_nominal_speed)
{
 8006cc8:	b580      	push	{r7, lr}
 8006cca:	b084      	sub	sp, #16
 8006ccc:	af00      	add	r7, sp, #0
 8006cce:	60f8      	str	r0, [r7, #12]
 8006cd0:	60b9      	str	r1, [r7, #8]
 8006cd2:	607a      	str	r2, [r7, #4]
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  if (nominal_speed > prev_nominal_speed) { block->max_entry_speed_sqr = prev_nominal_speed*prev_nominal_speed; }
 8006cd4:	6879      	ldr	r1, [r7, #4]
 8006cd6:	68b8      	ldr	r0, [r7, #8]
 8006cd8:	f7f9 fb10 	bl	80002fc <__aeabi_fcmpgt>
 8006cdc:	1e03      	subs	r3, r0, #0
 8006cde:	d008      	beq.n	8006cf2 <plan_compute_profile_parameters+0x2a>
 8006ce0:	6879      	ldr	r1, [r7, #4]
 8006ce2:	6878      	ldr	r0, [r7, #4]
 8006ce4:	f7f9 fe94 	bl	8000a10 <__aeabi_fmul>
 8006ce8:	1c03      	adds	r3, r0, #0
 8006cea:	1c1a      	adds	r2, r3, #0
 8006cec:	68fb      	ldr	r3, [r7, #12]
 8006cee:	619a      	str	r2, [r3, #24]
 8006cf0:	e007      	b.n	8006d02 <plan_compute_profile_parameters+0x3a>
  else { block->max_entry_speed_sqr = nominal_speed*nominal_speed; }
 8006cf2:	68b9      	ldr	r1, [r7, #8]
 8006cf4:	68b8      	ldr	r0, [r7, #8]
 8006cf6:	f7f9 fe8b 	bl	8000a10 <__aeabi_fmul>
 8006cfa:	1c03      	adds	r3, r0, #0
 8006cfc:	1c1a      	adds	r2, r3, #0
 8006cfe:	68fb      	ldr	r3, [r7, #12]
 8006d00:	619a      	str	r2, [r3, #24]
  if (block->max_entry_speed_sqr > block->max_junction_speed_sqr) { block->max_entry_speed_sqr = block->max_junction_speed_sqr; }
 8006d02:	68fb      	ldr	r3, [r7, #12]
 8006d04:	699a      	ldr	r2, [r3, #24]
 8006d06:	68fb      	ldr	r3, [r7, #12]
 8006d08:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006d0a:	1c19      	adds	r1, r3, #0
 8006d0c:	1c10      	adds	r0, r2, #0
 8006d0e:	f7f9 faf5 	bl	80002fc <__aeabi_fcmpgt>
 8006d12:	1e03      	subs	r3, r0, #0
 8006d14:	d100      	bne.n	8006d18 <plan_compute_profile_parameters+0x50>
}
 8006d16:	e003      	b.n	8006d20 <plan_compute_profile_parameters+0x58>
static void plan_compute_profile_parameters(plan_block_t *block, float nominal_speed, float prev_nominal_speed)
{
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  if (nominal_speed > prev_nominal_speed) { block->max_entry_speed_sqr = prev_nominal_speed*prev_nominal_speed; }
  else { block->max_entry_speed_sqr = nominal_speed*nominal_speed; }
  if (block->max_entry_speed_sqr > block->max_junction_speed_sqr) { block->max_entry_speed_sqr = block->max_junction_speed_sqr; }
 8006d18:	68fb      	ldr	r3, [r7, #12]
 8006d1a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006d1c:	68fb      	ldr	r3, [r7, #12]
 8006d1e:	619a      	str	r2, [r3, #24]
}
 8006d20:	46c0      	nop			; (mov r8, r8)
 8006d22:	46bd      	mov	sp, r7
 8006d24:	b004      	add	sp, #16
 8006d26:	bd80      	pop	{r7, pc}

08006d28 <plan_update_velocity_profile_parameters>:


// Re-calculates buffered motions profile parameters upon a motion-based override change.
void plan_update_velocity_profile_parameters()
{
 8006d28:	b590      	push	{r4, r7, lr}
 8006d2a:	b085      	sub	sp, #20
 8006d2c:	af00      	add	r7, sp, #0
  uint8_t block_index = block_buffer_tail;
 8006d2e:	230f      	movs	r3, #15
 8006d30:	18fb      	adds	r3, r7, r3
 8006d32:	4a1a      	ldr	r2, [pc, #104]	; (8006d9c <plan_update_velocity_profile_parameters+0x74>)
 8006d34:	7812      	ldrb	r2, [r2, #0]
 8006d36:	701a      	strb	r2, [r3, #0]
  plan_block_t *block;
  float nominal_speed;
  float prev_nominal_speed = SOME_LARGE_VALUE; // Set high for first block nominal speed calculation.
 8006d38:	4b19      	ldr	r3, [pc, #100]	; (8006da0 <plan_update_velocity_profile_parameters+0x78>)
 8006d3a:	60bb      	str	r3, [r7, #8]
  while (block_index != block_buffer_head) {
 8006d3c:	e01f      	b.n	8006d7e <plan_update_velocity_profile_parameters+0x56>
    block = &block_buffer[block_index];
 8006d3e:	230f      	movs	r3, #15
 8006d40:	18fb      	adds	r3, r7, r3
 8006d42:	781b      	ldrb	r3, [r3, #0]
 8006d44:	2234      	movs	r2, #52	; 0x34
 8006d46:	435a      	muls	r2, r3
 8006d48:	4b16      	ldr	r3, [pc, #88]	; (8006da4 <plan_update_velocity_profile_parameters+0x7c>)
 8006d4a:	18d3      	adds	r3, r2, r3
 8006d4c:	607b      	str	r3, [r7, #4]
    nominal_speed = plan_compute_profile_nominal_speed(block);
 8006d4e:	687b      	ldr	r3, [r7, #4]
 8006d50:	0018      	movs	r0, r3
 8006d52:	f7ff ff65 	bl	8006c20 <plan_compute_profile_nominal_speed>
 8006d56:	1c03      	adds	r3, r0, #0
 8006d58:	603b      	str	r3, [r7, #0]
    plan_compute_profile_parameters(block, nominal_speed, prev_nominal_speed);
 8006d5a:	68ba      	ldr	r2, [r7, #8]
 8006d5c:	6839      	ldr	r1, [r7, #0]
 8006d5e:	687b      	ldr	r3, [r7, #4]
 8006d60:	0018      	movs	r0, r3
 8006d62:	f7ff ffb1 	bl	8006cc8 <plan_compute_profile_parameters>
    prev_nominal_speed = nominal_speed;
 8006d66:	683b      	ldr	r3, [r7, #0]
 8006d68:	60bb      	str	r3, [r7, #8]
    block_index = plan_next_block_index(block_index);
 8006d6a:	230f      	movs	r3, #15
 8006d6c:	18fc      	adds	r4, r7, r3
 8006d6e:	230f      	movs	r3, #15
 8006d70:	18fb      	adds	r3, r7, r3
 8006d72:	781b      	ldrb	r3, [r3, #0]
 8006d74:	0018      	movs	r0, r3
 8006d76:	f7ff fd39 	bl	80067ec <plan_next_block_index>
 8006d7a:	0003      	movs	r3, r0
 8006d7c:	7023      	strb	r3, [r4, #0]
{
  uint8_t block_index = block_buffer_tail;
  plan_block_t *block;
  float nominal_speed;
  float prev_nominal_speed = SOME_LARGE_VALUE; // Set high for first block nominal speed calculation.
  while (block_index != block_buffer_head) {
 8006d7e:	4b0a      	ldr	r3, [pc, #40]	; (8006da8 <plan_update_velocity_profile_parameters+0x80>)
 8006d80:	781b      	ldrb	r3, [r3, #0]
 8006d82:	220f      	movs	r2, #15
 8006d84:	18ba      	adds	r2, r7, r2
 8006d86:	7812      	ldrb	r2, [r2, #0]
 8006d88:	429a      	cmp	r2, r3
 8006d8a:	d1d8      	bne.n	8006d3e <plan_update_velocity_profile_parameters+0x16>
    nominal_speed = plan_compute_profile_nominal_speed(block);
    plan_compute_profile_parameters(block, nominal_speed, prev_nominal_speed);
    prev_nominal_speed = nominal_speed;
    block_index = plan_next_block_index(block_index);
  }
  pl.previous_nominal_speed = prev_nominal_speed; // Update prev nominal speed for next incoming block.
 8006d8c:	4b07      	ldr	r3, [pc, #28]	; (8006dac <plan_update_velocity_profile_parameters+0x84>)
 8006d8e:	68ba      	ldr	r2, [r7, #8]
 8006d90:	619a      	str	r2, [r3, #24]
}
 8006d92:	46c0      	nop			; (mov r8, r8)
 8006d94:	46bd      	mov	sp, r7
 8006d96:	b005      	add	sp, #20
 8006d98:	bd90      	pop	{r4, r7, pc}
 8006d9a:	46c0      	nop			; (mov r8, r8)
 8006d9c:	200003d8 	.word	0x200003d8
 8006da0:	7f7fffff 	.word	0x7f7fffff
 8006da4:	20000098 	.word	0x20000098
 8006da8:	200003d9 	.word	0x200003d9
 8006dac:	200003dc 	.word	0x200003dc

08006db0 <plan_buffer_line>:
   The system motion condition tells the planner to plan a motion in the always unused block buffer
   head. It avoids changing the planner state and preserves the buffer to ensure subsequent gcode
   motions are still planned correctly, while the stepper module only points to the block buffer head
   to execute the special system motion. */
uint8_t plan_buffer_line(float *target, plan_line_data_t *pl_data)
{
 8006db0:	b590      	push	{r4, r7, lr}
 8006db2:	b097      	sub	sp, #92	; 0x5c
 8006db4:	af00      	add	r7, sp, #0
 8006db6:	6078      	str	r0, [r7, #4]
 8006db8:	6039      	str	r1, [r7, #0]
  // Prepare and initialize new block. Copy relevant pl_data for block execution.
  plan_block_t *block = &block_buffer[block_buffer_head];
 8006dba:	4bd6      	ldr	r3, [pc, #856]	; (8007114 <plan_buffer_line+0x364>)
 8006dbc:	781b      	ldrb	r3, [r3, #0]
 8006dbe:	001a      	movs	r2, r3
 8006dc0:	2334      	movs	r3, #52	; 0x34
 8006dc2:	435a      	muls	r2, r3
 8006dc4:	4bd4      	ldr	r3, [pc, #848]	; (8007118 <plan_buffer_line+0x368>)
 8006dc6:	18d3      	adds	r3, r2, r3
 8006dc8:	64fb      	str	r3, [r7, #76]	; 0x4c
  memset(block,0,sizeof(plan_block_t)); // Zero all block values.
 8006dca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006dcc:	2234      	movs	r2, #52	; 0x34
 8006dce:	2100      	movs	r1, #0
 8006dd0:	0018      	movs	r0, r3
 8006dd2:	f005 f995 	bl	800c100 <memset>
  block->condition = pl_data->condition;
 8006dd6:	683b      	ldr	r3, [r7, #0]
 8006dd8:	7a1a      	ldrb	r2, [r3, #8]
 8006dda:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006ddc:	745a      	strb	r2, [r3, #17]
  #ifdef VARIABLE_SPINDLE
    block->spindle_speed = pl_data->spindle_speed;
 8006dde:	683b      	ldr	r3, [r7, #0]
 8006de0:	685a      	ldr	r2, [r3, #4]
 8006de2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006de4:	631a      	str	r2, [r3, #48]	; 0x30
  int32_t target_steps[N_AXIS], position_steps[N_AXIS];
  float unit_vec[N_AXIS], delta_mm;
  uint8_t idx;

  // Copy position data based on type of motion being planned.
  if (block->condition & PL_COND_FLAG_SYSTEM_MOTION) {
 8006de6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006de8:	7c5b      	ldrb	r3, [r3, #17]
 8006dea:	001a      	movs	r2, r3
 8006dec:	2302      	movs	r3, #2
 8006dee:	4013      	ands	r3, r2
 8006df0:	d005      	beq.n	8006dfe <plan_buffer_line+0x4e>
#ifdef COREXY
    position_steps[X_AXIS] = system_convert_corexy_to_x_axis_steps(sys_position);
    position_steps[Y_AXIS] = system_convert_corexy_to_y_axis_steps(sys_position);
    position_steps[Z_AXIS] = sys_position[Z_AXIS];
#else
    memcpy(position_steps, sys_position, sizeof(sys_position));
 8006df2:	2324      	movs	r3, #36	; 0x24
 8006df4:	18fb      	adds	r3, r7, r3
 8006df6:	4ac9      	ldr	r2, [pc, #804]	; (800711c <plan_buffer_line+0x36c>)
 8006df8:	ca13      	ldmia	r2!, {r0, r1, r4}
 8006dfa:	c313      	stmia	r3!, {r0, r1, r4}
 8006dfc:	e004      	b.n	8006e08 <plan_buffer_line+0x58>
#endif
  }
  else { memcpy(position_steps, pl.position, sizeof(pl.position)); }
 8006dfe:	2324      	movs	r3, #36	; 0x24
 8006e00:	18fb      	adds	r3, r7, r3
 8006e02:	4ac7      	ldr	r2, [pc, #796]	; (8007120 <plan_buffer_line+0x370>)
 8006e04:	ca13      	ldmia	r2!, {r0, r1, r4}
 8006e06:	c313      	stmia	r3!, {r0, r1, r4}
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-position_steps[X_AXIS]) + (target_steps[Y_AXIS]-position_steps[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-position_steps[X_AXIS]) - (target_steps[Y_AXIS]-position_steps[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
 8006e08:	2357      	movs	r3, #87	; 0x57
 8006e0a:	18fb      	adds	r3, r7, r3
 8006e0c:	2200      	movs	r2, #0
 8006e0e:	701a      	strb	r2, [r3, #0]
 8006e10:	e087      	b.n	8006f22 <plan_buffer_line+0x172>
        delta_mm = (target_steps[X_AXIS]-position_steps[X_AXIS] - target_steps[Y_AXIS]+position_steps[Y_AXIS])/settings.steps_per_mm[idx];
      } else {
        delta_mm = (target_steps[idx] - position_steps[idx])/settings.steps_per_mm[idx];
      }
    #else
      target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
 8006e12:	2357      	movs	r3, #87	; 0x57
 8006e14:	18fb      	adds	r3, r7, r3
 8006e16:	781c      	ldrb	r4, [r3, #0]
 8006e18:	2357      	movs	r3, #87	; 0x57
 8006e1a:	18fb      	adds	r3, r7, r3
 8006e1c:	781b      	ldrb	r3, [r3, #0]
 8006e1e:	009b      	lsls	r3, r3, #2
 8006e20:	687a      	ldr	r2, [r7, #4]
 8006e22:	18d3      	adds	r3, r2, r3
 8006e24:	6818      	ldr	r0, [r3, #0]
 8006e26:	2357      	movs	r3, #87	; 0x57
 8006e28:	18fb      	adds	r3, r7, r3
 8006e2a:	781a      	ldrb	r2, [r3, #0]
 8006e2c:	4bbd      	ldr	r3, [pc, #756]	; (8007124 <plan_buffer_line+0x374>)
 8006e2e:	0092      	lsls	r2, r2, #2
 8006e30:	58d3      	ldr	r3, [r2, r3]
 8006e32:	1c19      	adds	r1, r3, #0
 8006e34:	f7f9 fdec 	bl	8000a10 <__aeabi_fmul>
 8006e38:	1c03      	adds	r3, r0, #0
 8006e3a:	1c18      	adds	r0, r3, #0
 8006e3c:	f7fb fc1c 	bl	8002678 <__aeabi_f2d>
 8006e40:	0002      	movs	r2, r0
 8006e42:	000b      	movs	r3, r1
 8006e44:	0010      	movs	r0, r2
 8006e46:	0019      	movs	r1, r3
 8006e48:	f005 f962 	bl	800c110 <lround>
 8006e4c:	0001      	movs	r1, r0
 8006e4e:	2330      	movs	r3, #48	; 0x30
 8006e50:	18fb      	adds	r3, r7, r3
 8006e52:	00a2      	lsls	r2, r4, #2
 8006e54:	50d1      	str	r1, [r2, r3]
      block->steps[idx] = labs(target_steps[idx]-position_steps[idx]);
 8006e56:	2357      	movs	r3, #87	; 0x57
 8006e58:	18fb      	adds	r3, r7, r3
 8006e5a:	781a      	ldrb	r2, [r3, #0]
 8006e5c:	2357      	movs	r3, #87	; 0x57
 8006e5e:	18fb      	adds	r3, r7, r3
 8006e60:	7819      	ldrb	r1, [r3, #0]
 8006e62:	2330      	movs	r3, #48	; 0x30
 8006e64:	18fb      	adds	r3, r7, r3
 8006e66:	0089      	lsls	r1, r1, #2
 8006e68:	58c9      	ldr	r1, [r1, r3]
 8006e6a:	2357      	movs	r3, #87	; 0x57
 8006e6c:	18fb      	adds	r3, r7, r3
 8006e6e:	7818      	ldrb	r0, [r3, #0]
 8006e70:	2324      	movs	r3, #36	; 0x24
 8006e72:	18fb      	adds	r3, r7, r3
 8006e74:	0080      	lsls	r0, r0, #2
 8006e76:	58c3      	ldr	r3, [r0, r3]
 8006e78:	1acb      	subs	r3, r1, r3
 8006e7a:	17d9      	asrs	r1, r3, #31
 8006e7c:	185b      	adds	r3, r3, r1
 8006e7e:	404b      	eors	r3, r1
 8006e80:	0019      	movs	r1, r3
 8006e82:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006e84:	0092      	lsls	r2, r2, #2
 8006e86:	50d1      	str	r1, [r2, r3]
      block->step_event_count = max(block->step_event_count, block->steps[idx]);
 8006e88:	2357      	movs	r3, #87	; 0x57
 8006e8a:	18fb      	adds	r3, r7, r3
 8006e8c:	781a      	ldrb	r2, [r3, #0]
 8006e8e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006e90:	0092      	lsls	r2, r2, #2
 8006e92:	58d1      	ldr	r1, [r2, r3]
 8006e94:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006e96:	68da      	ldr	r2, [r3, #12]
 8006e98:	1e0b      	subs	r3, r1, #0
 8006e9a:	4293      	cmp	r3, r2
 8006e9c:	d200      	bcs.n	8006ea0 <plan_buffer_line+0xf0>
 8006e9e:	0013      	movs	r3, r2
 8006ea0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8006ea2:	60d3      	str	r3, [r2, #12]
      delta_mm = (target_steps[idx] - position_steps[idx])/settings.steps_per_mm[idx];
 8006ea4:	2357      	movs	r3, #87	; 0x57
 8006ea6:	18fb      	adds	r3, r7, r3
 8006ea8:	781a      	ldrb	r2, [r3, #0]
 8006eaa:	2330      	movs	r3, #48	; 0x30
 8006eac:	18fb      	adds	r3, r7, r3
 8006eae:	0092      	lsls	r2, r2, #2
 8006eb0:	58d2      	ldr	r2, [r2, r3]
 8006eb2:	2357      	movs	r3, #87	; 0x57
 8006eb4:	18fb      	adds	r3, r7, r3
 8006eb6:	7819      	ldrb	r1, [r3, #0]
 8006eb8:	2324      	movs	r3, #36	; 0x24
 8006eba:	18fb      	adds	r3, r7, r3
 8006ebc:	0089      	lsls	r1, r1, #2
 8006ebe:	58cb      	ldr	r3, [r1, r3]
 8006ec0:	1ad3      	subs	r3, r2, r3
 8006ec2:	0018      	movs	r0, r3
 8006ec4:	f7fa f878 	bl	8000fb8 <__aeabi_i2f>
 8006ec8:	2357      	movs	r3, #87	; 0x57
 8006eca:	18fb      	adds	r3, r7, r3
 8006ecc:	781a      	ldrb	r2, [r3, #0]
 8006ece:	4b95      	ldr	r3, [pc, #596]	; (8007124 <plan_buffer_line+0x374>)
 8006ed0:	0092      	lsls	r2, r2, #2
 8006ed2:	58d3      	ldr	r3, [r2, r3]
 8006ed4:	1c19      	adds	r1, r3, #0
 8006ed6:	f7f9 fbd1 	bl	800067c <__aeabi_fdiv>
 8006eda:	1c03      	adds	r3, r0, #0
 8006edc:	64bb      	str	r3, [r7, #72]	; 0x48
	  #endif
    unit_vec[idx] = delta_mm; // Store unit vector numerator
 8006ede:	2357      	movs	r3, #87	; 0x57
 8006ee0:	18fb      	adds	r3, r7, r3
 8006ee2:	781a      	ldrb	r2, [r3, #0]
 8006ee4:	2318      	movs	r3, #24
 8006ee6:	18fb      	adds	r3, r7, r3
 8006ee8:	0092      	lsls	r2, r2, #2
 8006eea:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8006eec:	50d1      	str	r1, [r2, r3]

    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0.0f ) { block->direction_bits |= direction_pin_mask[idx]; }
 8006eee:	2100      	movs	r1, #0
 8006ef0:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8006ef2:	f7f9 f9ef 	bl	80002d4 <__aeabi_fcmplt>
 8006ef6:	1e03      	subs	r3, r0, #0
 8006ef8:	d00c      	beq.n	8006f14 <plan_buffer_line+0x164>
 8006efa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006efc:	7c1a      	ldrb	r2, [r3, #16]
 8006efe:	2357      	movs	r3, #87	; 0x57
 8006f00:	18fb      	adds	r3, r7, r3
 8006f02:	7819      	ldrb	r1, [r3, #0]
 8006f04:	4b88      	ldr	r3, [pc, #544]	; (8007128 <plan_buffer_line+0x378>)
 8006f06:	0049      	lsls	r1, r1, #1
 8006f08:	5acb      	ldrh	r3, [r1, r3]
 8006f0a:	b2db      	uxtb	r3, r3
 8006f0c:	4313      	orrs	r3, r2
 8006f0e:	b2da      	uxtb	r2, r3
 8006f10:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f12:	741a      	strb	r2, [r3, #16]
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-position_steps[X_AXIS]) + (target_steps[Y_AXIS]-position_steps[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-position_steps[X_AXIS]) - (target_steps[Y_AXIS]-position_steps[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
 8006f14:	2357      	movs	r3, #87	; 0x57
 8006f16:	18fb      	adds	r3, r7, r3
 8006f18:	781a      	ldrb	r2, [r3, #0]
 8006f1a:	2357      	movs	r3, #87	; 0x57
 8006f1c:	18fb      	adds	r3, r7, r3
 8006f1e:	3201      	adds	r2, #1
 8006f20:	701a      	strb	r2, [r3, #0]
 8006f22:	2357      	movs	r3, #87	; 0x57
 8006f24:	18fb      	adds	r3, r7, r3
 8006f26:	781b      	ldrb	r3, [r3, #0]
 8006f28:	2b02      	cmp	r3, #2
 8006f2a:	d800      	bhi.n	8006f2e <plan_buffer_line+0x17e>
 8006f2c:	e771      	b.n	8006e12 <plan_buffer_line+0x62>
    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0.0f ) { block->direction_bits |= direction_pin_mask[idx]; }
  }

  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return(PLAN_EMPTY_BLOCK); }
 8006f2e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f30:	68db      	ldr	r3, [r3, #12]
 8006f32:	2b00      	cmp	r3, #0
 8006f34:	d101      	bne.n	8006f3a <plan_buffer_line+0x18a>
 8006f36:	2300      	movs	r3, #0
 8006f38:	e150      	b.n	80071dc <plan_buffer_line+0x42c>

  // Calculate the unit vector of the line move and the block maximum feed rate and acceleration scaled
  // down such that no individual axes maximum values are exceeded with respect to the line direction.
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  block->millimeters = convert_delta_vector_to_unit_vector(unit_vec);
 8006f3a:	2318      	movs	r3, #24
 8006f3c:	18fb      	adds	r3, r7, r3
 8006f3e:	0018      	movs	r0, r3
 8006f40:	f7ff fb84 	bl	800664c <convert_delta_vector_to_unit_vector>
 8006f44:	1c02      	adds	r2, r0, #0
 8006f46:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f48:	621a      	str	r2, [r3, #32]
  block->acceleration = limit_value_by_axis_maximum(settings.acceleration, unit_vec);
 8006f4a:	2318      	movs	r3, #24
 8006f4c:	18fa      	adds	r2, r7, r3
 8006f4e:	4b77      	ldr	r3, [pc, #476]	; (800712c <plan_buffer_line+0x37c>)
 8006f50:	0011      	movs	r1, r2
 8006f52:	0018      	movs	r0, r3
 8006f54:	f7ff fbec 	bl	8006730 <limit_value_by_axis_maximum>
 8006f58:	1c02      	adds	r2, r0, #0
 8006f5a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f5c:	61da      	str	r2, [r3, #28]
  block->rapid_rate = limit_value_by_axis_maximum(settings.max_rate, unit_vec);
 8006f5e:	2318      	movs	r3, #24
 8006f60:	18fa      	adds	r2, r7, r3
 8006f62:	4b73      	ldr	r3, [pc, #460]	; (8007130 <plan_buffer_line+0x380>)
 8006f64:	0011      	movs	r1, r2
 8006f66:	0018      	movs	r0, r3
 8006f68:	f7ff fbe2 	bl	8006730 <limit_value_by_axis_maximum>
 8006f6c:	1c02      	adds	r2, r0, #0
 8006f6e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f70:	629a      	str	r2, [r3, #40]	; 0x28

  // Store programmed rate.
  if (block->condition & PL_COND_FLAG_RAPID_MOTION) { block->programmed_rate = block->rapid_rate; }
 8006f72:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f74:	7c5b      	ldrb	r3, [r3, #17]
 8006f76:	001a      	movs	r2, r3
 8006f78:	2301      	movs	r3, #1
 8006f7a:	4013      	ands	r3, r2
 8006f7c:	d004      	beq.n	8006f88 <plan_buffer_line+0x1d8>
 8006f7e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f80:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8006f82:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f84:	62da      	str	r2, [r3, #44]	; 0x2c
 8006f86:	e015      	b.n	8006fb4 <plan_buffer_line+0x204>
  else { 
    block->programmed_rate = pl_data->feed_rate;
 8006f88:	683b      	ldr	r3, [r7, #0]
 8006f8a:	681a      	ldr	r2, [r3, #0]
 8006f8c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f8e:	62da      	str	r2, [r3, #44]	; 0x2c
    if (block->condition & PL_COND_FLAG_INVERSE_TIME) { block->programmed_rate *= block->millimeters; }
 8006f90:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f92:	7c5b      	ldrb	r3, [r3, #17]
 8006f94:	001a      	movs	r2, r3
 8006f96:	2308      	movs	r3, #8
 8006f98:	4013      	ands	r3, r2
 8006f9a:	d00b      	beq.n	8006fb4 <plan_buffer_line+0x204>
 8006f9c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006f9e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8006fa0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006fa2:	6a1b      	ldr	r3, [r3, #32]
 8006fa4:	1c19      	adds	r1, r3, #0
 8006fa6:	1c10      	adds	r0, r2, #0
 8006fa8:	f7f9 fd32 	bl	8000a10 <__aeabi_fmul>
 8006fac:	1c03      	adds	r3, r0, #0
 8006fae:	1c1a      	adds	r2, r3, #0
 8006fb0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006fb2:	62da      	str	r2, [r3, #44]	; 0x2c
  }

  // TODO: Need to check this method handling zero junction speeds when starting from rest.
  if ((block_buffer_head == block_buffer_tail) || (block->condition & PL_COND_FLAG_SYSTEM_MOTION)) {
 8006fb4:	4b57      	ldr	r3, [pc, #348]	; (8007114 <plan_buffer_line+0x364>)
 8006fb6:	781a      	ldrb	r2, [r3, #0]
 8006fb8:	4b5e      	ldr	r3, [pc, #376]	; (8007134 <plan_buffer_line+0x384>)
 8006fba:	781b      	ldrb	r3, [r3, #0]
 8006fbc:	429a      	cmp	r2, r3
 8006fbe:	d005      	beq.n	8006fcc <plan_buffer_line+0x21c>
 8006fc0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006fc2:	7c5b      	ldrb	r3, [r3, #17]
 8006fc4:	001a      	movs	r2, r3
 8006fc6:	2302      	movs	r3, #2
 8006fc8:	4013      	ands	r3, r2
 8006fca:	d006      	beq.n	8006fda <plan_buffer_line+0x22a>

    // Initialize block entry speed as zero. Assume it will be starting from rest. Planner will correct this later.
    // If system motion, the system motion block always is assumed to start from rest and end at a complete stop.
    block->entry_speed_sqr = 0.0f;
 8006fcc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006fce:	2200      	movs	r2, #0
 8006fd0:	615a      	str	r2, [r3, #20]
    block->max_junction_speed_sqr = 0.0f; // Starting from rest. Enforce start from zero velocity.
 8006fd2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8006fd4:	2200      	movs	r2, #0
 8006fd6:	625a      	str	r2, [r3, #36]	; 0x24
 8006fd8:	e0cf      	b.n	800717a <plan_buffer_line+0x3ca>
    // changed dynamically during operation nor can the line move geometry. This must be kept in
    // memory in the event of a feedrate override changing the nominal speeds of blocks, which can
    // change the overall maximum entry speed conditions of all blocks.

    float junction_unit_vec[N_AXIS];
    float junction_cos_theta = 0.0f;
 8006fda:	2300      	movs	r3, #0
 8006fdc:	653b      	str	r3, [r7, #80]	; 0x50
    for (idx=0; idx<N_AXIS; idx++) {
 8006fde:	2357      	movs	r3, #87	; 0x57
 8006fe0:	18fb      	adds	r3, r7, r3
 8006fe2:	2200      	movs	r2, #0
 8006fe4:	701a      	strb	r2, [r3, #0]
 8006fe6:	e03c      	b.n	8007062 <plan_buffer_line+0x2b2>
      junction_cos_theta -= pl.previous_unit_vec[idx]*unit_vec[idx];
 8006fe8:	2357      	movs	r3, #87	; 0x57
 8006fea:	18fb      	adds	r3, r7, r3
 8006fec:	781b      	ldrb	r3, [r3, #0]
 8006fee:	4a4c      	ldr	r2, [pc, #304]	; (8007120 <plan_buffer_line+0x370>)
 8006ff0:	3302      	adds	r3, #2
 8006ff2:	009b      	lsls	r3, r3, #2
 8006ff4:	18d3      	adds	r3, r2, r3
 8006ff6:	3304      	adds	r3, #4
 8006ff8:	6818      	ldr	r0, [r3, #0]
 8006ffa:	2357      	movs	r3, #87	; 0x57
 8006ffc:	18fb      	adds	r3, r7, r3
 8006ffe:	781a      	ldrb	r2, [r3, #0]
 8007000:	2318      	movs	r3, #24
 8007002:	18fb      	adds	r3, r7, r3
 8007004:	0092      	lsls	r2, r2, #2
 8007006:	58d3      	ldr	r3, [r2, r3]
 8007008:	1c19      	adds	r1, r3, #0
 800700a:	f7f9 fd01 	bl	8000a10 <__aeabi_fmul>
 800700e:	1c03      	adds	r3, r0, #0
 8007010:	1c19      	adds	r1, r3, #0
 8007012:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8007014:	f7f9 fe10 	bl	8000c38 <__aeabi_fsub>
 8007018:	1c03      	adds	r3, r0, #0
 800701a:	653b      	str	r3, [r7, #80]	; 0x50
      junction_unit_vec[idx] = unit_vec[idx]-pl.previous_unit_vec[idx];
 800701c:	2357      	movs	r3, #87	; 0x57
 800701e:	18fb      	adds	r3, r7, r3
 8007020:	781c      	ldrb	r4, [r3, #0]
 8007022:	2357      	movs	r3, #87	; 0x57
 8007024:	18fb      	adds	r3, r7, r3
 8007026:	781a      	ldrb	r2, [r3, #0]
 8007028:	2318      	movs	r3, #24
 800702a:	18fb      	adds	r3, r7, r3
 800702c:	0092      	lsls	r2, r2, #2
 800702e:	58d0      	ldr	r0, [r2, r3]
 8007030:	2357      	movs	r3, #87	; 0x57
 8007032:	18fb      	adds	r3, r7, r3
 8007034:	781b      	ldrb	r3, [r3, #0]
 8007036:	4a3a      	ldr	r2, [pc, #232]	; (8007120 <plan_buffer_line+0x370>)
 8007038:	3302      	adds	r3, #2
 800703a:	009b      	lsls	r3, r3, #2
 800703c:	18d3      	adds	r3, r2, r3
 800703e:	3304      	adds	r3, #4
 8007040:	681b      	ldr	r3, [r3, #0]
 8007042:	1c19      	adds	r1, r3, #0
 8007044:	f7f9 fdf8 	bl	8000c38 <__aeabi_fsub>
 8007048:	1c03      	adds	r3, r0, #0
 800704a:	1c19      	adds	r1, r3, #0
 800704c:	230c      	movs	r3, #12
 800704e:	18fb      	adds	r3, r7, r3
 8007050:	00a2      	lsls	r2, r4, #2
 8007052:	50d1      	str	r1, [r2, r3]
    // memory in the event of a feedrate override changing the nominal speeds of blocks, which can
    // change the overall maximum entry speed conditions of all blocks.

    float junction_unit_vec[N_AXIS];
    float junction_cos_theta = 0.0f;
    for (idx=0; idx<N_AXIS; idx++) {
 8007054:	2357      	movs	r3, #87	; 0x57
 8007056:	18fb      	adds	r3, r7, r3
 8007058:	781a      	ldrb	r2, [r3, #0]
 800705a:	2357      	movs	r3, #87	; 0x57
 800705c:	18fb      	adds	r3, r7, r3
 800705e:	3201      	adds	r2, #1
 8007060:	701a      	strb	r2, [r3, #0]
 8007062:	2357      	movs	r3, #87	; 0x57
 8007064:	18fb      	adds	r3, r7, r3
 8007066:	781b      	ldrb	r3, [r3, #0]
 8007068:	2b02      	cmp	r3, #2
 800706a:	d9bd      	bls.n	8006fe8 <plan_buffer_line+0x238>
      junction_cos_theta -= pl.previous_unit_vec[idx]*unit_vec[idx];
      junction_unit_vec[idx] = unit_vec[idx]-pl.previous_unit_vec[idx];
    }

    // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
    if (junction_cos_theta > 0.999999f) {
 800706c:	4932      	ldr	r1, [pc, #200]	; (8007138 <plan_buffer_line+0x388>)
 800706e:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8007070:	f7f9 f944 	bl	80002fc <__aeabi_fcmpgt>
 8007074:	1e03      	subs	r3, r0, #0
 8007076:	d003      	beq.n	8007080 <plan_buffer_line+0x2d0>
      //  For a 0 degree acute junction, just set minimum junction speed.
      block->max_junction_speed_sqr = MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED;
 8007078:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800707a:	2200      	movs	r2, #0
 800707c:	625a      	str	r2, [r3, #36]	; 0x24
 800707e:	e07c      	b.n	800717a <plan_buffer_line+0x3ca>
    } else {
      if (junction_cos_theta < -0.999999f) {
 8007080:	492e      	ldr	r1, [pc, #184]	; (800713c <plan_buffer_line+0x38c>)
 8007082:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8007084:	f7f9 f926 	bl	80002d4 <__aeabi_fcmplt>
 8007088:	1e03      	subs	r3, r0, #0
 800708a:	d003      	beq.n	8007094 <plan_buffer_line+0x2e4>
        // Junction is a straight line or 180 degrees. Junction speed is infinite.
        block->max_junction_speed_sqr = SOME_LARGE_VALUE;
 800708c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800708e:	4a2c      	ldr	r2, [pc, #176]	; (8007140 <plan_buffer_line+0x390>)
 8007090:	625a      	str	r2, [r3, #36]	; 0x24
 8007092:	e072      	b.n	800717a <plan_buffer_line+0x3ca>
      } else {
        convert_delta_vector_to_unit_vector(junction_unit_vec);
 8007094:	230c      	movs	r3, #12
 8007096:	18fb      	adds	r3, r7, r3
 8007098:	0018      	movs	r0, r3
 800709a:	f7ff fad7 	bl	800664c <convert_delta_vector_to_unit_vector>
        float junction_acceleration = limit_value_by_axis_maximum(settings.acceleration, junction_unit_vec);
 800709e:	230c      	movs	r3, #12
 80070a0:	18fa      	adds	r2, r7, r3
 80070a2:	4b22      	ldr	r3, [pc, #136]	; (800712c <plan_buffer_line+0x37c>)
 80070a4:	0011      	movs	r1, r2
 80070a6:	0018      	movs	r0, r3
 80070a8:	f7ff fb42 	bl	8006730 <limit_value_by_axis_maximum>
 80070ac:	1c03      	adds	r3, r0, #0
 80070ae:	647b      	str	r3, [r7, #68]	; 0x44
        float sin_theta_d2 = sqrtf(0.5f*(1.0f-junction_cos_theta)); // Trig half angle identity. Always positive.
 80070b0:	6d39      	ldr	r1, [r7, #80]	; 0x50
 80070b2:	20fe      	movs	r0, #254	; 0xfe
 80070b4:	0580      	lsls	r0, r0, #22
 80070b6:	f7f9 fdbf 	bl	8000c38 <__aeabi_fsub>
 80070ba:	1c03      	adds	r3, r0, #0
 80070bc:	21fc      	movs	r1, #252	; 0xfc
 80070be:	0589      	lsls	r1, r1, #22
 80070c0:	1c18      	adds	r0, r3, #0
 80070c2:	f7f9 fca5 	bl	8000a10 <__aeabi_fmul>
 80070c6:	1c03      	adds	r3, r0, #0
 80070c8:	1c18      	adds	r0, r3, #0
 80070ca:	f005 f9ad 	bl	800c428 <sqrtf>
 80070ce:	1c03      	adds	r3, r0, #0
 80070d0:	643b      	str	r3, [r7, #64]	; 0x40
        block->max_junction_speed_sqr = max( MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED,
 80070d2:	4b14      	ldr	r3, [pc, #80]	; (8007124 <plan_buffer_line+0x374>)
 80070d4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80070d6:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80070d8:	1c18      	adds	r0, r3, #0
 80070da:	f7f9 fc99 	bl	8000a10 <__aeabi_fmul>
 80070de:	1c03      	adds	r3, r0, #0
 80070e0:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80070e2:	1c18      	adds	r0, r3, #0
 80070e4:	f7f9 fc94 	bl	8000a10 <__aeabi_fmul>
 80070e8:	1c03      	adds	r3, r0, #0
 80070ea:	1c1c      	adds	r4, r3, #0
 80070ec:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80070ee:	20fe      	movs	r0, #254	; 0xfe
 80070f0:	0580      	lsls	r0, r0, #22
 80070f2:	f7f9 fda1 	bl	8000c38 <__aeabi_fsub>
 80070f6:	1c03      	adds	r3, r0, #0
 80070f8:	1c19      	adds	r1, r3, #0
 80070fa:	1c20      	adds	r0, r4, #0
 80070fc:	f7f9 fabe 	bl	800067c <__aeabi_fdiv>
 8007100:	1c03      	adds	r3, r0, #0
 8007102:	2100      	movs	r1, #0
 8007104:	1c18      	adds	r0, r3, #0
 8007106:	f7f9 f8e5 	bl	80002d4 <__aeabi_fcmplt>
 800710a:	1e03      	subs	r3, r0, #0
 800710c:	d01a      	beq.n	8007144 <plan_buffer_line+0x394>
 800710e:	2200      	movs	r2, #0
 8007110:	e031      	b.n	8007176 <plan_buffer_line+0x3c6>
 8007112:	46c0      	nop			; (mov r8, r8)
 8007114:	200003d9 	.word	0x200003d9
 8007118:	20000098 	.word	0x20000098
 800711c:	20000b50 	.word	0x20000b50
 8007120:	200003dc 	.word	0x200003dc
 8007124:	20000acc 	.word	0x20000acc
 8007128:	0800da88 	.word	0x0800da88
 800712c:	20000ae4 	.word	0x20000ae4
 8007130:	20000ad8 	.word	0x20000ad8
 8007134:	200003d8 	.word	0x200003d8
 8007138:	3f7fffef 	.word	0x3f7fffef
 800713c:	bf7fffef 	.word	0xbf7fffef
 8007140:	7f7fffff 	.word	0x7f7fffff
 8007144:	4b27      	ldr	r3, [pc, #156]	; (80071e4 <plan_buffer_line+0x434>)
 8007146:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007148:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800714a:	1c18      	adds	r0, r3, #0
 800714c:	f7f9 fc60 	bl	8000a10 <__aeabi_fmul>
 8007150:	1c03      	adds	r3, r0, #0
 8007152:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8007154:	1c18      	adds	r0, r3, #0
 8007156:	f7f9 fc5b 	bl	8000a10 <__aeabi_fmul>
 800715a:	1c03      	adds	r3, r0, #0
 800715c:	1c1c      	adds	r4, r3, #0
 800715e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8007160:	20fe      	movs	r0, #254	; 0xfe
 8007162:	0580      	lsls	r0, r0, #22
 8007164:	f7f9 fd68 	bl	8000c38 <__aeabi_fsub>
 8007168:	1c03      	adds	r3, r0, #0
 800716a:	1c19      	adds	r1, r3, #0
 800716c:	1c20      	adds	r0, r4, #0
 800716e:	f7f9 fa85 	bl	800067c <__aeabi_fdiv>
 8007172:	1c03      	adds	r3, r0, #0
 8007174:	1c1a      	adds	r2, r3, #0
 8007176:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007178:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
  }

  // Block system motion from updating this data to ensure next g-code motion is computed correctly.
  if (!(block->condition & PL_COND_FLAG_SYSTEM_MOTION)) {
 800717a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800717c:	7c5b      	ldrb	r3, [r3, #17]
 800717e:	001a      	movs	r2, r3
 8007180:	2302      	movs	r3, #2
 8007182:	4013      	ands	r3, r2
 8007184:	d129      	bne.n	80071da <plan_buffer_line+0x42a>
    float nominal_speed = plan_compute_profile_nominal_speed(block);
 8007186:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007188:	0018      	movs	r0, r3
 800718a:	f7ff fd49 	bl	8006c20 <plan_compute_profile_nominal_speed>
 800718e:	1c03      	adds	r3, r0, #0
 8007190:	63fb      	str	r3, [r7, #60]	; 0x3c
    plan_compute_profile_parameters(block, nominal_speed, pl.previous_nominal_speed);
 8007192:	4b15      	ldr	r3, [pc, #84]	; (80071e8 <plan_buffer_line+0x438>)
 8007194:	699a      	ldr	r2, [r3, #24]
 8007196:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8007198:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800719a:	0018      	movs	r0, r3
 800719c:	f7ff fd94 	bl	8006cc8 <plan_compute_profile_parameters>
    pl.previous_nominal_speed = nominal_speed;
 80071a0:	4b11      	ldr	r3, [pc, #68]	; (80071e8 <plan_buffer_line+0x438>)
 80071a2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80071a4:	619a      	str	r2, [r3, #24]

    // Update previous path unit_vector and planner position.
    memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[]
 80071a6:	4b10      	ldr	r3, [pc, #64]	; (80071e8 <plan_buffer_line+0x438>)
 80071a8:	2218      	movs	r2, #24
 80071aa:	18ba      	adds	r2, r7, r2
 80071ac:	330c      	adds	r3, #12
 80071ae:	ca13      	ldmia	r2!, {r0, r1, r4}
 80071b0:	c313      	stmia	r3!, {r0, r1, r4}
    memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
 80071b2:	4b0d      	ldr	r3, [pc, #52]	; (80071e8 <plan_buffer_line+0x438>)
 80071b4:	2230      	movs	r2, #48	; 0x30
 80071b6:	18ba      	adds	r2, r7, r2
 80071b8:	ca13      	ldmia	r2!, {r0, r1, r4}
 80071ba:	c313      	stmia	r3!, {r0, r1, r4}

    // New block is all set. Update buffer head and next buffer head indices.
    block_buffer_head = next_buffer_head;
 80071bc:	4b0b      	ldr	r3, [pc, #44]	; (80071ec <plan_buffer_line+0x43c>)
 80071be:	781a      	ldrb	r2, [r3, #0]
 80071c0:	4b0b      	ldr	r3, [pc, #44]	; (80071f0 <plan_buffer_line+0x440>)
 80071c2:	701a      	strb	r2, [r3, #0]
    next_buffer_head = plan_next_block_index(block_buffer_head);
 80071c4:	4b0a      	ldr	r3, [pc, #40]	; (80071f0 <plan_buffer_line+0x440>)
 80071c6:	781b      	ldrb	r3, [r3, #0]
 80071c8:	0018      	movs	r0, r3
 80071ca:	f7ff fb0f 	bl	80067ec <plan_next_block_index>
 80071ce:	0003      	movs	r3, r0
 80071d0:	001a      	movs	r2, r3
 80071d2:	4b06      	ldr	r3, [pc, #24]	; (80071ec <plan_buffer_line+0x43c>)
 80071d4:	701a      	strb	r2, [r3, #0]

    // Finish up by recalculating the plan with the new block.
    planner_recalculate();
 80071d6:	f7ff fb39 	bl	800684c <planner_recalculate>
  }
  return(PLAN_OK);
 80071da:	2301      	movs	r3, #1
}
 80071dc:	0018      	movs	r0, r3
 80071de:	46bd      	mov	sp, r7
 80071e0:	b017      	add	sp, #92	; 0x5c
 80071e2:	bd90      	pop	{r4, r7, pc}
 80071e4:	20000acc 	.word	0x20000acc
 80071e8:	200003dc 	.word	0x200003dc
 80071ec:	200003da 	.word	0x200003da
 80071f0:	200003d9 	.word	0x200003d9

080071f4 <plan_sync_position>:


// Reset the planner position vectors. Called by the system abort/initialization routine.
void plan_sync_position()
{
 80071f4:	b580      	push	{r7, lr}
 80071f6:	b082      	sub	sp, #8
 80071f8:	af00      	add	r7, sp, #0
  // TODO: For motor configurations not in the same coordinate frame as the machine position,
  // this function needs to be updated to accomodate the difference.
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 80071fa:	1dfb      	adds	r3, r7, #7
 80071fc:	2200      	movs	r2, #0
 80071fe:	701a      	strb	r2, [r3, #0]
 8007200:	e00e      	b.n	8007220 <plan_sync_position+0x2c>
        pl.position[Y_AXIS] = system_convert_corexy_to_y_axis_steps(sys_position);
      } else {
        pl.position[idx] = sys_position[idx];
      }
    #else
      pl.position[idx] = sys_position[idx];
 8007202:	1dfb      	adds	r3, r7, #7
 8007204:	781a      	ldrb	r2, [r3, #0]
 8007206:	1dfb      	adds	r3, r7, #7
 8007208:	7819      	ldrb	r1, [r3, #0]
 800720a:	4b09      	ldr	r3, [pc, #36]	; (8007230 <plan_sync_position+0x3c>)
 800720c:	0089      	lsls	r1, r1, #2
 800720e:	58c9      	ldr	r1, [r1, r3]
 8007210:	4b08      	ldr	r3, [pc, #32]	; (8007234 <plan_sync_position+0x40>)
 8007212:	0092      	lsls	r2, r2, #2
 8007214:	50d1      	str	r1, [r2, r3]
void plan_sync_position()
{
  // TODO: For motor configurations not in the same coordinate frame as the machine position,
  // this function needs to be updated to accomodate the difference.
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 8007216:	1dfb      	adds	r3, r7, #7
 8007218:	781a      	ldrb	r2, [r3, #0]
 800721a:	1dfb      	adds	r3, r7, #7
 800721c:	3201      	adds	r2, #1
 800721e:	701a      	strb	r2, [r3, #0]
 8007220:	1dfb      	adds	r3, r7, #7
 8007222:	781b      	ldrb	r3, [r3, #0]
 8007224:	2b02      	cmp	r3, #2
 8007226:	d9ec      	bls.n	8007202 <plan_sync_position+0xe>
      }
    #else
      pl.position[idx] = sys_position[idx];
    #endif
  }
}
 8007228:	46c0      	nop			; (mov r8, r8)
 800722a:	46bd      	mov	sp, r7
 800722c:	b002      	add	sp, #8
 800722e:	bd80      	pop	{r7, pc}
 8007230:	20000b50 	.word	0x20000b50
 8007234:	200003dc 	.word	0x200003dc

08007238 <plan_get_block_buffer_available>:


// Returns the number of available blocks are in the planner buffer.
uint8_t plan_get_block_buffer_available()
{
 8007238:	b580      	push	{r7, lr}
 800723a:	af00      	add	r7, sp, #0
  if (block_buffer_head >= block_buffer_tail) { return((BLOCK_BUFFER_SIZE-1)-(block_buffer_head-block_buffer_tail)); }
 800723c:	4b0c      	ldr	r3, [pc, #48]	; (8007270 <plan_get_block_buffer_available+0x38>)
 800723e:	781a      	ldrb	r2, [r3, #0]
 8007240:	4b0c      	ldr	r3, [pc, #48]	; (8007274 <plan_get_block_buffer_available+0x3c>)
 8007242:	781b      	ldrb	r3, [r3, #0]
 8007244:	429a      	cmp	r2, r3
 8007246:	d308      	bcc.n	800725a <plan_get_block_buffer_available+0x22>
 8007248:	4b0a      	ldr	r3, [pc, #40]	; (8007274 <plan_get_block_buffer_available+0x3c>)
 800724a:	781a      	ldrb	r2, [r3, #0]
 800724c:	4b08      	ldr	r3, [pc, #32]	; (8007270 <plan_get_block_buffer_available+0x38>)
 800724e:	781b      	ldrb	r3, [r3, #0]
 8007250:	1ad3      	subs	r3, r2, r3
 8007252:	b2db      	uxtb	r3, r3
 8007254:	330f      	adds	r3, #15
 8007256:	b2db      	uxtb	r3, r3
 8007258:	e007      	b.n	800726a <plan_get_block_buffer_available+0x32>
  return((block_buffer_tail-block_buffer_head-1));
 800725a:	4b06      	ldr	r3, [pc, #24]	; (8007274 <plan_get_block_buffer_available+0x3c>)
 800725c:	781a      	ldrb	r2, [r3, #0]
 800725e:	4b04      	ldr	r3, [pc, #16]	; (8007270 <plan_get_block_buffer_available+0x38>)
 8007260:	781b      	ldrb	r3, [r3, #0]
 8007262:	1ad3      	subs	r3, r2, r3
 8007264:	b2db      	uxtb	r3, r3
 8007266:	3b01      	subs	r3, #1
 8007268:	b2db      	uxtb	r3, r3
}
 800726a:	0018      	movs	r0, r3
 800726c:	46bd      	mov	sp, r7
 800726e:	bd80      	pop	{r7, pc}
 8007270:	200003d9 	.word	0x200003d9
 8007274:	200003d8 	.word	0x200003d8

08007278 <plan_cycle_reinitialize>:


// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
 8007278:	b580      	push	{r7, lr}
 800727a:	af00      	add	r7, sp, #0
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
 800727c:	f003 f95e 	bl	800a53c <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
 8007280:	4b04      	ldr	r3, [pc, #16]	; (8007294 <plan_cycle_reinitialize+0x1c>)
 8007282:	781a      	ldrb	r2, [r3, #0]
 8007284:	4b04      	ldr	r3, [pc, #16]	; (8007298 <plan_cycle_reinitialize+0x20>)
 8007286:	701a      	strb	r2, [r3, #0]
  planner_recalculate();
 8007288:	f7ff fae0 	bl	800684c <planner_recalculate>
}
 800728c:	46c0      	nop			; (mov r8, r8)
 800728e:	46bd      	mov	sp, r7
 8007290:	bd80      	pop	{r7, pc}
 8007292:	46c0      	nop			; (mov r8, r8)
 8007294:	200003d8 	.word	0x200003d8
 8007298:	200003db 	.word	0x200003db

0800729c <printString>:

#include "grbl.h"


void printString(const char *s)
{
 800729c:	b580      	push	{r7, lr}
 800729e:	b082      	sub	sp, #8
 80072a0:	af00      	add	r7, sp, #0
 80072a2:	6078      	str	r0, [r7, #4]
  while (*s)
 80072a4:	e006      	b.n	80072b4 <printString+0x18>
    serial_write(*s++);
 80072a6:	687b      	ldr	r3, [r7, #4]
 80072a8:	1c5a      	adds	r2, r3, #1
 80072aa:	607a      	str	r2, [r7, #4]
 80072ac:	781b      	ldrb	r3, [r3, #0]
 80072ae:	0018      	movs	r0, r3
 80072b0:	f001 fea6 	bl	8009000 <serial_write>
#include "grbl.h"


void printString(const char *s)
{
  while (*s)
 80072b4:	687b      	ldr	r3, [r7, #4]
 80072b6:	781b      	ldrb	r3, [r3, #0]
 80072b8:	2b00      	cmp	r3, #0
 80072ba:	d1f4      	bne.n	80072a6 <printString+0xa>
    serial_write(*s++);
}
 80072bc:	46c0      	nop			; (mov r8, r8)
 80072be:	46bd      	mov	sp, r7
 80072c0:	b002      	add	sp, #8
 80072c2:	bd80      	pop	{r7, pc}

080072c4 <print_uint8_base10>:
// }


// Prints an uint8 variable in base 10.
void print_uint8_base10(uint8_t n)
{
 80072c4:	b590      	push	{r4, r7, lr}
 80072c6:	b085      	sub	sp, #20
 80072c8:	af00      	add	r7, sp, #0
 80072ca:	0002      	movs	r2, r0
 80072cc:	1dfb      	adds	r3, r7, #7
 80072ce:	701a      	strb	r2, [r3, #0]
  uint8_t digit_a = 0;
 80072d0:	230f      	movs	r3, #15
 80072d2:	18fb      	adds	r3, r7, r3
 80072d4:	2200      	movs	r2, #0
 80072d6:	701a      	strb	r2, [r3, #0]
  uint8_t digit_b = 0;
 80072d8:	230e      	movs	r3, #14
 80072da:	18fb      	adds	r3, r7, r3
 80072dc:	2200      	movs	r2, #0
 80072de:	701a      	strb	r2, [r3, #0]
  if (n >= 100) { // 100-255
 80072e0:	1dfb      	adds	r3, r7, #7
 80072e2:	781b      	ldrb	r3, [r3, #0]
 80072e4:	2b63      	cmp	r3, #99	; 0x63
 80072e6:	d914      	bls.n	8007312 <print_uint8_base10+0x4e>
    digit_a = '0' + n % 10;
 80072e8:	1dfb      	adds	r3, r7, #7
 80072ea:	781b      	ldrb	r3, [r3, #0]
 80072ec:	210a      	movs	r1, #10
 80072ee:	0018      	movs	r0, r3
 80072f0:	f7f8 ff9a 	bl	8000228 <__aeabi_uidivmod>
 80072f4:	000b      	movs	r3, r1
 80072f6:	b2da      	uxtb	r2, r3
 80072f8:	230f      	movs	r3, #15
 80072fa:	18fb      	adds	r3, r7, r3
 80072fc:	3230      	adds	r2, #48	; 0x30
 80072fe:	701a      	strb	r2, [r3, #0]
    n /= 10;
 8007300:	1dfc      	adds	r4, r7, #7
 8007302:	1dfb      	adds	r3, r7, #7
 8007304:	781b      	ldrb	r3, [r3, #0]
 8007306:	210a      	movs	r1, #10
 8007308:	0018      	movs	r0, r3
 800730a:	f7f8 ff07 	bl	800011c <__aeabi_uidiv>
 800730e:	0003      	movs	r3, r0
 8007310:	7023      	strb	r3, [r4, #0]
  }
  if (n >= 10) { // 10-99
 8007312:	1dfb      	adds	r3, r7, #7
 8007314:	781b      	ldrb	r3, [r3, #0]
 8007316:	2b09      	cmp	r3, #9
 8007318:	d914      	bls.n	8007344 <print_uint8_base10+0x80>
    digit_b = '0' + n % 10;
 800731a:	1dfb      	adds	r3, r7, #7
 800731c:	781b      	ldrb	r3, [r3, #0]
 800731e:	210a      	movs	r1, #10
 8007320:	0018      	movs	r0, r3
 8007322:	f7f8 ff81 	bl	8000228 <__aeabi_uidivmod>
 8007326:	000b      	movs	r3, r1
 8007328:	b2da      	uxtb	r2, r3
 800732a:	230e      	movs	r3, #14
 800732c:	18fb      	adds	r3, r7, r3
 800732e:	3230      	adds	r2, #48	; 0x30
 8007330:	701a      	strb	r2, [r3, #0]
    n /= 10;
 8007332:	1dfc      	adds	r4, r7, #7
 8007334:	1dfb      	adds	r3, r7, #7
 8007336:	781b      	ldrb	r3, [r3, #0]
 8007338:	210a      	movs	r1, #10
 800733a:	0018      	movs	r0, r3
 800733c:	f7f8 feee 	bl	800011c <__aeabi_uidiv>
 8007340:	0003      	movs	r3, r0
 8007342:	7023      	strb	r3, [r4, #0]
  }
  serial_write('0' + n);
 8007344:	1dfb      	adds	r3, r7, #7
 8007346:	781b      	ldrb	r3, [r3, #0]
 8007348:	3330      	adds	r3, #48	; 0x30
 800734a:	b2db      	uxtb	r3, r3
 800734c:	0018      	movs	r0, r3
 800734e:	f001 fe57 	bl	8009000 <serial_write>
  if (digit_b) { serial_write(digit_b); }
 8007352:	230e      	movs	r3, #14
 8007354:	18fb      	adds	r3, r7, r3
 8007356:	781b      	ldrb	r3, [r3, #0]
 8007358:	2b00      	cmp	r3, #0
 800735a:	d005      	beq.n	8007368 <print_uint8_base10+0xa4>
 800735c:	230e      	movs	r3, #14
 800735e:	18fb      	adds	r3, r7, r3
 8007360:	781b      	ldrb	r3, [r3, #0]
 8007362:	0018      	movs	r0, r3
 8007364:	f001 fe4c 	bl	8009000 <serial_write>
  if (digit_a) { serial_write(digit_a); }
 8007368:	230f      	movs	r3, #15
 800736a:	18fb      	adds	r3, r7, r3
 800736c:	781b      	ldrb	r3, [r3, #0]
 800736e:	2b00      	cmp	r3, #0
 8007370:	d005      	beq.n	800737e <print_uint8_base10+0xba>
 8007372:	230f      	movs	r3, #15
 8007374:	18fb      	adds	r3, r7, r3
 8007376:	781b      	ldrb	r3, [r3, #0]
 8007378:	0018      	movs	r0, r3
 800737a:	f001 fe41 	bl	8009000 <serial_write>
}
 800737e:	46c0      	nop			; (mov r8, r8)
 8007380:	46bd      	mov	sp, r7
 8007382:	b005      	add	sp, #20
 8007384:	bd90      	pop	{r4, r7, pc}
 8007386:	46c0      	nop			; (mov r8, r8)

08007388 <printFloat>:
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
 8007388:	b590      	push	{r4, r7, lr}
 800738a:	b089      	sub	sp, #36	; 0x24
 800738c:	af00      	add	r7, sp, #0
 800738e:	6078      	str	r0, [r7, #4]
 8007390:	000a      	movs	r2, r1
 8007392:	1cfb      	adds	r3, r7, #3
 8007394:	701a      	strb	r2, [r3, #0]
  if (n < 0) {
 8007396:	2100      	movs	r1, #0
 8007398:	6878      	ldr	r0, [r7, #4]
 800739a:	f7f8 ff9b 	bl	80002d4 <__aeabi_fcmplt>
 800739e:	1e03      	subs	r3, r0, #0
 80073a0:	d007      	beq.n	80073b2 <printFloat+0x2a>
    serial_write('-');
 80073a2:	202d      	movs	r0, #45	; 0x2d
 80073a4:	f001 fe2c 	bl	8009000 <serial_write>
    n = -n;
 80073a8:	687b      	ldr	r3, [r7, #4]
 80073aa:	2280      	movs	r2, #128	; 0x80
 80073ac:	0612      	lsls	r2, r2, #24
 80073ae:	4053      	eors	r3, r2
 80073b0:	607b      	str	r3, [r7, #4]
  }

  uint8_t decimals = decimal_places;
 80073b2:	231f      	movs	r3, #31
 80073b4:	18fb      	adds	r3, r7, r3
 80073b6:	1cfa      	adds	r2, r7, #3
 80073b8:	7812      	ldrb	r2, [r2, #0]
 80073ba:	701a      	strb	r2, [r3, #0]
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
 80073bc:	e00c      	b.n	80073d8 <printFloat+0x50>
    n *= 100;
 80073be:	494c      	ldr	r1, [pc, #304]	; (80074f0 <printFloat+0x168>)
 80073c0:	6878      	ldr	r0, [r7, #4]
 80073c2:	f7f9 fb25 	bl	8000a10 <__aeabi_fmul>
 80073c6:	1c03      	adds	r3, r0, #0
 80073c8:	607b      	str	r3, [r7, #4]
    decimals -= 2;
 80073ca:	231f      	movs	r3, #31
 80073cc:	18fb      	adds	r3, r7, r3
 80073ce:	221f      	movs	r2, #31
 80073d0:	18ba      	adds	r2, r7, r2
 80073d2:	7812      	ldrb	r2, [r2, #0]
 80073d4:	3a02      	subs	r2, #2
 80073d6:	701a      	strb	r2, [r3, #0]
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
 80073d8:	231f      	movs	r3, #31
 80073da:	18fb      	adds	r3, r7, r3
 80073dc:	781b      	ldrb	r3, [r3, #0]
 80073de:	2b01      	cmp	r3, #1
 80073e0:	d8ed      	bhi.n	80073be <printFloat+0x36>
    n *= 100;
    decimals -= 2;
  }
  if (decimals) { n *= 10; }
 80073e2:	231f      	movs	r3, #31
 80073e4:	18fb      	adds	r3, r7, r3
 80073e6:	781b      	ldrb	r3, [r3, #0]
 80073e8:	2b00      	cmp	r3, #0
 80073ea:	d005      	beq.n	80073f8 <printFloat+0x70>
 80073ec:	4941      	ldr	r1, [pc, #260]	; (80074f4 <printFloat+0x16c>)
 80073ee:	6878      	ldr	r0, [r7, #4]
 80073f0:	f7f9 fb0e 	bl	8000a10 <__aeabi_fmul>
 80073f4:	1c03      	adds	r3, r0, #0
 80073f6:	607b      	str	r3, [r7, #4]
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
 80073f8:	21fc      	movs	r1, #252	; 0xfc
 80073fa:	0589      	lsls	r1, r1, #22
 80073fc:	6878      	ldr	r0, [r7, #4]
 80073fe:	f7f8 ffc7 	bl	8000390 <__aeabi_fadd>
 8007402:	1c03      	adds	r3, r0, #0
 8007404:	607b      	str	r3, [r7, #4]

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
 8007406:	231e      	movs	r3, #30
 8007408:	18fb      	adds	r3, r7, r3
 800740a:	2200      	movs	r2, #0
 800740c:	701a      	strb	r2, [r3, #0]
  uint32_t a = (long)n;
 800740e:	6878      	ldr	r0, [r7, #4]
 8007410:	f7f9 fdb0 	bl	8000f74 <__aeabi_f2iz>
 8007414:	0003      	movs	r3, r0
 8007416:	61bb      	str	r3, [r7, #24]
  while(a > 0) {
 8007418:	e01a      	b.n	8007450 <printFloat+0xc8>
    buf[i++] = (a % 10) + '0'; // Get digit
 800741a:	231e      	movs	r3, #30
 800741c:	18fb      	adds	r3, r7, r3
 800741e:	781b      	ldrb	r3, [r3, #0]
 8007420:	221e      	movs	r2, #30
 8007422:	18ba      	adds	r2, r7, r2
 8007424:	1c59      	adds	r1, r3, #1
 8007426:	7011      	strb	r1, [r2, #0]
 8007428:	001c      	movs	r4, r3
 800742a:	69bb      	ldr	r3, [r7, #24]
 800742c:	210a      	movs	r1, #10
 800742e:	0018      	movs	r0, r3
 8007430:	f7f8 fefa 	bl	8000228 <__aeabi_uidivmod>
 8007434:	000b      	movs	r3, r1
 8007436:	b2db      	uxtb	r3, r3
 8007438:	3330      	adds	r3, #48	; 0x30
 800743a:	b2da      	uxtb	r2, r3
 800743c:	2308      	movs	r3, #8
 800743e:	18fb      	adds	r3, r7, r3
 8007440:	551a      	strb	r2, [r3, r4]
    a /= 10;
 8007442:	69bb      	ldr	r3, [r7, #24]
 8007444:	210a      	movs	r1, #10
 8007446:	0018      	movs	r0, r3
 8007448:	f7f8 fe68 	bl	800011c <__aeabi_uidiv>
 800744c:	0003      	movs	r3, r0
 800744e:	61bb      	str	r3, [r7, #24]

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
  uint32_t a = (long)n;
  while(a > 0) {
 8007450:	69bb      	ldr	r3, [r7, #24]
 8007452:	2b00      	cmp	r3, #0
 8007454:	d1e1      	bne.n	800741a <printFloat+0x92>
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) {
 8007456:	e00b      	b.n	8007470 <printFloat+0xe8>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
 8007458:	231e      	movs	r3, #30
 800745a:	18fb      	adds	r3, r7, r3
 800745c:	781b      	ldrb	r3, [r3, #0]
 800745e:	221e      	movs	r2, #30
 8007460:	18ba      	adds	r2, r7, r2
 8007462:	1c59      	adds	r1, r3, #1
 8007464:	7011      	strb	r1, [r2, #0]
 8007466:	001a      	movs	r2, r3
 8007468:	2308      	movs	r3, #8
 800746a:	18fb      	adds	r3, r7, r3
 800746c:	2130      	movs	r1, #48	; 0x30
 800746e:	5499      	strb	r1, [r3, r2]
  uint32_t a = (long)n;
  while(a > 0) {
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) {
 8007470:	231e      	movs	r3, #30
 8007472:	18fa      	adds	r2, r7, r3
 8007474:	1cfb      	adds	r3, r7, #3
 8007476:	7812      	ldrb	r2, [r2, #0]
 8007478:	781b      	ldrb	r3, [r3, #0]
 800747a:	429a      	cmp	r2, r3
 800747c:	d3ec      	bcc.n	8007458 <printFloat+0xd0>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
 800747e:	231e      	movs	r3, #30
 8007480:	18fa      	adds	r2, r7, r3
 8007482:	1cfb      	adds	r3, r7, #3
 8007484:	7812      	ldrb	r2, [r2, #0]
 8007486:	781b      	ldrb	r3, [r3, #0]
 8007488:	429a      	cmp	r2, r3
 800748a:	d127      	bne.n	80074dc <printFloat+0x154>
    buf[i++] = '0';
 800748c:	231e      	movs	r3, #30
 800748e:	18fb      	adds	r3, r7, r3
 8007490:	781b      	ldrb	r3, [r3, #0]
 8007492:	221e      	movs	r2, #30
 8007494:	18ba      	adds	r2, r7, r2
 8007496:	1c59      	adds	r1, r3, #1
 8007498:	7011      	strb	r1, [r2, #0]
 800749a:	001a      	movs	r2, r3
 800749c:	2308      	movs	r3, #8
 800749e:	18fb      	adds	r3, r7, r3
 80074a0:	2130      	movs	r1, #48	; 0x30
 80074a2:	5499      	strb	r1, [r3, r2]
  }

  // Print the generated string.
  for (; i > 0; i--) {
 80074a4:	e01a      	b.n	80074dc <printFloat+0x154>
    if (i == decimal_places) { serial_write('.'); } // Insert decimal point in right place.
 80074a6:	231e      	movs	r3, #30
 80074a8:	18fa      	adds	r2, r7, r3
 80074aa:	1cfb      	adds	r3, r7, #3
 80074ac:	7812      	ldrb	r2, [r2, #0]
 80074ae:	781b      	ldrb	r3, [r3, #0]
 80074b0:	429a      	cmp	r2, r3
 80074b2:	d102      	bne.n	80074ba <printFloat+0x132>
 80074b4:	202e      	movs	r0, #46	; 0x2e
 80074b6:	f001 fda3 	bl	8009000 <serial_write>
    serial_write(buf[i-1]);
 80074ba:	231e      	movs	r3, #30
 80074bc:	18fb      	adds	r3, r7, r3
 80074be:	781b      	ldrb	r3, [r3, #0]
 80074c0:	3b01      	subs	r3, #1
 80074c2:	2208      	movs	r2, #8
 80074c4:	18ba      	adds	r2, r7, r2
 80074c6:	5cd3      	ldrb	r3, [r2, r3]
 80074c8:	0018      	movs	r0, r3
 80074ca:	f001 fd99 	bl	8009000 <serial_write>
  if (i == decimal_places) { // Fill in leading zero, if needed.
    buf[i++] = '0';
  }

  // Print the generated string.
  for (; i > 0; i--) {
 80074ce:	231e      	movs	r3, #30
 80074d0:	18fb      	adds	r3, r7, r3
 80074d2:	781a      	ldrb	r2, [r3, #0]
 80074d4:	231e      	movs	r3, #30
 80074d6:	18fb      	adds	r3, r7, r3
 80074d8:	3a01      	subs	r2, #1
 80074da:	701a      	strb	r2, [r3, #0]
 80074dc:	231e      	movs	r3, #30
 80074de:	18fb      	adds	r3, r7, r3
 80074e0:	781b      	ldrb	r3, [r3, #0]
 80074e2:	2b00      	cmp	r3, #0
 80074e4:	d1df      	bne.n	80074a6 <printFloat+0x11e>
    if (i == decimal_places) { serial_write('.'); } // Insert decimal point in right place.
    serial_write(buf[i-1]);
  }
}
 80074e6:	46c0      	nop			; (mov r8, r8)
 80074e8:	46bd      	mov	sp, r7
 80074ea:	b009      	add	sp, #36	; 0x24
 80074ec:	bd90      	pop	{r4, r7, pc}
 80074ee:	46c0      	nop			; (mov r8, r8)
 80074f0:	42c80000 	.word	0x42c80000
 80074f4:	41200000 	.word	0x41200000

080074f8 <printFloat_CoordValue>:

// Floating value printing handlers for special variables types used in Grbl and are defined
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
void printFloat_CoordValue(float n) {
 80074f8:	b580      	push	{r7, lr}
 80074fa:	b082      	sub	sp, #8
 80074fc:	af00      	add	r7, sp, #0
 80074fe:	6078      	str	r0, [r7, #4]
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
 8007500:	4b0c      	ldr	r3, [pc, #48]	; (8007534 <printFloat_CoordValue+0x3c>)
 8007502:	2248      	movs	r2, #72	; 0x48
 8007504:	5c9b      	ldrb	r3, [r3, r2]
 8007506:	001a      	movs	r2, r3
 8007508:	2301      	movs	r3, #1
 800750a:	4013      	ands	r3, r2
 800750c:	d009      	beq.n	8007522 <printFloat_CoordValue+0x2a>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
 800750e:	490a      	ldr	r1, [pc, #40]	; (8007538 <printFloat_CoordValue+0x40>)
 8007510:	6878      	ldr	r0, [r7, #4]
 8007512:	f7f9 fa7d 	bl	8000a10 <__aeabi_fmul>
 8007516:	1c03      	adds	r3, r0, #0
 8007518:	2104      	movs	r1, #4
 800751a:	1c18      	adds	r0, r3, #0
 800751c:	f7ff ff34 	bl	8007388 <printFloat>
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
  }
}
 8007520:	e004      	b.n	800752c <printFloat_CoordValue+0x34>
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
void printFloat_CoordValue(float n) {
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
 8007522:	687b      	ldr	r3, [r7, #4]
 8007524:	2103      	movs	r1, #3
 8007526:	1c18      	adds	r0, r3, #0
 8007528:	f7ff ff2e 	bl	8007388 <printFloat>
  }
}
 800752c:	46c0      	nop			; (mov r8, r8)
 800752e:	46bd      	mov	sp, r7
 8007530:	b002      	add	sp, #8
 8007532:	bd80      	pop	{r7, pc}
 8007534:	20000acc 	.word	0x20000acc
 8007538:	3d21428b 	.word	0x3d21428b

0800753c <printFloat_RateValue>:

void printFloat_RateValue(float n) {
 800753c:	b580      	push	{r7, lr}
 800753e:	b082      	sub	sp, #8
 8007540:	af00      	add	r7, sp, #0
 8007542:	6078      	str	r0, [r7, #4]
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
 8007544:	4b0c      	ldr	r3, [pc, #48]	; (8007578 <printFloat_RateValue+0x3c>)
 8007546:	2248      	movs	r2, #72	; 0x48
 8007548:	5c9b      	ldrb	r3, [r3, r2]
 800754a:	001a      	movs	r2, r3
 800754c:	2301      	movs	r3, #1
 800754e:	4013      	ands	r3, r2
 8007550:	d009      	beq.n	8007566 <printFloat_RateValue+0x2a>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
 8007552:	490a      	ldr	r1, [pc, #40]	; (800757c <printFloat_RateValue+0x40>)
 8007554:	6878      	ldr	r0, [r7, #4]
 8007556:	f7f9 fa5b 	bl	8000a10 <__aeabi_fmul>
 800755a:	1c03      	adds	r3, r0, #0
 800755c:	2101      	movs	r1, #1
 800755e:	1c18      	adds	r0, r3, #0
 8007560:	f7ff ff12 	bl	8007388 <printFloat>
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
  }
}
 8007564:	e004      	b.n	8007570 <printFloat_RateValue+0x34>

void printFloat_RateValue(float n) {
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
 8007566:	687b      	ldr	r3, [r7, #4]
 8007568:	2100      	movs	r1, #0
 800756a:	1c18      	adds	r0, r3, #0
 800756c:	f7ff ff0c 	bl	8007388 <printFloat>
  }
}
 8007570:	46c0      	nop			; (mov r8, r8)
 8007572:	46bd      	mov	sp, r7
 8007574:	b002      	add	sp, #8
 8007576:	bd80      	pop	{r7, pc}
 8007578:	20000acc 	.word	0x20000acc
 800757c:	3d21428b 	.word	0x3d21428b

08007580 <probe_init>:
uint8_t probe_invert_mask;


// Probe pin initialization routine.
void probe_init()
{
 8007580:	b580      	push	{r7, lr}
 8007582:	b082      	sub	sp, #8
 8007584:	af00      	add	r7, sp, #0
	GPIO_InitStructure.GPIO_Pin = PROBE_MASK;
	GPIO_Init(PROBE_PORT, &GPIO_InitStructure);
#endif
#ifdef STM32F0DISCOVERY
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_PROBE_PORT, ENABLE);
 8007586:	2380      	movs	r3, #128	; 0x80
 8007588:	029b      	lsls	r3, r3, #10
 800758a:	2101      	movs	r1, #1
 800758c:	0018      	movs	r0, r3
 800758e:	f7fb fd7f 	bl	8003090 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8007592:	003b      	movs	r3, r7
 8007594:	2203      	movs	r2, #3
 8007596:	715a      	strb	r2, [r3, #5]
#ifdef DISABLE_PROBE_PIN_PULL_UP
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
#else
	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8007598:	003b      	movs	r3, r7
 800759a:	2200      	movs	r2, #0
 800759c:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 800759e:	003b      	movs	r3, r7
 80075a0:	2201      	movs	r2, #1
 80075a2:	71da      	strb	r2, [r3, #7]
#endif
	GPIO_InitStructure.GPIO_Pin = PROBE_MASK;
 80075a4:	003b      	movs	r3, r7
 80075a6:	2280      	movs	r2, #128	; 0x80
 80075a8:	0212      	lsls	r2, r2, #8
 80075aa:	601a      	str	r2, [r3, #0]
	GPIO_Init(PROBE_PORT, &GPIO_InitStructure);
 80075ac:	003a      	movs	r2, r7
 80075ae:	2390      	movs	r3, #144	; 0x90
 80075b0:	05db      	lsls	r3, r3, #23
 80075b2:	0011      	movs	r1, r2
 80075b4:	0018      	movs	r0, r3
 80075b6:	f7fb f9cd 	bl	8002954 <GPIO_Init>
#endif
  probe_configure_invert_mask(false); // Initialize invert mask.
 80075ba:	2000      	movs	r0, #0
 80075bc:	f000 f804 	bl	80075c8 <probe_configure_invert_mask>
}
 80075c0:	46c0      	nop			; (mov r8, r8)
 80075c2:	46bd      	mov	sp, r7
 80075c4:	b002      	add	sp, #8
 80075c6:	bd80      	pop	{r7, pc}

080075c8 <probe_configure_invert_mask>:

// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to
// appropriately set the pin logic according to setting for normal-high/normal-low operation
// and the probing cycle modes for toward-workpiece/away-from-workpiece.
void probe_configure_invert_mask(uint8_t is_probe_away)
{
 80075c8:	b580      	push	{r7, lr}
 80075ca:	b082      	sub	sp, #8
 80075cc:	af00      	add	r7, sp, #0
 80075ce:	0002      	movs	r2, r0
 80075d0:	1dfb      	adds	r3, r7, #7
 80075d2:	701a      	strb	r2, [r3, #0]
  probe_invert_mask = 0; // Initialize as zero.
 80075d4:	4b0c      	ldr	r3, [pc, #48]	; (8007608 <probe_configure_invert_mask+0x40>)
 80075d6:	2200      	movs	r2, #0
 80075d8:	701a      	strb	r2, [r3, #0]
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
 80075da:	4b0c      	ldr	r3, [pc, #48]	; (800760c <probe_configure_invert_mask+0x44>)
 80075dc:	2248      	movs	r2, #72	; 0x48
 80075de:	5c9b      	ldrb	r3, [r3, r2]
 80075e0:	b25b      	sxtb	r3, r3
 80075e2:	2b00      	cmp	r3, #0
 80075e4:	db03      	blt.n	80075ee <probe_configure_invert_mask+0x26>
 80075e6:	4b08      	ldr	r3, [pc, #32]	; (8007608 <probe_configure_invert_mask+0x40>)
 80075e8:	781a      	ldrb	r2, [r3, #0]
 80075ea:	4b07      	ldr	r3, [pc, #28]	; (8007608 <probe_configure_invert_mask+0x40>)
 80075ec:	701a      	strb	r2, [r3, #0]
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
 80075ee:	1dfb      	adds	r3, r7, #7
 80075f0:	781b      	ldrb	r3, [r3, #0]
 80075f2:	2b00      	cmp	r3, #0
 80075f4:	d003      	beq.n	80075fe <probe_configure_invert_mask+0x36>
 80075f6:	4b04      	ldr	r3, [pc, #16]	; (8007608 <probe_configure_invert_mask+0x40>)
 80075f8:	781a      	ldrb	r2, [r3, #0]
 80075fa:	4b03      	ldr	r3, [pc, #12]	; (8007608 <probe_configure_invert_mask+0x40>)
 80075fc:	701a      	strb	r2, [r3, #0]
}
 80075fe:	46c0      	nop			; (mov r8, r8)
 8007600:	46bd      	mov	sp, r7
 8007602:	b002      	add	sp, #8
 8007604:	bd80      	pop	{r7, pc}
 8007606:	46c0      	nop			; (mov r8, r8)
 8007608:	200009e0 	.word	0x200009e0
 800760c:	20000acc 	.word	0x20000acc

08007610 <probe_get_state>:


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() 
{ 
 8007610:	b580      	push	{r7, lr}
 8007612:	af00      	add	r7, sp, #0
#endif
#ifdef STM32F103C8
	return ((GPIO_ReadInputData(PROBE_PORT) & PROBE_MASK) ^ probe_invert_mask) != 0;
#endif
#ifdef STM32F0DISCOVERY
	return ((GPIO_ReadInputData(PROBE_PORT) & PROBE_MASK) ^ probe_invert_mask) != 0;
 8007614:	2390      	movs	r3, #144	; 0x90
 8007616:	05db      	lsls	r3, r3, #23
 8007618:	0018      	movs	r0, r3
 800761a:	f7fb fa33 	bl	8002a84 <GPIO_ReadInputData>
 800761e:	0003      	movs	r3, r0
 8007620:	001a      	movs	r2, r3
 8007622:	2380      	movs	r3, #128	; 0x80
 8007624:	021b      	lsls	r3, r3, #8
 8007626:	4013      	ands	r3, r2
 8007628:	4a04      	ldr	r2, [pc, #16]	; (800763c <probe_get_state+0x2c>)
 800762a:	7812      	ldrb	r2, [r2, #0]
 800762c:	1a9b      	subs	r3, r3, r2
 800762e:	1e5a      	subs	r2, r3, #1
 8007630:	4193      	sbcs	r3, r2
 8007632:	b2db      	uxtb	r3, r3
#endif
}
 8007634:	0018      	movs	r0, r3
 8007636:	46bd      	mov	sp, r7
 8007638:	bd80      	pop	{r7, pc}
 800763a:	46c0      	nop			; (mov r8, r8)
 800763c:	200009e0 	.word	0x200009e0

08007640 <probe_state_monitor>:

// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
 8007640:	b5b0      	push	{r4, r5, r7, lr}
 8007642:	af00      	add	r7, sp, #0
  if (probe_get_state()) {
 8007644:	f7ff ffe4 	bl	8007610 <probe_get_state>
 8007648:	1e03      	subs	r3, r0, #0
 800764a:	d00e      	beq.n	800766a <probe_state_monitor+0x2a>
    sys_probe_state = PROBE_OFF;
 800764c:	4b08      	ldr	r3, [pc, #32]	; (8007670 <probe_state_monitor+0x30>)
 800764e:	2200      	movs	r2, #0
 8007650:	701a      	strb	r2, [r3, #0]
    memcpy(sys_probe_position, sys_position, sizeof(sys_position));
 8007652:	4b08      	ldr	r3, [pc, #32]	; (8007674 <probe_state_monitor+0x34>)
 8007654:	4a08      	ldr	r2, [pc, #32]	; (8007678 <probe_state_monitor+0x38>)
 8007656:	ca13      	ldmia	r2!, {r0, r1, r4}
 8007658:	c313      	stmia	r3!, {r0, r1, r4}
    bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
 800765a:	4b08      	ldr	r3, [pc, #32]	; (800767c <probe_state_monitor+0x3c>)
 800765c:	781b      	ldrb	r3, [r3, #0]
 800765e:	b2db      	uxtb	r3, r3
 8007660:	2240      	movs	r2, #64	; 0x40
 8007662:	4313      	orrs	r3, r2
 8007664:	b2da      	uxtb	r2, r3
 8007666:	4b05      	ldr	r3, [pc, #20]	; (800767c <probe_state_monitor+0x3c>)
 8007668:	701a      	strb	r2, [r3, #0]
  }
}
 800766a:	46c0      	nop			; (mov r8, r8)
 800766c:	46bd      	mov	sp, r7
 800766e:	bdb0      	pop	{r4, r5, r7, pc}
 8007670:	20000b42 	.word	0x20000b42
 8007674:	20000b44 	.word	0x20000b44
 8007678:	20000b50 	.word	0x20000b50
 800767c:	20000b41 	.word	0x20000b41

08007680 <protocol_main_loop>:

/*
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
 8007680:	b590      	push	{r4, r7, lr}
 8007682:	b083      	sub	sp, #12
 8007684:	af00      	add	r7, sp, #0
  // Perform some machine checks to make sure everything is good to go.
  #ifdef CHECK_LIMITS_AT_INIT
    if (bit_istrue(settings.flags, BITFLAG_HARD_LIMIT_ENABLE)) {
 8007686:	4b91      	ldr	r3, [pc, #580]	; (80078cc <protocol_main_loop+0x24c>)
 8007688:	2248      	movs	r2, #72	; 0x48
 800768a:	5c9b      	ldrb	r3, [r3, r2]
 800768c:	001a      	movs	r2, r3
 800768e:	2308      	movs	r3, #8
 8007690:	4013      	ands	r3, r2
 8007692:	d009      	beq.n	80076a8 <protocol_main_loop+0x28>
      if (limits_get_state()) {
 8007694:	f7fd ffc6 	bl	8005624 <limits_get_state>
 8007698:	1e03      	subs	r3, r0, #0
 800769a:	d005      	beq.n	80076a8 <protocol_main_loop+0x28>
        sys.state = STATE_ALARM; // Ensure alarm state is active.
 800769c:	4b8c      	ldr	r3, [pc, #560]	; (80078d0 <protocol_main_loop+0x250>)
 800769e:	2201      	movs	r2, #1
 80076a0:	701a      	strb	r2, [r3, #0]
        report_feedback_message(MESSAGE_CHECK_LIMITS);
 80076a2:	2007      	movs	r0, #7
 80076a4:	f000 fe8a 	bl	80083bc <report_feedback_message>
    }
  #endif
  // Check for and report alarm state after a reset, error, or an initial power up.
  // NOTE: Sleep mode disables the stepper drivers and position can't be guaranteed.
  // Re-initialize the sleep state as an ALARM mode to ensure user homes or acknowledges.
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
 80076a8:	4b89      	ldr	r3, [pc, #548]	; (80078d0 <protocol_main_loop+0x250>)
 80076aa:	781b      	ldrb	r3, [r3, #0]
 80076ac:	001a      	movs	r2, r3
 80076ae:	2381      	movs	r3, #129	; 0x81
 80076b0:	4013      	ands	r3, r2
 80076b2:	d006      	beq.n	80076c2 <protocol_main_loop+0x42>
    report_feedback_message(MESSAGE_ALARM_LOCK);
 80076b4:	2002      	movs	r0, #2
 80076b6:	f000 fe81 	bl	80083bc <report_feedback_message>
    sys.state = STATE_ALARM; // Ensure alarm state is set.
 80076ba:	4b85      	ldr	r3, [pc, #532]	; (80078d0 <protocol_main_loop+0x250>)
 80076bc:	2201      	movs	r2, #1
 80076be:	701a      	strb	r2, [r3, #0]
 80076c0:	e014      	b.n	80076ec <protocol_main_loop+0x6c>
  } else {
    // Check if the safety door is open.
    sys.state = STATE_IDLE;
 80076c2:	4b83      	ldr	r3, [pc, #524]	; (80078d0 <protocol_main_loop+0x250>)
 80076c4:	2200      	movs	r2, #0
 80076c6:	701a      	strb	r2, [r3, #0]
    if (system_check_safety_door_ajar()) {
 80076c8:	f003 fe48 	bl	800b35c <system_check_safety_door_ajar>
 80076cc:	1e03      	subs	r3, r0, #0
 80076ce:	d009      	beq.n	80076e4 <protocol_main_loop+0x64>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
 80076d0:	4b80      	ldr	r3, [pc, #512]	; (80078d4 <protocol_main_loop+0x254>)
 80076d2:	781b      	ldrb	r3, [r3, #0]
 80076d4:	b2db      	uxtb	r3, r3
 80076d6:	2220      	movs	r2, #32
 80076d8:	4313      	orrs	r3, r2
 80076da:	b2da      	uxtb	r2, r3
 80076dc:	4b7d      	ldr	r3, [pc, #500]	; (80078d4 <protocol_main_loop+0x254>)
 80076de:	701a      	strb	r2, [r3, #0]
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
 80076e0:	f000 f920 	bl	8007924 <protocol_execute_realtime>
    }
    // All systems go!
    system_execute_startup(line); // Execute startup script.
 80076e4:	4b7c      	ldr	r3, [pc, #496]	; (80078d8 <protocol_main_loop+0x258>)
 80076e6:	0018      	movs	r0, r3
 80076e8:	f003 fe3e 	bl	800b368 <system_execute_startup>
  // ---------------------------------------------------------------------------------
  // Primary loop! Upon a system abort, this exits back to main() to reset the system.
  // This is also where Grbl idles while waiting for something to do.
  // ---------------------------------------------------------------------------------

  uint8_t line_flags = 0;
 80076ec:	1dfb      	adds	r3, r7, #7
 80076ee:	2200      	movs	r2, #0
 80076f0:	701a      	strb	r2, [r3, #0]
  uint8_t char_counter = 0;
 80076f2:	1dbb      	adds	r3, r7, #6
 80076f4:	2200      	movs	r2, #0
 80076f6:	701a      	strb	r2, [r3, #0]
  uint8_t c;
  for (;;) {

    // Process one line of incoming serial data, as the data becomes available. Performs an
    // initial filtering by removing spaces and comments and capitalizing all letters.
    while((c = serial_read()) != SERIAL_NO_DATA) {
 80076f8:	e0ce      	b.n	8007898 <protocol_main_loop+0x218>
      if ((c == '\n') || (c == '\r')) { // End of line reached
 80076fa:	1d7b      	adds	r3, r7, #5
 80076fc:	781b      	ldrb	r3, [r3, #0]
 80076fe:	2b0a      	cmp	r3, #10
 8007700:	d003      	beq.n	800770a <protocol_main_loop+0x8a>
 8007702:	1d7b      	adds	r3, r7, #5
 8007704:	781b      	ldrb	r3, [r3, #0]
 8007706:	2b0d      	cmp	r3, #13
 8007708:	d142      	bne.n	8007790 <protocol_main_loop+0x110>

        protocol_execute_realtime(); // Runtime command check point.
 800770a:	f000 f90b 	bl	8007924 <protocol_execute_realtime>
        if (sys.abort) { return; } // Bail to calling function upon system abort
 800770e:	4b70      	ldr	r3, [pc, #448]	; (80078d0 <protocol_main_loop+0x250>)
 8007710:	785b      	ldrb	r3, [r3, #1]
 8007712:	2b00      	cmp	r3, #0
 8007714:	d000      	beq.n	8007718 <protocol_main_loop+0x98>
 8007716:	e0d2      	b.n	80078be <protocol_main_loop+0x23e>

        line[char_counter] = 0; // Set string termination character.
 8007718:	1dbb      	adds	r3, r7, #6
 800771a:	781b      	ldrb	r3, [r3, #0]
 800771c:	4a6e      	ldr	r2, [pc, #440]	; (80078d8 <protocol_main_loop+0x258>)
 800771e:	2100      	movs	r1, #0
 8007720:	54d1      	strb	r1, [r2, r3]
				#ifdef REPORT_ECHO_LINE_RECEIVED
          report_echo_line_received(line);
        #endif

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
 8007722:	1dfb      	adds	r3, r7, #7
 8007724:	781b      	ldrb	r3, [r3, #0]
 8007726:	2201      	movs	r2, #1
 8007728:	4013      	ands	r3, r2
 800772a:	d003      	beq.n	8007734 <protocol_main_loop+0xb4>
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
 800772c:	200b      	movs	r0, #11
 800772e:	f000 fe07 	bl	8008340 <report_status_message>
 8007732:	e026      	b.n	8007782 <protocol_main_loop+0x102>
        } else if (line[0] == 0) {
 8007734:	4b68      	ldr	r3, [pc, #416]	; (80078d8 <protocol_main_loop+0x258>)
 8007736:	781b      	ldrb	r3, [r3, #0]
 8007738:	2b00      	cmp	r3, #0
 800773a:	d103      	bne.n	8007744 <protocol_main_loop+0xc4>
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
 800773c:	2000      	movs	r0, #0
 800773e:	f000 fdff 	bl	8008340 <report_status_message>
 8007742:	e01e      	b.n	8007782 <protocol_main_loop+0x102>
        } else if (line[0] == '$') {
 8007744:	4b64      	ldr	r3, [pc, #400]	; (80078d8 <protocol_main_loop+0x258>)
 8007746:	781b      	ldrb	r3, [r3, #0]
 8007748:	2b24      	cmp	r3, #36	; 0x24
 800774a:	d108      	bne.n	800775e <protocol_main_loop+0xde>
          // Grbl '$' system command
          report_status_message(system_execute_line(line));
 800774c:	4b62      	ldr	r3, [pc, #392]	; (80078d8 <protocol_main_loop+0x258>)
 800774e:	0018      	movs	r0, r3
 8007750:	f003 fe4a 	bl	800b3e8 <system_execute_line>
 8007754:	0003      	movs	r3, r0
 8007756:	0018      	movs	r0, r3
 8007758:	f000 fdf2 	bl	8008340 <report_status_message>
 800775c:	e011      	b.n	8007782 <protocol_main_loop+0x102>
        } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
 800775e:	4b5c      	ldr	r3, [pc, #368]	; (80078d0 <protocol_main_loop+0x250>)
 8007760:	781b      	ldrb	r3, [r3, #0]
 8007762:	001a      	movs	r2, r3
 8007764:	2321      	movs	r3, #33	; 0x21
 8007766:	4013      	ands	r3, r2
 8007768:	d003      	beq.n	8007772 <protocol_main_loop+0xf2>
          // Everything else is gcode. Block if in alarm or jog mode.
          report_status_message(STATUS_SYSTEM_GC_LOCK);
 800776a:	2009      	movs	r0, #9
 800776c:	f000 fde8 	bl	8008340 <report_status_message>
 8007770:	e007      	b.n	8007782 <protocol_main_loop+0x102>
        } else {
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
 8007772:	4b59      	ldr	r3, [pc, #356]	; (80078d8 <protocol_main_loop+0x258>)
 8007774:	0018      	movs	r0, r3
 8007776:	f7fc f967 	bl	8003a48 <gc_execute_line>
 800777a:	0003      	movs	r3, r0
 800777c:	0018      	movs	r0, r3
 800777e:	f000 fddf 	bl	8008340 <report_status_message>
        }

        // Reset tracking data for next line.
        line_flags = 0;
 8007782:	1dfb      	adds	r3, r7, #7
 8007784:	2200      	movs	r2, #0
 8007786:	701a      	strb	r2, [r3, #0]
        char_counter = 0;
 8007788:	1dbb      	adds	r3, r7, #6
 800778a:	2200      	movs	r2, #0
 800778c:	701a      	strb	r2, [r3, #0]
 800778e:	e083      	b.n	8007898 <protocol_main_loop+0x218>

      } else {

        if (line_flags) {
 8007790:	1dfb      	adds	r3, r7, #7
 8007792:	781b      	ldrb	r3, [r3, #0]
 8007794:	2b00      	cmp	r3, #0
 8007796:	d013      	beq.n	80077c0 <protocol_main_loop+0x140>
          // Throw away all (except EOL) comment characters and overflow characters.
          if (c == ')') {
 8007798:	1d7b      	adds	r3, r7, #5
 800779a:	781b      	ldrb	r3, [r3, #0]
 800779c:	2b29      	cmp	r3, #41	; 0x29
 800779e:	d10a      	bne.n	80077b6 <protocol_main_loop+0x136>
            // End of '()' comment. Resume line allowed.
            if (line_flags & LINE_FLAG_COMMENT_PARENTHESES) { line_flags &= ~(LINE_FLAG_COMMENT_PARENTHESES); }
 80077a0:	1dfb      	adds	r3, r7, #7
 80077a2:	781b      	ldrb	r3, [r3, #0]
 80077a4:	2202      	movs	r2, #2
 80077a6:	4013      	ands	r3, r2
 80077a8:	d005      	beq.n	80077b6 <protocol_main_loop+0x136>
 80077aa:	1dfb      	adds	r3, r7, #7
 80077ac:	1dfa      	adds	r2, r7, #7
 80077ae:	7812      	ldrb	r2, [r2, #0]
 80077b0:	2102      	movs	r1, #2
 80077b2:	438a      	bics	r2, r1
 80077b4:	701a      	strb	r2, [r3, #0]
 80077b6:	1dbb      	adds	r3, r7, #6
 80077b8:	1dba      	adds	r2, r7, #6
 80077ba:	7812      	ldrb	r2, [r2, #0]
 80077bc:	701a      	strb	r2, [r3, #0]
 80077be:	e06b      	b.n	8007898 <protocol_main_loop+0x218>
 80077c0:	1dfb      	adds	r3, r7, #7
 80077c2:	1dfa      	adds	r2, r7, #7
 80077c4:	7812      	ldrb	r2, [r2, #0]
 80077c6:	701a      	strb	r2, [r3, #0]
 80077c8:	1dbb      	adds	r3, r7, #6
 80077ca:	1dba      	adds	r2, r7, #6
 80077cc:	7812      	ldrb	r2, [r2, #0]
 80077ce:	701a      	strb	r2, [r3, #0]
          }
        } else {
          if (c <= ' ') {
 80077d0:	1d7b      	adds	r3, r7, #5
 80077d2:	781b      	ldrb	r3, [r3, #0]
 80077d4:	2b20      	cmp	r3, #32
 80077d6:	d95f      	bls.n	8007898 <protocol_main_loop+0x218>
 80077d8:	1dfb      	adds	r3, r7, #7
 80077da:	1dfa      	adds	r2, r7, #7
 80077dc:	7812      	ldrb	r2, [r2, #0]
 80077de:	701a      	strb	r2, [r3, #0]
 80077e0:	1dbb      	adds	r3, r7, #6
 80077e2:	1dba      	adds	r2, r7, #6
 80077e4:	7812      	ldrb	r2, [r2, #0]
 80077e6:	701a      	strb	r2, [r3, #0]
            // Throw away whitepace and control characters
          } else if (c == '/') {
 80077e8:	1d7b      	adds	r3, r7, #5
 80077ea:	781b      	ldrb	r3, [r3, #0]
 80077ec:	2b2f      	cmp	r3, #47	; 0x2f
 80077ee:	d053      	beq.n	8007898 <protocol_main_loop+0x218>
            // Block delete NOT SUPPORTED. Ignore character.
            // NOTE: If supported, would simply need to check the system if block delete is enabled.
          } else if (c == '(') {
 80077f0:	1d7b      	adds	r3, r7, #5
 80077f2:	781b      	ldrb	r3, [r3, #0]
 80077f4:	2b28      	cmp	r3, #40	; 0x28
 80077f6:	d10a      	bne.n	800780e <protocol_main_loop+0x18e>
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
 80077f8:	1dfb      	adds	r3, r7, #7
 80077fa:	1dfa      	adds	r2, r7, #7
 80077fc:	7812      	ldrb	r2, [r2, #0]
 80077fe:	2102      	movs	r1, #2
 8007800:	430a      	orrs	r2, r1
 8007802:	701a      	strb	r2, [r3, #0]
 8007804:	1dbb      	adds	r3, r7, #6
 8007806:	1dba      	adds	r2, r7, #6
 8007808:	7812      	ldrb	r2, [r2, #0]
 800780a:	701a      	strb	r2, [r3, #0]
 800780c:	e044      	b.n	8007898 <protocol_main_loop+0x218>
          } else if (c == ';') {
 800780e:	1d7b      	adds	r3, r7, #5
 8007810:	781b      	ldrb	r3, [r3, #0]
 8007812:	2b3b      	cmp	r3, #59	; 0x3b
 8007814:	d10a      	bne.n	800782c <protocol_main_loop+0x1ac>
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            line_flags |= LINE_FLAG_COMMENT_SEMICOLON;
 8007816:	1dfb      	adds	r3, r7, #7
 8007818:	1dfa      	adds	r2, r7, #7
 800781a:	7812      	ldrb	r2, [r2, #0]
 800781c:	2104      	movs	r1, #4
 800781e:	430a      	orrs	r2, r1
 8007820:	701a      	strb	r2, [r3, #0]
 8007822:	1dbb      	adds	r3, r7, #6
 8007824:	1dba      	adds	r2, r7, #6
 8007826:	7812      	ldrb	r2, [r2, #0]
 8007828:	701a      	strb	r2, [r3, #0]
 800782a:	e035      	b.n	8007898 <protocol_main_loop+0x218>
            // Program start-end percent sign NOT SUPPORTED.
            // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
            // where, during a program, the system auto-cycle start will continue to execute
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.
          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
 800782c:	1dbb      	adds	r3, r7, #6
 800782e:	781b      	ldrb	r3, [r3, #0]
 8007830:	2b4e      	cmp	r3, #78	; 0x4e
 8007832:	d90a      	bls.n	800784a <protocol_main_loop+0x1ca>
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
 8007834:	1dfb      	adds	r3, r7, #7
 8007836:	1dfa      	adds	r2, r7, #7
 8007838:	7812      	ldrb	r2, [r2, #0]
 800783a:	2101      	movs	r1, #1
 800783c:	430a      	orrs	r2, r1
 800783e:	701a      	strb	r2, [r3, #0]
 8007840:	1dbb      	adds	r3, r7, #6
 8007842:	1dba      	adds	r2, r7, #6
 8007844:	7812      	ldrb	r2, [r2, #0]
 8007846:	701a      	strb	r2, [r3, #0]
 8007848:	e026      	b.n	8007898 <protocol_main_loop+0x218>
          } else if (c >= 'a' && c <= 'z') { // Upcase lowercase
 800784a:	1d7b      	adds	r3, r7, #5
 800784c:	781b      	ldrb	r3, [r3, #0]
 800784e:	2b60      	cmp	r3, #96	; 0x60
 8007850:	d914      	bls.n	800787c <protocol_main_loop+0x1fc>
 8007852:	1d7b      	adds	r3, r7, #5
 8007854:	781b      	ldrb	r3, [r3, #0]
 8007856:	2b7a      	cmp	r3, #122	; 0x7a
 8007858:	d810      	bhi.n	800787c <protocol_main_loop+0x1fc>
            line[char_counter++] = c-'a'+'A';
 800785a:	1dbb      	adds	r3, r7, #6
 800785c:	781b      	ldrb	r3, [r3, #0]
 800785e:	1dba      	adds	r2, r7, #6
 8007860:	1c59      	adds	r1, r3, #1
 8007862:	7011      	strb	r1, [r2, #0]
 8007864:	001a      	movs	r2, r3
 8007866:	1d7b      	adds	r3, r7, #5
 8007868:	781b      	ldrb	r3, [r3, #0]
 800786a:	3b20      	subs	r3, #32
 800786c:	b2d9      	uxtb	r1, r3
 800786e:	4b1a      	ldr	r3, [pc, #104]	; (80078d8 <protocol_main_loop+0x258>)
 8007870:	5499      	strb	r1, [r3, r2]
 8007872:	1dfb      	adds	r3, r7, #7
 8007874:	1dfa      	adds	r2, r7, #7
 8007876:	7812      	ldrb	r2, [r2, #0]
 8007878:	701a      	strb	r2, [r3, #0]
 800787a:	e00d      	b.n	8007898 <protocol_main_loop+0x218>
          } else {
            line[char_counter++] = c;
 800787c:	1dbb      	adds	r3, r7, #6
 800787e:	781b      	ldrb	r3, [r3, #0]
 8007880:	1dba      	adds	r2, r7, #6
 8007882:	1c59      	adds	r1, r3, #1
 8007884:	7011      	strb	r1, [r2, #0]
 8007886:	0019      	movs	r1, r3
 8007888:	4b13      	ldr	r3, [pc, #76]	; (80078d8 <protocol_main_loop+0x258>)
 800788a:	1d7a      	adds	r2, r7, #5
 800788c:	7812      	ldrb	r2, [r2, #0]
 800788e:	545a      	strb	r2, [r3, r1]
 8007890:	1dfb      	adds	r3, r7, #7
 8007892:	1dfa      	adds	r2, r7, #7
 8007894:	7812      	ldrb	r2, [r2, #0]
 8007896:	701a      	strb	r2, [r3, #0]
  uint8_t c;
  for (;;) {

    // Process one line of incoming serial data, as the data becomes available. Performs an
    // initial filtering by removing spaces and comments and capitalizing all letters.
    while((c = serial_read()) != SERIAL_NO_DATA) {
 8007898:	1d7c      	adds	r4, r7, #5
 800789a:	f001 fbd3 	bl	8009044 <serial_read>
 800789e:	0003      	movs	r3, r0
 80078a0:	7023      	strb	r3, [r4, #0]
 80078a2:	1d7b      	adds	r3, r7, #5
 80078a4:	781b      	ldrb	r3, [r3, #0]
 80078a6:	2bff      	cmp	r3, #255	; 0xff
 80078a8:	d000      	beq.n	80078ac <protocol_main_loop+0x22c>
 80078aa:	e726      	b.n	80076fa <protocol_main_loop+0x7a>
    }

    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
 80078ac:	f000 f82e 	bl	800790c <protocol_auto_cycle_start>

    protocol_execute_realtime();  // Runtime command check point.
 80078b0:	f000 f838 	bl	8007924 <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
 80078b4:	4b06      	ldr	r3, [pc, #24]	; (80078d0 <protocol_main_loop+0x250>)
 80078b6:	785b      	ldrb	r3, [r3, #1]
 80078b8:	2b00      	cmp	r3, #0
 80078ba:	d102      	bne.n	80078c2 <protocol_main_loop+0x242>
  }
 80078bc:	e71c      	b.n	80076f8 <protocol_main_loop+0x78>
    // initial filtering by removing spaces and comments and capitalizing all letters.
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached

        protocol_execute_realtime(); // Runtime command check point.
        if (sys.abort) { return; } // Bail to calling function upon system abort
 80078be:	46c0      	nop			; (mov r8, r8)
 80078c0:	e000      	b.n	80078c4 <protocol_main_loop+0x244>
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();

    protocol_execute_realtime();  // Runtime command check point.
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
 80078c2:	46c0      	nop			; (mov r8, r8)
  }

  return; /* Never reached */
}
 80078c4:	46bd      	mov	sp, r7
 80078c6:	b003      	add	sp, #12
 80078c8:	bd90      	pop	{r4, r7, pc}
 80078ca:	46c0      	nop			; (mov r8, r8)
 80078cc:	20000acc 	.word	0x20000acc
 80078d0:	20000b2c 	.word	0x20000b2c
 80078d4:	20000b41 	.word	0x20000b41
 80078d8:	200003f8 	.word	0x200003f8

080078dc <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
 80078dc:	b580      	push	{r7, lr}
 80078de:	af00      	add	r7, sp, #0
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
 80078e0:	f000 f814 	bl	800790c <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
 80078e4:	f000 f81e 	bl	8007924 <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
 80078e8:	4b07      	ldr	r3, [pc, #28]	; (8007908 <protocol_buffer_synchronize+0x2c>)
 80078ea:	785b      	ldrb	r3, [r3, #1]
 80078ec:	2b00      	cmp	r3, #0
 80078ee:	d108      	bne.n	8007902 <protocol_buffer_synchronize+0x26>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
 80078f0:	f7ff f944 	bl	8006b7c <plan_get_current_block>
 80078f4:	1e03      	subs	r3, r0, #0
 80078f6:	d1f5      	bne.n	80078e4 <protocol_buffer_synchronize+0x8>
 80078f8:	4b03      	ldr	r3, [pc, #12]	; (8007908 <protocol_buffer_synchronize+0x2c>)
 80078fa:	781b      	ldrb	r3, [r3, #0]
 80078fc:	2b08      	cmp	r3, #8
 80078fe:	d0f1      	beq.n	80078e4 <protocol_buffer_synchronize+0x8>
 8007900:	e000      	b.n	8007904 <protocol_buffer_synchronize+0x28>
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
 8007902:	46c0      	nop			; (mov r8, r8)
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
}
 8007904:	46bd      	mov	sp, r7
 8007906:	bd80      	pop	{r7, pc}
 8007908:	20000b2c 	.word	0x20000b2c

0800790c <protocol_auto_cycle_start>:
// NOTE: This function is called from the main loop, buffer sync, and mc_line() only and executes
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming
// is finished, single commands), a command that needs to wait for the motions in the buffer to
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start()
{
 800790c:	b580      	push	{r7, lr}
 800790e:	af00      	add	r7, sp, #0
  if (plan_get_current_block() != NULL) { // Check if there are any blocks in the buffer.
 8007910:	f7ff f934 	bl	8006b7c <plan_get_current_block>
 8007914:	1e03      	subs	r3, r0, #0
 8007916:	d002      	beq.n	800791e <protocol_auto_cycle_start+0x12>
    system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
 8007918:	2002      	movs	r0, #2
 800791a:	f004 f86b 	bl	800b9f4 <system_set_exec_state_flag>
  }
}
 800791e:	46c0      	nop			; (mov r8, r8)
 8007920:	46bd      	mov	sp, r7
 8007922:	bd80      	pop	{r7, pc}

08007924 <protocol_execute_realtime>:
// also provides a controlled way to execute certain tasks without having two or more instances of
// the same task, such as the planner recalculating the buffer upon a feedhold or overrides.
// NOTE: The sys_rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
 8007924:	b580      	push	{r7, lr}
 8007926:	af00      	add	r7, sp, #0
  protocol_exec_rt_system();
 8007928:	f000 f80c 	bl	8007944 <protocol_exec_rt_system>
  if (sys.suspend) { protocol_exec_rt_suspend(); }
 800792c:	4b04      	ldr	r3, [pc, #16]	; (8007940 <protocol_execute_realtime+0x1c>)
 800792e:	789b      	ldrb	r3, [r3, #2]
 8007930:	2b00      	cmp	r3, #0
 8007932:	d001      	beq.n	8007938 <protocol_execute_realtime+0x14>
 8007934:	f000 fb04 	bl	8007f40 <protocol_exec_rt_suspend>
}
 8007938:	46c0      	nop			; (mov r8, r8)
 800793a:	46bd      	mov	sp, r7
 800793c:	bd80      	pop	{r7, pc}
 800793e:	46c0      	nop			; (mov r8, r8)
 8007940:	20000b2c 	.word	0x20000b2c

08007944 <protocol_exec_rt_system>:

// Executes run-time commands, when required. This function primarily operates as Grbl's state
// machine and controls the various real-time features Grbl has to offer.
// NOTE: Do not alter this unless you know exactly what you are doing!
void protocol_exec_rt_system()
{
 8007944:	b580      	push	{r7, lr}
 8007946:	b082      	sub	sp, #8
 8007948:	af00      	add	r7, sp, #0
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
 800794a:	1cfb      	adds	r3, r7, #3
 800794c:	4abc      	ldr	r2, [pc, #752]	; (8007c40 <protocol_exec_rt_system+0x2fc>)
 800794e:	7812      	ldrb	r2, [r2, #0]
 8007950:	701a      	strb	r2, [r3, #0]
  if (rt_exec) { // Enter only if any bit flag is true
 8007952:	1cfb      	adds	r3, r7, #3
 8007954:	781b      	ldrb	r3, [r3, #0]
 8007956:	2b00      	cmp	r3, #0
 8007958:	d01e      	beq.n	8007998 <protocol_exec_rt_system+0x54>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
 800795a:	4bba      	ldr	r3, [pc, #744]	; (8007c44 <protocol_exec_rt_system+0x300>)
 800795c:	2201      	movs	r2, #1
 800795e:	701a      	strb	r2, [r3, #0]
    report_alarm_message(rt_exec);
 8007960:	1cfb      	adds	r3, r7, #3
 8007962:	781b      	ldrb	r3, [r3, #0]
 8007964:	0018      	movs	r0, r3
 8007966:	f000 fd0d 	bl	8008384 <report_alarm_message>
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if ((rt_exec == EXEC_ALARM_HARD_LIMIT) || (rt_exec == EXEC_ALARM_SOFT_LIMIT)) {
 800796a:	1cfb      	adds	r3, r7, #3
 800796c:	781b      	ldrb	r3, [r3, #0]
 800796e:	2b01      	cmp	r3, #1
 8007970:	d003      	beq.n	800797a <protocol_exec_rt_system+0x36>
 8007972:	1cfb      	adds	r3, r7, #3
 8007974:	781b      	ldrb	r3, [r3, #0]
 8007976:	2b02      	cmp	r3, #2
 8007978:	d10c      	bne.n	8007994 <protocol_exec_rt_system+0x50>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
 800797a:	2001      	movs	r0, #1
 800797c:	f000 fd1e 	bl	80083bc <report_feedback_message>
      system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
 8007980:	2010      	movs	r0, #16
 8007982:	f004 f84f 	bl	800ba24 <system_clear_exec_state_flag>
        // Block everything, except reset and status reports, until user issues reset or power
        // cycles. Hard limits typically occur while unattended or not paying attention. Gives
        // the user and a GUI time to do what is needed before resetting, like killing the
        // incoming stream. The same could be said about soft limits. While the position is not
        // lost, continued streaming could cause a serious crash if by chance it gets executed.
      } while (bit_isfalse(sys_rt_exec_state,EXEC_RESET));
 8007986:	4bb0      	ldr	r3, [pc, #704]	; (8007c48 <protocol_exec_rt_system+0x304>)
 8007988:	781b      	ldrb	r3, [r3, #0]
 800798a:	b2db      	uxtb	r3, r3
 800798c:	001a      	movs	r2, r3
 800798e:	2310      	movs	r3, #16
 8007990:	4013      	ands	r3, r2
 8007992:	d0f8      	beq.n	8007986 <protocol_exec_rt_system+0x42>
    }
    system_clear_exec_alarm(); // Clear alarm
 8007994:	f004 f87a 	bl	800ba8c <system_clear_exec_alarm>
  }

  rt_exec = sys_rt_exec_state; // Copy volatile sys_rt_exec_state.
 8007998:	1cfb      	adds	r3, r7, #3
 800799a:	4aab      	ldr	r2, [pc, #684]	; (8007c48 <protocol_exec_rt_system+0x304>)
 800799c:	7812      	ldrb	r2, [r2, #0]
 800799e:	701a      	strb	r2, [r3, #0]
  if (rt_exec) {
 80079a0:	1cfb      	adds	r3, r7, #3
 80079a2:	781b      	ldrb	r3, [r3, #0]
 80079a4:	2b00      	cmp	r3, #0
 80079a6:	d100      	bne.n	80079aa <protocol_exec_rt_system+0x66>
 80079a8:	e181      	b.n	8007cae <protocol_exec_rt_system+0x36a>

    // Execute system abort.
    if (rt_exec & EXEC_RESET) {
 80079aa:	1cfb      	adds	r3, r7, #3
 80079ac:	781b      	ldrb	r3, [r3, #0]
 80079ae:	2210      	movs	r2, #16
 80079b0:	4013      	ands	r3, r2
 80079b2:	d003      	beq.n	80079bc <protocol_exec_rt_system+0x78>
      sys.abort = true;  // Only place this is set true.
 80079b4:	4ba3      	ldr	r3, [pc, #652]	; (8007c44 <protocol_exec_rt_system+0x300>)
 80079b6:	2201      	movs	r2, #1
 80079b8:	705a      	strb	r2, [r3, #1]
      return; // Nothing else to do but exit.
 80079ba:	e2b5      	b.n	8007f28 <protocol_exec_rt_system+0x5e4>
    }

    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) {
 80079bc:	1cfb      	adds	r3, r7, #3
 80079be:	781b      	ldrb	r3, [r3, #0]
 80079c0:	2201      	movs	r2, #1
 80079c2:	4013      	ands	r3, r2
 80079c4:	d004      	beq.n	80079d0 <protocol_exec_rt_system+0x8c>
      report_realtime_status();
 80079c6:	f001 f87f 	bl	8008ac8 <report_realtime_status>
      system_clear_exec_state_flag(EXEC_STATUS_REPORT);
 80079ca:	2001      	movs	r0, #1
 80079cc:	f004 f82a 	bl	800ba24 <system_clear_exec_state_flag>
    }

    // NOTE: Once hold is initiated, the system immediately enters a suspend state to block all
    // main program processes until either reset or resumed. This ensures a hold completes safely.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP)) {
 80079d0:	1cfb      	adds	r3, r7, #3
 80079d2:	781b      	ldrb	r3, [r3, #0]
 80079d4:	22e8      	movs	r2, #232	; 0xe8
 80079d6:	4013      	ands	r3, r2
 80079d8:	d100      	bne.n	80079dc <protocol_exec_rt_system+0x98>
 80079da:	e098      	b.n	8007b0e <protocol_exec_rt_system+0x1ca>

      // State check for allowable states for hold methods.
      if (!(sys.state & (STATE_ALARM | STATE_CHECK_MODE))) {
 80079dc:	4b99      	ldr	r3, [pc, #612]	; (8007c44 <protocol_exec_rt_system+0x300>)
 80079de:	781b      	ldrb	r3, [r3, #0]
 80079e0:	001a      	movs	r2, r3
 80079e2:	2303      	movs	r3, #3
 80079e4:	4013      	ands	r3, r2
 80079e6:	d000      	beq.n	80079ea <protocol_exec_rt_system+0xa6>
 80079e8:	e07b      	b.n	8007ae2 <protocol_exec_rt_system+0x19e>
      
        // If in CYCLE or JOG states, immediately initiate a motion HOLD.
        if (sys.state & (STATE_CYCLE | STATE_JOG)) {
 80079ea:	4b96      	ldr	r3, [pc, #600]	; (8007c44 <protocol_exec_rt_system+0x300>)
 80079ec:	781b      	ldrb	r3, [r3, #0]
 80079ee:	001a      	movs	r2, r3
 80079f0:	2328      	movs	r3, #40	; 0x28
 80079f2:	4013      	ands	r3, r2
 80079f4:	d01b      	beq.n	8007a2e <protocol_exec_rt_system+0xea>
          if (!(sys.suspend & (SUSPEND_MOTION_CANCEL | SUSPEND_JOG_CANCEL))) { // Block, if already holding.
 80079f6:	4b93      	ldr	r3, [pc, #588]	; (8007c44 <protocol_exec_rt_system+0x300>)
 80079f8:	789b      	ldrb	r3, [r3, #2]
 80079fa:	001a      	movs	r2, r3
 80079fc:	23c0      	movs	r3, #192	; 0xc0
 80079fe:	4013      	ands	r3, r2
 8007a00:	d115      	bne.n	8007a2e <protocol_exec_rt_system+0xea>
            st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
 8007a02:	f002 fd9b 	bl	800a53c <st_update_plan_block_parameters>
            sys.step_control = STEP_CONTROL_EXECUTE_HOLD; // Initiate suspend state with active flag.
 8007a06:	4b8f      	ldr	r3, [pc, #572]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007a08:	2202      	movs	r2, #2
 8007a0a:	711a      	strb	r2, [r3, #4]
            if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping.
 8007a0c:	4b8d      	ldr	r3, [pc, #564]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007a0e:	781b      	ldrb	r3, [r3, #0]
 8007a10:	2b20      	cmp	r3, #32
 8007a12:	d10c      	bne.n	8007a2e <protocol_exec_rt_system+0xea>
              if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
 8007a14:	1cfb      	adds	r3, r7, #3
 8007a16:	781b      	ldrb	r3, [r3, #0]
 8007a18:	b25b      	sxtb	r3, r3
 8007a1a:	2b00      	cmp	r3, #0
 8007a1c:	db07      	blt.n	8007a2e <protocol_exec_rt_system+0xea>
 8007a1e:	4b89      	ldr	r3, [pc, #548]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007a20:	789b      	ldrb	r3, [r3, #2]
 8007a22:	2280      	movs	r2, #128	; 0x80
 8007a24:	4252      	negs	r2, r2
 8007a26:	4313      	orrs	r3, r2
 8007a28:	b2da      	uxtb	r2, r3
 8007a2a:	4b86      	ldr	r3, [pc, #536]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007a2c:	709a      	strb	r2, [r3, #2]
            }
          }
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend state and hold is complete.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_HOLD_COMPLETE; }
 8007a2e:	4b85      	ldr	r3, [pc, #532]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007a30:	781b      	ldrb	r3, [r3, #0]
 8007a32:	2b00      	cmp	r3, #0
 8007a34:	d102      	bne.n	8007a3c <protocol_exec_rt_system+0xf8>
 8007a36:	4b83      	ldr	r3, [pc, #524]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007a38:	2201      	movs	r2, #1
 8007a3a:	709a      	strb	r2, [r3, #2]

        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
 8007a3c:	1cfb      	adds	r3, r7, #3
 8007a3e:	781b      	ldrb	r3, [r3, #0]
 8007a40:	2240      	movs	r2, #64	; 0x40
 8007a42:	4013      	ands	r3, r2
 8007a44:	d00c      	beq.n	8007a60 <protocol_exec_rt_system+0x11c>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. Motion cancel is valid for a single planner block motion only, while jog cancel
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
 8007a46:	4b7f      	ldr	r3, [pc, #508]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007a48:	781b      	ldrb	r3, [r3, #0]
 8007a4a:	001a      	movs	r2, r3
 8007a4c:	2320      	movs	r3, #32
 8007a4e:	4013      	ands	r3, r2
 8007a50:	d106      	bne.n	8007a60 <protocol_exec_rt_system+0x11c>
 8007a52:	4b7c      	ldr	r3, [pc, #496]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007a54:	789b      	ldrb	r3, [r3, #2]
 8007a56:	2240      	movs	r2, #64	; 0x40
 8007a58:	4313      	orrs	r3, r2
 8007a5a:	b2da      	uxtb	r2, r3
 8007a5c:	4b79      	ldr	r3, [pc, #484]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007a5e:	709a      	strb	r2, [r3, #2]
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
 8007a60:	1cfb      	adds	r3, r7, #3
 8007a62:	781b      	ldrb	r3, [r3, #0]
 8007a64:	2208      	movs	r2, #8
 8007a66:	4013      	ands	r3, r2
 8007a68:	d008      	beq.n	8007a7c <protocol_exec_rt_system+0x138>
          // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
          if (!(sys.state & (STATE_SAFETY_DOOR | STATE_JOG | STATE_SLEEP))) { sys.state = STATE_HOLD; }
 8007a6a:	4b76      	ldr	r3, [pc, #472]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007a6c:	781b      	ldrb	r3, [r3, #0]
 8007a6e:	001a      	movs	r2, r3
 8007a70:	23e0      	movs	r3, #224	; 0xe0
 8007a72:	4013      	ands	r3, r2
 8007a74:	d102      	bne.n	8007a7c <protocol_exec_rt_system+0x138>
 8007a76:	4b73      	ldr	r3, [pc, #460]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007a78:	2210      	movs	r2, #16
 8007a7a:	701a      	strb	r2, [r3, #0]
        }

        // Execute a safety door stop with a feed hold and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged.
        if (rt_exec & EXEC_SAFETY_DOOR) {
 8007a7c:	1cfb      	adds	r3, r7, #3
 8007a7e:	781b      	ldrb	r3, [r3, #0]
 8007a80:	2220      	movs	r2, #32
 8007a82:	4013      	ands	r3, r2
 8007a84:	d02d      	beq.n	8007ae2 <protocol_exec_rt_system+0x19e>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR);
 8007a86:	2006      	movs	r0, #6
 8007a88:	f000 fc98 	bl	80083bc <report_feedback_message>
          // If jogging, block safety door methods until jog cancel is complete. Just flag that it happened.
          if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
 8007a8c:	4b6d      	ldr	r3, [pc, #436]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007a8e:	789b      	ldrb	r3, [r3, #2]
 8007a90:	b25b      	sxtb	r3, r3
 8007a92:	2b00      	cmp	r3, #0
 8007a94:	db1e      	blt.n	8007ad4 <protocol_exec_rt_system+0x190>
            // Check if the safety re-opened during a restore parking motion only. Ignore if
            // already retracting, parked or in sleep state.
            if (sys.state == STATE_SAFETY_DOOR) {
 8007a96:	4b6b      	ldr	r3, [pc, #428]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007a98:	781b      	ldrb	r3, [r3, #0]
 8007a9a:	2b40      	cmp	r3, #64	; 0x40
 8007a9c:	d113      	bne.n	8007ac6 <protocol_exec_rt_system+0x182>
              if (sys.suspend & SUSPEND_INITIATE_RESTORE) { // Actively restoring
 8007a9e:	4b69      	ldr	r3, [pc, #420]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007aa0:	789b      	ldrb	r3, [r3, #2]
 8007aa2:	001a      	movs	r2, r3
 8007aa4:	2308      	movs	r3, #8
 8007aa6:	4013      	ands	r3, r2
 8007aa8:	d00d      	beq.n	8007ac6 <protocol_exec_rt_system+0x182>
                    st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
                    sys.step_control = (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION);
                    sys.suspend &= ~(SUSPEND_HOLD_COMPLETE);
                  } // else NO_MOTION is active.
                #endif
                sys.suspend &= ~(SUSPEND_RETRACT_COMPLETE | SUSPEND_INITIATE_RESTORE | SUSPEND_RESTORE_COMPLETE);
 8007aaa:	4b66      	ldr	r3, [pc, #408]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007aac:	789b      	ldrb	r3, [r3, #2]
 8007aae:	221c      	movs	r2, #28
 8007ab0:	4393      	bics	r3, r2
 8007ab2:	b2da      	uxtb	r2, r3
 8007ab4:	4b63      	ldr	r3, [pc, #396]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007ab6:	709a      	strb	r2, [r3, #2]
                sys.suspend |= SUSPEND_RESTART_RETRACT;
 8007ab8:	4b62      	ldr	r3, [pc, #392]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007aba:	789b      	ldrb	r3, [r3, #2]
 8007abc:	2202      	movs	r2, #2
 8007abe:	4313      	orrs	r3, r2
 8007ac0:	b2da      	uxtb	r2, r3
 8007ac2:	4b60      	ldr	r3, [pc, #384]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007ac4:	709a      	strb	r2, [r3, #2]
              }
            }
            if (sys.state != STATE_SLEEP) { sys.state = STATE_SAFETY_DOOR; }
 8007ac6:	4b5f      	ldr	r3, [pc, #380]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007ac8:	781b      	ldrb	r3, [r3, #0]
 8007aca:	2b80      	cmp	r3, #128	; 0x80
 8007acc:	d002      	beq.n	8007ad4 <protocol_exec_rt_system+0x190>
 8007ace:	4b5d      	ldr	r3, [pc, #372]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007ad0:	2240      	movs	r2, #64	; 0x40
 8007ad2:	701a      	strb	r2, [r3, #0]
          }
          // NOTE: This flag doesn't change when the door closes, unlike sys.state. Ensures any parking motions
          // are executed if the door switch closes and the state returns to HOLD.
          sys.suspend |= SUSPEND_SAFETY_DOOR_AJAR;
 8007ad4:	4b5b      	ldr	r3, [pc, #364]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007ad6:	789b      	ldrb	r3, [r3, #2]
 8007ad8:	2220      	movs	r2, #32
 8007ada:	4313      	orrs	r3, r2
 8007adc:	b2da      	uxtb	r2, r3
 8007ade:	4b59      	ldr	r3, [pc, #356]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007ae0:	709a      	strb	r2, [r3, #2]
        }
        
      }

      if (rt_exec & EXEC_SLEEP) {
 8007ae2:	1cfb      	adds	r3, r7, #3
 8007ae4:	781b      	ldrb	r3, [r3, #0]
 8007ae6:	b25b      	sxtb	r3, r3
 8007ae8:	2b00      	cmp	r3, #0
 8007aea:	da0d      	bge.n	8007b08 <protocol_exec_rt_system+0x1c4>
        if (sys.state == STATE_ALARM) { sys.suspend |= (SUSPEND_RETRACT_COMPLETE|SUSPEND_HOLD_COMPLETE); }
 8007aec:	4b55      	ldr	r3, [pc, #340]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007aee:	781b      	ldrb	r3, [r3, #0]
 8007af0:	2b01      	cmp	r3, #1
 8007af2:	d106      	bne.n	8007b02 <protocol_exec_rt_system+0x1be>
 8007af4:	4b53      	ldr	r3, [pc, #332]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007af6:	789b      	ldrb	r3, [r3, #2]
 8007af8:	2205      	movs	r2, #5
 8007afa:	4313      	orrs	r3, r2
 8007afc:	b2da      	uxtb	r2, r3
 8007afe:	4b51      	ldr	r3, [pc, #324]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b00:	709a      	strb	r2, [r3, #2]
        sys.state = STATE_SLEEP; 
 8007b02:	4b50      	ldr	r3, [pc, #320]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b04:	2280      	movs	r2, #128	; 0x80
 8007b06:	701a      	strb	r2, [r3, #0]
      }

      system_clear_exec_state_flag((EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP));
 8007b08:	20e8      	movs	r0, #232	; 0xe8
 8007b0a:	f003 ff8b 	bl	800ba24 <system_clear_exec_state_flag>
    }

    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
 8007b0e:	1cfb      	adds	r3, r7, #3
 8007b10:	781b      	ldrb	r3, [r3, #0]
 8007b12:	2202      	movs	r2, #2
 8007b14:	4013      	ands	r3, r2
 8007b16:	d100      	bne.n	8007b1a <protocol_exec_rt_system+0x1d6>
 8007b18:	e066      	b.n	8007be8 <protocol_exec_rt_system+0x2a4>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) {
 8007b1a:	1cfb      	adds	r3, r7, #3
 8007b1c:	781b      	ldrb	r3, [r3, #0]
 8007b1e:	2268      	movs	r2, #104	; 0x68
 8007b20:	4013      	ands	r3, r2
 8007b22:	d15e      	bne.n	8007be2 <protocol_exec_rt_system+0x29e>
        // Resume door state when parking motion has retracted and door has been closed.
        if ((sys.state == STATE_SAFETY_DOOR) && !(sys.suspend & SUSPEND_SAFETY_DOOR_AJAR)) {
 8007b24:	4b47      	ldr	r3, [pc, #284]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b26:	781b      	ldrb	r3, [r3, #0]
 8007b28:	2b40      	cmp	r3, #64	; 0x40
 8007b2a:	d11c      	bne.n	8007b66 <protocol_exec_rt_system+0x222>
 8007b2c:	4b45      	ldr	r3, [pc, #276]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b2e:	789b      	ldrb	r3, [r3, #2]
 8007b30:	001a      	movs	r2, r3
 8007b32:	2320      	movs	r3, #32
 8007b34:	4013      	ands	r3, r2
 8007b36:	d116      	bne.n	8007b66 <protocol_exec_rt_system+0x222>
          if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
 8007b38:	4b42      	ldr	r3, [pc, #264]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b3a:	789b      	ldrb	r3, [r3, #2]
 8007b3c:	001a      	movs	r2, r3
 8007b3e:	2310      	movs	r3, #16
 8007b40:	4013      	ands	r3, r2
 8007b42:	d003      	beq.n	8007b4c <protocol_exec_rt_system+0x208>
            sys.state = STATE_IDLE; // Set to IDLE to immediately resume the cycle.
 8007b44:	4b3f      	ldr	r3, [pc, #252]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b46:	2200      	movs	r2, #0
 8007b48:	701a      	strb	r2, [r3, #0]
 8007b4a:	e00c      	b.n	8007b66 <protocol_exec_rt_system+0x222>
          } else if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
 8007b4c:	4b3d      	ldr	r3, [pc, #244]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b4e:	789b      	ldrb	r3, [r3, #2]
 8007b50:	001a      	movs	r2, r3
 8007b52:	2304      	movs	r3, #4
 8007b54:	4013      	ands	r3, r2
 8007b56:	d006      	beq.n	8007b66 <protocol_exec_rt_system+0x222>
            // Flag to re-energize powered components and restore original position, if disabled by SAFETY_DOOR.
            // NOTE: For a safety door to resume, the switch must be closed, as indicated by HOLD state, and
            // the retraction execution is complete, which implies the initial feed hold is not active. To
            // restore normal operation, the restore procedures must be initiated by the following flag. Once,
            // they are complete, it will call CYCLE_START automatically to resume and exit the suspend.
            sys.suspend |= SUSPEND_INITIATE_RESTORE;
 8007b58:	4b3a      	ldr	r3, [pc, #232]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b5a:	789b      	ldrb	r3, [r3, #2]
 8007b5c:	2208      	movs	r2, #8
 8007b5e:	4313      	orrs	r3, r2
 8007b60:	b2da      	uxtb	r2, r3
 8007b62:	4b38      	ldr	r3, [pc, #224]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b64:	709a      	strb	r2, [r3, #2]
          }
        }
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        if ((sys.state == STATE_IDLE) || ((sys.state & STATE_HOLD) && (sys.suspend & SUSPEND_HOLD_COMPLETE))) {
 8007b66:	4b37      	ldr	r3, [pc, #220]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b68:	781b      	ldrb	r3, [r3, #0]
 8007b6a:	2b00      	cmp	r3, #0
 8007b6c:	d00b      	beq.n	8007b86 <protocol_exec_rt_system+0x242>
 8007b6e:	4b35      	ldr	r3, [pc, #212]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b70:	781b      	ldrb	r3, [r3, #0]
 8007b72:	001a      	movs	r2, r3
 8007b74:	2310      	movs	r3, #16
 8007b76:	4013      	ands	r3, r2
 8007b78:	d033      	beq.n	8007be2 <protocol_exec_rt_system+0x29e>
 8007b7a:	4b32      	ldr	r3, [pc, #200]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b7c:	789b      	ldrb	r3, [r3, #2]
 8007b7e:	001a      	movs	r2, r3
 8007b80:	2301      	movs	r3, #1
 8007b82:	4013      	ands	r3, r2
 8007b84:	d02d      	beq.n	8007be2 <protocol_exec_rt_system+0x29e>
          if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
 8007b86:	4b2f      	ldr	r3, [pc, #188]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b88:	781b      	ldrb	r3, [r3, #0]
 8007b8a:	2b10      	cmp	r3, #16
 8007b8c:	d10b      	bne.n	8007ba6 <protocol_exec_rt_system+0x262>
 8007b8e:	4b2d      	ldr	r3, [pc, #180]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b90:	7a9b      	ldrb	r3, [r3, #10]
 8007b92:	2b00      	cmp	r3, #0
 8007b94:	d007      	beq.n	8007ba6 <protocol_exec_rt_system+0x262>
            sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend routine and cycle start after.
 8007b96:	4b2b      	ldr	r3, [pc, #172]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007b98:	7a9b      	ldrb	r3, [r3, #10]
 8007b9a:	2208      	movs	r2, #8
 8007b9c:	4313      	orrs	r3, r2
 8007b9e:	b2da      	uxtb	r2, r3
 8007ba0:	4b28      	ldr	r3, [pc, #160]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007ba2:	729a      	strb	r2, [r3, #10]
 8007ba4:	e01d      	b.n	8007be2 <protocol_exec_rt_system+0x29e>
          } else {
            // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
            sys.step_control = STEP_CONTROL_NORMAL_OP; // Restore step control to normal operation
 8007ba6:	4b27      	ldr	r3, [pc, #156]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007ba8:	2200      	movs	r2, #0
 8007baa:	711a      	strb	r2, [r3, #4]
            if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
 8007bac:	f7fe ffe6 	bl	8006b7c <plan_get_current_block>
 8007bb0:	1e03      	subs	r3, r0, #0
 8007bb2:	d010      	beq.n	8007bd6 <protocol_exec_rt_system+0x292>
 8007bb4:	4b23      	ldr	r3, [pc, #140]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007bb6:	789b      	ldrb	r3, [r3, #2]
 8007bb8:	001a      	movs	r2, r3
 8007bba:	2340      	movs	r3, #64	; 0x40
 8007bbc:	4013      	ands	r3, r2
 8007bbe:	d10a      	bne.n	8007bd6 <protocol_exec_rt_system+0x292>
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
 8007bc0:	4b20      	ldr	r3, [pc, #128]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007bc2:	2200      	movs	r2, #0
 8007bc4:	709a      	strb	r2, [r3, #2]
              sys.state = STATE_CYCLE;
 8007bc6:	4b1f      	ldr	r3, [pc, #124]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007bc8:	2208      	movs	r2, #8
 8007bca:	701a      	strb	r2, [r3, #0]
              st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
 8007bcc:	f002 fcf2 	bl	800a5b4 <st_prep_buffer>
              st_wake_up();
 8007bd0:	f002 f91e 	bl	8009e10 <st_wake_up>
 8007bd4:	e005      	b.n	8007be2 <protocol_exec_rt_system+0x29e>
            } else { // Otherwise, do nothing. Set and resume IDLE state.
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
 8007bd6:	4b1b      	ldr	r3, [pc, #108]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007bd8:	2200      	movs	r2, #0
 8007bda:	709a      	strb	r2, [r3, #2]
              sys.state = STATE_IDLE;
 8007bdc:	4b19      	ldr	r3, [pc, #100]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007bde:	2200      	movs	r2, #0
 8007be0:	701a      	strb	r2, [r3, #0]
            }
          }
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_START);
 8007be2:	2002      	movs	r0, #2
 8007be4:	f003 ff1e 	bl	800ba24 <system_clear_exec_state_flag>
    }

    if (rt_exec & EXEC_CYCLE_STOP) {
 8007be8:	1cfb      	adds	r3, r7, #3
 8007bea:	781b      	ldrb	r3, [r3, #0]
 8007bec:	2204      	movs	r2, #4
 8007bee:	4013      	ands	r3, r2
 8007bf0:	d05d      	beq.n	8007cae <protocol_exec_rt_system+0x36a>
      // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by
      // realtime command execution in the main program, ensuring that the planner re-plans safely.
      // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
      // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.
      // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
      if ((sys.state & (STATE_HOLD|STATE_SAFETY_DOOR|STATE_SLEEP)) && !(sys.soft_limit) && !(sys.suspend & SUSPEND_JOG_CANCEL)) {
 8007bf2:	4b14      	ldr	r3, [pc, #80]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007bf4:	781b      	ldrb	r3, [r3, #0]
 8007bf6:	001a      	movs	r2, r3
 8007bf8:	23d0      	movs	r3, #208	; 0xd0
 8007bfa:	4013      	ands	r3, r2
 8007bfc:	d026      	beq.n	8007c4c <protocol_exec_rt_system+0x308>
 8007bfe:	4b11      	ldr	r3, [pc, #68]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007c00:	78db      	ldrb	r3, [r3, #3]
 8007c02:	2b00      	cmp	r3, #0
 8007c04:	d122      	bne.n	8007c4c <protocol_exec_rt_system+0x308>
 8007c06:	4b0f      	ldr	r3, [pc, #60]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007c08:	789b      	ldrb	r3, [r3, #2]
 8007c0a:	b25b      	sxtb	r3, r3
 8007c0c:	2b00      	cmp	r3, #0
 8007c0e:	db1d      	blt.n	8007c4c <protocol_exec_rt_system+0x308>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        plan_cycle_reinitialize();
 8007c10:	f7ff fb32 	bl	8007278 <plan_cycle_reinitialize>
        if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { sys.suspend |= SUSPEND_HOLD_COMPLETE; }
 8007c14:	4b0b      	ldr	r3, [pc, #44]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007c16:	791b      	ldrb	r3, [r3, #4]
 8007c18:	001a      	movs	r2, r3
 8007c1a:	2302      	movs	r3, #2
 8007c1c:	4013      	ands	r3, r2
 8007c1e:	d006      	beq.n	8007c2e <protocol_exec_rt_system+0x2ea>
 8007c20:	4b08      	ldr	r3, [pc, #32]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007c22:	789b      	ldrb	r3, [r3, #2]
 8007c24:	2201      	movs	r2, #1
 8007c26:	4313      	orrs	r3, r2
 8007c28:	b2da      	uxtb	r2, r3
 8007c2a:	4b06      	ldr	r3, [pc, #24]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007c2c:	709a      	strb	r2, [r3, #2]
        bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
 8007c2e:	4b05      	ldr	r3, [pc, #20]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007c30:	791b      	ldrb	r3, [r3, #4]
 8007c32:	2206      	movs	r2, #6
 8007c34:	4393      	bics	r3, r2
 8007c36:	b2da      	uxtb	r2, r3
 8007c38:	4b02      	ldr	r3, [pc, #8]	; (8007c44 <protocol_exec_rt_system+0x300>)
 8007c3a:	711a      	strb	r2, [r3, #4]
 8007c3c:	e034      	b.n	8007ca8 <protocol_exec_rt_system+0x364>
 8007c3e:	46c0      	nop			; (mov r8, r8)
 8007c40:	20000b5c 	.word	0x20000b5c
 8007c44:	20000b2c 	.word	0x20000b2c
 8007c48:	20000b41 	.word	0x20000b41
      } else {
        // Motion complete. Includes CYCLE/JOG/HOMING states and jog cancel/motion cancel/soft limit events.
        // NOTE: Motion and jog cancel both immediately return to idle after the hold completes.
        if (sys.suspend & SUSPEND_JOG_CANCEL) {   // For jog cancel, flush buffers and sync positions.
 8007c4c:	4bb8      	ldr	r3, [pc, #736]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007c4e:	789b      	ldrb	r3, [r3, #2]
 8007c50:	b25b      	sxtb	r3, r3
 8007c52:	2b00      	cmp	r3, #0
 8007c54:	da0a      	bge.n	8007c6c <protocol_exec_rt_system+0x328>
          sys.step_control = STEP_CONTROL_NORMAL_OP;
 8007c56:	4bb6      	ldr	r3, [pc, #728]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007c58:	2200      	movs	r2, #0
 8007c5a:	711a      	strb	r2, [r3, #4]
          plan_reset();
 8007c5c:	f7fe ff2a 	bl	8006ab4 <plan_reset>
          st_reset();
 8007c60:	f002 fb98 	bl	800a394 <st_reset>
          gc_sync_position();
 8007c64:	f7fb fee0 	bl	8003a28 <gc_sync_position>
          plan_sync_position();
 8007c68:	f7ff fac4 	bl	80071f4 <plan_sync_position>
        }
        if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) { // Only occurs when safety door opens during jog.
 8007c6c:	4bb0      	ldr	r3, [pc, #704]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007c6e:	789b      	ldrb	r3, [r3, #2]
 8007c70:	001a      	movs	r2, r3
 8007c72:	2320      	movs	r3, #32
 8007c74:	4013      	ands	r3, r2
 8007c76:	d011      	beq.n	8007c9c <protocol_exec_rt_system+0x358>
          sys.suspend &= ~(SUSPEND_JOG_CANCEL);
 8007c78:	4bad      	ldr	r3, [pc, #692]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007c7a:	789b      	ldrb	r3, [r3, #2]
 8007c7c:	227f      	movs	r2, #127	; 0x7f
 8007c7e:	4013      	ands	r3, r2
 8007c80:	b2da      	uxtb	r2, r3
 8007c82:	4bab      	ldr	r3, [pc, #684]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007c84:	709a      	strb	r2, [r3, #2]
          sys.suspend |= SUSPEND_HOLD_COMPLETE;
 8007c86:	4baa      	ldr	r3, [pc, #680]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007c88:	789b      	ldrb	r3, [r3, #2]
 8007c8a:	2201      	movs	r2, #1
 8007c8c:	4313      	orrs	r3, r2
 8007c8e:	b2da      	uxtb	r2, r3
 8007c90:	4ba7      	ldr	r3, [pc, #668]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007c92:	709a      	strb	r2, [r3, #2]
          sys.state = STATE_SAFETY_DOOR;
 8007c94:	4ba6      	ldr	r3, [pc, #664]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007c96:	2240      	movs	r2, #64	; 0x40
 8007c98:	701a      	strb	r2, [r3, #0]
 8007c9a:	e005      	b.n	8007ca8 <protocol_exec_rt_system+0x364>
        } else {
          sys.suspend = SUSPEND_DISABLE;
 8007c9c:	4ba4      	ldr	r3, [pc, #656]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007c9e:	2200      	movs	r2, #0
 8007ca0:	709a      	strb	r2, [r3, #2]
          sys.state = STATE_IDLE;
 8007ca2:	4ba3      	ldr	r3, [pc, #652]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007ca4:	2200      	movs	r2, #0
 8007ca6:	701a      	strb	r2, [r3, #0]
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_STOP);
 8007ca8:	2004      	movs	r0, #4
 8007caa:	f003 febb 	bl	800ba24 <system_clear_exec_state_flag>
    }
  }

  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
 8007cae:	1cfb      	adds	r3, r7, #3
 8007cb0:	4aa0      	ldr	r2, [pc, #640]	; (8007f34 <protocol_exec_rt_system+0x5f0>)
 8007cb2:	7812      	ldrb	r2, [r2, #0]
 8007cb4:	701a      	strb	r2, [r3, #0]
  if (rt_exec) {
 8007cb6:	1cfb      	adds	r3, r7, #3
 8007cb8:	781b      	ldrb	r3, [r3, #0]
 8007cba:	2b00      	cmp	r3, #0
 8007cbc:	d100      	bne.n	8007cc0 <protocol_exec_rt_system+0x37c>
 8007cbe:	e07c      	b.n	8007dba <protocol_exec_rt_system+0x476>
    system_clear_exec_motion_overrides(); // Clear all motion override flags.
 8007cc0:	f003 ff20 	bl	800bb04 <system_clear_exec_motion_overrides>

    uint8_t new_f_override =  sys.f_override;
 8007cc4:	1dfb      	adds	r3, r7, #7
 8007cc6:	4a9a      	ldr	r2, [pc, #616]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007cc8:	79d2      	ldrb	r2, [r2, #7]
 8007cca:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
 8007ccc:	1cfb      	adds	r3, r7, #3
 8007cce:	781b      	ldrb	r3, [r3, #0]
 8007cd0:	2201      	movs	r2, #1
 8007cd2:	4013      	ands	r3, r2
 8007cd4:	d002      	beq.n	8007cdc <protocol_exec_rt_system+0x398>
 8007cd6:	1dfb      	adds	r3, r7, #7
 8007cd8:	2264      	movs	r2, #100	; 0x64
 8007cda:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_FEED_OVR_COARSE_PLUS) { new_f_override += FEED_OVERRIDE_COARSE_INCREMENT; }
 8007cdc:	1cfb      	adds	r3, r7, #3
 8007cde:	781b      	ldrb	r3, [r3, #0]
 8007ce0:	2202      	movs	r2, #2
 8007ce2:	4013      	ands	r3, r2
 8007ce4:	d004      	beq.n	8007cf0 <protocol_exec_rt_system+0x3ac>
 8007ce6:	1dfb      	adds	r3, r7, #7
 8007ce8:	1dfa      	adds	r2, r7, #7
 8007cea:	7812      	ldrb	r2, [r2, #0]
 8007cec:	320a      	adds	r2, #10
 8007cee:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_FEED_OVR_COARSE_MINUS) { new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT; }
 8007cf0:	1cfb      	adds	r3, r7, #3
 8007cf2:	781b      	ldrb	r3, [r3, #0]
 8007cf4:	2204      	movs	r2, #4
 8007cf6:	4013      	ands	r3, r2
 8007cf8:	d004      	beq.n	8007d04 <protocol_exec_rt_system+0x3c0>
 8007cfa:	1dfb      	adds	r3, r7, #7
 8007cfc:	1dfa      	adds	r2, r7, #7
 8007cfe:	7812      	ldrb	r2, [r2, #0]
 8007d00:	3a0a      	subs	r2, #10
 8007d02:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
 8007d04:	1cfb      	adds	r3, r7, #3
 8007d06:	781b      	ldrb	r3, [r3, #0]
 8007d08:	2208      	movs	r2, #8
 8007d0a:	4013      	ands	r3, r2
 8007d0c:	d004      	beq.n	8007d18 <protocol_exec_rt_system+0x3d4>
 8007d0e:	1dfb      	adds	r3, r7, #7
 8007d10:	1dfa      	adds	r2, r7, #7
 8007d12:	7812      	ldrb	r2, [r2, #0]
 8007d14:	3201      	adds	r2, #1
 8007d16:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
 8007d18:	1cfb      	adds	r3, r7, #3
 8007d1a:	781b      	ldrb	r3, [r3, #0]
 8007d1c:	2210      	movs	r2, #16
 8007d1e:	4013      	ands	r3, r2
 8007d20:	d004      	beq.n	8007d2c <protocol_exec_rt_system+0x3e8>
 8007d22:	1dfb      	adds	r3, r7, #7
 8007d24:	1dfa      	adds	r2, r7, #7
 8007d26:	7812      	ldrb	r2, [r2, #0]
 8007d28:	3a01      	subs	r2, #1
 8007d2a:	701a      	strb	r2, [r3, #0]
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
 8007d2c:	1dfa      	adds	r2, r7, #7
 8007d2e:	1dfb      	adds	r3, r7, #7
 8007d30:	781b      	ldrb	r3, [r3, #0]
 8007d32:	b2d9      	uxtb	r1, r3
 8007d34:	29c8      	cmp	r1, #200	; 0xc8
 8007d36:	d900      	bls.n	8007d3a <protocol_exec_rt_system+0x3f6>
 8007d38:	23c8      	movs	r3, #200	; 0xc8
 8007d3a:	7013      	strb	r3, [r2, #0]
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);
 8007d3c:	1dfa      	adds	r2, r7, #7
 8007d3e:	1dfb      	adds	r3, r7, #7
 8007d40:	781b      	ldrb	r3, [r3, #0]
 8007d42:	b2d9      	uxtb	r1, r3
 8007d44:	290a      	cmp	r1, #10
 8007d46:	d200      	bcs.n	8007d4a <protocol_exec_rt_system+0x406>
 8007d48:	230a      	movs	r3, #10
 8007d4a:	7013      	strb	r3, [r2, #0]

    uint8_t new_r_override = sys.r_override;
 8007d4c:	1dbb      	adds	r3, r7, #6
 8007d4e:	4a78      	ldr	r2, [pc, #480]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007d50:	7a12      	ldrb	r2, [r2, #8]
 8007d52:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
 8007d54:	1cfb      	adds	r3, r7, #3
 8007d56:	781b      	ldrb	r3, [r3, #0]
 8007d58:	2220      	movs	r2, #32
 8007d5a:	4013      	ands	r3, r2
 8007d5c:	d002      	beq.n	8007d64 <protocol_exec_rt_system+0x420>
 8007d5e:	1dbb      	adds	r3, r7, #6
 8007d60:	2264      	movs	r2, #100	; 0x64
 8007d62:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_RAPID_OVR_MEDIUM) { new_r_override = RAPID_OVERRIDE_MEDIUM; }
 8007d64:	1cfb      	adds	r3, r7, #3
 8007d66:	781b      	ldrb	r3, [r3, #0]
 8007d68:	2240      	movs	r2, #64	; 0x40
 8007d6a:	4013      	ands	r3, r2
 8007d6c:	d002      	beq.n	8007d74 <protocol_exec_rt_system+0x430>
 8007d6e:	1dbb      	adds	r3, r7, #6
 8007d70:	2232      	movs	r2, #50	; 0x32
 8007d72:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_RAPID_OVR_LOW) { new_r_override = RAPID_OVERRIDE_LOW; }
 8007d74:	1cfb      	adds	r3, r7, #3
 8007d76:	781b      	ldrb	r3, [r3, #0]
 8007d78:	b25b      	sxtb	r3, r3
 8007d7a:	2b00      	cmp	r3, #0
 8007d7c:	da02      	bge.n	8007d84 <protocol_exec_rt_system+0x440>
 8007d7e:	1dbb      	adds	r3, r7, #6
 8007d80:	2219      	movs	r2, #25
 8007d82:	701a      	strb	r2, [r3, #0]

    if ((new_f_override != sys.f_override) || (new_r_override != sys.r_override)) {
 8007d84:	4b6a      	ldr	r3, [pc, #424]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007d86:	79db      	ldrb	r3, [r3, #7]
 8007d88:	1dfa      	adds	r2, r7, #7
 8007d8a:	7812      	ldrb	r2, [r2, #0]
 8007d8c:	429a      	cmp	r2, r3
 8007d8e:	d105      	bne.n	8007d9c <protocol_exec_rt_system+0x458>
 8007d90:	4b67      	ldr	r3, [pc, #412]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007d92:	7a1b      	ldrb	r3, [r3, #8]
 8007d94:	1dba      	adds	r2, r7, #6
 8007d96:	7812      	ldrb	r2, [r2, #0]
 8007d98:	429a      	cmp	r2, r3
 8007d9a:	d00e      	beq.n	8007dba <protocol_exec_rt_system+0x476>
      sys.f_override = new_f_override;
 8007d9c:	4b64      	ldr	r3, [pc, #400]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007d9e:	1dfa      	adds	r2, r7, #7
 8007da0:	7812      	ldrb	r2, [r2, #0]
 8007da2:	71da      	strb	r2, [r3, #7]
      sys.r_override = new_r_override;
 8007da4:	4b62      	ldr	r3, [pc, #392]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007da6:	1dba      	adds	r2, r7, #6
 8007da8:	7812      	ldrb	r2, [r2, #0]
 8007daa:	721a      	strb	r2, [r3, #8]
      sys.report_ovr_counter = 0; // Set to report change immediately
 8007dac:	4b60      	ldr	r3, [pc, #384]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007dae:	2200      	movs	r2, #0
 8007db0:	72da      	strb	r2, [r3, #11]
      plan_update_velocity_profile_parameters();
 8007db2:	f7fe ffb9 	bl	8006d28 <plan_update_velocity_profile_parameters>
      plan_cycle_reinitialize();
 8007db6:	f7ff fa5f 	bl	8007278 <plan_cycle_reinitialize>
    }
  }

  rt_exec = sys_rt_exec_accessory_override;
 8007dba:	1cfb      	adds	r3, r7, #3
 8007dbc:	4a5e      	ldr	r2, [pc, #376]	; (8007f38 <protocol_exec_rt_system+0x5f4>)
 8007dbe:	7812      	ldrb	r2, [r2, #0]
 8007dc0:	701a      	strb	r2, [r3, #0]
  if (rt_exec) {
 8007dc2:	1cfb      	adds	r3, r7, #3
 8007dc4:	781b      	ldrb	r3, [r3, #0]
 8007dc6:	2b00      	cmp	r3, #0
 8007dc8:	d100      	bne.n	8007dcc <protocol_exec_rt_system+0x488>
 8007dca:	e0a5      	b.n	8007f18 <protocol_exec_rt_system+0x5d4>
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.
 8007dcc:	f003 fea6 	bl	800bb1c <system_clear_exec_accessory_overrides>

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
 8007dd0:	1d7b      	adds	r3, r7, #5
 8007dd2:	4a57      	ldr	r2, [pc, #348]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007dd4:	7a52      	ldrb	r2, [r2, #9]
 8007dd6:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
 8007dd8:	1cfb      	adds	r3, r7, #3
 8007dda:	781b      	ldrb	r3, [r3, #0]
 8007ddc:	2201      	movs	r2, #1
 8007dde:	4013      	ands	r3, r2
 8007de0:	d002      	beq.n	8007de8 <protocol_exec_rt_system+0x4a4>
 8007de2:	1d7b      	adds	r3, r7, #5
 8007de4:	2264      	movs	r2, #100	; 0x64
 8007de6:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_PLUS) { last_s_override += SPINDLE_OVERRIDE_COARSE_INCREMENT; }
 8007de8:	1cfb      	adds	r3, r7, #3
 8007dea:	781b      	ldrb	r3, [r3, #0]
 8007dec:	2202      	movs	r2, #2
 8007dee:	4013      	ands	r3, r2
 8007df0:	d004      	beq.n	8007dfc <protocol_exec_rt_system+0x4b8>
 8007df2:	1d7b      	adds	r3, r7, #5
 8007df4:	1d7a      	adds	r2, r7, #5
 8007df6:	7812      	ldrb	r2, [r2, #0]
 8007df8:	320a      	adds	r2, #10
 8007dfa:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_COARSE_INCREMENT; }
 8007dfc:	1cfb      	adds	r3, r7, #3
 8007dfe:	781b      	ldrb	r3, [r3, #0]
 8007e00:	2204      	movs	r2, #4
 8007e02:	4013      	ands	r3, r2
 8007e04:	d004      	beq.n	8007e10 <protocol_exec_rt_system+0x4cc>
 8007e06:	1d7b      	adds	r3, r7, #5
 8007e08:	1d7a      	adds	r2, r7, #5
 8007e0a:	7812      	ldrb	r2, [r2, #0]
 8007e0c:	3a0a      	subs	r2, #10
 8007e0e:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_PLUS) { last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT; }
 8007e10:	1cfb      	adds	r3, r7, #3
 8007e12:	781b      	ldrb	r3, [r3, #0]
 8007e14:	2208      	movs	r2, #8
 8007e16:	4013      	ands	r3, r2
 8007e18:	d004      	beq.n	8007e24 <protocol_exec_rt_system+0x4e0>
 8007e1a:	1d7b      	adds	r3, r7, #5
 8007e1c:	1d7a      	adds	r2, r7, #5
 8007e1e:	7812      	ldrb	r2, [r2, #0]
 8007e20:	3201      	adds	r2, #1
 8007e22:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT; }
 8007e24:	1cfb      	adds	r3, r7, #3
 8007e26:	781b      	ldrb	r3, [r3, #0]
 8007e28:	2210      	movs	r2, #16
 8007e2a:	4013      	ands	r3, r2
 8007e2c:	d004      	beq.n	8007e38 <protocol_exec_rt_system+0x4f4>
 8007e2e:	1d7b      	adds	r3, r7, #5
 8007e30:	1d7a      	adds	r2, r7, #5
 8007e32:	7812      	ldrb	r2, [r2, #0]
 8007e34:	3a01      	subs	r2, #1
 8007e36:	701a      	strb	r2, [r3, #0]
    last_s_override = min(last_s_override,MAX_SPINDLE_SPEED_OVERRIDE);
 8007e38:	1d7a      	adds	r2, r7, #5
 8007e3a:	1d7b      	adds	r3, r7, #5
 8007e3c:	781b      	ldrb	r3, [r3, #0]
 8007e3e:	b2d9      	uxtb	r1, r3
 8007e40:	29c8      	cmp	r1, #200	; 0xc8
 8007e42:	d900      	bls.n	8007e46 <protocol_exec_rt_system+0x502>
 8007e44:	23c8      	movs	r3, #200	; 0xc8
 8007e46:	7013      	strb	r3, [r2, #0]
    last_s_override = max(last_s_override,MIN_SPINDLE_SPEED_OVERRIDE);
 8007e48:	1d7a      	adds	r2, r7, #5
 8007e4a:	1d7b      	adds	r3, r7, #5
 8007e4c:	781b      	ldrb	r3, [r3, #0]
 8007e4e:	b2d9      	uxtb	r1, r3
 8007e50:	290a      	cmp	r1, #10
 8007e52:	d200      	bcs.n	8007e56 <protocol_exec_rt_system+0x512>
 8007e54:	230a      	movs	r3, #10
 8007e56:	7013      	strb	r3, [r2, #0]

    if (last_s_override != sys.spindle_speed_ovr) {
 8007e58:	4b35      	ldr	r3, [pc, #212]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007e5a:	7a5b      	ldrb	r3, [r3, #9]
 8007e5c:	1d7a      	adds	r2, r7, #5
 8007e5e:	7812      	ldrb	r2, [r2, #0]
 8007e60:	429a      	cmp	r2, r3
 8007e62:	d00d      	beq.n	8007e80 <protocol_exec_rt_system+0x53c>
      bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 8007e64:	4b32      	ldr	r3, [pc, #200]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007e66:	791b      	ldrb	r3, [r3, #4]
 8007e68:	2208      	movs	r2, #8
 8007e6a:	4313      	orrs	r3, r2
 8007e6c:	b2da      	uxtb	r2, r3
 8007e6e:	4b30      	ldr	r3, [pc, #192]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007e70:	711a      	strb	r2, [r3, #4]
      sys.spindle_speed_ovr = last_s_override;
 8007e72:	4b2f      	ldr	r3, [pc, #188]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007e74:	1d7a      	adds	r2, r7, #5
 8007e76:	7812      	ldrb	r2, [r2, #0]
 8007e78:	725a      	strb	r2, [r3, #9]
      sys.report_ovr_counter = 0; // Set to report change immediately
 8007e7a:	4b2d      	ldr	r3, [pc, #180]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007e7c:	2200      	movs	r2, #0
 8007e7e:	72da      	strb	r2, [r3, #11]
    }

    if (rt_exec & EXEC_SPINDLE_OVR_STOP) {
 8007e80:	1cfb      	adds	r3, r7, #3
 8007e82:	781b      	ldrb	r3, [r3, #0]
 8007e84:	2220      	movs	r2, #32
 8007e86:	4013      	ands	r3, r2
 8007e88:	d018      	beq.n	8007ebc <protocol_exec_rt_system+0x578>
      // Spindle stop override allowed only while in HOLD state.
      // NOTE: Report counters are set in spindle_set_state() when spindle stop is executed.
      if (sys.state == STATE_HOLD) {
 8007e8a:	4b29      	ldr	r3, [pc, #164]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007e8c:	781b      	ldrb	r3, [r3, #0]
 8007e8e:	2b10      	cmp	r3, #16
 8007e90:	d114      	bne.n	8007ebc <protocol_exec_rt_system+0x578>
        if (!(sys.spindle_stop_ovr)) { sys.spindle_stop_ovr = SPINDLE_STOP_OVR_INITIATE; }
 8007e92:	4b27      	ldr	r3, [pc, #156]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007e94:	7a9b      	ldrb	r3, [r3, #10]
 8007e96:	2b00      	cmp	r3, #0
 8007e98:	d103      	bne.n	8007ea2 <protocol_exec_rt_system+0x55e>
 8007e9a:	4b25      	ldr	r3, [pc, #148]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007e9c:	2202      	movs	r2, #2
 8007e9e:	729a      	strb	r2, [r3, #10]
 8007ea0:	e00c      	b.n	8007ebc <protocol_exec_rt_system+0x578>
        else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE; }
 8007ea2:	4b23      	ldr	r3, [pc, #140]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007ea4:	7a9b      	ldrb	r3, [r3, #10]
 8007ea6:	001a      	movs	r2, r3
 8007ea8:	2301      	movs	r3, #1
 8007eaa:	4013      	ands	r3, r2
 8007eac:	d006      	beq.n	8007ebc <protocol_exec_rt_system+0x578>
 8007eae:	4b20      	ldr	r3, [pc, #128]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007eb0:	7a9b      	ldrb	r3, [r3, #10]
 8007eb2:	2204      	movs	r2, #4
 8007eb4:	4313      	orrs	r3, r2
 8007eb6:	b2da      	uxtb	r2, r3
 8007eb8:	4b1d      	ldr	r3, [pc, #116]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007eba:	729a      	strb	r2, [r3, #10]
      }
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
 8007ebc:	1cfb      	adds	r3, r7, #3
 8007ebe:	781b      	ldrb	r3, [r3, #0]
 8007ec0:	22c0      	movs	r2, #192	; 0xc0
 8007ec2:	4013      	ands	r3, r2
 8007ec4:	d028      	beq.n	8007f18 <protocol_exec_rt_system+0x5d4>
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 8007ec6:	4b1a      	ldr	r3, [pc, #104]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007ec8:	781b      	ldrb	r3, [r3, #0]
 8007eca:	2b00      	cmp	r3, #0
 8007ecc:	d005      	beq.n	8007eda <protocol_exec_rt_system+0x596>
 8007ece:	4b18      	ldr	r3, [pc, #96]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007ed0:	781b      	ldrb	r3, [r3, #0]
 8007ed2:	001a      	movs	r2, r3
 8007ed4:	2318      	movs	r3, #24
 8007ed6:	4013      	ands	r3, r2
 8007ed8:	d01e      	beq.n	8007f18 <protocol_exec_rt_system+0x5d4>
        uint8_t coolant_state = gc_state.modal.coolant;
 8007eda:	1d3b      	adds	r3, r7, #4
 8007edc:	4a17      	ldr	r2, [pc, #92]	; (8007f3c <protocol_exec_rt_system+0x5f8>)
 8007ede:	7a12      	ldrb	r2, [r2, #8]
 8007ee0:	701a      	strb	r2, [r3, #0]
          if (rt_exec & EXEC_COOLANT_FLOOD_OVR_TOGGLE) {
            if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABLE); }
            else { coolant_state |= COOLANT_FLOOD_ENABLE; }
          }
        #else
          if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABLE); }
 8007ee2:	1d3b      	adds	r3, r7, #4
 8007ee4:	781b      	ldrb	r3, [r3, #0]
 8007ee6:	2240      	movs	r2, #64	; 0x40
 8007ee8:	4013      	ands	r3, r2
 8007eea:	d006      	beq.n	8007efa <protocol_exec_rt_system+0x5b6>
 8007eec:	1d3b      	adds	r3, r7, #4
 8007eee:	1d3a      	adds	r2, r7, #4
 8007ef0:	7812      	ldrb	r2, [r2, #0]
 8007ef2:	2140      	movs	r1, #64	; 0x40
 8007ef4:	438a      	bics	r2, r1
 8007ef6:	701a      	strb	r2, [r3, #0]
 8007ef8:	e005      	b.n	8007f06 <protocol_exec_rt_system+0x5c2>
          else { coolant_state |= COOLANT_FLOOD_ENABLE; }
 8007efa:	1d3b      	adds	r3, r7, #4
 8007efc:	1d3a      	adds	r2, r7, #4
 8007efe:	7812      	ldrb	r2, [r2, #0]
 8007f00:	2140      	movs	r1, #64	; 0x40
 8007f02:	430a      	orrs	r2, r1
 8007f04:	701a      	strb	r2, [r3, #0]
        #endif
        coolant_set_state(coolant_state); // Report counter set in coolant_set_state().
 8007f06:	1d3b      	adds	r3, r7, #4
 8007f08:	781b      	ldrb	r3, [r3, #0]
 8007f0a:	0018      	movs	r0, r3
 8007f0c:	f7fb fc8c 	bl	8003828 <coolant_set_state>
        gc_state.modal.coolant = coolant_state;
 8007f10:	4b0a      	ldr	r3, [pc, #40]	; (8007f3c <protocol_exec_rt_system+0x5f8>)
 8007f12:	1d3a      	adds	r2, r7, #4
 8007f14:	7812      	ldrb	r2, [r2, #0]
 8007f16:	721a      	strb	r2, [r3, #8]
      sys_rt_exec_debug = 0;
    }
  #endif

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
 8007f18:	4b05      	ldr	r3, [pc, #20]	; (8007f30 <protocol_exec_rt_system+0x5ec>)
 8007f1a:	781b      	ldrb	r3, [r3, #0]
 8007f1c:	001a      	movs	r2, r3
 8007f1e:	23fc      	movs	r3, #252	; 0xfc
 8007f20:	4013      	ands	r3, r2
 8007f22:	d001      	beq.n	8007f28 <protocol_exec_rt_system+0x5e4>
    st_prep_buffer();
 8007f24:	f002 fb46 	bl	800a5b4 <st_prep_buffer>
  }

}
 8007f28:	46bd      	mov	sp, r7
 8007f2a:	b002      	add	sp, #8
 8007f2c:	bd80      	pop	{r7, pc}
 8007f2e:	46c0      	nop			; (mov r8, r8)
 8007f30:	20000b2c 	.word	0x20000b2c
 8007f34:	20000b28 	.word	0x20000b28
 8007f38:	20000b40 	.word	0x20000b40
 8007f3c:	2000095c 	.word	0x2000095c

08007f40 <protocol_exec_rt_suspend>:
// The system will enter this loop, create local variables for suspend tasks, and return to
// whatever function that invoked the suspend, such that Grbl resumes normal operation.
// This function is written in a way to promote custom parking motions. Simply use this as a
// template
static void protocol_exec_rt_suspend()
{
 8007f40:	b580      	push	{r7, lr}
 8007f42:	b084      	sub	sp, #16
 8007f44:	af00      	add	r7, sp, #0
    #ifdef USE_LINE_NUMBERS
      pl_data->line_number = PARKING_MOTION_LINE_NUMBER;
    #endif
  #endif

  plan_block_t *block = plan_get_current_block();
 8007f46:	f7fe fe19 	bl	8006b7c <plan_get_current_block>
 8007f4a:	0003      	movs	r3, r0
 8007f4c:	607b      	str	r3, [r7, #4]
  uint8_t restore_condition;
  #ifdef VARIABLE_SPINDLE
    float restore_spindle_speed;
    if (block == NULL) {
 8007f4e:	687b      	ldr	r3, [r7, #4]
 8007f50:	2b00      	cmp	r3, #0
 8007f52:	d10b      	bne.n	8007f6c <protocol_exec_rt_suspend+0x2c>
      restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant);
 8007f54:	4ba4      	ldr	r3, [pc, #656]	; (80081e8 <protocol_exec_rt_suspend+0x2a8>)
 8007f56:	7a59      	ldrb	r1, [r3, #9]
 8007f58:	4ba3      	ldr	r3, [pc, #652]	; (80081e8 <protocol_exec_rt_suspend+0x2a8>)
 8007f5a:	7a1a      	ldrb	r2, [r3, #8]
 8007f5c:	230f      	movs	r3, #15
 8007f5e:	18fb      	adds	r3, r7, r3
 8007f60:	430a      	orrs	r2, r1
 8007f62:	701a      	strb	r2, [r3, #0]
      restore_spindle_speed = gc_state.spindle_speed;
 8007f64:	4ba0      	ldr	r3, [pc, #640]	; (80081e8 <protocol_exec_rt_suspend+0x2a8>)
 8007f66:	68db      	ldr	r3, [r3, #12]
 8007f68:	60bb      	str	r3, [r7, #8]
 8007f6a:	e007      	b.n	8007f7c <protocol_exec_rt_suspend+0x3c>
    } else {
      restore_condition = block->condition;
 8007f6c:	230f      	movs	r3, #15
 8007f6e:	18fb      	adds	r3, r7, r3
 8007f70:	687a      	ldr	r2, [r7, #4]
 8007f72:	7c52      	ldrb	r2, [r2, #17]
 8007f74:	701a      	strb	r2, [r3, #0]
      restore_spindle_speed = block->spindle_speed;
 8007f76:	687b      	ldr	r3, [r7, #4]
 8007f78:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007f7a:	60bb      	str	r3, [r7, #8]
    }
    #ifdef DISABLE_LASER_DURING_HOLD
      if (bit_istrue(settings.flags, BITFLAG_LASER_MODE)) {
 8007f7c:	4b9b      	ldr	r3, [pc, #620]	; (80081ec <protocol_exec_rt_suspend+0x2ac>)
 8007f7e:	2248      	movs	r2, #72	; 0x48
 8007f80:	5c9b      	ldrb	r3, [r3, r2]
 8007f82:	001a      	movs	r2, r3
 8007f84:	2302      	movs	r3, #2
 8007f86:	4013      	ands	r3, r2
 8007f88:	d100      	bne.n	8007f8c <protocol_exec_rt_suspend+0x4c>
 8007f8a:	e123      	b.n	80081d4 <protocol_exec_rt_suspend+0x294>
        system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
 8007f8c:	2020      	movs	r0, #32
 8007f8e:	f003 fda1 	bl	800bad4 <system_set_exec_accessory_override_flag>
  #else
    if (block == NULL) { restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant); }
    else { restore_condition = block->condition; }
  #endif

  while (sys.suspend) {
 8007f92:	e11f      	b.n	80081d4 <protocol_exec_rt_suspend+0x294>

    if (sys.abort) { return; }
 8007f94:	4b96      	ldr	r3, [pc, #600]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8007f96:	785b      	ldrb	r3, [r3, #1]
 8007f98:	2b00      	cmp	r3, #0
 8007f9a:	d000      	beq.n	8007f9e <protocol_exec_rt_suspend+0x5e>
 8007f9c:	e120      	b.n	80081e0 <protocol_exec_rt_suspend+0x2a0>

    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {
 8007f9e:	4b94      	ldr	r3, [pc, #592]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8007fa0:	789b      	ldrb	r3, [r3, #2]
 8007fa2:	001a      	movs	r2, r3
 8007fa4:	2301      	movs	r3, #1
 8007fa6:	4013      	ands	r3, r2
 8007fa8:	d100      	bne.n	8007fac <protocol_exec_rt_suspend+0x6c>
 8007faa:	e111      	b.n	80081d0 <protocol_exec_rt_suspend+0x290>

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
 8007fac:	4b90      	ldr	r3, [pc, #576]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8007fae:	781b      	ldrb	r3, [r3, #0]
 8007fb0:	001a      	movs	r2, r3
 8007fb2:	23c0      	movs	r3, #192	; 0xc0
 8007fb4:	4013      	ands	r3, r2
 8007fb6:	d100      	bne.n	8007fba <protocol_exec_rt_suspend+0x7a>
 8007fb8:	e0a3      	b.n	8008102 <protocol_exec_rt_suspend+0x1c2>
      
        // Handles retraction motions and de-energizing.
        if (bit_isfalse(sys.suspend,SUSPEND_RETRACT_COMPLETE)) {
 8007fba:	4b8d      	ldr	r3, [pc, #564]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8007fbc:	789b      	ldrb	r3, [r3, #2]
 8007fbe:	001a      	movs	r2, r3
 8007fc0:	2304      	movs	r3, #4
 8007fc2:	4013      	ands	r3, r2
 8007fc4:	d119      	bne.n	8007ffa <protocol_exec_rt_suspend+0xba>

          // Ensure any prior spindle stop override is disabled at start of safety door routine.
          sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED;
 8007fc6:	4b8a      	ldr	r3, [pc, #552]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8007fc8:	2200      	movs	r2, #0
 8007fca:	729a      	strb	r2, [r3, #10]

          #ifndef PARKING_ENABLE

            spindle_set_state(SPINDLE_DISABLE,0.0f); // De-energize
 8007fcc:	2300      	movs	r3, #0
 8007fce:	1c19      	adds	r1, r3, #0
 8007fd0:	2000      	movs	r0, #0
 8007fd2:	f001 fe89 	bl	8009ce8 <spindle_set_state>
            coolant_set_state(COOLANT_DISABLE);     // De-energize
 8007fd6:	2000      	movs	r0, #0
 8007fd8:	f7fb fc26 	bl	8003828 <coolant_set_state>

            }

          #endif

          sys.suspend &= ~(SUSPEND_RESTART_RETRACT);
 8007fdc:	4b84      	ldr	r3, [pc, #528]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8007fde:	789b      	ldrb	r3, [r3, #2]
 8007fe0:	2202      	movs	r2, #2
 8007fe2:	4393      	bics	r3, r2
 8007fe4:	b2da      	uxtb	r2, r3
 8007fe6:	4b82      	ldr	r3, [pc, #520]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8007fe8:	709a      	strb	r2, [r3, #2]
          sys.suspend |= SUSPEND_RETRACT_COMPLETE;
 8007fea:	4b81      	ldr	r3, [pc, #516]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8007fec:	789b      	ldrb	r3, [r3, #2]
 8007fee:	2204      	movs	r2, #4
 8007ff0:	4313      	orrs	r3, r2
 8007ff2:	b2da      	uxtb	r2, r3
 8007ff4:	4b7e      	ldr	r3, [pc, #504]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8007ff6:	709a      	strb	r2, [r3, #2]
 8007ff8:	e0ea      	b.n	80081d0 <protocol_exec_rt_suspend+0x290>

        } else {

          
          if (sys.state == STATE_SLEEP) {
 8007ffa:	4b7d      	ldr	r3, [pc, #500]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8007ffc:	781b      	ldrb	r3, [r3, #0]
 8007ffe:	2b80      	cmp	r3, #128	; 0x80
 8008000:	d114      	bne.n	800802c <protocol_exec_rt_suspend+0xec>
            report_feedback_message(MESSAGE_SLEEP_MODE);
 8008002:	200b      	movs	r0, #11
 8008004:	f000 f9da 	bl	80083bc <report_feedback_message>
            // Spindle and coolant should already be stopped, but do it again just to be sure.
            spindle_set_state(SPINDLE_DISABLE,0.0f); // De-energize
 8008008:	2300      	movs	r3, #0
 800800a:	1c19      	adds	r1, r3, #0
 800800c:	2000      	movs	r0, #0
 800800e:	f001 fe6b 	bl	8009ce8 <spindle_set_state>
            coolant_set_state(COOLANT_DISABLE); // De-energize
 8008012:	2000      	movs	r0, #0
 8008014:	f7fb fc08 	bl	8003828 <coolant_set_state>
            st_go_idle(); // Disable steppers
 8008018:	f001 ff1e 	bl	8009e58 <st_go_idle>
            while (!(sys.abort)) { protocol_exec_rt_system(); } // Do nothing until reset.
 800801c:	e001      	b.n	8008022 <protocol_exec_rt_suspend+0xe2>
 800801e:	f7ff fc91 	bl	8007944 <protocol_exec_rt_system>
 8008022:	4b73      	ldr	r3, [pc, #460]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8008024:	785b      	ldrb	r3, [r3, #1]
 8008026:	2b00      	cmp	r3, #0
 8008028:	d0f9      	beq.n	800801e <protocol_exec_rt_suspend+0xde>
            return; // Abort received. Return to re-initialize.
 800802a:	e0da      	b.n	80081e2 <protocol_exec_rt_suspend+0x2a2>
          }    
          
          // Allows resuming from parking/safety door. Actively checks if safety door is closed and ready to resume.
          if (sys.state == STATE_SAFETY_DOOR) {
 800802c:	4b70      	ldr	r3, [pc, #448]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 800802e:	781b      	ldrb	r3, [r3, #0]
 8008030:	2b40      	cmp	r3, #64	; 0x40
 8008032:	d10a      	bne.n	800804a <protocol_exec_rt_suspend+0x10a>
            if (!(system_check_safety_door_ajar())) {
 8008034:	f003 f992 	bl	800b35c <system_check_safety_door_ajar>
 8008038:	1e03      	subs	r3, r0, #0
 800803a:	d106      	bne.n	800804a <protocol_exec_rt_suspend+0x10a>
              sys.suspend &= ~(SUSPEND_SAFETY_DOOR_AJAR); // Reset door ajar flag to denote ready to resume.
 800803c:	4b6c      	ldr	r3, [pc, #432]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 800803e:	789b      	ldrb	r3, [r3, #2]
 8008040:	2220      	movs	r2, #32
 8008042:	4393      	bics	r3, r2
 8008044:	b2da      	uxtb	r2, r3
 8008046:	4b6a      	ldr	r3, [pc, #424]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8008048:	709a      	strb	r2, [r3, #2]
            }
          }

          // Handles parking restore and safety door resume.
          if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
 800804a:	4b69      	ldr	r3, [pc, #420]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 800804c:	789b      	ldrb	r3, [r3, #2]
 800804e:	001a      	movs	r2, r3
 8008050:	2308      	movs	r3, #8
 8008052:	4013      	ands	r3, r2
 8008054:	d100      	bne.n	8008058 <protocol_exec_rt_suspend+0x118>
 8008056:	e0bb      	b.n	80081d0 <protocol_exec_rt_suspend+0x290>
                }
              }
            #endif

            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
 8008058:	4b63      	ldr	r3, [pc, #396]	; (80081e8 <protocol_exec_rt_suspend+0x2a8>)
 800805a:	7a5b      	ldrb	r3, [r3, #9]
 800805c:	2b00      	cmp	r3, #0
 800805e:	d025      	beq.n	80080ac <protocol_exec_rt_suspend+0x16c>
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
 8008060:	4b63      	ldr	r3, [pc, #396]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8008062:	789b      	ldrb	r3, [r3, #2]
 8008064:	001a      	movs	r2, r3
 8008066:	2302      	movs	r3, #2
 8008068:	4013      	ands	r3, r2
 800806a:	d11f      	bne.n	80080ac <protocol_exec_rt_suspend+0x16c>
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
 800806c:	4b5f      	ldr	r3, [pc, #380]	; (80081ec <protocol_exec_rt_suspend+0x2ac>)
 800806e:	2248      	movs	r2, #72	; 0x48
 8008070:	5c9b      	ldrb	r3, [r3, r2]
 8008072:	001a      	movs	r2, r3
 8008074:	2302      	movs	r3, #2
 8008076:	4013      	ands	r3, r2
 8008078:	d007      	beq.n	800808a <protocol_exec_rt_suspend+0x14a>
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 800807a:	4b5d      	ldr	r3, [pc, #372]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 800807c:	791b      	ldrb	r3, [r3, #4]
 800807e:	2208      	movs	r2, #8
 8008080:	4313      	orrs	r3, r2
 8008082:	b2da      	uxtb	r2, r3
 8008084:	4b5a      	ldr	r3, [pc, #360]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8008086:	711a      	strb	r2, [r3, #4]
 8008088:	e010      	b.n	80080ac <protocol_exec_rt_suspend+0x16c>
                } else {
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
 800808a:	230f      	movs	r3, #15
 800808c:	18fb      	adds	r3, r7, r3
 800808e:	781b      	ldrb	r3, [r3, #0]
 8008090:	2230      	movs	r2, #48	; 0x30
 8008092:	4013      	ands	r3, r2
 8008094:	b2db      	uxtb	r3, r3
 8008096:	68ba      	ldr	r2, [r7, #8]
 8008098:	1c11      	adds	r1, r2, #0
 800809a:	0018      	movs	r0, r3
 800809c:	f001 fe24 	bl	8009ce8 <spindle_set_state>
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
 80080a0:	2381      	movs	r3, #129	; 0x81
 80080a2:	05db      	lsls	r3, r3, #23
 80080a4:	2101      	movs	r1, #1
 80080a6:	1c18      	adds	r0, r3, #0
 80080a8:	f7fe fa5a 	bl	8006560 <delay_sec>
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
 80080ac:	4b4e      	ldr	r3, [pc, #312]	; (80081e8 <protocol_exec_rt_suspend+0x2a8>)
 80080ae:	7a1b      	ldrb	r3, [r3, #8]
 80080b0:	2b00      	cmp	r3, #0
 80080b2:	d014      	beq.n	80080de <protocol_exec_rt_suspend+0x19e>
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
 80080b4:	4b4e      	ldr	r3, [pc, #312]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 80080b6:	789b      	ldrb	r3, [r3, #2]
 80080b8:	001a      	movs	r2, r3
 80080ba:	2302      	movs	r3, #2
 80080bc:	4013      	ands	r3, r2
 80080be:	d10e      	bne.n	80080de <protocol_exec_rt_suspend+0x19e>
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_FLOOD)));
 80080c0:	230f      	movs	r3, #15
 80080c2:	18fb      	adds	r3, r7, r3
 80080c4:	781b      	ldrb	r3, [r3, #0]
 80080c6:	2240      	movs	r2, #64	; 0x40
 80080c8:	4013      	ands	r3, r2
 80080ca:	b2db      	uxtb	r3, r3
 80080cc:	0018      	movs	r0, r3
 80080ce:	f7fb fbab 	bl	8003828 <coolant_set_state>
                delay_sec(SAFETY_DOOR_COOLANT_DELAY, DELAY_MODE_SYS_SUSPEND);
 80080d2:	23fe      	movs	r3, #254	; 0xfe
 80080d4:	059b      	lsls	r3, r3, #22
 80080d6:	2101      	movs	r1, #1
 80080d8:	1c18      	adds	r0, r3, #0
 80080da:	f7fe fa41 	bl	8006560 <delay_sec>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
 80080de:	4b44      	ldr	r3, [pc, #272]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 80080e0:	789b      	ldrb	r3, [r3, #2]
 80080e2:	001a      	movs	r2, r3
 80080e4:	2302      	movs	r3, #2
 80080e6:	4013      	ands	r3, r2
 80080e8:	d000      	beq.n	80080ec <protocol_exec_rt_suspend+0x1ac>
 80080ea:	e071      	b.n	80081d0 <protocol_exec_rt_suspend+0x290>
              sys.suspend |= SUSPEND_RESTORE_COMPLETE;
 80080ec:	4b40      	ldr	r3, [pc, #256]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 80080ee:	789b      	ldrb	r3, [r3, #2]
 80080f0:	2210      	movs	r2, #16
 80080f2:	4313      	orrs	r3, r2
 80080f4:	b2da      	uxtb	r2, r3
 80080f6:	4b3e      	ldr	r3, [pc, #248]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 80080f8:	709a      	strb	r2, [r3, #2]
              system_set_exec_state_flag(EXEC_CYCLE_START); // Set to resume program.
 80080fa:	2002      	movs	r0, #2
 80080fc:	f003 fc7a 	bl	800b9f4 <system_set_exec_state_flag>
 8008100:	e066      	b.n	80081d0 <protocol_exec_rt_suspend+0x290>

      } else {

        // Feed hold manager. Controls spindle stop override states.
        // NOTE: Hold ensured as completed by condition check at the beginning of suspend routine.
        if (sys.spindle_stop_ovr) {
 8008102:	4b3b      	ldr	r3, [pc, #236]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8008104:	7a9b      	ldrb	r3, [r3, #10]
 8008106:	2b00      	cmp	r3, #0
 8008108:	d04a      	beq.n	80081a0 <protocol_exec_rt_suspend+0x260>
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
 800810a:	4b39      	ldr	r3, [pc, #228]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 800810c:	7a9b      	ldrb	r3, [r3, #10]
 800810e:	001a      	movs	r2, r3
 8008110:	2302      	movs	r3, #2
 8008112:	4013      	ands	r3, r2
 8008114:	d010      	beq.n	8008138 <protocol_exec_rt_suspend+0x1f8>
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
 8008116:	4b34      	ldr	r3, [pc, #208]	; (80081e8 <protocol_exec_rt_suspend+0x2a8>)
 8008118:	7a5b      	ldrb	r3, [r3, #9]
 800811a:	2b00      	cmp	r3, #0
 800811c:	d008      	beq.n	8008130 <protocol_exec_rt_suspend+0x1f0>
              spindle_set_state(SPINDLE_DISABLE,0.0f); // De-energize
 800811e:	2300      	movs	r3, #0
 8008120:	1c19      	adds	r1, r3, #0
 8008122:	2000      	movs	r0, #0
 8008124:	f001 fde0 	bl	8009ce8 <spindle_set_state>
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
 8008128:	4b31      	ldr	r3, [pc, #196]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 800812a:	2201      	movs	r2, #1
 800812c:	729a      	strb	r2, [r3, #10]
 800812e:	e04f      	b.n	80081d0 <protocol_exec_rt_suspend+0x290>
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
 8008130:	4b2f      	ldr	r3, [pc, #188]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8008132:	2200      	movs	r2, #0
 8008134:	729a      	strb	r2, [r3, #10]
 8008136:	e04b      	b.n	80081d0 <protocol_exec_rt_suspend+0x290>
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
 8008138:	4b2d      	ldr	r3, [pc, #180]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 800813a:	7a9b      	ldrb	r3, [r3, #10]
 800813c:	001a      	movs	r2, r3
 800813e:	230c      	movs	r3, #12
 8008140:	4013      	ands	r3, r2
 8008142:	d045      	beq.n	80081d0 <protocol_exec_rt_suspend+0x290>
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
 8008144:	4b28      	ldr	r3, [pc, #160]	; (80081e8 <protocol_exec_rt_suspend+0x2a8>)
 8008146:	7a5b      	ldrb	r3, [r3, #9]
 8008148:	2b00      	cmp	r3, #0
 800814a:	d01c      	beq.n	8008186 <protocol_exec_rt_suspend+0x246>
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
 800814c:	200a      	movs	r0, #10
 800814e:	f000 f935 	bl	80083bc <report_feedback_message>
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
 8008152:	4b26      	ldr	r3, [pc, #152]	; (80081ec <protocol_exec_rt_suspend+0x2ac>)
 8008154:	2248      	movs	r2, #72	; 0x48
 8008156:	5c9b      	ldrb	r3, [r3, r2]
 8008158:	001a      	movs	r2, r3
 800815a:	2302      	movs	r3, #2
 800815c:	4013      	ands	r3, r2
 800815e:	d007      	beq.n	8008170 <protocol_exec_rt_suspend+0x230>
                // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 8008160:	4b23      	ldr	r3, [pc, #140]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8008162:	791b      	ldrb	r3, [r3, #4]
 8008164:	2208      	movs	r2, #8
 8008166:	4313      	orrs	r3, r2
 8008168:	b2da      	uxtb	r2, r3
 800816a:	4b21      	ldr	r3, [pc, #132]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 800816c:	711a      	strb	r2, [r3, #4]
 800816e:	e00a      	b.n	8008186 <protocol_exec_rt_suspend+0x246>
              } else {
                spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
 8008170:	230f      	movs	r3, #15
 8008172:	18fb      	adds	r3, r7, r3
 8008174:	781b      	ldrb	r3, [r3, #0]
 8008176:	2230      	movs	r2, #48	; 0x30
 8008178:	4013      	ands	r3, r2
 800817a:	b2db      	uxtb	r3, r3
 800817c:	68ba      	ldr	r2, [r7, #8]
 800817e:	1c11      	adds	r1, r2, #0
 8008180:	0018      	movs	r0, r3
 8008182:	f001 fdb1 	bl	8009ce8 <spindle_set_state>
              }
            }
            if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_RESTORE_CYCLE) {
 8008186:	4b1a      	ldr	r3, [pc, #104]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 8008188:	7a9b      	ldrb	r3, [r3, #10]
 800818a:	001a      	movs	r2, r3
 800818c:	2308      	movs	r3, #8
 800818e:	4013      	ands	r3, r2
 8008190:	d002      	beq.n	8008198 <protocol_exec_rt_suspend+0x258>
              system_set_exec_state_flag(EXEC_CYCLE_START);  // Set to resume program.
 8008192:	2002      	movs	r0, #2
 8008194:	f003 fc2e 	bl	800b9f4 <system_set_exec_state_flag>
            }
            sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
 8008198:	4b15      	ldr	r3, [pc, #84]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 800819a:	2200      	movs	r2, #0
 800819c:	729a      	strb	r2, [r3, #10]
 800819e:	e017      	b.n	80081d0 <protocol_exec_rt_suspend+0x290>
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
 80081a0:	4b13      	ldr	r3, [pc, #76]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 80081a2:	791b      	ldrb	r3, [r3, #4]
 80081a4:	001a      	movs	r2, r3
 80081a6:	2308      	movs	r3, #8
 80081a8:	4013      	ands	r3, r2
 80081aa:	d011      	beq.n	80081d0 <protocol_exec_rt_suspend+0x290>
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
 80081ac:	230f      	movs	r3, #15
 80081ae:	18fb      	adds	r3, r7, r3
 80081b0:	781b      	ldrb	r3, [r3, #0]
 80081b2:	2230      	movs	r2, #48	; 0x30
 80081b4:	4013      	ands	r3, r2
 80081b6:	b2db      	uxtb	r3, r3
 80081b8:	68ba      	ldr	r2, [r7, #8]
 80081ba:	1c11      	adds	r1, r2, #0
 80081bc:	0018      	movs	r0, r3
 80081be:	f001 fd93 	bl	8009ce8 <spindle_set_state>
            bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 80081c2:	4b0b      	ldr	r3, [pc, #44]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 80081c4:	791b      	ldrb	r3, [r3, #4]
 80081c6:	2208      	movs	r2, #8
 80081c8:	4393      	bics	r3, r2
 80081ca:	b2da      	uxtb	r2, r3
 80081cc:	4b08      	ldr	r3, [pc, #32]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 80081ce:	711a      	strb	r2, [r3, #4]
        }

      }
    }

    protocol_exec_rt_system();
 80081d0:	f7ff fbb8 	bl	8007944 <protocol_exec_rt_system>
  #else
    if (block == NULL) { restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant); }
    else { restore_condition = block->condition; }
  #endif

  while (sys.suspend) {
 80081d4:	4b06      	ldr	r3, [pc, #24]	; (80081f0 <protocol_exec_rt_suspend+0x2b0>)
 80081d6:	789b      	ldrb	r3, [r3, #2]
 80081d8:	2b00      	cmp	r3, #0
 80081da:	d000      	beq.n	80081de <protocol_exec_rt_suspend+0x29e>
 80081dc:	e6da      	b.n	8007f94 <protocol_exec_rt_suspend+0x54>
 80081de:	e000      	b.n	80081e2 <protocol_exec_rt_suspend+0x2a2>

    if (sys.abort) { return; }
 80081e0:	46c0      	nop			; (mov r8, r8)
    }

    protocol_exec_rt_system();

  }
}
 80081e2:	46bd      	mov	sp, r7
 80081e4:	b004      	add	sp, #16
 80081e6:	bd80      	pop	{r7, pc}
 80081e8:	2000095c 	.word	0x2000095c
 80081ec:	20000acc 	.word	0x20000acc
 80081f0:	20000b2c 	.word	0x20000b2c

080081f4 <report_util_setting_prefix>:

#include "grbl.h"


// Internal report utilities to reduce flash with repetitive tasks turned into functions.
void report_util_setting_prefix(uint8_t n) { serial_write('$'); print_uint8_base10(n); serial_write('='); }
 80081f4:	b580      	push	{r7, lr}
 80081f6:	b082      	sub	sp, #8
 80081f8:	af00      	add	r7, sp, #0
 80081fa:	0002      	movs	r2, r0
 80081fc:	1dfb      	adds	r3, r7, #7
 80081fe:	701a      	strb	r2, [r3, #0]
 8008200:	2024      	movs	r0, #36	; 0x24
 8008202:	f000 fefd 	bl	8009000 <serial_write>
 8008206:	1dfb      	adds	r3, r7, #7
 8008208:	781b      	ldrb	r3, [r3, #0]
 800820a:	0018      	movs	r0, r3
 800820c:	f7ff f85a 	bl	80072c4 <print_uint8_base10>
 8008210:	203d      	movs	r0, #61	; 0x3d
 8008212:	f000 fef5 	bl	8009000 <serial_write>
 8008216:	46c0      	nop			; (mov r8, r8)
 8008218:	46bd      	mov	sp, r7
 800821a:	b002      	add	sp, #8
 800821c:	bd80      	pop	{r7, pc}
 800821e:	46c0      	nop			; (mov r8, r8)

08008220 <report_util_line_feed>:
static void report_util_line_feed() { printPgmString(PSTR("\r\n")); }
 8008220:	b580      	push	{r7, lr}
 8008222:	af00      	add	r7, sp, #0
 8008224:	4b03      	ldr	r3, [pc, #12]	; (8008234 <report_util_line_feed+0x14>)
 8008226:	0018      	movs	r0, r3
 8008228:	f7ff f838 	bl	800729c <printString>
 800822c:	46c0      	nop			; (mov r8, r8)
 800822e:	46bd      	mov	sp, r7
 8008230:	bd80      	pop	{r7, pc}
 8008232:	46c0      	nop			; (mov r8, r8)
 8008234:	0800d3ec 	.word	0x0800d3ec

08008238 <report_util_feedback_line_feed>:
static void report_util_feedback_line_feed() { serial_write(']'); report_util_line_feed(); }
 8008238:	b580      	push	{r7, lr}
 800823a:	af00      	add	r7, sp, #0
 800823c:	205d      	movs	r0, #93	; 0x5d
 800823e:	f000 fedf 	bl	8009000 <serial_write>
 8008242:	f7ff ffed 	bl	8008220 <report_util_line_feed>
 8008246:	46c0      	nop			; (mov r8, r8)
 8008248:	46bd      	mov	sp, r7
 800824a:	bd80      	pop	{r7, pc}

0800824c <report_util_gcode_modes_G>:
static void report_util_gcode_modes_G() { printPgmString(PSTR(" G")); }
 800824c:	b580      	push	{r7, lr}
 800824e:	af00      	add	r7, sp, #0
 8008250:	4b03      	ldr	r3, [pc, #12]	; (8008260 <report_util_gcode_modes_G+0x14>)
 8008252:	0018      	movs	r0, r3
 8008254:	f7ff f822 	bl	800729c <printString>
 8008258:	46c0      	nop			; (mov r8, r8)
 800825a:	46bd      	mov	sp, r7
 800825c:	bd80      	pop	{r7, pc}
 800825e:	46c0      	nop			; (mov r8, r8)
 8008260:	0800d3f0 	.word	0x0800d3f0

08008264 <report_util_gcode_modes_M>:
static void report_util_gcode_modes_M() { printPgmString(PSTR(" M")); }
 8008264:	b580      	push	{r7, lr}
 8008266:	af00      	add	r7, sp, #0
 8008268:	4b03      	ldr	r3, [pc, #12]	; (8008278 <report_util_gcode_modes_M+0x14>)
 800826a:	0018      	movs	r0, r3
 800826c:	f7ff f816 	bl	800729c <printString>
 8008270:	46c0      	nop			; (mov r8, r8)
 8008272:	46bd      	mov	sp, r7
 8008274:	bd80      	pop	{r7, pc}
 8008276:	46c0      	nop			; (mov r8, r8)
 8008278:	0800d3f4 	.word	0x0800d3f4

0800827c <report_util_axis_values>:
// static void report_util_comment_line_feed() { serial_write(')'); report_util_line_feed(); }
static void report_util_axis_values(float *axis_value) {
 800827c:	b580      	push	{r7, lr}
 800827e:	b084      	sub	sp, #16
 8008280:	af00      	add	r7, sp, #0
 8008282:	6078      	str	r0, [r7, #4]
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 8008284:	230f      	movs	r3, #15
 8008286:	18fb      	adds	r3, r7, r3
 8008288:	2200      	movs	r2, #0
 800828a:	701a      	strb	r2, [r3, #0]
 800828c:	e018      	b.n	80082c0 <report_util_axis_values+0x44>
    printFloat_CoordValue(axis_value[idx]);
 800828e:	230f      	movs	r3, #15
 8008290:	18fb      	adds	r3, r7, r3
 8008292:	781b      	ldrb	r3, [r3, #0]
 8008294:	009b      	lsls	r3, r3, #2
 8008296:	687a      	ldr	r2, [r7, #4]
 8008298:	18d3      	adds	r3, r2, r3
 800829a:	681b      	ldr	r3, [r3, #0]
 800829c:	1c18      	adds	r0, r3, #0
 800829e:	f7ff f92b 	bl	80074f8 <printFloat_CoordValue>
    if (idx < (N_AXIS-1)) { serial_write(','); }
 80082a2:	230f      	movs	r3, #15
 80082a4:	18fb      	adds	r3, r7, r3
 80082a6:	781b      	ldrb	r3, [r3, #0]
 80082a8:	2b01      	cmp	r3, #1
 80082aa:	d802      	bhi.n	80082b2 <report_util_axis_values+0x36>
 80082ac:	202c      	movs	r0, #44	; 0x2c
 80082ae:	f000 fea7 	bl	8009000 <serial_write>
static void report_util_gcode_modes_G() { printPgmString(PSTR(" G")); }
static void report_util_gcode_modes_M() { printPgmString(PSTR(" M")); }
// static void report_util_comment_line_feed() { serial_write(')'); report_util_line_feed(); }
static void report_util_axis_values(float *axis_value) {
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 80082b2:	230f      	movs	r3, #15
 80082b4:	18fb      	adds	r3, r7, r3
 80082b6:	781a      	ldrb	r2, [r3, #0]
 80082b8:	230f      	movs	r3, #15
 80082ba:	18fb      	adds	r3, r7, r3
 80082bc:	3201      	adds	r2, #1
 80082be:	701a      	strb	r2, [r3, #0]
 80082c0:	230f      	movs	r3, #15
 80082c2:	18fb      	adds	r3, r7, r3
 80082c4:	781b      	ldrb	r3, [r3, #0]
 80082c6:	2b02      	cmp	r3, #2
 80082c8:	d9e1      	bls.n	800828e <report_util_axis_values+0x12>
    printFloat_CoordValue(axis_value[idx]);
    if (idx < (N_AXIS-1)) { serial_write(','); }
  }
}
 80082ca:	46c0      	nop			; (mov r8, r8)
 80082cc:	46bd      	mov	sp, r7
 80082ce:	b004      	add	sp, #16
 80082d0:	bd80      	pop	{r7, pc}
 80082d2:	46c0      	nop			; (mov r8, r8)

080082d4 <report_util_uint8_setting>:
  }
  report_util_comment_line_feed();
}
*/

static void report_util_uint8_setting(uint8_t n, int val) {
 80082d4:	b580      	push	{r7, lr}
 80082d6:	b082      	sub	sp, #8
 80082d8:	af00      	add	r7, sp, #0
 80082da:	0002      	movs	r2, r0
 80082dc:	6039      	str	r1, [r7, #0]
 80082de:	1dfb      	adds	r3, r7, #7
 80082e0:	701a      	strb	r2, [r3, #0]
  report_util_setting_prefix(n);
 80082e2:	1dfb      	adds	r3, r7, #7
 80082e4:	781b      	ldrb	r3, [r3, #0]
 80082e6:	0018      	movs	r0, r3
 80082e8:	f7ff ff84 	bl	80081f4 <report_util_setting_prefix>
  print_uint8_base10(val);
 80082ec:	683b      	ldr	r3, [r7, #0]
 80082ee:	b2db      	uxtb	r3, r3
 80082f0:	0018      	movs	r0, r3
 80082f2:	f7fe ffe7 	bl	80072c4 <print_uint8_base10>
  report_util_line_feed(); // report_util_setting_string(n); 
 80082f6:	f7ff ff93 	bl	8008220 <report_util_line_feed>
}
 80082fa:	46c0      	nop			; (mov r8, r8)
 80082fc:	46bd      	mov	sp, r7
 80082fe:	b002      	add	sp, #8
 8008300:	bd80      	pop	{r7, pc}
 8008302:	46c0      	nop			; (mov r8, r8)

08008304 <report_util_float_setting>:
static void report_util_float_setting(uint8_t n, float val, uint8_t n_decimal) {
 8008304:	b580      	push	{r7, lr}
 8008306:	b082      	sub	sp, #8
 8008308:	af00      	add	r7, sp, #0
 800830a:	6039      	str	r1, [r7, #0]
 800830c:	0011      	movs	r1, r2
 800830e:	1dfb      	adds	r3, r7, #7
 8008310:	1c02      	adds	r2, r0, #0
 8008312:	701a      	strb	r2, [r3, #0]
 8008314:	1dbb      	adds	r3, r7, #6
 8008316:	1c0a      	adds	r2, r1, #0
 8008318:	701a      	strb	r2, [r3, #0]
  report_util_setting_prefix(n);
 800831a:	1dfb      	adds	r3, r7, #7
 800831c:	781b      	ldrb	r3, [r3, #0]
 800831e:	0018      	movs	r0, r3
 8008320:	f7ff ff68 	bl	80081f4 <report_util_setting_prefix>
  printFloat(val, n_decimal);
 8008324:	1dbb      	adds	r3, r7, #6
 8008326:	781a      	ldrb	r2, [r3, #0]
 8008328:	683b      	ldr	r3, [r7, #0]
 800832a:	0011      	movs	r1, r2
 800832c:	1c18      	adds	r0, r3, #0
 800832e:	f7ff f82b 	bl	8007388 <printFloat>
  report_util_line_feed(); // report_util_setting_string(n);
 8008332:	f7ff ff75 	bl	8008220 <report_util_line_feed>
}
 8008336:	46c0      	nop			; (mov r8, r8)
 8008338:	46bd      	mov	sp, r7
 800833a:	b002      	add	sp, #8
 800833c:	bd80      	pop	{r7, pc}
 800833e:	46c0      	nop			; (mov r8, r8)

08008340 <report_status_message>:
// 'error:'  to indicate some error event with the line or some critical system error during
// operation. Errors events can originate from the g-code parser, settings module, or asynchronously
// from a critical error, such as a triggered hard limit. Interface should always monitor for these
// responses.
void report_status_message(uint8_t status_code)
{
 8008340:	b580      	push	{r7, lr}
 8008342:	b082      	sub	sp, #8
 8008344:	af00      	add	r7, sp, #0
 8008346:	0002      	movs	r2, r0
 8008348:	1dfb      	adds	r3, r7, #7
 800834a:	701a      	strb	r2, [r3, #0]
  switch(status_code) {
 800834c:	1dfb      	adds	r3, r7, #7
 800834e:	781b      	ldrb	r3, [r3, #0]
 8008350:	2b00      	cmp	r3, #0
 8008352:	d104      	bne.n	800835e <report_status_message+0x1e>
    case STATUS_OK: // STATUS_OK
      printPgmString(PSTR("ok\r\n")); break;
 8008354:	4b09      	ldr	r3, [pc, #36]	; (800837c <report_status_message+0x3c>)
 8008356:	0018      	movs	r0, r3
 8008358:	f7fe ffa0 	bl	800729c <printString>
 800835c:	e00a      	b.n	8008374 <report_status_message+0x34>
    default:
      printPgmString(PSTR("error:"));
 800835e:	4b08      	ldr	r3, [pc, #32]	; (8008380 <report_status_message+0x40>)
 8008360:	0018      	movs	r0, r3
 8008362:	f7fe ff9b 	bl	800729c <printString>
      print_uint8_base10(status_code);
 8008366:	1dfb      	adds	r3, r7, #7
 8008368:	781b      	ldrb	r3, [r3, #0]
 800836a:	0018      	movs	r0, r3
 800836c:	f7fe ffaa 	bl	80072c4 <print_uint8_base10>
      report_util_line_feed();
 8008370:	f7ff ff56 	bl	8008220 <report_util_line_feed>
  }
}
 8008374:	46c0      	nop			; (mov r8, r8)
 8008376:	46bd      	mov	sp, r7
 8008378:	b002      	add	sp, #8
 800837a:	bd80      	pop	{r7, pc}
 800837c:	0800d3f8 	.word	0x0800d3f8
 8008380:	0800d400 	.word	0x0800d400

08008384 <report_alarm_message>:

// Prints alarm messages.
void report_alarm_message(uint8_t alarm_code)
{
 8008384:	b580      	push	{r7, lr}
 8008386:	b082      	sub	sp, #8
 8008388:	af00      	add	r7, sp, #0
 800838a:	0002      	movs	r2, r0
 800838c:	1dfb      	adds	r3, r7, #7
 800838e:	701a      	strb	r2, [r3, #0]
  printPgmString(PSTR("ALARM:"));
 8008390:	4b09      	ldr	r3, [pc, #36]	; (80083b8 <report_alarm_message+0x34>)
 8008392:	0018      	movs	r0, r3
 8008394:	f7fe ff82 	bl	800729c <printString>
  print_uint8_base10(alarm_code);
 8008398:	1dfb      	adds	r3, r7, #7
 800839a:	781b      	ldrb	r3, [r3, #0]
 800839c:	0018      	movs	r0, r3
 800839e:	f7fe ff91 	bl	80072c4 <print_uint8_base10>
  report_util_line_feed();
 80083a2:	f7ff ff3d 	bl	8008220 <report_util_line_feed>
  delay_ms(500); // Force delay to ensure message clears serial write buffer.
 80083a6:	23fa      	movs	r3, #250	; 0xfa
 80083a8:	005b      	lsls	r3, r3, #1
 80083aa:	0018      	movs	r0, r3
 80083ac:	f7fe f91a 	bl	80065e4 <delay_ms>
}
 80083b0:	46c0      	nop			; (mov r8, r8)
 80083b2:	46bd      	mov	sp, r7
 80083b4:	b002      	add	sp, #8
 80083b6:	bd80      	pop	{r7, pc}
 80083b8:	0800d408 	.word	0x0800d408

080083bc <report_feedback_message>:
// user feedback for things that are not of the status/alarm message protocol. These are
// messages such as setup warnings, switch toggling, and how to exit alarms.
// NOTE: For interfaces, messages are always placed within brackets. And if silent mode
// is installed, the message number codes are less than zero.
void report_feedback_message(uint8_t message_code)
{
 80083bc:	b580      	push	{r7, lr}
 80083be:	b082      	sub	sp, #8
 80083c0:	af00      	add	r7, sp, #0
 80083c2:	0002      	movs	r2, r0
 80083c4:	1dfb      	adds	r3, r7, #7
 80083c6:	701a      	strb	r2, [r3, #0]
  printPgmString(PSTR("[MSG:"));
 80083c8:	4b24      	ldr	r3, [pc, #144]	; (800845c <report_feedback_message+0xa0>)
 80083ca:	0018      	movs	r0, r3
 80083cc:	f7fe ff66 	bl	800729c <printString>
  switch(message_code) {
 80083d0:	1dfb      	adds	r3, r7, #7
 80083d2:	781b      	ldrb	r3, [r3, #0]
 80083d4:	2b0b      	cmp	r3, #11
 80083d6:	d83b      	bhi.n	8008450 <report_feedback_message+0x94>
 80083d8:	009a      	lsls	r2, r3, #2
 80083da:	4b21      	ldr	r3, [pc, #132]	; (8008460 <report_feedback_message+0xa4>)
 80083dc:	18d3      	adds	r3, r2, r3
 80083de:	681b      	ldr	r3, [r3, #0]
 80083e0:	469f      	mov	pc, r3
    case MESSAGE_CRITICAL_EVENT:
      printPgmString(PSTR("Reset to continue")); break;
 80083e2:	4b20      	ldr	r3, [pc, #128]	; (8008464 <report_feedback_message+0xa8>)
 80083e4:	0018      	movs	r0, r3
 80083e6:	f7fe ff59 	bl	800729c <printString>
 80083ea:	e031      	b.n	8008450 <report_feedback_message+0x94>
    case MESSAGE_ALARM_LOCK:
      printPgmString(PSTR("'$H'|'$X' to unlock")); break;
 80083ec:	4b1e      	ldr	r3, [pc, #120]	; (8008468 <report_feedback_message+0xac>)
 80083ee:	0018      	movs	r0, r3
 80083f0:	f7fe ff54 	bl	800729c <printString>
 80083f4:	e02c      	b.n	8008450 <report_feedback_message+0x94>
    case MESSAGE_ALARM_UNLOCK:
      printPgmString(PSTR("Caution: Unlocked")); break;
 80083f6:	4b1d      	ldr	r3, [pc, #116]	; (800846c <report_feedback_message+0xb0>)
 80083f8:	0018      	movs	r0, r3
 80083fa:	f7fe ff4f 	bl	800729c <printString>
 80083fe:	e027      	b.n	8008450 <report_feedback_message+0x94>
    case MESSAGE_ENABLED:
      printPgmString(PSTR("Enabled")); break;
 8008400:	4b1b      	ldr	r3, [pc, #108]	; (8008470 <report_feedback_message+0xb4>)
 8008402:	0018      	movs	r0, r3
 8008404:	f7fe ff4a 	bl	800729c <printString>
 8008408:	e022      	b.n	8008450 <report_feedback_message+0x94>
    case MESSAGE_DISABLED:
      printPgmString(PSTR("Disabled")); break;
 800840a:	4b1a      	ldr	r3, [pc, #104]	; (8008474 <report_feedback_message+0xb8>)
 800840c:	0018      	movs	r0, r3
 800840e:	f7fe ff45 	bl	800729c <printString>
 8008412:	e01d      	b.n	8008450 <report_feedback_message+0x94>
    case MESSAGE_SAFETY_DOOR_AJAR:
      printPgmString(PSTR("Check Door")); break;
 8008414:	4b18      	ldr	r3, [pc, #96]	; (8008478 <report_feedback_message+0xbc>)
 8008416:	0018      	movs	r0, r3
 8008418:	f7fe ff40 	bl	800729c <printString>
 800841c:	e018      	b.n	8008450 <report_feedback_message+0x94>
    case MESSAGE_CHECK_LIMITS:
      printPgmString(PSTR("Check Limits")); break;
 800841e:	4b17      	ldr	r3, [pc, #92]	; (800847c <report_feedback_message+0xc0>)
 8008420:	0018      	movs	r0, r3
 8008422:	f7fe ff3b 	bl	800729c <printString>
 8008426:	e013      	b.n	8008450 <report_feedback_message+0x94>
    case MESSAGE_PROGRAM_END:
      printPgmString(PSTR("Pgm End")); break;
 8008428:	4b15      	ldr	r3, [pc, #84]	; (8008480 <report_feedback_message+0xc4>)
 800842a:	0018      	movs	r0, r3
 800842c:	f7fe ff36 	bl	800729c <printString>
 8008430:	e00e      	b.n	8008450 <report_feedback_message+0x94>
    case MESSAGE_RESTORE_DEFAULTS:
      printPgmString(PSTR("Restoring defaults")); break;
 8008432:	4b14      	ldr	r3, [pc, #80]	; (8008484 <report_feedback_message+0xc8>)
 8008434:	0018      	movs	r0, r3
 8008436:	f7fe ff31 	bl	800729c <printString>
 800843a:	e009      	b.n	8008450 <report_feedback_message+0x94>
    case MESSAGE_SPINDLE_RESTORE:
      printPgmString(PSTR("Restoring spindle")); break;
 800843c:	4b12      	ldr	r3, [pc, #72]	; (8008488 <report_feedback_message+0xcc>)
 800843e:	0018      	movs	r0, r3
 8008440:	f7fe ff2c 	bl	800729c <printString>
 8008444:	e004      	b.n	8008450 <report_feedback_message+0x94>
    case MESSAGE_SLEEP_MODE:
      printPgmString(PSTR("Sleeping")); break;
 8008446:	4b11      	ldr	r3, [pc, #68]	; (800848c <report_feedback_message+0xd0>)
 8008448:	0018      	movs	r0, r3
 800844a:	f7fe ff27 	bl	800729c <printString>
 800844e:	46c0      	nop			; (mov r8, r8)
  }
  report_util_feedback_line_feed();
 8008450:	f7ff fef2 	bl	8008238 <report_util_feedback_line_feed>
}
 8008454:	46c0      	nop			; (mov r8, r8)
 8008456:	46bd      	mov	sp, r7
 8008458:	b002      	add	sp, #8
 800845a:	bd80      	pop	{r7, pc}
 800845c:	0800d410 	.word	0x0800d410
 8008460:	0800d958 	.word	0x0800d958
 8008464:	0800d418 	.word	0x0800d418
 8008468:	0800d42c 	.word	0x0800d42c
 800846c:	0800d440 	.word	0x0800d440
 8008470:	0800d454 	.word	0x0800d454
 8008474:	0800d45c 	.word	0x0800d45c
 8008478:	0800d468 	.word	0x0800d468
 800847c:	0800d474 	.word	0x0800d474
 8008480:	0800d484 	.word	0x0800d484
 8008484:	0800d48c 	.word	0x0800d48c
 8008488:	0800d4a0 	.word	0x0800d4a0
 800848c:	0800d4b4 	.word	0x0800d4b4

08008490 <report_init_message>:


// Welcome message
void report_init_message()
{
 8008490:	b580      	push	{r7, lr}
 8008492:	af00      	add	r7, sp, #0
  printPgmString(PSTR("\r\nGrbl " GRBL_VERSION " ['$' for help]\r\n"));
 8008494:	4b03      	ldr	r3, [pc, #12]	; (80084a4 <report_init_message+0x14>)
 8008496:	0018      	movs	r0, r3
 8008498:	f7fe ff00 	bl	800729c <printString>
}
 800849c:	46c0      	nop			; (mov r8, r8)
 800849e:	46bd      	mov	sp, r7
 80084a0:	bd80      	pop	{r7, pc}
 80084a2:	46c0      	nop			; (mov r8, r8)
 80084a4:	0800d4c0 	.word	0x0800d4c0

080084a8 <report_grbl_help>:

// Grbl help message
void report_grbl_help() {
 80084a8:	b580      	push	{r7, lr}
 80084aa:	af00      	add	r7, sp, #0
  printPgmString(PSTR("[HLP:$$ $# $G $I $N $x=val $Nx=line $J=line $SLP $C $X $H ~ ! ? ctrl-x]\r\n"));    
 80084ac:	4b03      	ldr	r3, [pc, #12]	; (80084bc <report_grbl_help+0x14>)
 80084ae:	0018      	movs	r0, r3
 80084b0:	f7fe fef4 	bl	800729c <printString>
}
 80084b4:	46c0      	nop			; (mov r8, r8)
 80084b6:	46bd      	mov	sp, r7
 80084b8:	bd80      	pop	{r7, pc}
 80084ba:	46c0      	nop			; (mov r8, r8)
 80084bc:	0800d4e0 	.word	0x0800d4e0

080084c0 <report_grbl_settings>:


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
 80084c0:	b590      	push	{r4, r7, lr}
 80084c2:	b083      	sub	sp, #12
 80084c4:	af00      	add	r7, sp, #0
  // Print Grbl settings.
  report_util_uint8_setting(0,settings.pulse_microseconds);
 80084c6:	4ba5      	ldr	r3, [pc, #660]	; (800875c <report_grbl_settings+0x29c>)
 80084c8:	2230      	movs	r2, #48	; 0x30
 80084ca:	5c9b      	ldrb	r3, [r3, r2]
 80084cc:	0019      	movs	r1, r3
 80084ce:	2000      	movs	r0, #0
 80084d0:	f7ff ff00 	bl	80082d4 <report_util_uint8_setting>
  report_util_uint8_setting(1,settings.stepper_idle_lock_time);
 80084d4:	4ba1      	ldr	r3, [pc, #644]	; (800875c <report_grbl_settings+0x29c>)
 80084d6:	2233      	movs	r2, #51	; 0x33
 80084d8:	5c9b      	ldrb	r3, [r3, r2]
 80084da:	0019      	movs	r1, r3
 80084dc:	2001      	movs	r0, #1
 80084de:	f7ff fef9 	bl	80082d4 <report_util_uint8_setting>
  report_util_uint8_setting(2,settings.step_invert_mask);
 80084e2:	4b9e      	ldr	r3, [pc, #632]	; (800875c <report_grbl_settings+0x29c>)
 80084e4:	2231      	movs	r2, #49	; 0x31
 80084e6:	5c9b      	ldrb	r3, [r3, r2]
 80084e8:	0019      	movs	r1, r3
 80084ea:	2002      	movs	r0, #2
 80084ec:	f7ff fef2 	bl	80082d4 <report_util_uint8_setting>
  report_util_uint8_setting(3,settings.dir_invert_mask);
 80084f0:	4b9a      	ldr	r3, [pc, #616]	; (800875c <report_grbl_settings+0x29c>)
 80084f2:	2232      	movs	r2, #50	; 0x32
 80084f4:	5c9b      	ldrb	r3, [r3, r2]
 80084f6:	0019      	movs	r1, r3
 80084f8:	2003      	movs	r0, #3
 80084fa:	f7ff feeb 	bl	80082d4 <report_util_uint8_setting>
  report_util_uint8_setting(4,bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE));
 80084fe:	4b97      	ldr	r3, [pc, #604]	; (800875c <report_grbl_settings+0x29c>)
 8008500:	2248      	movs	r2, #72	; 0x48
 8008502:	5c9b      	ldrb	r3, [r3, r2]
 8008504:	001a      	movs	r2, r3
 8008506:	2304      	movs	r3, #4
 8008508:	4013      	ands	r3, r2
 800850a:	1e5a      	subs	r2, r3, #1
 800850c:	4193      	sbcs	r3, r2
 800850e:	b2db      	uxtb	r3, r3
 8008510:	0019      	movs	r1, r3
 8008512:	2004      	movs	r0, #4
 8008514:	f7ff fede 	bl	80082d4 <report_util_uint8_setting>
  report_util_uint8_setting(5,bit_istrue(settings.flags,BITFLAG_INVERT_LIMIT_PINS));
 8008518:	4b90      	ldr	r3, [pc, #576]	; (800875c <report_grbl_settings+0x29c>)
 800851a:	2248      	movs	r2, #72	; 0x48
 800851c:	5c9b      	ldrb	r3, [r3, r2]
 800851e:	001a      	movs	r2, r3
 8008520:	2340      	movs	r3, #64	; 0x40
 8008522:	4013      	ands	r3, r2
 8008524:	1e5a      	subs	r2, r3, #1
 8008526:	4193      	sbcs	r3, r2
 8008528:	b2db      	uxtb	r3, r3
 800852a:	0019      	movs	r1, r3
 800852c:	2005      	movs	r0, #5
 800852e:	f7ff fed1 	bl	80082d4 <report_util_uint8_setting>
  report_util_uint8_setting(6,bit_istrue(settings.flags,BITFLAG_INVERT_PROBE_PIN));
 8008532:	4b8a      	ldr	r3, [pc, #552]	; (800875c <report_grbl_settings+0x29c>)
 8008534:	2248      	movs	r2, #72	; 0x48
 8008536:	5c9b      	ldrb	r3, [r3, r2]
 8008538:	b25b      	sxtb	r3, r3
 800853a:	b2db      	uxtb	r3, r3
 800853c:	09db      	lsrs	r3, r3, #7
 800853e:	b2db      	uxtb	r3, r3
 8008540:	0019      	movs	r1, r3
 8008542:	2006      	movs	r0, #6
 8008544:	f7ff fec6 	bl	80082d4 <report_util_uint8_setting>
  report_util_uint8_setting(10,settings.status_report_mask);
 8008548:	4b84      	ldr	r3, [pc, #528]	; (800875c <report_grbl_settings+0x29c>)
 800854a:	2234      	movs	r2, #52	; 0x34
 800854c:	5c9b      	ldrb	r3, [r3, r2]
 800854e:	0019      	movs	r1, r3
 8008550:	200a      	movs	r0, #10
 8008552:	f7ff febf 	bl	80082d4 <report_util_uint8_setting>
  report_util_float_setting(11,settings.junction_deviation,N_DECIMAL_SETTINGVALUE);
 8008556:	4b81      	ldr	r3, [pc, #516]	; (800875c <report_grbl_settings+0x29c>)
 8008558:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800855a:	2203      	movs	r2, #3
 800855c:	1c19      	adds	r1, r3, #0
 800855e:	200b      	movs	r0, #11
 8008560:	f7ff fed0 	bl	8008304 <report_util_float_setting>
  report_util_float_setting(12,settings.arc_tolerance,N_DECIMAL_SETTINGVALUE);
 8008564:	4b7d      	ldr	r3, [pc, #500]	; (800875c <report_grbl_settings+0x29c>)
 8008566:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8008568:	2203      	movs	r2, #3
 800856a:	1c19      	adds	r1, r3, #0
 800856c:	200c      	movs	r0, #12
 800856e:	f7ff fec9 	bl	8008304 <report_util_float_setting>
  report_util_uint8_setting(13,bit_istrue(settings.flags,BITFLAG_REPORT_INCHES));
 8008572:	4b7a      	ldr	r3, [pc, #488]	; (800875c <report_grbl_settings+0x29c>)
 8008574:	2248      	movs	r2, #72	; 0x48
 8008576:	5c9b      	ldrb	r3, [r3, r2]
 8008578:	001a      	movs	r2, r3
 800857a:	2301      	movs	r3, #1
 800857c:	4013      	ands	r3, r2
 800857e:	1e5a      	subs	r2, r3, #1
 8008580:	4193      	sbcs	r3, r2
 8008582:	b2db      	uxtb	r3, r3
 8008584:	0019      	movs	r1, r3
 8008586:	200d      	movs	r0, #13
 8008588:	f7ff fea4 	bl	80082d4 <report_util_uint8_setting>
  report_util_uint8_setting(20,bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE));
 800858c:	4b73      	ldr	r3, [pc, #460]	; (800875c <report_grbl_settings+0x29c>)
 800858e:	2248      	movs	r2, #72	; 0x48
 8008590:	5c9b      	ldrb	r3, [r3, r2]
 8008592:	001a      	movs	r2, r3
 8008594:	2320      	movs	r3, #32
 8008596:	4013      	ands	r3, r2
 8008598:	1e5a      	subs	r2, r3, #1
 800859a:	4193      	sbcs	r3, r2
 800859c:	b2db      	uxtb	r3, r3
 800859e:	0019      	movs	r1, r3
 80085a0:	2014      	movs	r0, #20
 80085a2:	f7ff fe97 	bl	80082d4 <report_util_uint8_setting>
  report_util_uint8_setting(21,bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE));
 80085a6:	4b6d      	ldr	r3, [pc, #436]	; (800875c <report_grbl_settings+0x29c>)
 80085a8:	2248      	movs	r2, #72	; 0x48
 80085aa:	5c9b      	ldrb	r3, [r3, r2]
 80085ac:	001a      	movs	r2, r3
 80085ae:	2308      	movs	r3, #8
 80085b0:	4013      	ands	r3, r2
 80085b2:	1e5a      	subs	r2, r3, #1
 80085b4:	4193      	sbcs	r3, r2
 80085b6:	b2db      	uxtb	r3, r3
 80085b8:	0019      	movs	r1, r3
 80085ba:	2015      	movs	r0, #21
 80085bc:	f7ff fe8a 	bl	80082d4 <report_util_uint8_setting>
  report_util_uint8_setting(22,bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE));
 80085c0:	4b66      	ldr	r3, [pc, #408]	; (800875c <report_grbl_settings+0x29c>)
 80085c2:	2248      	movs	r2, #72	; 0x48
 80085c4:	5c9b      	ldrb	r3, [r3, r2]
 80085c6:	001a      	movs	r2, r3
 80085c8:	2310      	movs	r3, #16
 80085ca:	4013      	ands	r3, r2
 80085cc:	1e5a      	subs	r2, r3, #1
 80085ce:	4193      	sbcs	r3, r2
 80085d0:	b2db      	uxtb	r3, r3
 80085d2:	0019      	movs	r1, r3
 80085d4:	2016      	movs	r0, #22
 80085d6:	f7ff fe7d 	bl	80082d4 <report_util_uint8_setting>
  report_util_uint8_setting(23,settings.homing_dir_mask);
 80085da:	4b60      	ldr	r3, [pc, #384]	; (800875c <report_grbl_settings+0x29c>)
 80085dc:	2249      	movs	r2, #73	; 0x49
 80085de:	5c9b      	ldrb	r3, [r3, r2]
 80085e0:	0019      	movs	r1, r3
 80085e2:	2017      	movs	r0, #23
 80085e4:	f7ff fe76 	bl	80082d4 <report_util_uint8_setting>
  report_util_float_setting(24,settings.homing_feed_rate,N_DECIMAL_SETTINGVALUE);
 80085e8:	4b5c      	ldr	r3, [pc, #368]	; (800875c <report_grbl_settings+0x29c>)
 80085ea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80085ec:	2203      	movs	r2, #3
 80085ee:	1c19      	adds	r1, r3, #0
 80085f0:	2018      	movs	r0, #24
 80085f2:	f7ff fe87 	bl	8008304 <report_util_float_setting>
  report_util_float_setting(25,settings.homing_seek_rate,N_DECIMAL_SETTINGVALUE);
 80085f6:	4b59      	ldr	r3, [pc, #356]	; (800875c <report_grbl_settings+0x29c>)
 80085f8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80085fa:	2203      	movs	r2, #3
 80085fc:	1c19      	adds	r1, r3, #0
 80085fe:	2019      	movs	r0, #25
 8008600:	f7ff fe80 	bl	8008304 <report_util_float_setting>
  report_util_uint8_setting(26,settings.homing_debounce_delay);
 8008604:	4b55      	ldr	r3, [pc, #340]	; (800875c <report_grbl_settings+0x29c>)
 8008606:	2254      	movs	r2, #84	; 0x54
 8008608:	5a9b      	ldrh	r3, [r3, r2]
 800860a:	0019      	movs	r1, r3
 800860c:	201a      	movs	r0, #26
 800860e:	f7ff fe61 	bl	80082d4 <report_util_uint8_setting>
  report_util_float_setting(27,settings.homing_pulloff,N_DECIMAL_SETTINGVALUE);
 8008612:	4b52      	ldr	r3, [pc, #328]	; (800875c <report_grbl_settings+0x29c>)
 8008614:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008616:	2203      	movs	r2, #3
 8008618:	1c19      	adds	r1, r3, #0
 800861a:	201b      	movs	r0, #27
 800861c:	f7ff fe72 	bl	8008304 <report_util_float_setting>
  report_util_float_setting(30,settings.rpm_max,N_DECIMAL_RPMVALUE);
 8008620:	4b4e      	ldr	r3, [pc, #312]	; (800875c <report_grbl_settings+0x29c>)
 8008622:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008624:	2200      	movs	r2, #0
 8008626:	1c19      	adds	r1, r3, #0
 8008628:	201e      	movs	r0, #30
 800862a:	f7ff fe6b 	bl	8008304 <report_util_float_setting>
  report_util_float_setting(31,settings.rpm_min,N_DECIMAL_RPMVALUE);
 800862e:	4b4b      	ldr	r3, [pc, #300]	; (800875c <report_grbl_settings+0x29c>)
 8008630:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008632:	2200      	movs	r2, #0
 8008634:	1c19      	adds	r1, r3, #0
 8008636:	201f      	movs	r0, #31
 8008638:	f7ff fe64 	bl	8008304 <report_util_float_setting>
  #ifdef VARIABLE_SPINDLE
    report_util_uint8_setting(32,bit_istrue(settings.flags,BITFLAG_LASER_MODE));
 800863c:	4b47      	ldr	r3, [pc, #284]	; (800875c <report_grbl_settings+0x29c>)
 800863e:	2248      	movs	r2, #72	; 0x48
 8008640:	5c9b      	ldrb	r3, [r3, r2]
 8008642:	001a      	movs	r2, r3
 8008644:	2302      	movs	r3, #2
 8008646:	4013      	ands	r3, r2
 8008648:	1e5a      	subs	r2, r3, #1
 800864a:	4193      	sbcs	r3, r2
 800864c:	b2db      	uxtb	r3, r3
 800864e:	0019      	movs	r1, r3
 8008650:	2020      	movs	r0, #32
 8008652:	f7ff fe3f 	bl	80082d4 <report_util_uint8_setting>
  #else
    report_util_uint8_setting(32,0);
  #endif
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
 8008656:	1d7b      	adds	r3, r7, #5
 8008658:	2264      	movs	r2, #100	; 0x64
 800865a:	701a      	strb	r2, [r3, #0]
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
 800865c:	1dbb      	adds	r3, r7, #6
 800865e:	2200      	movs	r2, #0
 8008660:	701a      	strb	r2, [r3, #0]
 8008662:	e073      	b.n	800874c <report_grbl_settings+0x28c>
    for (idx=0; idx<N_AXIS; idx++) {
 8008664:	1dfb      	adds	r3, r7, #7
 8008666:	2200      	movs	r2, #0
 8008668:	701a      	strb	r2, [r3, #0]
 800866a:	e061      	b.n	8008730 <report_grbl_settings+0x270>
      switch (set_idx) {
 800866c:	1dbb      	adds	r3, r7, #6
 800866e:	781b      	ldrb	r3, [r3, #0]
 8008670:	2b01      	cmp	r3, #1
 8008672:	d018      	beq.n	80086a6 <report_grbl_settings+0x1e6>
 8008674:	dc02      	bgt.n	800867c <report_grbl_settings+0x1bc>
 8008676:	2b00      	cmp	r3, #0
 8008678:	d005      	beq.n	8008686 <report_grbl_settings+0x1c6>
 800867a:	e054      	b.n	8008726 <report_grbl_settings+0x266>
 800867c:	2b02      	cmp	r3, #2
 800867e:	d025      	beq.n	80086cc <report_grbl_settings+0x20c>
 8008680:	2b03      	cmp	r3, #3
 8008682:	d03a      	beq.n	80086fa <report_grbl_settings+0x23a>
 8008684:	e04f      	b.n	8008726 <report_grbl_settings+0x266>
        case 0: report_util_float_setting(val+idx,settings.steps_per_mm[idx],N_DECIMAL_SETTINGVALUE); break;
 8008686:	1d7a      	adds	r2, r7, #5
 8008688:	1dfb      	adds	r3, r7, #7
 800868a:	7812      	ldrb	r2, [r2, #0]
 800868c:	781b      	ldrb	r3, [r3, #0]
 800868e:	18d3      	adds	r3, r2, r3
 8008690:	b2d8      	uxtb	r0, r3
 8008692:	1dfb      	adds	r3, r7, #7
 8008694:	781a      	ldrb	r2, [r3, #0]
 8008696:	4b31      	ldr	r3, [pc, #196]	; (800875c <report_grbl_settings+0x29c>)
 8008698:	0092      	lsls	r2, r2, #2
 800869a:	58d3      	ldr	r3, [r2, r3]
 800869c:	2203      	movs	r2, #3
 800869e:	1c19      	adds	r1, r3, #0
 80086a0:	f7ff fe30 	bl	8008304 <report_util_float_setting>
 80086a4:	e03f      	b.n	8008726 <report_grbl_settings+0x266>
        case 1: report_util_float_setting(val+idx,settings.max_rate[idx],N_DECIMAL_SETTINGVALUE); break;
 80086a6:	1d7a      	adds	r2, r7, #5
 80086a8:	1dfb      	adds	r3, r7, #7
 80086aa:	7812      	ldrb	r2, [r2, #0]
 80086ac:	781b      	ldrb	r3, [r3, #0]
 80086ae:	18d3      	adds	r3, r2, r3
 80086b0:	b2d8      	uxtb	r0, r3
 80086b2:	1dfb      	adds	r3, r7, #7
 80086b4:	781b      	ldrb	r3, [r3, #0]
 80086b6:	4a29      	ldr	r2, [pc, #164]	; (800875c <report_grbl_settings+0x29c>)
 80086b8:	3302      	adds	r3, #2
 80086ba:	009b      	lsls	r3, r3, #2
 80086bc:	18d3      	adds	r3, r2, r3
 80086be:	3304      	adds	r3, #4
 80086c0:	681b      	ldr	r3, [r3, #0]
 80086c2:	2203      	movs	r2, #3
 80086c4:	1c19      	adds	r1, r3, #0
 80086c6:	f7ff fe1d 	bl	8008304 <report_util_float_setting>
 80086ca:	e02c      	b.n	8008726 <report_grbl_settings+0x266>
        case 2: report_util_float_setting(val+idx,settings.acceleration[idx]/(60*60),N_DECIMAL_SETTINGVALUE); break;
 80086cc:	1d7a      	adds	r2, r7, #5
 80086ce:	1dfb      	adds	r3, r7, #7
 80086d0:	7812      	ldrb	r2, [r2, #0]
 80086d2:	781b      	ldrb	r3, [r3, #0]
 80086d4:	18d3      	adds	r3, r2, r3
 80086d6:	b2dc      	uxtb	r4, r3
 80086d8:	1dfb      	adds	r3, r7, #7
 80086da:	781a      	ldrb	r2, [r3, #0]
 80086dc:	4b1f      	ldr	r3, [pc, #124]	; (800875c <report_grbl_settings+0x29c>)
 80086de:	3206      	adds	r2, #6
 80086e0:	0092      	lsls	r2, r2, #2
 80086e2:	58d3      	ldr	r3, [r2, r3]
 80086e4:	491e      	ldr	r1, [pc, #120]	; (8008760 <report_grbl_settings+0x2a0>)
 80086e6:	1c18      	adds	r0, r3, #0
 80086e8:	f7f7 ffc8 	bl	800067c <__aeabi_fdiv>
 80086ec:	1c03      	adds	r3, r0, #0
 80086ee:	2203      	movs	r2, #3
 80086f0:	1c19      	adds	r1, r3, #0
 80086f2:	0020      	movs	r0, r4
 80086f4:	f7ff fe06 	bl	8008304 <report_util_float_setting>
 80086f8:	e015      	b.n	8008726 <report_grbl_settings+0x266>
        case 3: report_util_float_setting(val+idx,-settings.max_travel[idx],N_DECIMAL_SETTINGVALUE); break;
 80086fa:	1d7a      	adds	r2, r7, #5
 80086fc:	1dfb      	adds	r3, r7, #7
 80086fe:	7812      	ldrb	r2, [r2, #0]
 8008700:	781b      	ldrb	r3, [r3, #0]
 8008702:	18d3      	adds	r3, r2, r3
 8008704:	b2d8      	uxtb	r0, r3
 8008706:	1dfb      	adds	r3, r7, #7
 8008708:	781b      	ldrb	r3, [r3, #0]
 800870a:	4a14      	ldr	r2, [pc, #80]	; (800875c <report_grbl_settings+0x29c>)
 800870c:	3308      	adds	r3, #8
 800870e:	009b      	lsls	r3, r3, #2
 8008710:	18d3      	adds	r3, r2, r3
 8008712:	3304      	adds	r3, #4
 8008714:	681b      	ldr	r3, [r3, #0]
 8008716:	2280      	movs	r2, #128	; 0x80
 8008718:	0612      	lsls	r2, r2, #24
 800871a:	4053      	eors	r3, r2
 800871c:	2203      	movs	r2, #3
 800871e:	1c19      	adds	r1, r3, #0
 8008720:	f7ff fdf0 	bl	8008304 <report_util_float_setting>
 8008724:	46c0      	nop			; (mov r8, r8)
  #endif
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
 8008726:	1dfb      	adds	r3, r7, #7
 8008728:	781a      	ldrb	r2, [r3, #0]
 800872a:	1dfb      	adds	r3, r7, #7
 800872c:	3201      	adds	r2, #1
 800872e:	701a      	strb	r2, [r3, #0]
 8008730:	1dfb      	adds	r3, r7, #7
 8008732:	781b      	ldrb	r3, [r3, #0]
 8008734:	2b02      	cmp	r3, #2
 8008736:	d999      	bls.n	800866c <report_grbl_settings+0x1ac>
        case 1: report_util_float_setting(val+idx,settings.max_rate[idx],N_DECIMAL_SETTINGVALUE); break;
        case 2: report_util_float_setting(val+idx,settings.acceleration[idx]/(60*60),N_DECIMAL_SETTINGVALUE); break;
        case 3: report_util_float_setting(val+idx,-settings.max_travel[idx],N_DECIMAL_SETTINGVALUE); break;
      }
    }
    val += AXIS_SETTINGS_INCREMENT;
 8008738:	1d7b      	adds	r3, r7, #5
 800873a:	1d7a      	adds	r2, r7, #5
 800873c:	7812      	ldrb	r2, [r2, #0]
 800873e:	320a      	adds	r2, #10
 8008740:	701a      	strb	r2, [r3, #0]
    report_util_uint8_setting(32,0);
  #endif
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
 8008742:	1dbb      	adds	r3, r7, #6
 8008744:	781a      	ldrb	r2, [r3, #0]
 8008746:	1dbb      	adds	r3, r7, #6
 8008748:	3201      	adds	r2, #1
 800874a:	701a      	strb	r2, [r3, #0]
 800874c:	1dbb      	adds	r3, r7, #6
 800874e:	781b      	ldrb	r3, [r3, #0]
 8008750:	2b03      	cmp	r3, #3
 8008752:	d987      	bls.n	8008664 <report_grbl_settings+0x1a4>
        case 3: report_util_float_setting(val+idx,-settings.max_travel[idx],N_DECIMAL_SETTINGVALUE); break;
      }
    }
    val += AXIS_SETTINGS_INCREMENT;
  }
}
 8008754:	46c0      	nop			; (mov r8, r8)
 8008756:	46bd      	mov	sp, r7
 8008758:	b003      	add	sp, #12
 800875a:	bd90      	pop	{r4, r7, pc}
 800875c:	20000acc 	.word	0x20000acc
 8008760:	45610000 	.word	0x45610000

08008764 <report_probe_parameters>:

// Prints current probe parameters. Upon a probe command, these parameters are updated upon a
// successful probe or upon a failed probe with the G38.3 without errors command (if supported).
// These values are retained until Grbl is power-cycled, whereby they will be re-zeroed.
void report_probe_parameters()
{
 8008764:	b580      	push	{r7, lr}
 8008766:	b084      	sub	sp, #16
 8008768:	af00      	add	r7, sp, #0
  // Report in terms of machine position.
  printPgmString(PSTR("[PRB:"));
 800876a:	4b0e      	ldr	r3, [pc, #56]	; (80087a4 <report_probe_parameters+0x40>)
 800876c:	0018      	movs	r0, r3
 800876e:	f7fe fd95 	bl	800729c <printString>
  float print_position[N_AXIS];
  system_convert_array_steps_to_mpos(print_position,sys_probe_position);
 8008772:	4a0d      	ldr	r2, [pc, #52]	; (80087a8 <report_probe_parameters+0x44>)
 8008774:	1d3b      	adds	r3, r7, #4
 8008776:	0011      	movs	r1, r2
 8008778:	0018      	movs	r0, r3
 800877a:	f003 f8d1 	bl	800b920 <system_convert_array_steps_to_mpos>
  report_util_axis_values(print_position);
 800877e:	1d3b      	adds	r3, r7, #4
 8008780:	0018      	movs	r0, r3
 8008782:	f7ff fd7b 	bl	800827c <report_util_axis_values>
  serial_write(':');
 8008786:	203a      	movs	r0, #58	; 0x3a
 8008788:	f000 fc3a 	bl	8009000 <serial_write>
  print_uint8_base10(sys.probe_succeeded);
 800878c:	4b07      	ldr	r3, [pc, #28]	; (80087ac <report_probe_parameters+0x48>)
 800878e:	795b      	ldrb	r3, [r3, #5]
 8008790:	0018      	movs	r0, r3
 8008792:	f7fe fd97 	bl	80072c4 <print_uint8_base10>
  report_util_feedback_line_feed();
 8008796:	f7ff fd4f 	bl	8008238 <report_util_feedback_line_feed>
}
 800879a:	46c0      	nop			; (mov r8, r8)
 800879c:	46bd      	mov	sp, r7
 800879e:	b004      	add	sp, #16
 80087a0:	bd80      	pop	{r7, pc}
 80087a2:	46c0      	nop			; (mov r8, r8)
 80087a4:	0800d52c 	.word	0x0800d52c
 80087a8:	20000b44 	.word	0x20000b44
 80087ac:	20000b2c 	.word	0x20000b2c

080087b0 <report_ngc_parameters>:


// Prints Grbl NGC parameters (coordinate offsets, probing)
void report_ngc_parameters()
{
 80087b0:	b580      	push	{r7, lr}
 80087b2:	b084      	sub	sp, #16
 80087b4:	af00      	add	r7, sp, #0
  float coord_data[N_AXIS];
  uint8_t coord_select;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) {
 80087b6:	230f      	movs	r3, #15
 80087b8:	18fb      	adds	r3, r7, r3
 80087ba:	2200      	movs	r2, #0
 80087bc:	701a      	strb	r2, [r3, #0]
 80087be:	e03c      	b.n	800883a <report_ngc_parameters+0x8a>
    if (!(settings_read_coord_data(coord_select,coord_data))) {
 80087c0:	003a      	movs	r2, r7
 80087c2:	230f      	movs	r3, #15
 80087c4:	18fb      	adds	r3, r7, r3
 80087c6:	781b      	ldrb	r3, [r3, #0]
 80087c8:	0011      	movs	r1, r2
 80087ca:	0018      	movs	r0, r3
 80087cc:	f000 febe 	bl	800954c <settings_read_coord_data>
 80087d0:	1e03      	subs	r3, r0, #0
 80087d2:	d103      	bne.n	80087dc <report_ngc_parameters+0x2c>
      report_status_message(STATUS_SETTING_READ_FAIL);
 80087d4:	2007      	movs	r0, #7
 80087d6:	f7ff fdb3 	bl	8008340 <report_status_message>
 80087da:	e04a      	b.n	8008872 <report_ngc_parameters+0xc2>
      return;
    }
    printPgmString(PSTR("[G"));
 80087dc:	4b26      	ldr	r3, [pc, #152]	; (8008878 <report_ngc_parameters+0xc8>)
 80087de:	0018      	movs	r0, r3
 80087e0:	f7fe fd5c 	bl	800729c <printString>
    switch (coord_select) {
 80087e4:	230f      	movs	r3, #15
 80087e6:	18fb      	adds	r3, r7, r3
 80087e8:	781b      	ldrb	r3, [r3, #0]
 80087ea:	2b06      	cmp	r3, #6
 80087ec:	d002      	beq.n	80087f4 <report_ngc_parameters+0x44>
 80087ee:	2b07      	cmp	r3, #7
 80087f0:	d005      	beq.n	80087fe <report_ngc_parameters+0x4e>
 80087f2:	e009      	b.n	8008808 <report_ngc_parameters+0x58>
      case 6: printPgmString(PSTR("28")); break;
 80087f4:	4b21      	ldr	r3, [pc, #132]	; (800887c <report_ngc_parameters+0xcc>)
 80087f6:	0018      	movs	r0, r3
 80087f8:	f7fe fd50 	bl	800729c <printString>
 80087fc:	e00d      	b.n	800881a <report_ngc_parameters+0x6a>
      case 7: printPgmString(PSTR("30")); break;
 80087fe:	4b20      	ldr	r3, [pc, #128]	; (8008880 <report_ngc_parameters+0xd0>)
 8008800:	0018      	movs	r0, r3
 8008802:	f7fe fd4b 	bl	800729c <printString>
 8008806:	e008      	b.n	800881a <report_ngc_parameters+0x6a>
      default: print_uint8_base10(coord_select+54); break; // G54-G59
 8008808:	230f      	movs	r3, #15
 800880a:	18fb      	adds	r3, r7, r3
 800880c:	781b      	ldrb	r3, [r3, #0]
 800880e:	3336      	adds	r3, #54	; 0x36
 8008810:	b2db      	uxtb	r3, r3
 8008812:	0018      	movs	r0, r3
 8008814:	f7fe fd56 	bl	80072c4 <print_uint8_base10>
 8008818:	46c0      	nop			; (mov r8, r8)
    }
    serial_write(':');
 800881a:	203a      	movs	r0, #58	; 0x3a
 800881c:	f000 fbf0 	bl	8009000 <serial_write>
    report_util_axis_values(coord_data);
 8008820:	003b      	movs	r3, r7
 8008822:	0018      	movs	r0, r3
 8008824:	f7ff fd2a 	bl	800827c <report_util_axis_values>
    report_util_feedback_line_feed();
 8008828:	f7ff fd06 	bl	8008238 <report_util_feedback_line_feed>
// Prints Grbl NGC parameters (coordinate offsets, probing)
void report_ngc_parameters()
{
  float coord_data[N_AXIS];
  uint8_t coord_select;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) {
 800882c:	230f      	movs	r3, #15
 800882e:	18fb      	adds	r3, r7, r3
 8008830:	781a      	ldrb	r2, [r3, #0]
 8008832:	230f      	movs	r3, #15
 8008834:	18fb      	adds	r3, r7, r3
 8008836:	3201      	adds	r2, #1
 8008838:	701a      	strb	r2, [r3, #0]
 800883a:	230f      	movs	r3, #15
 800883c:	18fb      	adds	r3, r7, r3
 800883e:	781b      	ldrb	r3, [r3, #0]
 8008840:	2b07      	cmp	r3, #7
 8008842:	d9bd      	bls.n	80087c0 <report_ngc_parameters+0x10>
    }
    serial_write(':');
    report_util_axis_values(coord_data);
    report_util_feedback_line_feed();
  }
  printPgmString(PSTR("[G92:")); // Print G92,G92.1 which are not persistent in memory
 8008844:	4b0f      	ldr	r3, [pc, #60]	; (8008884 <report_ngc_parameters+0xd4>)
 8008846:	0018      	movs	r0, r3
 8008848:	f7fe fd28 	bl	800729c <printString>
  report_util_axis_values(gc_state.coord_offset);
 800884c:	4b0e      	ldr	r3, [pc, #56]	; (8008888 <report_ngc_parameters+0xd8>)
 800884e:	0018      	movs	r0, r3
 8008850:	f7ff fd14 	bl	800827c <report_util_axis_values>
  report_util_feedback_line_feed();
 8008854:	f7ff fcf0 	bl	8008238 <report_util_feedback_line_feed>
  printPgmString(PSTR("[TLO:")); // Print tool length offset value
 8008858:	4b0c      	ldr	r3, [pc, #48]	; (800888c <report_ngc_parameters+0xdc>)
 800885a:	0018      	movs	r0, r3
 800885c:	f7fe fd1e 	bl	800729c <printString>
  printFloat_CoordValue(gc_state.tool_length_offset);
 8008860:	4b0b      	ldr	r3, [pc, #44]	; (8008890 <report_ngc_parameters+0xe0>)
 8008862:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008864:	1c18      	adds	r0, r3, #0
 8008866:	f7fe fe47 	bl	80074f8 <printFloat_CoordValue>
  report_util_feedback_line_feed();
 800886a:	f7ff fce5 	bl	8008238 <report_util_feedback_line_feed>
  report_probe_parameters(); // Print probe parameters. Not persistent in memory.
 800886e:	f7ff ff79 	bl	8008764 <report_probe_parameters>
}
 8008872:	46bd      	mov	sp, r7
 8008874:	b004      	add	sp, #16
 8008876:	bd80      	pop	{r7, pc}
 8008878:	0800d534 	.word	0x0800d534
 800887c:	0800d538 	.word	0x0800d538
 8008880:	0800d53c 	.word	0x0800d53c
 8008884:	0800d540 	.word	0x0800d540
 8008888:	20000990 	.word	0x20000990
 800888c:	0800d548 	.word	0x0800d548
 8008890:	2000095c 	.word	0x2000095c

08008894 <report_gcode_modes>:


// Print current gcode parser mode state
void report_gcode_modes()
{
 8008894:	b580      	push	{r7, lr}
 8008896:	af00      	add	r7, sp, #0
  printPgmString(PSTR("[GC:G"));
 8008898:	4b52      	ldr	r3, [pc, #328]	; (80089e4 <report_gcode_modes+0x150>)
 800889a:	0018      	movs	r0, r3
 800889c:	f7fe fcfe 	bl	800729c <printString>
  if (gc_state.modal.motion >= MOTION_MODE_PROBE_TOWARD) {
 80088a0:	4b51      	ldr	r3, [pc, #324]	; (80089e8 <report_gcode_modes+0x154>)
 80088a2:	781b      	ldrb	r3, [r3, #0]
 80088a4:	2b8b      	cmp	r3, #139	; 0x8b
 80088a6:	d90b      	bls.n	80088c0 <report_gcode_modes+0x2c>
    printPgmString(PSTR("38."));
 80088a8:	4b50      	ldr	r3, [pc, #320]	; (80089ec <report_gcode_modes+0x158>)
 80088aa:	0018      	movs	r0, r3
 80088ac:	f7fe fcf6 	bl	800729c <printString>
    print_uint8_base10(gc_state.modal.motion - (MOTION_MODE_PROBE_TOWARD-2));
 80088b0:	4b4d      	ldr	r3, [pc, #308]	; (80089e8 <report_gcode_modes+0x154>)
 80088b2:	781b      	ldrb	r3, [r3, #0]
 80088b4:	3376      	adds	r3, #118	; 0x76
 80088b6:	b2db      	uxtb	r3, r3
 80088b8:	0018      	movs	r0, r3
 80088ba:	f7fe fd03 	bl	80072c4 <print_uint8_base10>
 80088be:	e004      	b.n	80088ca <report_gcode_modes+0x36>
  } else {
    print_uint8_base10(gc_state.modal.motion);
 80088c0:	4b49      	ldr	r3, [pc, #292]	; (80089e8 <report_gcode_modes+0x154>)
 80088c2:	781b      	ldrb	r3, [r3, #0]
 80088c4:	0018      	movs	r0, r3
 80088c6:	f7fe fcfd 	bl	80072c4 <print_uint8_base10>
  }

  report_util_gcode_modes_G();
 80088ca:	f7ff fcbf 	bl	800824c <report_util_gcode_modes_G>
  print_uint8_base10(gc_state.modal.coord_select+54);
 80088ce:	4b46      	ldr	r3, [pc, #280]	; (80089e8 <report_gcode_modes+0x154>)
 80088d0:	799b      	ldrb	r3, [r3, #6]
 80088d2:	3336      	adds	r3, #54	; 0x36
 80088d4:	b2db      	uxtb	r3, r3
 80088d6:	0018      	movs	r0, r3
 80088d8:	f7fe fcf4 	bl	80072c4 <print_uint8_base10>

  report_util_gcode_modes_G();
 80088dc:	f7ff fcb6 	bl	800824c <report_util_gcode_modes_G>
  print_uint8_base10(gc_state.modal.plane_select+17);
 80088e0:	4b41      	ldr	r3, [pc, #260]	; (80089e8 <report_gcode_modes+0x154>)
 80088e2:	791b      	ldrb	r3, [r3, #4]
 80088e4:	3311      	adds	r3, #17
 80088e6:	b2db      	uxtb	r3, r3
 80088e8:	0018      	movs	r0, r3
 80088ea:	f7fe fceb 	bl	80072c4 <print_uint8_base10>

  report_util_gcode_modes_G();
 80088ee:	f7ff fcad 	bl	800824c <report_util_gcode_modes_G>
  print_uint8_base10(21-gc_state.modal.units);
 80088f2:	4b3d      	ldr	r3, [pc, #244]	; (80089e8 <report_gcode_modes+0x154>)
 80088f4:	789b      	ldrb	r3, [r3, #2]
 80088f6:	2215      	movs	r2, #21
 80088f8:	1ad3      	subs	r3, r2, r3
 80088fa:	b2db      	uxtb	r3, r3
 80088fc:	0018      	movs	r0, r3
 80088fe:	f7fe fce1 	bl	80072c4 <print_uint8_base10>

  report_util_gcode_modes_G();
 8008902:	f7ff fca3 	bl	800824c <report_util_gcode_modes_G>
  print_uint8_base10(gc_state.modal.distance+90);
 8008906:	4b38      	ldr	r3, [pc, #224]	; (80089e8 <report_gcode_modes+0x154>)
 8008908:	78db      	ldrb	r3, [r3, #3]
 800890a:	335a      	adds	r3, #90	; 0x5a
 800890c:	b2db      	uxtb	r3, r3
 800890e:	0018      	movs	r0, r3
 8008910:	f7fe fcd8 	bl	80072c4 <print_uint8_base10>

  report_util_gcode_modes_G();
 8008914:	f7ff fc9a 	bl	800824c <report_util_gcode_modes_G>
  print_uint8_base10(94-gc_state.modal.feed_rate);
 8008918:	4b33      	ldr	r3, [pc, #204]	; (80089e8 <report_gcode_modes+0x154>)
 800891a:	785b      	ldrb	r3, [r3, #1]
 800891c:	225e      	movs	r2, #94	; 0x5e
 800891e:	1ad3      	subs	r3, r2, r3
 8008920:	b2db      	uxtb	r3, r3
 8008922:	0018      	movs	r0, r3
 8008924:	f7fe fcce 	bl	80072c4 <print_uint8_base10>

  if (gc_state.modal.program_flow) {
 8008928:	4b2f      	ldr	r3, [pc, #188]	; (80089e8 <report_gcode_modes+0x154>)
 800892a:	79db      	ldrb	r3, [r3, #7]
 800892c:	2b00      	cmp	r3, #0
 800892e:	d014      	beq.n	800895a <report_gcode_modes+0xc6>
    report_util_gcode_modes_M();
 8008930:	f7ff fc98 	bl	8008264 <report_util_gcode_modes_M>
    switch (gc_state.modal.program_flow) {
 8008934:	4b2c      	ldr	r3, [pc, #176]	; (80089e8 <report_gcode_modes+0x154>)
 8008936:	79db      	ldrb	r3, [r3, #7]
 8008938:	2b03      	cmp	r3, #3
 800893a:	d004      	beq.n	8008946 <report_gcode_modes+0xb2>
 800893c:	2b1e      	cmp	r3, #30
 800893e:	d006      	beq.n	800894e <report_gcode_modes+0xba>
 8008940:	2b02      	cmp	r3, #2
 8008942:	d004      	beq.n	800894e <report_gcode_modes+0xba>
 8008944:	e009      	b.n	800895a <report_gcode_modes+0xc6>
      case PROGRAM_FLOW_PAUSED : serial_write('0'); break;
 8008946:	2030      	movs	r0, #48	; 0x30
 8008948:	f000 fb5a 	bl	8009000 <serial_write>
 800894c:	e005      	b.n	800895a <report_gcode_modes+0xc6>
      // case PROGRAM_FLOW_OPTIONAL_STOP : serial_write('1'); break; // M1 is ignored and not supported.
      case PROGRAM_FLOW_COMPLETED_M2 : 
      case PROGRAM_FLOW_COMPLETED_M30 : 
        print_uint8_base10(gc_state.modal.program_flow);
 800894e:	4b26      	ldr	r3, [pc, #152]	; (80089e8 <report_gcode_modes+0x154>)
 8008950:	79db      	ldrb	r3, [r3, #7]
 8008952:	0018      	movs	r0, r3
 8008954:	f7fe fcb6 	bl	80072c4 <print_uint8_base10>
        break;
 8008958:	46c0      	nop			; (mov r8, r8)
    }
  }

  report_util_gcode_modes_M();
 800895a:	f7ff fc83 	bl	8008264 <report_util_gcode_modes_M>
  switch (gc_state.modal.spindle) {
 800895e:	4b22      	ldr	r3, [pc, #136]	; (80089e8 <report_gcode_modes+0x154>)
 8008960:	7a5b      	ldrb	r3, [r3, #9]
 8008962:	2b10      	cmp	r3, #16
 8008964:	d004      	beq.n	8008970 <report_gcode_modes+0xdc>
 8008966:	2b20      	cmp	r3, #32
 8008968:	d006      	beq.n	8008978 <report_gcode_modes+0xe4>
 800896a:	2b00      	cmp	r3, #0
 800896c:	d008      	beq.n	8008980 <report_gcode_modes+0xec>
 800896e:	e00b      	b.n	8008988 <report_gcode_modes+0xf4>
    case SPINDLE_ENABLE_CW : serial_write('3'); break;
 8008970:	2033      	movs	r0, #51	; 0x33
 8008972:	f000 fb45 	bl	8009000 <serial_write>
 8008976:	e007      	b.n	8008988 <report_gcode_modes+0xf4>
    case SPINDLE_ENABLE_CCW : serial_write('4'); break;
 8008978:	2034      	movs	r0, #52	; 0x34
 800897a:	f000 fb41 	bl	8009000 <serial_write>
 800897e:	e003      	b.n	8008988 <report_gcode_modes+0xf4>
    case SPINDLE_DISABLE : serial_write('5'); break;
 8008980:	2035      	movs	r0, #53	; 0x35
 8008982:	f000 fb3d 	bl	8009000 <serial_write>
 8008986:	46c0      	nop			; (mov r8, r8)
  }

  report_util_gcode_modes_M();
 8008988:	f7ff fc6c 	bl	8008264 <report_util_gcode_modes_M>
    if (gc_state.modal.coolant) { // Note: Multiple coolant states may be active at the same time.
      if (gc_state.modal.coolant & PL_COND_FLAG_COOLANT_MIST) { serial_write('7'); }
      if (gc_state.modal.coolant & PL_COND_FLAG_COOLANT_FLOOD) { serial_write('8'); }
    } else { serial_write('9'); }
  #else
    if (gc_state.modal.coolant) { serial_write('8'); }
 800898c:	4b16      	ldr	r3, [pc, #88]	; (80089e8 <report_gcode_modes+0x154>)
 800898e:	7a1b      	ldrb	r3, [r3, #8]
 8008990:	2b00      	cmp	r3, #0
 8008992:	d003      	beq.n	800899c <report_gcode_modes+0x108>
 8008994:	2038      	movs	r0, #56	; 0x38
 8008996:	f000 fb33 	bl	8009000 <serial_write>
 800899a:	e002      	b.n	80089a2 <report_gcode_modes+0x10e>
    else { serial_write('9'); }
 800899c:	2039      	movs	r0, #57	; 0x39
 800899e:	f000 fb2f 	bl	8009000 <serial_write>
			report_util_gcode_modes_M();
			print_uint8_base10(56);
		}
	#endif

  printPgmString(PSTR(" T"));
 80089a2:	4b13      	ldr	r3, [pc, #76]	; (80089f0 <report_gcode_modes+0x15c>)
 80089a4:	0018      	movs	r0, r3
 80089a6:	f7fe fc79 	bl	800729c <printString>
  print_uint8_base10(gc_state.tool);
 80089aa:	4b0f      	ldr	r3, [pc, #60]	; (80089e8 <report_gcode_modes+0x154>)
 80089ac:	7d1b      	ldrb	r3, [r3, #20]
 80089ae:	0018      	movs	r0, r3
 80089b0:	f7fe fc88 	bl	80072c4 <print_uint8_base10>

  printPgmString(PSTR(" F"));
 80089b4:	4b0f      	ldr	r3, [pc, #60]	; (80089f4 <report_gcode_modes+0x160>)
 80089b6:	0018      	movs	r0, r3
 80089b8:	f7fe fc70 	bl	800729c <printString>
  printFloat_RateValue(gc_state.feed_rate);
 80089bc:	4b0a      	ldr	r3, [pc, #40]	; (80089e8 <report_gcode_modes+0x154>)
 80089be:	691b      	ldr	r3, [r3, #16]
 80089c0:	1c18      	adds	r0, r3, #0
 80089c2:	f7fe fdbb 	bl	800753c <printFloat_RateValue>

  #ifdef VARIABLE_SPINDLE
    printPgmString(PSTR(" S"));
 80089c6:	4b0c      	ldr	r3, [pc, #48]	; (80089f8 <report_gcode_modes+0x164>)
 80089c8:	0018      	movs	r0, r3
 80089ca:	f7fe fc67 	bl	800729c <printString>
    printFloat(gc_state.spindle_speed,N_DECIMAL_RPMVALUE);
 80089ce:	4b06      	ldr	r3, [pc, #24]	; (80089e8 <report_gcode_modes+0x154>)
 80089d0:	68db      	ldr	r3, [r3, #12]
 80089d2:	2100      	movs	r1, #0
 80089d4:	1c18      	adds	r0, r3, #0
 80089d6:	f7fe fcd7 	bl	8007388 <printFloat>
  #endif

  report_util_feedback_line_feed();
 80089da:	f7ff fc2d 	bl	8008238 <report_util_feedback_line_feed>
}
 80089de:	46c0      	nop			; (mov r8, r8)
 80089e0:	46bd      	mov	sp, r7
 80089e2:	bd80      	pop	{r7, pc}
 80089e4:	0800d550 	.word	0x0800d550
 80089e8:	2000095c 	.word	0x2000095c
 80089ec:	0800d558 	.word	0x0800d558
 80089f0:	0800d55c 	.word	0x0800d55c
 80089f4:	0800d560 	.word	0x0800d560
 80089f8:	0800d564 	.word	0x0800d564

080089fc <report_startup_line>:

// Prints specified startup line
void report_startup_line(uint8_t n, char *line)
{
 80089fc:	b580      	push	{r7, lr}
 80089fe:	b082      	sub	sp, #8
 8008a00:	af00      	add	r7, sp, #0
 8008a02:	0002      	movs	r2, r0
 8008a04:	6039      	str	r1, [r7, #0]
 8008a06:	1dfb      	adds	r3, r7, #7
 8008a08:	701a      	strb	r2, [r3, #0]
  printPgmString(PSTR("$N"));
 8008a0a:	4b0b      	ldr	r3, [pc, #44]	; (8008a38 <report_startup_line+0x3c>)
 8008a0c:	0018      	movs	r0, r3
 8008a0e:	f7fe fc45 	bl	800729c <printString>
  print_uint8_base10(n);
 8008a12:	1dfb      	adds	r3, r7, #7
 8008a14:	781b      	ldrb	r3, [r3, #0]
 8008a16:	0018      	movs	r0, r3
 8008a18:	f7fe fc54 	bl	80072c4 <print_uint8_base10>
  serial_write('=');
 8008a1c:	203d      	movs	r0, #61	; 0x3d
 8008a1e:	f000 faef 	bl	8009000 <serial_write>
  printString(line);
 8008a22:	683b      	ldr	r3, [r7, #0]
 8008a24:	0018      	movs	r0, r3
 8008a26:	f7fe fc39 	bl	800729c <printString>
  report_util_line_feed();
 8008a2a:	f7ff fbf9 	bl	8008220 <report_util_line_feed>
}
 8008a2e:	46c0      	nop			; (mov r8, r8)
 8008a30:	46bd      	mov	sp, r7
 8008a32:	b002      	add	sp, #8
 8008a34:	bd80      	pop	{r7, pc}
 8008a36:	46c0      	nop			; (mov r8, r8)
 8008a38:	0800d568 	.word	0x0800d568

08008a3c <report_execute_startup_message>:

void report_execute_startup_message(char *line, uint8_t status_code)
{
 8008a3c:	b580      	push	{r7, lr}
 8008a3e:	b082      	sub	sp, #8
 8008a40:	af00      	add	r7, sp, #0
 8008a42:	6078      	str	r0, [r7, #4]
 8008a44:	000a      	movs	r2, r1
 8008a46:	1cfb      	adds	r3, r7, #3
 8008a48:	701a      	strb	r2, [r3, #0]
  serial_write('>');
 8008a4a:	203e      	movs	r0, #62	; 0x3e
 8008a4c:	f000 fad8 	bl	8009000 <serial_write>
  printString(line);
 8008a50:	687b      	ldr	r3, [r7, #4]
 8008a52:	0018      	movs	r0, r3
 8008a54:	f7fe fc22 	bl	800729c <printString>
  serial_write(':');
 8008a58:	203a      	movs	r0, #58	; 0x3a
 8008a5a:	f000 fad1 	bl	8009000 <serial_write>
  report_status_message(status_code);
 8008a5e:	1cfb      	adds	r3, r7, #3
 8008a60:	781b      	ldrb	r3, [r3, #0]
 8008a62:	0018      	movs	r0, r3
 8008a64:	f7ff fc6c 	bl	8008340 <report_status_message>
}
 8008a68:	46c0      	nop			; (mov r8, r8)
 8008a6a:	46bd      	mov	sp, r7
 8008a6c:	b002      	add	sp, #8
 8008a6e:	bd80      	pop	{r7, pc}

08008a70 <report_build_info>:

// Prints build info line
void report_build_info(char *line)
{
 8008a70:	b580      	push	{r7, lr}
 8008a72:	b082      	sub	sp, #8
 8008a74:	af00      	add	r7, sp, #0
 8008a76:	6078      	str	r0, [r7, #4]
  printPgmString(PSTR("[VER:" GRBL_VERSION "." GRBL_VERSION_BUILD ":"));
 8008a78:	4b11      	ldr	r3, [pc, #68]	; (8008ac0 <report_build_info+0x50>)
 8008a7a:	0018      	movs	r0, r3
 8008a7c:	f7fe fc0e 	bl	800729c <printString>
  printString(line);
 8008a80:	687b      	ldr	r3, [r7, #4]
 8008a82:	0018      	movs	r0, r3
 8008a84:	f7fe fc0a 	bl	800729c <printString>
  report_util_feedback_line_feed();
 8008a88:	f7ff fbd6 	bl	8008238 <report_util_feedback_line_feed>
  printPgmString(PSTR("[OPT:")); // Generate compile-time build option list
 8008a8c:	4b0d      	ldr	r3, [pc, #52]	; (8008ac4 <report_build_info+0x54>)
 8008a8e:	0018      	movs	r0, r3
 8008a90:	f7fe fc04 	bl	800729c <printString>
  #ifdef VARIABLE_SPINDLE
    serial_write('V');
 8008a94:	2056      	movs	r0, #86	; 0x56
 8008a96:	f000 fab3 	bl	8009000 <serial_write>
	#ifndef HOMING_INIT_LOCK
		serial_write('L');
	#endif

  // NOTE: Compiled values, like override increments/max/min values, may be added at some point later.
	serial_write(',');
 8008a9a:	202c      	movs	r0, #44	; 0x2c
 8008a9c:	f000 fab0 	bl	8009000 <serial_write>
	print_uint8_base10(BLOCK_BUFFER_SIZE - 1);
 8008aa0:	200f      	movs	r0, #15
 8008aa2:	f7fe fc0f 	bl	80072c4 <print_uint8_base10>
	serial_write(',');
 8008aa6:	202c      	movs	r0, #44	; 0x2c
 8008aa8:	f000 faaa 	bl	8009000 <serial_write>
	print_uint8_base10(RX_BUFFER_SIZE);
 8008aac:	2080      	movs	r0, #128	; 0x80
 8008aae:	f7fe fc09 	bl	80072c4 <print_uint8_base10>

	report_util_feedback_line_feed();
 8008ab2:	f7ff fbc1 	bl	8008238 <report_util_feedback_line_feed>
}
 8008ab6:	46c0      	nop			; (mov r8, r8)
 8008ab8:	46bd      	mov	sp, r7
 8008aba:	b002      	add	sp, #8
 8008abc:	bd80      	pop	{r7, pc}
 8008abe:	46c0      	nop			; (mov r8, r8)
 8008ac0:	0800d56c 	.word	0x0800d56c
 8008ac4:	0800d580 	.word	0x0800d580

08008ac8 <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly,
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
 8008ac8:	b590      	push	{r4, r7, lr}
 8008aca:	b08d      	sub	sp, #52	; 0x34
 8008acc:	af00      	add	r7, sp, #0
  uint8_t idx;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position, sys_position, sizeof(sys_position));
 8008ace:	231c      	movs	r3, #28
 8008ad0:	18fb      	adds	r3, r7, r3
 8008ad2:	4a82      	ldr	r2, [pc, #520]	; (8008cdc <report_realtime_status+0x214>)
 8008ad4:	ca13      	ldmia	r2!, {r0, r1, r4}
 8008ad6:	c313      	stmia	r3!, {r0, r1, r4}
  float print_position[N_AXIS];
  system_convert_array_steps_to_mpos(print_position, current_position);
 8008ad8:	231c      	movs	r3, #28
 8008ada:	18fa      	adds	r2, r7, r3
 8008adc:	2310      	movs	r3, #16
 8008ade:	18fb      	adds	r3, r7, r3
 8008ae0:	0011      	movs	r1, r2
 8008ae2:	0018      	movs	r0, r3
 8008ae4:	f002 ff1c 	bl	800b920 <system_convert_array_steps_to_mpos>

  // Report current machine state and sub-states
  serial_write('<');
 8008ae8:	203c      	movs	r0, #60	; 0x3c
 8008aea:	f000 fa89 	bl	8009000 <serial_write>
  switch (sys.state) {
 8008aee:	4b7c      	ldr	r3, [pc, #496]	; (8008ce0 <report_realtime_status+0x218>)
 8008af0:	781b      	ldrb	r3, [r3, #0]
 8008af2:	2b08      	cmp	r3, #8
 8008af4:	d01b      	beq.n	8008b2e <report_realtime_status+0x66>
 8008af6:	dc0a      	bgt.n	8008b0e <report_realtime_status+0x46>
 8008af8:	2b01      	cmp	r3, #1
 8008afa:	d03e      	beq.n	8008b7a <report_realtime_status+0xb2>
 8008afc:	dc02      	bgt.n	8008b04 <report_realtime_status+0x3c>
 8008afe:	2b00      	cmp	r3, #0
 8008b00:	d010      	beq.n	8008b24 <report_realtime_status+0x5c>
 8008b02:	e06f      	b.n	8008be4 <report_realtime_status+0x11c>
 8008b04:	2b02      	cmp	r3, #2
 8008b06:	d03d      	beq.n	8008b84 <report_realtime_status+0xbc>
 8008b08:	2b04      	cmp	r3, #4
 8008b0a:	d031      	beq.n	8008b70 <report_realtime_status+0xa8>
 8008b0c:	e06a      	b.n	8008be4 <report_realtime_status+0x11c>
 8008b0e:	2b20      	cmp	r3, #32
 8008b10:	d029      	beq.n	8008b66 <report_realtime_status+0x9e>
 8008b12:	dc02      	bgt.n	8008b1a <report_realtime_status+0x52>
 8008b14:	2b10      	cmp	r3, #16
 8008b16:	d00f      	beq.n	8008b38 <report_realtime_status+0x70>
 8008b18:	e064      	b.n	8008be4 <report_realtime_status+0x11c>
 8008b1a:	2b40      	cmp	r3, #64	; 0x40
 8008b1c:	d037      	beq.n	8008b8e <report_realtime_status+0xc6>
 8008b1e:	2b80      	cmp	r3, #128	; 0x80
 8008b20:	d05b      	beq.n	8008bda <report_realtime_status+0x112>
 8008b22:	e05f      	b.n	8008be4 <report_realtime_status+0x11c>
  case STATE_IDLE: printPgmString(PSTR("Idle")); break;
 8008b24:	4b6f      	ldr	r3, [pc, #444]	; (8008ce4 <report_realtime_status+0x21c>)
 8008b26:	0018      	movs	r0, r3
 8008b28:	f7fe fbb8 	bl	800729c <printString>
 8008b2c:	e05a      	b.n	8008be4 <report_realtime_status+0x11c>
  case STATE_CYCLE: printPgmString(PSTR("Run")); break;
 8008b2e:	4b6e      	ldr	r3, [pc, #440]	; (8008ce8 <report_realtime_status+0x220>)
 8008b30:	0018      	movs	r0, r3
 8008b32:	f7fe fbb3 	bl	800729c <printString>
 8008b36:	e055      	b.n	8008be4 <report_realtime_status+0x11c>
  case STATE_HOLD:
    if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
 8008b38:	4b69      	ldr	r3, [pc, #420]	; (8008ce0 <report_realtime_status+0x218>)
 8008b3a:	789b      	ldrb	r3, [r3, #2]
 8008b3c:	b25b      	sxtb	r3, r3
 8008b3e:	2b00      	cmp	r3, #0
 8008b40:	db11      	blt.n	8008b66 <report_realtime_status+0x9e>
      printPgmString(PSTR("Hold:"));
 8008b42:	4b6a      	ldr	r3, [pc, #424]	; (8008cec <report_realtime_status+0x224>)
 8008b44:	0018      	movs	r0, r3
 8008b46:	f7fe fba9 	bl	800729c <printString>
      if (sys.suspend & SUSPEND_HOLD_COMPLETE) { serial_write('0'); } // Ready to resume
 8008b4a:	4b65      	ldr	r3, [pc, #404]	; (8008ce0 <report_realtime_status+0x218>)
 8008b4c:	789b      	ldrb	r3, [r3, #2]
 8008b4e:	001a      	movs	r2, r3
 8008b50:	2301      	movs	r3, #1
 8008b52:	4013      	ands	r3, r2
 8008b54:	d003      	beq.n	8008b5e <report_realtime_status+0x96>
 8008b56:	2030      	movs	r0, #48	; 0x30
 8008b58:	f000 fa52 	bl	8009000 <serial_write>
      else { serial_write('1'); } // Actively holding
      break;
 8008b5c:	e042      	b.n	8008be4 <report_realtime_status+0x11c>
  case STATE_CYCLE: printPgmString(PSTR("Run")); break;
  case STATE_HOLD:
    if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
      printPgmString(PSTR("Hold:"));
      if (sys.suspend & SUSPEND_HOLD_COMPLETE) { serial_write('0'); } // Ready to resume
      else { serial_write('1'); } // Actively holding
 8008b5e:	2031      	movs	r0, #49	; 0x31
 8008b60:	f000 fa4e 	bl	8009000 <serial_write>
      break;
 8008b64:	e03e      	b.n	8008be4 <report_realtime_status+0x11c>
    } // Continues to print jog state during jog cancel.
  case STATE_JOG: printPgmString(PSTR("Jog")); break;
 8008b66:	4b62      	ldr	r3, [pc, #392]	; (8008cf0 <report_realtime_status+0x228>)
 8008b68:	0018      	movs	r0, r3
 8008b6a:	f7fe fb97 	bl	800729c <printString>
 8008b6e:	e039      	b.n	8008be4 <report_realtime_status+0x11c>
  case STATE_HOMING: printPgmString(PSTR("Home")); break;
 8008b70:	4b60      	ldr	r3, [pc, #384]	; (8008cf4 <report_realtime_status+0x22c>)
 8008b72:	0018      	movs	r0, r3
 8008b74:	f7fe fb92 	bl	800729c <printString>
 8008b78:	e034      	b.n	8008be4 <report_realtime_status+0x11c>
  case STATE_ALARM: printPgmString(PSTR("Alarm")); break;
 8008b7a:	4b5f      	ldr	r3, [pc, #380]	; (8008cf8 <report_realtime_status+0x230>)
 8008b7c:	0018      	movs	r0, r3
 8008b7e:	f7fe fb8d 	bl	800729c <printString>
 8008b82:	e02f      	b.n	8008be4 <report_realtime_status+0x11c>
  case STATE_CHECK_MODE: printPgmString(PSTR("Check")); break;
 8008b84:	4b5d      	ldr	r3, [pc, #372]	; (8008cfc <report_realtime_status+0x234>)
 8008b86:	0018      	movs	r0, r3
 8008b88:	f7fe fb88 	bl	800729c <printString>
 8008b8c:	e02a      	b.n	8008be4 <report_realtime_status+0x11c>
  case STATE_SAFETY_DOOR:
    printPgmString(PSTR("Door:"));
 8008b8e:	4b5c      	ldr	r3, [pc, #368]	; (8008d00 <report_realtime_status+0x238>)
 8008b90:	0018      	movs	r0, r3
 8008b92:	f7fe fb83 	bl	800729c <printString>
    if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
 8008b96:	4b52      	ldr	r3, [pc, #328]	; (8008ce0 <report_realtime_status+0x218>)
 8008b98:	789b      	ldrb	r3, [r3, #2]
 8008b9a:	001a      	movs	r2, r3
 8008b9c:	2308      	movs	r3, #8
 8008b9e:	4013      	ands	r3, r2
 8008ba0:	d003      	beq.n	8008baa <report_realtime_status+0xe2>
      serial_write('3'); // Restoring
 8008ba2:	2033      	movs	r0, #51	; 0x33
 8008ba4:	f000 fa2c 	bl	8009000 <serial_write>
      }
      else {
        serial_write('2'); // Retracting
      }
    }
    break;
 8008ba8:	e01c      	b.n	8008be4 <report_realtime_status+0x11c>
    printPgmString(PSTR("Door:"));
    if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
      serial_write('3'); // Restoring
    }
    else {
      if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
 8008baa:	4b4d      	ldr	r3, [pc, #308]	; (8008ce0 <report_realtime_status+0x218>)
 8008bac:	789b      	ldrb	r3, [r3, #2]
 8008bae:	001a      	movs	r2, r3
 8008bb0:	2304      	movs	r3, #4
 8008bb2:	4013      	ands	r3, r2
 8008bb4:	d00d      	beq.n	8008bd2 <report_realtime_status+0x10a>
        if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) {
 8008bb6:	4b4a      	ldr	r3, [pc, #296]	; (8008ce0 <report_realtime_status+0x218>)
 8008bb8:	789b      	ldrb	r3, [r3, #2]
 8008bba:	001a      	movs	r2, r3
 8008bbc:	2320      	movs	r3, #32
 8008bbe:	4013      	ands	r3, r2
 8008bc0:	d003      	beq.n	8008bca <report_realtime_status+0x102>
          serial_write('1'); // Door ajar
 8008bc2:	2031      	movs	r0, #49	; 0x31
 8008bc4:	f000 fa1c 	bl	8009000 <serial_write>
      }
      else {
        serial_write('2'); // Retracting
      }
    }
    break;
 8008bc8:	e00c      	b.n	8008be4 <report_realtime_status+0x11c>
      if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
        if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) {
          serial_write('1'); // Door ajar
        }
        else {
          serial_write('0');
 8008bca:	2030      	movs	r0, #48	; 0x30
 8008bcc:	f000 fa18 	bl	8009000 <serial_write>
      }
      else {
        serial_write('2'); // Retracting
      }
    }
    break;
 8008bd0:	e008      	b.n	8008be4 <report_realtime_status+0x11c>
        else {
          serial_write('0');
        } // Door closed and ready to resume
      }
      else {
        serial_write('2'); // Retracting
 8008bd2:	2032      	movs	r0, #50	; 0x32
 8008bd4:	f000 fa14 	bl	8009000 <serial_write>
      }
    }
    break;
 8008bd8:	e004      	b.n	8008be4 <report_realtime_status+0x11c>
  case STATE_SLEEP: printPgmString(PSTR("Sleep")); break;
 8008bda:	4b4a      	ldr	r3, [pc, #296]	; (8008d04 <report_realtime_status+0x23c>)
 8008bdc:	0018      	movs	r0, r3
 8008bde:	f7fe fb5d 	bl	800729c <printString>
 8008be2:	46c0      	nop			; (mov r8, r8)
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE) ||
 8008be4:	4b48      	ldr	r3, [pc, #288]	; (8008d08 <report_realtime_status+0x240>)
 8008be6:	2234      	movs	r2, #52	; 0x34
 8008be8:	5c9b      	ldrb	r3, [r3, r2]
 8008bea:	001a      	movs	r2, r3
 8008bec:	2301      	movs	r3, #1
 8008bee:	4013      	ands	r3, r2
 8008bf0:	d003      	beq.n	8008bfa <report_realtime_status+0x132>
    (sys.report_wco_counter == 0)) {
 8008bf2:	4b3b      	ldr	r3, [pc, #236]	; (8008ce0 <report_realtime_status+0x218>)
 8008bf4:	7b1b      	ldrb	r3, [r3, #12]
    break;
  case STATE_SLEEP: printPgmString(PSTR("Sleep")); break;
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE) ||
 8008bf6:	2b00      	cmp	r3, #0
 8008bf8:	d164      	bne.n	8008cc4 <report_realtime_status+0x1fc>
    (sys.report_wco_counter == 0)) {
    for (idx = 0; idx< N_AXIS; idx++) {
 8008bfa:	232f      	movs	r3, #47	; 0x2f
 8008bfc:	18fb      	adds	r3, r7, r3
 8008bfe:	2200      	movs	r2, #0
 8008c00:	701a      	strb	r2, [r3, #0]
 8008c02:	e05a      	b.n	8008cba <report_realtime_status+0x1f2>
      // Apply work coordinate offsets and tool length offset to current position.
      wco[idx] = gc_state.coord_system[idx] + gc_state.coord_offset[idx];
 8008c04:	232f      	movs	r3, #47	; 0x2f
 8008c06:	18fb      	adds	r3, r7, r3
 8008c08:	781c      	ldrb	r4, [r3, #0]
 8008c0a:	232f      	movs	r3, #47	; 0x2f
 8008c0c:	18fb      	adds	r3, r7, r3
 8008c0e:	781a      	ldrb	r2, [r3, #0]
 8008c10:	4b3e      	ldr	r3, [pc, #248]	; (8008d0c <report_realtime_status+0x244>)
 8008c12:	320a      	adds	r2, #10
 8008c14:	0092      	lsls	r2, r2, #2
 8008c16:	58d0      	ldr	r0, [r2, r3]
 8008c18:	232f      	movs	r3, #47	; 0x2f
 8008c1a:	18fb      	adds	r3, r7, r3
 8008c1c:	781b      	ldrb	r3, [r3, #0]
 8008c1e:	4a3b      	ldr	r2, [pc, #236]	; (8008d0c <report_realtime_status+0x244>)
 8008c20:	330c      	adds	r3, #12
 8008c22:	009b      	lsls	r3, r3, #2
 8008c24:	18d3      	adds	r3, r2, r3
 8008c26:	3304      	adds	r3, #4
 8008c28:	681b      	ldr	r3, [r3, #0]
 8008c2a:	1c19      	adds	r1, r3, #0
 8008c2c:	f7f7 fbb0 	bl	8000390 <__aeabi_fadd>
 8008c30:	1c03      	adds	r3, r0, #0
 8008c32:	1c19      	adds	r1, r3, #0
 8008c34:	1d3b      	adds	r3, r7, #4
 8008c36:	00a2      	lsls	r2, r4, #2
 8008c38:	50d1      	str	r1, [r2, r3]
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { wco[idx] += gc_state.tool_length_offset; }
 8008c3a:	232f      	movs	r3, #47	; 0x2f
 8008c3c:	18fb      	adds	r3, r7, r3
 8008c3e:	781b      	ldrb	r3, [r3, #0]
 8008c40:	2b02      	cmp	r3, #2
 8008c42:	d113      	bne.n	8008c6c <report_realtime_status+0x1a4>
 8008c44:	232f      	movs	r3, #47	; 0x2f
 8008c46:	18fb      	adds	r3, r7, r3
 8008c48:	781c      	ldrb	r4, [r3, #0]
 8008c4a:	232f      	movs	r3, #47	; 0x2f
 8008c4c:	18fb      	adds	r3, r7, r3
 8008c4e:	781a      	ldrb	r2, [r3, #0]
 8008c50:	1d3b      	adds	r3, r7, #4
 8008c52:	0092      	lsls	r2, r2, #2
 8008c54:	58d2      	ldr	r2, [r2, r3]
 8008c56:	4b2d      	ldr	r3, [pc, #180]	; (8008d0c <report_realtime_status+0x244>)
 8008c58:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008c5a:	1c19      	adds	r1, r3, #0
 8008c5c:	1c10      	adds	r0, r2, #0
 8008c5e:	f7f7 fb97 	bl	8000390 <__aeabi_fadd>
 8008c62:	1c03      	adds	r3, r0, #0
 8008c64:	1c19      	adds	r1, r3, #0
 8008c66:	1d3b      	adds	r3, r7, #4
 8008c68:	00a2      	lsls	r2, r4, #2
 8008c6a:	50d1      	str	r1, [r2, r3]
      if (bit_isfalse(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE)) {
 8008c6c:	4b26      	ldr	r3, [pc, #152]	; (8008d08 <report_realtime_status+0x240>)
 8008c6e:	2234      	movs	r2, #52	; 0x34
 8008c70:	5c9b      	ldrb	r3, [r3, r2]
 8008c72:	001a      	movs	r2, r3
 8008c74:	2301      	movs	r3, #1
 8008c76:	4013      	ands	r3, r2
 8008c78:	d118      	bne.n	8008cac <report_realtime_status+0x1e4>
        print_position[idx] -= wco[idx];
 8008c7a:	232f      	movs	r3, #47	; 0x2f
 8008c7c:	18fb      	adds	r3, r7, r3
 8008c7e:	781c      	ldrb	r4, [r3, #0]
 8008c80:	232f      	movs	r3, #47	; 0x2f
 8008c82:	18fb      	adds	r3, r7, r3
 8008c84:	781a      	ldrb	r2, [r3, #0]
 8008c86:	2310      	movs	r3, #16
 8008c88:	18fb      	adds	r3, r7, r3
 8008c8a:	0092      	lsls	r2, r2, #2
 8008c8c:	58d0      	ldr	r0, [r2, r3]
 8008c8e:	232f      	movs	r3, #47	; 0x2f
 8008c90:	18fb      	adds	r3, r7, r3
 8008c92:	781a      	ldrb	r2, [r3, #0]
 8008c94:	1d3b      	adds	r3, r7, #4
 8008c96:	0092      	lsls	r2, r2, #2
 8008c98:	58d3      	ldr	r3, [r2, r3]
 8008c9a:	1c19      	adds	r1, r3, #0
 8008c9c:	f7f7 ffcc 	bl	8000c38 <__aeabi_fsub>
 8008ca0:	1c03      	adds	r3, r0, #0
 8008ca2:	1c19      	adds	r1, r3, #0
 8008ca4:	2310      	movs	r3, #16
 8008ca6:	18fb      	adds	r3, r7, r3
 8008ca8:	00a2      	lsls	r2, r4, #2
 8008caa:	50d1      	str	r1, [r2, r3]
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE) ||
    (sys.report_wco_counter == 0)) {
    for (idx = 0; idx< N_AXIS; idx++) {
 8008cac:	232f      	movs	r3, #47	; 0x2f
 8008cae:	18fb      	adds	r3, r7, r3
 8008cb0:	781a      	ldrb	r2, [r3, #0]
 8008cb2:	232f      	movs	r3, #47	; 0x2f
 8008cb4:	18fb      	adds	r3, r7, r3
 8008cb6:	3201      	adds	r2, #1
 8008cb8:	701a      	strb	r2, [r3, #0]
 8008cba:	232f      	movs	r3, #47	; 0x2f
 8008cbc:	18fb      	adds	r3, r7, r3
 8008cbe:	781b      	ldrb	r3, [r3, #0]
 8008cc0:	2b02      	cmp	r3, #2
 8008cc2:	d99f      	bls.n	8008c04 <report_realtime_status+0x13c>
      }
    }
  }

  // Report machine position
  if (bit_istrue(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE)) {
 8008cc4:	4b10      	ldr	r3, [pc, #64]	; (8008d08 <report_realtime_status+0x240>)
 8008cc6:	2234      	movs	r2, #52	; 0x34
 8008cc8:	5c9b      	ldrb	r3, [r3, r2]
 8008cca:	001a      	movs	r2, r3
 8008ccc:	2301      	movs	r3, #1
 8008cce:	4013      	ands	r3, r2
 8008cd0:	d020      	beq.n	8008d14 <report_realtime_status+0x24c>
    printPgmString(PSTR("|MPos:"));
 8008cd2:	4b0f      	ldr	r3, [pc, #60]	; (8008d10 <report_realtime_status+0x248>)
 8008cd4:	0018      	movs	r0, r3
 8008cd6:	f7fe fae1 	bl	800729c <printString>
 8008cda:	e01f      	b.n	8008d1c <report_realtime_status+0x254>
 8008cdc:	20000b50 	.word	0x20000b50
 8008ce0:	20000b2c 	.word	0x20000b2c
 8008ce4:	0800d590 	.word	0x0800d590
 8008ce8:	0800d598 	.word	0x0800d598
 8008cec:	0800d59c 	.word	0x0800d59c
 8008cf0:	0800d5a4 	.word	0x0800d5a4
 8008cf4:	0800d5a8 	.word	0x0800d5a8
 8008cf8:	0800d5b0 	.word	0x0800d5b0
 8008cfc:	0800d5b8 	.word	0x0800d5b8
 8008d00:	0800d5c0 	.word	0x0800d5c0
 8008d04:	0800d5c8 	.word	0x0800d5c8
 8008d08:	20000acc 	.word	0x20000acc
 8008d0c:	2000095c 	.word	0x2000095c
 8008d10:	0800d5d0 	.word	0x0800d5d0
  }
  else {
    printPgmString(PSTR("|WPos:"));
 8008d14:	4b9b      	ldr	r3, [pc, #620]	; (8008f84 <report_realtime_status+0x4bc>)
 8008d16:	0018      	movs	r0, r3
 8008d18:	f7fe fac0 	bl	800729c <printString>
  }
  report_util_axis_values(print_position);
 8008d1c:	2310      	movs	r3, #16
 8008d1e:	18fb      	adds	r3, r7, r3
 8008d20:	0018      	movs	r0, r3
 8008d22:	f7ff faab 	bl	800827c <report_util_axis_values>

  // Returns planner and serial read buffer states.
#ifdef REPORT_FIELD_BUFFER_STATE
  if (bit_istrue(settings.status_report_mask, BITFLAG_RT_STATUS_BUFFER_STATE)) {
 8008d26:	4b98      	ldr	r3, [pc, #608]	; (8008f88 <report_realtime_status+0x4c0>)
 8008d28:	2234      	movs	r2, #52	; 0x34
 8008d2a:	5c9b      	ldrb	r3, [r3, r2]
 8008d2c:	001a      	movs	r2, r3
 8008d2e:	2302      	movs	r3, #2
 8008d30:	4013      	ands	r3, r2
 8008d32:	d012      	beq.n	8008d5a <report_realtime_status+0x292>
    printPgmString(PSTR("|Bf:"));
 8008d34:	4b95      	ldr	r3, [pc, #596]	; (8008f8c <report_realtime_status+0x4c4>)
 8008d36:	0018      	movs	r0, r3
 8008d38:	f7fe fab0 	bl	800729c <printString>
    print_uint8_base10(plan_get_block_buffer_available());
 8008d3c:	f7fe fa7c 	bl	8007238 <plan_get_block_buffer_available>
 8008d40:	0003      	movs	r3, r0
 8008d42:	0018      	movs	r0, r3
 8008d44:	f7fe fabe 	bl	80072c4 <print_uint8_base10>
    serial_write(',');
 8008d48:	202c      	movs	r0, #44	; 0x2c
 8008d4a:	f000 f959 	bl	8009000 <serial_write>
    print_uint8_base10(serial_get_rx_buffer_available());
 8008d4e:	f000 f92b 	bl	8008fa8 <serial_get_rx_buffer_available>
 8008d52:	0003      	movs	r3, r0
 8008d54:	0018      	movs	r0, r3
 8008d56:	f7fe fab5 	bl	80072c4 <print_uint8_base10>
#endif

  // Report realtime feed speed
#ifdef REPORT_FIELD_CURRENT_FEED_SPEED
#ifdef VARIABLE_SPINDLE
  printPgmString(PSTR("|FS:"));
 8008d5a:	4b8d      	ldr	r3, [pc, #564]	; (8008f90 <report_realtime_status+0x4c8>)
 8008d5c:	0018      	movs	r0, r3
 8008d5e:	f7fe fa9d 	bl	800729c <printString>
  printFloat_RateValue(st_get_realtime_rate());
 8008d62:	f002 f9dd 	bl	800b120 <st_get_realtime_rate>
 8008d66:	1c03      	adds	r3, r0, #0
 8008d68:	1c18      	adds	r0, r3, #0
 8008d6a:	f7fe fbe7 	bl	800753c <printFloat_RateValue>
  serial_write(',');
 8008d6e:	202c      	movs	r0, #44	; 0x2c
 8008d70:	f000 f946 	bl	8009000 <serial_write>
  printFloat(sys.spindle_speed, N_DECIMAL_RPMVALUE);
 8008d74:	4b87      	ldr	r3, [pc, #540]	; (8008f94 <report_realtime_status+0x4cc>)
 8008d76:	691b      	ldr	r3, [r3, #16]
 8008d78:	2100      	movs	r1, #0
 8008d7a:	1c18      	adds	r0, r3, #0
 8008d7c:	f7fe fb04 	bl	8007388 <printFloat>
  printFloat_RateValue(st_get_realtime_rate());
#endif      
#endif

#ifdef REPORT_FIELD_PIN_STATE
  uint8_t lim_pin_state = limits_get_state();
 8008d80:	232e      	movs	r3, #46	; 0x2e
 8008d82:	18fc      	adds	r4, r7, r3
 8008d84:	f7fc fc4e 	bl	8005624 <limits_get_state>
 8008d88:	0003      	movs	r3, r0
 8008d8a:	7023      	strb	r3, [r4, #0]
  uint8_t ctrl_pin_state = system_control_get_state();
 8008d8c:	232d      	movs	r3, #45	; 0x2d
 8008d8e:	18fc      	adds	r4, r7, r3
 8008d90:	f002 faaa 	bl	800b2e8 <system_control_get_state>
 8008d94:	0003      	movs	r3, r0
 8008d96:	7023      	strb	r3, [r4, #0]
  uint8_t prb_pin_state = probe_get_state();
 8008d98:	232c      	movs	r3, #44	; 0x2c
 8008d9a:	18fc      	adds	r4, r7, r3
 8008d9c:	f7fe fc38 	bl	8007610 <probe_get_state>
 8008da0:	0003      	movs	r3, r0
 8008da2:	7023      	strb	r3, [r4, #0]
  if (lim_pin_state | ctrl_pin_state | prb_pin_state) {
 8008da4:	232e      	movs	r3, #46	; 0x2e
 8008da6:	18fa      	adds	r2, r7, r3
 8008da8:	232d      	movs	r3, #45	; 0x2d
 8008daa:	18fb      	adds	r3, r7, r3
 8008dac:	7812      	ldrb	r2, [r2, #0]
 8008dae:	781b      	ldrb	r3, [r3, #0]
 8008db0:	4313      	orrs	r3, r2
 8008db2:	b2da      	uxtb	r2, r3
 8008db4:	232c      	movs	r3, #44	; 0x2c
 8008db6:	18fb      	adds	r3, r7, r3
 8008db8:	781b      	ldrb	r3, [r3, #0]
 8008dba:	4313      	orrs	r3, r2
 8008dbc:	b2db      	uxtb	r3, r3
 8008dbe:	2b00      	cmp	r3, #0
 8008dc0:	d04b      	beq.n	8008e5a <report_realtime_status+0x392>
    printPgmString(PSTR("|Pn:"));
 8008dc2:	4b75      	ldr	r3, [pc, #468]	; (8008f98 <report_realtime_status+0x4d0>)
 8008dc4:	0018      	movs	r0, r3
 8008dc6:	f7fe fa69 	bl	800729c <printString>
    if (prb_pin_state) { serial_write('P'); }
 8008dca:	232c      	movs	r3, #44	; 0x2c
 8008dcc:	18fb      	adds	r3, r7, r3
 8008dce:	781b      	ldrb	r3, [r3, #0]
 8008dd0:	2b00      	cmp	r3, #0
 8008dd2:	d002      	beq.n	8008dda <report_realtime_status+0x312>
 8008dd4:	2050      	movs	r0, #80	; 0x50
 8008dd6:	f000 f913 	bl	8009000 <serial_write>
    if (lim_pin_state) {
 8008dda:	232e      	movs	r3, #46	; 0x2e
 8008ddc:	18fb      	adds	r3, r7, r3
 8008dde:	781b      	ldrb	r3, [r3, #0]
 8008de0:	2b00      	cmp	r3, #0
 8008de2:	d01a      	beq.n	8008e1a <report_realtime_status+0x352>
      if (bit_istrue(lim_pin_state, bit(X_AXIS))) { serial_write('X'); }
 8008de4:	232e      	movs	r3, #46	; 0x2e
 8008de6:	18fb      	adds	r3, r7, r3
 8008de8:	781b      	ldrb	r3, [r3, #0]
 8008dea:	2201      	movs	r2, #1
 8008dec:	4013      	ands	r3, r2
 8008dee:	d002      	beq.n	8008df6 <report_realtime_status+0x32e>
 8008df0:	2058      	movs	r0, #88	; 0x58
 8008df2:	f000 f905 	bl	8009000 <serial_write>
      if (bit_istrue(lim_pin_state, bit(Y_AXIS))) { serial_write('Y'); }
 8008df6:	232e      	movs	r3, #46	; 0x2e
 8008df8:	18fb      	adds	r3, r7, r3
 8008dfa:	781b      	ldrb	r3, [r3, #0]
 8008dfc:	2202      	movs	r2, #2
 8008dfe:	4013      	ands	r3, r2
 8008e00:	d002      	beq.n	8008e08 <report_realtime_status+0x340>
 8008e02:	2059      	movs	r0, #89	; 0x59
 8008e04:	f000 f8fc 	bl	8009000 <serial_write>
      if (bit_istrue(lim_pin_state, bit(Z_AXIS))) { serial_write('Z'); }
 8008e08:	232e      	movs	r3, #46	; 0x2e
 8008e0a:	18fb      	adds	r3, r7, r3
 8008e0c:	781b      	ldrb	r3, [r3, #0]
 8008e0e:	2204      	movs	r2, #4
 8008e10:	4013      	ands	r3, r2
 8008e12:	d002      	beq.n	8008e1a <report_realtime_status+0x352>
 8008e14:	205a      	movs	r0, #90	; 0x5a
 8008e16:	f000 f8f3 	bl	8009000 <serial_write>
    }
    if (ctrl_pin_state) {
 8008e1a:	232d      	movs	r3, #45	; 0x2d
 8008e1c:	18fb      	adds	r3, r7, r3
 8008e1e:	781b      	ldrb	r3, [r3, #0]
 8008e20:	2b00      	cmp	r3, #0
 8008e22:	d01a      	beq.n	8008e5a <report_realtime_status+0x392>
#ifdef ENABLE_SAFETY_DOOR_INPUT_PIN
      if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_SAFETY_DOOR)) { serial_write('D'); }
#endif
      if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_RESET)) { serial_write('R'); }
 8008e24:	232d      	movs	r3, #45	; 0x2d
 8008e26:	18fb      	adds	r3, r7, r3
 8008e28:	781b      	ldrb	r3, [r3, #0]
 8008e2a:	2201      	movs	r2, #1
 8008e2c:	4013      	ands	r3, r2
 8008e2e:	d002      	beq.n	8008e36 <report_realtime_status+0x36e>
 8008e30:	2052      	movs	r0, #82	; 0x52
 8008e32:	f000 f8e5 	bl	8009000 <serial_write>
      if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_FEED_HOLD)) { serial_write('H'); }
 8008e36:	232d      	movs	r3, #45	; 0x2d
 8008e38:	18fb      	adds	r3, r7, r3
 8008e3a:	781b      	ldrb	r3, [r3, #0]
 8008e3c:	2202      	movs	r2, #2
 8008e3e:	4013      	ands	r3, r2
 8008e40:	d002      	beq.n	8008e48 <report_realtime_status+0x380>
 8008e42:	2048      	movs	r0, #72	; 0x48
 8008e44:	f000 f8dc 	bl	8009000 <serial_write>
      if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_CYCLE_START)) { serial_write('S'); }
 8008e48:	232d      	movs	r3, #45	; 0x2d
 8008e4a:	18fb      	adds	r3, r7, r3
 8008e4c:	781b      	ldrb	r3, [r3, #0]
 8008e4e:	2204      	movs	r2, #4
 8008e50:	4013      	ands	r3, r2
 8008e52:	d002      	beq.n	8008e5a <report_realtime_status+0x392>
 8008e54:	2053      	movs	r0, #83	; 0x53
 8008e56:	f000 f8d3 	bl	8009000 <serial_write>
    }
  }
#endif

#ifdef REPORT_FIELD_WORK_COORD_OFFSET
  if (sys.report_wco_counter > 0) { sys.report_wco_counter--; }
 8008e5a:	4b4e      	ldr	r3, [pc, #312]	; (8008f94 <report_realtime_status+0x4cc>)
 8008e5c:	7b1b      	ldrb	r3, [r3, #12]
 8008e5e:	2b00      	cmp	r3, #0
 8008e60:	d006      	beq.n	8008e70 <report_realtime_status+0x3a8>
 8008e62:	4b4c      	ldr	r3, [pc, #304]	; (8008f94 <report_realtime_status+0x4cc>)
 8008e64:	7b1b      	ldrb	r3, [r3, #12]
 8008e66:	3b01      	subs	r3, #1
 8008e68:	b2da      	uxtb	r2, r3
 8008e6a:	4b4a      	ldr	r3, [pc, #296]	; (8008f94 <report_realtime_status+0x4cc>)
 8008e6c:	731a      	strb	r2, [r3, #12]
 8008e6e:	e01b      	b.n	8008ea8 <report_realtime_status+0x3e0>
  else {
    if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
 8008e70:	4b48      	ldr	r3, [pc, #288]	; (8008f94 <report_realtime_status+0x4cc>)
 8008e72:	781b      	ldrb	r3, [r3, #0]
 8008e74:	001a      	movs	r2, r3
 8008e76:	237c      	movs	r3, #124	; 0x7c
 8008e78:	4013      	ands	r3, r2
 8008e7a:	d003      	beq.n	8008e84 <report_realtime_status+0x3bc>
      sys.report_wco_counter = (REPORT_WCO_REFRESH_BUSY_COUNT - 1); // Reset counter for slow refresh
 8008e7c:	4b45      	ldr	r3, [pc, #276]	; (8008f94 <report_realtime_status+0x4cc>)
 8008e7e:	221d      	movs	r2, #29
 8008e80:	731a      	strb	r2, [r3, #12]
 8008e82:	e002      	b.n	8008e8a <report_realtime_status+0x3c2>
    }
    else { sys.report_wco_counter = (REPORT_WCO_REFRESH_IDLE_COUNT - 1); }
 8008e84:	4b43      	ldr	r3, [pc, #268]	; (8008f94 <report_realtime_status+0x4cc>)
 8008e86:	2209      	movs	r2, #9
 8008e88:	731a      	strb	r2, [r3, #12]
    if (sys.report_ovr_counter == 0) { sys.report_ovr_counter = 1; } // Set override on next report.
 8008e8a:	4b42      	ldr	r3, [pc, #264]	; (8008f94 <report_realtime_status+0x4cc>)
 8008e8c:	7adb      	ldrb	r3, [r3, #11]
 8008e8e:	2b00      	cmp	r3, #0
 8008e90:	d102      	bne.n	8008e98 <report_realtime_status+0x3d0>
 8008e92:	4b40      	ldr	r3, [pc, #256]	; (8008f94 <report_realtime_status+0x4cc>)
 8008e94:	2201      	movs	r2, #1
 8008e96:	72da      	strb	r2, [r3, #11]
    printPgmString(PSTR("|WCO:"));
 8008e98:	4b40      	ldr	r3, [pc, #256]	; (8008f9c <report_realtime_status+0x4d4>)
 8008e9a:	0018      	movs	r0, r3
 8008e9c:	f7fe f9fe 	bl	800729c <printString>
    report_util_axis_values(wco);
 8008ea0:	1d3b      	adds	r3, r7, #4
 8008ea2:	0018      	movs	r0, r3
 8008ea4:	f7ff f9ea 	bl	800827c <report_util_axis_values>
  }
#endif

  #ifdef REPORT_FIELD_OVERRIDES
    if (sys.report_ovr_counter > 0) { sys.report_ovr_counter--; }
 8008ea8:	4b3a      	ldr	r3, [pc, #232]	; (8008f94 <report_realtime_status+0x4cc>)
 8008eaa:	7adb      	ldrb	r3, [r3, #11]
 8008eac:	2b00      	cmp	r3, #0
 8008eae:	d006      	beq.n	8008ebe <report_realtime_status+0x3f6>
 8008eb0:	4b38      	ldr	r3, [pc, #224]	; (8008f94 <report_realtime_status+0x4cc>)
 8008eb2:	7adb      	ldrb	r3, [r3, #11]
 8008eb4:	3b01      	subs	r3, #1
 8008eb6:	b2da      	uxtb	r2, r3
 8008eb8:	4b36      	ldr	r3, [pc, #216]	; (8008f94 <report_realtime_status+0x4cc>)
 8008eba:	72da      	strb	r2, [r3, #11]
 8008ebc:	e059      	b.n	8008f72 <report_realtime_status+0x4aa>
    else {
      if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
 8008ebe:	4b35      	ldr	r3, [pc, #212]	; (8008f94 <report_realtime_status+0x4cc>)
 8008ec0:	781b      	ldrb	r3, [r3, #0]
 8008ec2:	001a      	movs	r2, r3
 8008ec4:	237c      	movs	r3, #124	; 0x7c
 8008ec6:	4013      	ands	r3, r2
 8008ec8:	d003      	beq.n	8008ed2 <report_realtime_status+0x40a>
        sys.report_ovr_counter = (REPORT_OVR_REFRESH_BUSY_COUNT - 1); // Reset counter for slow refresh
 8008eca:	4b32      	ldr	r3, [pc, #200]	; (8008f94 <report_realtime_status+0x4cc>)
 8008ecc:	2213      	movs	r2, #19
 8008ece:	72da      	strb	r2, [r3, #11]
 8008ed0:	e002      	b.n	8008ed8 <report_realtime_status+0x410>
      }
      else { sys.report_ovr_counter = (REPORT_OVR_REFRESH_IDLE_COUNT - 1); }
 8008ed2:	4b30      	ldr	r3, [pc, #192]	; (8008f94 <report_realtime_status+0x4cc>)
 8008ed4:	2209      	movs	r2, #9
 8008ed6:	72da      	strb	r2, [r3, #11]
      printPgmString(PSTR("|Ov:"));
 8008ed8:	4b31      	ldr	r3, [pc, #196]	; (8008fa0 <report_realtime_status+0x4d8>)
 8008eda:	0018      	movs	r0, r3
 8008edc:	f7fe f9de 	bl	800729c <printString>
      print_uint8_base10(sys.f_override);
 8008ee0:	4b2c      	ldr	r3, [pc, #176]	; (8008f94 <report_realtime_status+0x4cc>)
 8008ee2:	79db      	ldrb	r3, [r3, #7]
 8008ee4:	0018      	movs	r0, r3
 8008ee6:	f7fe f9ed 	bl	80072c4 <print_uint8_base10>
      serial_write(',');
 8008eea:	202c      	movs	r0, #44	; 0x2c
 8008eec:	f000 f888 	bl	8009000 <serial_write>
      print_uint8_base10(sys.r_override);
 8008ef0:	4b28      	ldr	r3, [pc, #160]	; (8008f94 <report_realtime_status+0x4cc>)
 8008ef2:	7a1b      	ldrb	r3, [r3, #8]
 8008ef4:	0018      	movs	r0, r3
 8008ef6:	f7fe f9e5 	bl	80072c4 <print_uint8_base10>
      serial_write(',');
 8008efa:	202c      	movs	r0, #44	; 0x2c
 8008efc:	f000 f880 	bl	8009000 <serial_write>
      print_uint8_base10(sys.spindle_speed_ovr);
 8008f00:	4b24      	ldr	r3, [pc, #144]	; (8008f94 <report_realtime_status+0x4cc>)
 8008f02:	7a5b      	ldrb	r3, [r3, #9]
 8008f04:	0018      	movs	r0, r3
 8008f06:	f7fe f9dd 	bl	80072c4 <print_uint8_base10>

      uint8_t sp_state = spindle_get_state();
 8008f0a:	232b      	movs	r3, #43	; 0x2b
 8008f0c:	18fc      	adds	r4, r7, r3
 8008f0e:	f000 fe25 	bl	8009b5c <spindle_get_state>
 8008f12:	0003      	movs	r3, r0
 8008f14:	7023      	strb	r3, [r4, #0]
      uint8_t cl_state = coolant_get_state();
 8008f16:	232a      	movs	r3, #42	; 0x2a
 8008f18:	18fc      	adds	r4, r7, r3
 8008f1a:	f7fa fc73 	bl	8003804 <coolant_get_state>
 8008f1e:	0003      	movs	r3, r0
 8008f20:	7023      	strb	r3, [r4, #0]
      if (sp_state || cl_state) {
 8008f22:	232b      	movs	r3, #43	; 0x2b
 8008f24:	18fb      	adds	r3, r7, r3
 8008f26:	781b      	ldrb	r3, [r3, #0]
 8008f28:	2b00      	cmp	r3, #0
 8008f2a:	d104      	bne.n	8008f36 <report_realtime_status+0x46e>
 8008f2c:	232a      	movs	r3, #42	; 0x2a
 8008f2e:	18fb      	adds	r3, r7, r3
 8008f30:	781b      	ldrb	r3, [r3, #0]
 8008f32:	2b00      	cmp	r3, #0
 8008f34:	d01d      	beq.n	8008f72 <report_realtime_status+0x4aa>
        printPgmString(PSTR("|A:"));
 8008f36:	4b1b      	ldr	r3, [pc, #108]	; (8008fa4 <report_realtime_status+0x4dc>)
 8008f38:	0018      	movs	r0, r3
 8008f3a:	f7fe f9af 	bl	800729c <printString>
        if (sp_state) { // != SPINDLE_STATE_DISABLE
 8008f3e:	232b      	movs	r3, #43	; 0x2b
 8008f40:	18fb      	adds	r3, r7, r3
 8008f42:	781b      	ldrb	r3, [r3, #0]
 8008f44:	2b00      	cmp	r3, #0
 8008f46:	d00b      	beq.n	8008f60 <report_realtime_status+0x498>
          #ifdef VARIABLE_SPINDLE 
            #ifdef USE_SPINDLE_DIR_AS_ENABLE_PIN
              serial_write('S'); // CW
            #else
              if (sp_state == SPINDLE_STATE_CW) { serial_write('S'); } // CW
 8008f48:	232b      	movs	r3, #43	; 0x2b
 8008f4a:	18fb      	adds	r3, r7, r3
 8008f4c:	781b      	ldrb	r3, [r3, #0]
 8008f4e:	2b01      	cmp	r3, #1
 8008f50:	d103      	bne.n	8008f5a <report_realtime_status+0x492>
 8008f52:	2053      	movs	r0, #83	; 0x53
 8008f54:	f000 f854 	bl	8009000 <serial_write>
 8008f58:	e002      	b.n	8008f60 <report_realtime_status+0x498>
              else { serial_write('C'); } // CCW
 8008f5a:	2043      	movs	r0, #67	; 0x43
 8008f5c:	f000 f850 	bl	8009000 <serial_write>
          #else
            if (sp_state & SPINDLE_STATE_CW) { serial_write('S'); } // CW
            else { serial_write('C'); } // CCW
          #endif
        }
        if (cl_state & COOLANT_STATE_FLOOD) { serial_write('F'); }
 8008f60:	232a      	movs	r3, #42	; 0x2a
 8008f62:	18fb      	adds	r3, r7, r3
 8008f64:	781b      	ldrb	r3, [r3, #0]
 8008f66:	2201      	movs	r2, #1
 8008f68:	4013      	ands	r3, r2
 8008f6a:	d002      	beq.n	8008f72 <report_realtime_status+0x4aa>
 8008f6c:	2046      	movs	r0, #70	; 0x46
 8008f6e:	f000 f847 	bl	8009000 <serial_write>
        #endif
      }
    }
  #endif

  serial_write('>');
 8008f72:	203e      	movs	r0, #62	; 0x3e
 8008f74:	f000 f844 	bl	8009000 <serial_write>
  report_util_line_feed();
 8008f78:	f7ff f952 	bl	8008220 <report_util_line_feed>
}
 8008f7c:	46c0      	nop			; (mov r8, r8)
 8008f7e:	46bd      	mov	sp, r7
 8008f80:	b00d      	add	sp, #52	; 0x34
 8008f82:	bd90      	pop	{r4, r7, pc}
 8008f84:	0800d5d8 	.word	0x0800d5d8
 8008f88:	20000acc 	.word	0x20000acc
 8008f8c:	0800d5e0 	.word	0x0800d5e0
 8008f90:	0800d5e8 	.word	0x0800d5e8
 8008f94:	20000b2c 	.word	0x20000b2c
 8008f98:	0800d5f0 	.word	0x0800d5f0
 8008f9c:	0800d5f8 	.word	0x0800d5f8
 8008fa0:	0800d600 	.word	0x0800d600
 8008fa4:	0800d608 	.word	0x0800d608

08008fa8 <serial_get_rx_buffer_available>:
volatile uint8_t serial_tx_buffer_tail = 0;


// Returns the number of bytes available in the RX serial buffer.
uint8_t serial_get_rx_buffer_available()
{
 8008fa8:	b580      	push	{r7, lr}
 8008faa:	b082      	sub	sp, #8
 8008fac:	af00      	add	r7, sp, #0
  uint8_t rtail = serial_rx_buffer_tail; // Copy to limit multiple calls to volatile
 8008fae:	1dfb      	adds	r3, r7, #7
 8008fb0:	4a0e      	ldr	r2, [pc, #56]	; (8008fec <serial_get_rx_buffer_available+0x44>)
 8008fb2:	7812      	ldrb	r2, [r2, #0]
 8008fb4:	701a      	strb	r2, [r3, #0]
  if (serial_rx_buffer_head >= rtail) { return(RX_BUFFER_SIZE - (serial_rx_buffer_head-rtail)); }
 8008fb6:	4b0e      	ldr	r3, [pc, #56]	; (8008ff0 <serial_get_rx_buffer_available+0x48>)
 8008fb8:	781b      	ldrb	r3, [r3, #0]
 8008fba:	1dfa      	adds	r2, r7, #7
 8008fbc:	7812      	ldrb	r2, [r2, #0]
 8008fbe:	429a      	cmp	r2, r3
 8008fc0:	d808      	bhi.n	8008fd4 <serial_get_rx_buffer_available+0x2c>
 8008fc2:	4b0b      	ldr	r3, [pc, #44]	; (8008ff0 <serial_get_rx_buffer_available+0x48>)
 8008fc4:	781b      	ldrb	r3, [r3, #0]
 8008fc6:	1dfa      	adds	r2, r7, #7
 8008fc8:	7812      	ldrb	r2, [r2, #0]
 8008fca:	1ad3      	subs	r3, r2, r3
 8008fcc:	b2db      	uxtb	r3, r3
 8008fce:	3b80      	subs	r3, #128	; 0x80
 8008fd0:	b2db      	uxtb	r3, r3
 8008fd2:	e007      	b.n	8008fe4 <serial_get_rx_buffer_available+0x3c>
  return((rtail-serial_rx_buffer_head-1));
 8008fd4:	4b06      	ldr	r3, [pc, #24]	; (8008ff0 <serial_get_rx_buffer_available+0x48>)
 8008fd6:	781b      	ldrb	r3, [r3, #0]
 8008fd8:	1dfa      	adds	r2, r7, #7
 8008fda:	7812      	ldrb	r2, [r2, #0]
 8008fdc:	1ad3      	subs	r3, r2, r3
 8008fde:	b2db      	uxtb	r3, r3
 8008fe0:	3b01      	subs	r3, #1
 8008fe2:	b2db      	uxtb	r3, r3
}
 8008fe4:	0018      	movs	r0, r3
 8008fe6:	46bd      	mov	sp, r7
 8008fe8:	b002      	add	sp, #8
 8008fea:	bd80      	pop	{r7, pc}
 8008fec:	20000449 	.word	0x20000449
 8008ff0:	20000448 	.word	0x20000448

08008ff4 <serial_init>:
  return (TX_RING_BUFFER - (ttail-serial_tx_buffer_head));
}


void serial_init()
{
 8008ff4:	b580      	push	{r7, lr}
 8008ff6:	af00      	add	r7, sp, #0
  // defaults to 8-bit, no parity, 1 stop bit
#endif
#ifdef WIN32
  InitializeCriticalSectionAndSpinCount(&CriticalSection,0x00000400);
#endif
}
 8008ff8:	46c0      	nop			; (mov r8, r8)
 8008ffa:	46bd      	mov	sp, r7
 8008ffc:	bd80      	pop	{r7, pc}
 8008ffe:	46c0      	nop			; (mov r8, r8)

08009000 <serial_write>:
}
#endif


// Writes one byte to the TX serial buffer. Called by main program.
void serial_write(uint8_t data) {
 8009000:	b580      	push	{r7, lr}
 8009002:	b084      	sub	sp, #16
 8009004:	af00      	add	r7, sp, #0
 8009006:	0002      	movs	r2, r0
 8009008:	1dfb      	adds	r3, r7, #7
 800900a:	701a      	strb	r2, [r3, #0]
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
 800900c:	4b0b      	ldr	r3, [pc, #44]	; (800903c <serial_write+0x3c>)
 800900e:	781a      	ldrb	r2, [r3, #0]
 8009010:	230f      	movs	r3, #15
 8009012:	18fb      	adds	r3, r7, r3
 8009014:	3201      	adds	r2, #1
 8009016:	701a      	strb	r2, [r3, #0]
    return;
#endif
#endif
#ifdef STM32F0DISCOVERY
#ifndef USEUSB
	USART_SendData(USART1, data);
 8009018:	1dfb      	adds	r3, r7, #7
 800901a:	781b      	ldrb	r3, [r3, #0]
 800901c:	b29b      	uxth	r3, r3
 800901e:	4a08      	ldr	r2, [pc, #32]	; (8009040 <serial_write+0x40>)
 8009020:	0019      	movs	r1, r3
 8009022:	0010      	movs	r0, r2
 8009024:	f7fa fb90 	bl	8003748 <USART_SendData>
	while (!(USART1->ISR & USART_ISR_TXE));		 //
 8009028:	46c0      	nop			; (mov r8, r8)
 800902a:	4b05      	ldr	r3, [pc, #20]	; (8009040 <serial_write+0x40>)
 800902c:	69db      	ldr	r3, [r3, #28]
 800902e:	2280      	movs	r2, #128	; 0x80
 8009030:	4013      	ands	r3, r2
 8009032:	d0fa      	beq.n	800902a <serial_write+0x2a>
  return;
 8009034:	46c0      	nop			; (mov r8, r8)

#ifdef AVRTARGET
  // Enable Data Register Empty Interrupt to make sure tx-streaming is running
  UCSR0B |=  (1 << UDRIE0);
#endif
}
 8009036:	46bd      	mov	sp, r7
 8009038:	b004      	add	sp, #16
 800903a:	bd80      	pop	{r7, pc}
 800903c:	2000044a 	.word	0x2000044a
 8009040:	40013800 	.word	0x40013800

08009044 <serial_read>:
}
#endif

// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
 8009044:	b580      	push	{r7, lr}
 8009046:	b082      	sub	sp, #8
 8009048:	af00      	add	r7, sp, #0
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
 800904a:	1dfb      	adds	r3, r7, #7
 800904c:	4a13      	ldr	r2, [pc, #76]	; (800909c <serial_read+0x58>)
 800904e:	7812      	ldrb	r2, [r2, #0]
 8009050:	701a      	strb	r2, [r3, #0]
  if (serial_rx_buffer_head == tail) {
 8009052:	4b13      	ldr	r3, [pc, #76]	; (80090a0 <serial_read+0x5c>)
 8009054:	781b      	ldrb	r3, [r3, #0]
 8009056:	1dfa      	adds	r2, r7, #7
 8009058:	7812      	ldrb	r2, [r2, #0]
 800905a:	429a      	cmp	r2, r3
 800905c:	d101      	bne.n	8009062 <serial_read+0x1e>
    return SERIAL_NO_DATA;
 800905e:	23ff      	movs	r3, #255	; 0xff
 8009060:	e017      	b.n	8009092 <serial_read+0x4e>
  } else {
    uint8_t data = serial_rx_buffer[tail];
 8009062:	1dfb      	adds	r3, r7, #7
 8009064:	781a      	ldrb	r2, [r3, #0]
 8009066:	1dbb      	adds	r3, r7, #6
 8009068:	490e      	ldr	r1, [pc, #56]	; (80090a4 <serial_read+0x60>)
 800906a:	5c8a      	ldrb	r2, [r1, r2]
 800906c:	701a      	strb	r2, [r3, #0]

    tail++;
 800906e:	1dfb      	adds	r3, r7, #7
 8009070:	781a      	ldrb	r2, [r3, #0]
 8009072:	1dfb      	adds	r3, r7, #7
 8009074:	3201      	adds	r2, #1
 8009076:	701a      	strb	r2, [r3, #0]
    if (tail == RX_RING_BUFFER) { tail = 0; }
 8009078:	1dfb      	adds	r3, r7, #7
 800907a:	781b      	ldrb	r3, [r3, #0]
 800907c:	2b80      	cmp	r3, #128	; 0x80
 800907e:	d102      	bne.n	8009086 <serial_read+0x42>
 8009080:	1dfb      	adds	r3, r7, #7
 8009082:	2200      	movs	r2, #0
 8009084:	701a      	strb	r2, [r3, #0]
    serial_rx_buffer_tail = tail;
 8009086:	4b05      	ldr	r3, [pc, #20]	; (800909c <serial_read+0x58>)
 8009088:	1dfa      	adds	r2, r7, #7
 800908a:	7812      	ldrb	r2, [r2, #0]
 800908c:	701a      	strb	r2, [r3, #0]

    return data;
 800908e:	1dbb      	adds	r3, r7, #6
 8009090:	781b      	ldrb	r3, [r3, #0]
  }
}
 8009092:	0018      	movs	r0, r3
 8009094:	46bd      	mov	sp, r7
 8009096:	b002      	add	sp, #8
 8009098:	bd80      	pop	{r7, pc}
 800909a:	46c0      	nop			; (mov r8, r8)
 800909c:	20000449 	.word	0x20000449
 80090a0:	20000448 	.word	0x20000448
 80090a4:	20000a4c 	.word	0x20000a4c

080090a8 <USART1_IRQHandler>:
/*----------------------------------------------------------------------------
  USART1_IRQHandler
  Handles USART1 global interrupt request.
 *----------------------------------------------------------------------------*/
void USART1_IRQHandler (void)
{
 80090a8:	b580      	push	{r7, lr}
 80090aa:	b082      	sub	sp, #8
 80090ac:	af00      	add	r7, sp, #0
    volatile unsigned int IIR;
    uint8_t data;
    uint8_t next_head;

    IIR = USART1->ISR;
 80090ae:	4b57      	ldr	r3, [pc, #348]	; (800920c <USART1_IRQHandler+0x164>)
 80090b0:	69db      	ldr	r3, [r3, #28]
 80090b2:	603b      	str	r3, [r7, #0]
    if (IIR & USART_ISR_RXNE)
 80090b4:	683b      	ldr	r3, [r7, #0]
 80090b6:	2220      	movs	r2, #32
 80090b8:	4013      	ands	r3, r2
 80090ba:	d100      	bne.n	80090be <USART1_IRQHandler+0x16>
 80090bc:	e0a1      	b.n	8009202 <USART1_IRQHandler+0x15a>
    {                  // read interrupt
        data = USART1->RDR & 0x1FF;
 80090be:	4b53      	ldr	r3, [pc, #332]	; (800920c <USART1_IRQHandler+0x164>)
 80090c0:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 80090c2:	b29a      	uxth	r2, r3
 80090c4:	1dbb      	adds	r3, r7, #6
 80090c6:	701a      	strb	r2, [r3, #0]
#endif
#endif
  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the main buffer, but these set system state flag bits for realtime execution.
  switch (data) {
 80090c8:	1dbb      	adds	r3, r7, #6
 80090ca:	781b      	ldrb	r3, [r3, #0]
 80090cc:	2b21      	cmp	r3, #33	; 0x21
 80090ce:	d013      	beq.n	80090f8 <USART1_IRQHandler+0x50>
 80090d0:	dc02      	bgt.n	80090d8 <USART1_IRQHandler+0x30>
 80090d2:	2b18      	cmp	r3, #24
 80090d4:	d005      	beq.n	80090e2 <USART1_IRQHandler+0x3a>
 80090d6:	e013      	b.n	8009100 <USART1_IRQHandler+0x58>
 80090d8:	2b3f      	cmp	r3, #63	; 0x3f
 80090da:	d005      	beq.n	80090e8 <USART1_IRQHandler+0x40>
 80090dc:	2b7e      	cmp	r3, #126	; 0x7e
 80090de:	d007      	beq.n	80090f0 <USART1_IRQHandler+0x48>
 80090e0:	e00e      	b.n	8009100 <USART1_IRQHandler+0x58>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
 80090e2:	f7fd f90b 	bl	80062fc <mc_reset>
 80090e6:	e086      	b.n	80091f6 <USART1_IRQHandler+0x14e>
    case CMD_STATUS_REPORT: system_set_exec_state_flag(EXEC_STATUS_REPORT); break; // Set as true
 80090e8:	2001      	movs	r0, #1
 80090ea:	f002 fc83 	bl	800b9f4 <system_set_exec_state_flag>
 80090ee:	e082      	b.n	80091f6 <USART1_IRQHandler+0x14e>
    case CMD_CYCLE_START:   system_set_exec_state_flag(EXEC_CYCLE_START); break; // Set as true
 80090f0:	2002      	movs	r0, #2
 80090f2:	f002 fc7f 	bl	800b9f4 <system_set_exec_state_flag>
 80090f6:	e07e      	b.n	80091f6 <USART1_IRQHandler+0x14e>
    case CMD_FEED_HOLD:     system_set_exec_state_flag(EXEC_FEED_HOLD); break; // Set as true
 80090f8:	2008      	movs	r0, #8
 80090fa:	f002 fc7b 	bl	800b9f4 <system_set_exec_state_flag>
 80090fe:	e07a      	b.n	80091f6 <USART1_IRQHandler+0x14e>
    default :
      if (data > 0x7F) { // Real-time control characters are extended ACSII only.
 8009100:	1dbb      	adds	r3, r7, #6
 8009102:	781b      	ldrb	r3, [r3, #0]
 8009104:	b25b      	sxtb	r3, r3
 8009106:	2b00      	cmp	r3, #0
 8009108:	da55      	bge.n	80091b6 <USART1_IRQHandler+0x10e>
        switch(data) {
 800910a:	1dbb      	adds	r3, r7, #6
 800910c:	781b      	ldrb	r3, [r3, #0]
 800910e:	3b84      	subs	r3, #132	; 0x84
 8009110:	2b1c      	cmp	r3, #28
 8009112:	d900      	bls.n	8009116 <USART1_IRQHandler+0x6e>
 8009114:	e06f      	b.n	80091f6 <USART1_IRQHandler+0x14e>
 8009116:	009a      	lsls	r2, r3, #2
 8009118:	4b3d      	ldr	r3, [pc, #244]	; (8009210 <USART1_IRQHandler+0x168>)
 800911a:	18d3      	adds	r3, r2, r3
 800911c:	681b      	ldr	r3, [r3, #0]
 800911e:	469f      	mov	pc, r3
          case CMD_SAFETY_DOOR:   system_set_exec_state_flag(EXEC_SAFETY_DOOR); break; // Set as true
 8009120:	2020      	movs	r0, #32
 8009122:	f002 fc67 	bl	800b9f4 <system_set_exec_state_flag>
 8009126:	e066      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_JOG_CANCEL:   
            if (sys.state & STATE_JOG) { // Block all other states from invoking motion cancel.
 8009128:	4b3a      	ldr	r3, [pc, #232]	; (8009214 <USART1_IRQHandler+0x16c>)
 800912a:	781b      	ldrb	r3, [r3, #0]
 800912c:	001a      	movs	r2, r3
 800912e:	2320      	movs	r3, #32
 8009130:	4013      	ands	r3, r2
 8009132:	d05f      	beq.n	80091f4 <USART1_IRQHandler+0x14c>
              system_set_exec_state_flag(EXEC_MOTION_CANCEL); 
 8009134:	2040      	movs	r0, #64	; 0x40
 8009136:	f002 fc5d 	bl	800b9f4 <system_set_exec_state_flag>
            }
            break; 
 800913a:	e05b      	b.n	80091f4 <USART1_IRQHandler+0x14c>
          #ifdef DEBUG
            case CMD_DEBUG_REPORT: {uint8_t sreg = SREG; cli(); bit_true(sys_rt_exec_debug,EXEC_DEBUG_REPORT); SREG = sreg;} break;
          #endif
          case CMD_FEED_OVR_RESET: system_set_exec_motion_override_flag(EXEC_FEED_OVR_RESET); break;
 800913c:	2001      	movs	r0, #1
 800913e:	f002 fcb1 	bl	800baa4 <system_set_exec_motion_override_flag>
 8009142:	e058      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_FEED_OVR_COARSE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_PLUS); break;
 8009144:	2002      	movs	r0, #2
 8009146:	f002 fcad 	bl	800baa4 <system_set_exec_motion_override_flag>
 800914a:	e054      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_FEED_OVR_COARSE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_MINUS); break;
 800914c:	2004      	movs	r0, #4
 800914e:	f002 fca9 	bl	800baa4 <system_set_exec_motion_override_flag>
 8009152:	e050      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_FEED_OVR_FINE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_PLUS); break;
 8009154:	2008      	movs	r0, #8
 8009156:	f002 fca5 	bl	800baa4 <system_set_exec_motion_override_flag>
 800915a:	e04c      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_FEED_OVR_FINE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_MINUS); break;
 800915c:	2010      	movs	r0, #16
 800915e:	f002 fca1 	bl	800baa4 <system_set_exec_motion_override_flag>
 8009162:	e048      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_RAPID_OVR_RESET: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_RESET); break;
 8009164:	2020      	movs	r0, #32
 8009166:	f002 fc9d 	bl	800baa4 <system_set_exec_motion_override_flag>
 800916a:	e044      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_RAPID_OVR_MEDIUM: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_MEDIUM); break;
 800916c:	2040      	movs	r0, #64	; 0x40
 800916e:	f002 fc99 	bl	800baa4 <system_set_exec_motion_override_flag>
 8009172:	e040      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_RAPID_OVR_LOW: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_LOW); break;
 8009174:	2080      	movs	r0, #128	; 0x80
 8009176:	f002 fc95 	bl	800baa4 <system_set_exec_motion_override_flag>
 800917a:	e03c      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_SPINDLE_OVR_RESET: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_RESET); break;
 800917c:	2001      	movs	r0, #1
 800917e:	f002 fca9 	bl	800bad4 <system_set_exec_accessory_override_flag>
 8009182:	e038      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_SPINDLE_OVR_COARSE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_PLUS); break;
 8009184:	2002      	movs	r0, #2
 8009186:	f002 fca5 	bl	800bad4 <system_set_exec_accessory_override_flag>
 800918a:	e034      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_SPINDLE_OVR_COARSE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_MINUS); break;
 800918c:	2004      	movs	r0, #4
 800918e:	f002 fca1 	bl	800bad4 <system_set_exec_accessory_override_flag>
 8009192:	e030      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_SPINDLE_OVR_FINE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_PLUS); break;
 8009194:	2008      	movs	r0, #8
 8009196:	f002 fc9d 	bl	800bad4 <system_set_exec_accessory_override_flag>
 800919a:	e02c      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_SPINDLE_OVR_FINE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_MINUS); break;
 800919c:	2010      	movs	r0, #16
 800919e:	f002 fc99 	bl	800bad4 <system_set_exec_accessory_override_flag>
 80091a2:	e028      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_SPINDLE_OVR_STOP: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP); break;
 80091a4:	2020      	movs	r0, #32
 80091a6:	f002 fc95 	bl	800bad4 <system_set_exec_accessory_override_flag>
 80091aa:	e024      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_COOLANT_FLOOD_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_FLOOD_OVR_TOGGLE); break;
 80091ac:	2040      	movs	r0, #64	; 0x40
 80091ae:	f002 fc91 	bl	800bad4 <system_set_exec_accessory_override_flag>
 80091b2:	46c0      	nop			; (mov r8, r8)
 80091b4:	e01f      	b.n	80091f6 <USART1_IRQHandler+0x14e>
            case CMD_COOLANT_MIST_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_MIST_OVR_TOGGLE); break;
          #endif
        }
        // Throw away any unfound extended-ASCII character by not passing it to the serial buffer.
      } else { // Write character to buffer
        next_head = serial_rx_buffer_head + 1;
 80091b6:	4b18      	ldr	r3, [pc, #96]	; (8009218 <USART1_IRQHandler+0x170>)
 80091b8:	781a      	ldrb	r2, [r3, #0]
 80091ba:	1dfb      	adds	r3, r7, #7
 80091bc:	3201      	adds	r2, #1
 80091be:	701a      	strb	r2, [r3, #0]
        if (next_head == RX_RING_BUFFER) { next_head = 0; }
 80091c0:	1dfb      	adds	r3, r7, #7
 80091c2:	781b      	ldrb	r3, [r3, #0]
 80091c4:	2b80      	cmp	r3, #128	; 0x80
 80091c6:	d102      	bne.n	80091ce <USART1_IRQHandler+0x126>
 80091c8:	1dfb      	adds	r3, r7, #7
 80091ca:	2200      	movs	r2, #0
 80091cc:	701a      	strb	r2, [r3, #0]

        // Write data to buffer unless it is full.
        if (next_head != serial_rx_buffer_tail) {
 80091ce:	4b13      	ldr	r3, [pc, #76]	; (800921c <USART1_IRQHandler+0x174>)
 80091d0:	781b      	ldrb	r3, [r3, #0]
 80091d2:	b2db      	uxtb	r3, r3
 80091d4:	1dfa      	adds	r2, r7, #7
 80091d6:	7812      	ldrb	r2, [r2, #0]
 80091d8:	429a      	cmp	r2, r3
 80091da:	d00c      	beq.n	80091f6 <USART1_IRQHandler+0x14e>
          serial_rx_buffer[serial_rx_buffer_head] = data;
 80091dc:	4b0e      	ldr	r3, [pc, #56]	; (8009218 <USART1_IRQHandler+0x170>)
 80091de:	781b      	ldrb	r3, [r3, #0]
 80091e0:	0019      	movs	r1, r3
 80091e2:	4b0f      	ldr	r3, [pc, #60]	; (8009220 <USART1_IRQHandler+0x178>)
 80091e4:	1dba      	adds	r2, r7, #6
 80091e6:	7812      	ldrb	r2, [r2, #0]
 80091e8:	545a      	strb	r2, [r3, r1]
          serial_rx_buffer_head = next_head;
 80091ea:	4b0b      	ldr	r3, [pc, #44]	; (8009218 <USART1_IRQHandler+0x170>)
 80091ec:	1dfa      	adds	r2, r7, #7
 80091ee:	7812      	ldrb	r2, [r2, #0]
 80091f0:	701a      	strb	r2, [r3, #0]
 80091f2:	e000      	b.n	80091f6 <USART1_IRQHandler+0x14e>
          case CMD_SAFETY_DOOR:   system_set_exec_state_flag(EXEC_SAFETY_DOOR); break; // Set as true
          case CMD_JOG_CANCEL:   
            if (sys.state & STATE_JOG) { // Block all other states from invoking motion cancel.
              system_set_exec_state_flag(EXEC_MOTION_CANCEL); 
            }
            break; 
 80091f4:	46c0      	nop			; (mov r8, r8)
#endif
   }
#endif
#ifdef STM32F0DISCOVERY
#ifndef USEUSB
        USART1->ISR &= ~USART_ISR_RXNE;	          // clear interrupt
 80091f6:	4b05      	ldr	r3, [pc, #20]	; (800920c <USART1_IRQHandler+0x164>)
 80091f8:	4a04      	ldr	r2, [pc, #16]	; (800920c <USART1_IRQHandler+0x164>)
 80091fa:	69d2      	ldr	r2, [r2, #28]
 80091fc:	2120      	movs	r1, #32
 80091fe:	438a      	bics	r2, r1
 8009200:	61da      	str	r2, [r3, #28]
#else
    length--;
#endif
   }
#endif
}
 8009202:	46c0      	nop			; (mov r8, r8)
 8009204:	46bd      	mov	sp, r7
 8009206:	b002      	add	sp, #8
 8009208:	bd80      	pop	{r7, pc}
 800920a:	46c0      	nop			; (mov r8, r8)
 800920c:	40013800 	.word	0x40013800
 8009210:	0800d988 	.word	0x0800d988
 8009214:	20000b2c 	.word	0x20000b2c
 8009218:	20000448 	.word	0x20000448
 800921c:	20000449 	.word	0x20000449
 8009220:	20000a4c 	.word	0x20000a4c

08009224 <serial_reset_read_buffer>:

void serial_reset_read_buffer()
{
 8009224:	b580      	push	{r7, lr}
 8009226:	af00      	add	r7, sp, #0
  serial_rx_buffer_tail = serial_rx_buffer_head;
 8009228:	4b03      	ldr	r3, [pc, #12]	; (8009238 <serial_reset_read_buffer+0x14>)
 800922a:	781a      	ldrb	r2, [r3, #0]
 800922c:	4b03      	ldr	r3, [pc, #12]	; (800923c <serial_reset_read_buffer+0x18>)
 800922e:	701a      	strb	r2, [r3, #0]
}
 8009230:	46c0      	nop			; (mov r8, r8)
 8009232:	46bd      	mov	sp, r7
 8009234:	bd80      	pop	{r7, pc}
 8009236:	46c0      	nop			; (mov r8, r8)
 8009238:	20000448 	.word	0x20000448
 800923c:	20000449 	.word	0x20000449

08009240 <settings_store_startup_line>:
settings_t settings;


// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
 8009240:	b580      	push	{r7, lr}
 8009242:	b084      	sub	sp, #16
 8009244:	af00      	add	r7, sp, #0
 8009246:	0002      	movs	r2, r0
 8009248:	6039      	str	r1, [r7, #0]
 800924a:	1dfb      	adds	r3, r7, #7
 800924c:	701a      	strb	r2, [r3, #0]
  #ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize(); // A startup line may contain a motion and be executing. 
 800924e:	f7fe fb45 	bl	80078dc <protocol_buffer_synchronize>
  #endif
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
 8009252:	1dfb      	adds	r3, r7, #7
 8009254:	781a      	ldrb	r2, [r3, #0]
 8009256:	0013      	movs	r3, r2
 8009258:	00db      	lsls	r3, r3, #3
 800925a:	189b      	adds	r3, r3, r2
 800925c:	00da      	lsls	r2, r3, #3
 800925e:	189b      	adds	r3, r3, r2
 8009260:	22c0      	movs	r2, #192	; 0xc0
 8009262:	0092      	lsls	r2, r2, #2
 8009264:	4694      	mov	ip, r2
 8009266:	4463      	add	r3, ip
 8009268:	60fb      	str	r3, [r7, #12]
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
 800926a:	6839      	ldr	r1, [r7, #0]
 800926c:	68fb      	ldr	r3, [r7, #12]
 800926e:	2250      	movs	r2, #80	; 0x50
 8009270:	0018      	movs	r0, r3
 8009272:	f7fa fb2d 	bl	80038d0 <memcpy_to_eeprom_with_checksum>
}
 8009276:	46c0      	nop			; (mov r8, r8)
 8009278:	46bd      	mov	sp, r7
 800927a:	b004      	add	sp, #16
 800927c:	bd80      	pop	{r7, pc}
 800927e:	46c0      	nop			; (mov r8, r8)

08009280 <settings_store_build_info>:


// Method to store build info into EEPROM
// NOTE: This function can only be called in IDLE state.
void settings_store_build_info(char *line)
{
 8009280:	b580      	push	{r7, lr}
 8009282:	b082      	sub	sp, #8
 8009284:	af00      	add	r7, sp, #0
 8009286:	6078      	str	r0, [r7, #4]
  // Build info can only be stored when state is IDLE.
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
 8009288:	687b      	ldr	r3, [r7, #4]
 800928a:	4804      	ldr	r0, [pc, #16]	; (800929c <settings_store_build_info+0x1c>)
 800928c:	2250      	movs	r2, #80	; 0x50
 800928e:	0019      	movs	r1, r3
 8009290:	f7fa fb1e 	bl	80038d0 <memcpy_to_eeprom_with_checksum>
}
 8009294:	46c0      	nop			; (mov r8, r8)
 8009296:	46bd      	mov	sp, r7
 8009298:	b002      	add	sp, #8
 800929a:	bd80      	pop	{r7, pc}
 800929c:	000003ae 	.word	0x000003ae

080092a0 <settings_write_coord_data>:


// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{
 80092a0:	b580      	push	{r7, lr}
 80092a2:	b084      	sub	sp, #16
 80092a4:	af00      	add	r7, sp, #0
 80092a6:	0002      	movs	r2, r0
 80092a8:	6039      	str	r1, [r7, #0]
 80092aa:	1dfb      	adds	r3, r7, #7
 80092ac:	701a      	strb	r2, [r3, #0]
  #ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize();
 80092ae:	f7fe fb15 	bl	80078dc <protocol_buffer_synchronize>
  #endif
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
 80092b2:	1dfb      	adds	r3, r7, #7
 80092b4:	781a      	ldrb	r2, [r3, #0]
 80092b6:	0013      	movs	r3, r2
 80092b8:	005b      	lsls	r3, r3, #1
 80092ba:	189b      	adds	r3, r3, r2
 80092bc:	009b      	lsls	r3, r3, #2
 80092be:	189b      	adds	r3, r3, r2
 80092c0:	2280      	movs	r2, #128	; 0x80
 80092c2:	0092      	lsls	r2, r2, #2
 80092c4:	4694      	mov	ip, r2
 80092c6:	4463      	add	r3, ip
 80092c8:	60fb      	str	r3, [r7, #12]
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
 80092ca:	6839      	ldr	r1, [r7, #0]
 80092cc:	68fb      	ldr	r3, [r7, #12]
 80092ce:	220c      	movs	r2, #12
 80092d0:	0018      	movs	r0, r3
 80092d2:	f7fa fafd 	bl	80038d0 <memcpy_to_eeprom_with_checksum>
}
 80092d6:	46c0      	nop			; (mov r8, r8)
 80092d8:	46bd      	mov	sp, r7
 80092da:	b004      	add	sp, #16
 80092dc:	bd80      	pop	{r7, pc}
 80092de:	46c0      	nop			; (mov r8, r8)

080092e0 <write_global_settings>:


// Method to store Grbl global settings struct and version number into EEPROM
// NOTE: This function can only be called in IDLE state.
void write_global_settings()
{
 80092e0:	b580      	push	{r7, lr}
 80092e2:	af00      	add	r7, sp, #0
  eeprom_put_char(0, SETTINGS_VERSION);
 80092e4:	210a      	movs	r1, #10
 80092e6:	2000      	movs	r0, #0
 80092e8:	f7fa fade 	bl	80038a8 <eeprom_put_char>
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
 80092ec:	4b04      	ldr	r3, [pc, #16]	; (8009300 <write_global_settings+0x20>)
 80092ee:	225c      	movs	r2, #92	; 0x5c
 80092f0:	0019      	movs	r1, r3
 80092f2:	2001      	movs	r0, #1
 80092f4:	f7fa faec 	bl	80038d0 <memcpy_to_eeprom_with_checksum>
}
 80092f8:	46c0      	nop			; (mov r8, r8)
 80092fa:	46bd      	mov	sp, r7
 80092fc:	bd80      	pop	{r7, pc}
 80092fe:	46c0      	nop			; (mov r8, r8)
 8009300:	20000acc 	.word	0x20000acc

08009304 <settings_restore>:


// Method to restore EEPROM-saved Grbl global settings back to defaults.
void settings_restore(uint8_t restore_flag) {
 8009304:	b580      	push	{r7, lr}
 8009306:	b086      	sub	sp, #24
 8009308:	af00      	add	r7, sp, #0
 800930a:	0002      	movs	r2, r0
 800930c:	1dfb      	adds	r3, r7, #7
 800930e:	701a      	strb	r2, [r3, #0]
  if (restore_flag & SETTINGS_RESTORE_DEFAULTS) {
 8009310:	1dfb      	adds	r3, r7, #7
 8009312:	781b      	ldrb	r3, [r3, #0]
 8009314:	2201      	movs	r2, #1
 8009316:	4013      	ands	r3, r2
 8009318:	d05b      	beq.n	80093d2 <settings_restore+0xce>
    settings.pulse_microseconds = DEFAULT_STEP_PULSE_MICROSECONDS;
 800931a:	4b57      	ldr	r3, [pc, #348]	; (8009478 <settings_restore+0x174>)
 800931c:	2230      	movs	r2, #48	; 0x30
 800931e:	210a      	movs	r1, #10
 8009320:	5499      	strb	r1, [r3, r2]
    settings.stepper_idle_lock_time = DEFAULT_STEPPER_IDLE_LOCK_TIME;
 8009322:	4b55      	ldr	r3, [pc, #340]	; (8009478 <settings_restore+0x174>)
 8009324:	2233      	movs	r2, #51	; 0x33
 8009326:	2100      	movs	r1, #0
 8009328:	5499      	strb	r1, [r3, r2]
    settings.step_invert_mask = DEFAULT_STEPPING_INVERT_MASK;
 800932a:	4b53      	ldr	r3, [pc, #332]	; (8009478 <settings_restore+0x174>)
 800932c:	2231      	movs	r2, #49	; 0x31
 800932e:	2107      	movs	r1, #7
 8009330:	5499      	strb	r1, [r3, r2]
    settings.dir_invert_mask = DEFAULT_DIRECTION_INVERT_MASK;
 8009332:	4b51      	ldr	r3, [pc, #324]	; (8009478 <settings_restore+0x174>)
 8009334:	2232      	movs	r2, #50	; 0x32
 8009336:	2107      	movs	r1, #7
 8009338:	5499      	strb	r1, [r3, r2]
    settings.status_report_mask = DEFAULT_STATUS_REPORT_MASK;
 800933a:	4b4f      	ldr	r3, [pc, #316]	; (8009478 <settings_restore+0x174>)
 800933c:	2234      	movs	r2, #52	; 0x34
 800933e:	2101      	movs	r1, #1
 8009340:	5499      	strb	r1, [r3, r2]
    settings.junction_deviation = DEFAULT_JUNCTION_DEVIATION;
 8009342:	4b4d      	ldr	r3, [pc, #308]	; (8009478 <settings_restore+0x174>)
 8009344:	4a4d      	ldr	r2, [pc, #308]	; (800947c <settings_restore+0x178>)
 8009346:	639a      	str	r2, [r3, #56]	; 0x38
    settings.arc_tolerance = DEFAULT_ARC_TOLERANCE;
 8009348:	4b4b      	ldr	r3, [pc, #300]	; (8009478 <settings_restore+0x174>)
 800934a:	4a4d      	ldr	r2, [pc, #308]	; (8009480 <settings_restore+0x17c>)
 800934c:	63da      	str	r2, [r3, #60]	; 0x3c

    settings.rpm_max = DEFAULT_SPINDLE_RPM_MAX;
 800934e:	4b4a      	ldr	r3, [pc, #296]	; (8009478 <settings_restore+0x174>)
 8009350:	4a4c      	ldr	r2, [pc, #304]	; (8009484 <settings_restore+0x180>)
 8009352:	641a      	str	r2, [r3, #64]	; 0x40
    settings.rpm_min = DEFAULT_SPINDLE_RPM_MIN;
 8009354:	4b48      	ldr	r3, [pc, #288]	; (8009478 <settings_restore+0x174>)
 8009356:	2200      	movs	r2, #0
 8009358:	645a      	str	r2, [r3, #68]	; 0x44

    settings.homing_dir_mask = DEFAULT_HOMING_DIR_MASK;
 800935a:	4b47      	ldr	r3, [pc, #284]	; (8009478 <settings_restore+0x174>)
 800935c:	2249      	movs	r2, #73	; 0x49
 800935e:	2100      	movs	r1, #0
 8009360:	5499      	strb	r1, [r3, r2]
    settings.homing_feed_rate = DEFAULT_HOMING_FEED_RATE;
 8009362:	4b45      	ldr	r3, [pc, #276]	; (8009478 <settings_restore+0x174>)
 8009364:	4a48      	ldr	r2, [pc, #288]	; (8009488 <settings_restore+0x184>)
 8009366:	64da      	str	r2, [r3, #76]	; 0x4c
    settings.homing_seek_rate = DEFAULT_HOMING_SEEK_RATE;
 8009368:	4b43      	ldr	r3, [pc, #268]	; (8009478 <settings_restore+0x174>)
 800936a:	4a48      	ldr	r2, [pc, #288]	; (800948c <settings_restore+0x188>)
 800936c:	651a      	str	r2, [r3, #80]	; 0x50
    settings.homing_debounce_delay = DEFAULT_HOMING_DEBOUNCE_DELAY;
 800936e:	4b42      	ldr	r3, [pc, #264]	; (8009478 <settings_restore+0x174>)
 8009370:	2254      	movs	r2, #84	; 0x54
 8009372:	21fa      	movs	r1, #250	; 0xfa
 8009374:	5299      	strh	r1, [r3, r2]
    settings.homing_pulloff = DEFAULT_HOMING_PULLOFF;
 8009376:	4b40      	ldr	r3, [pc, #256]	; (8009478 <settings_restore+0x174>)
 8009378:	22fe      	movs	r2, #254	; 0xfe
 800937a:	0592      	lsls	r2, r2, #22
 800937c:	659a      	str	r2, [r3, #88]	; 0x58

    settings.flags = 0;
 800937e:	4b3e      	ldr	r3, [pc, #248]	; (8009478 <settings_restore+0x174>)
 8009380:	2248      	movs	r2, #72	; 0x48
 8009382:	2100      	movs	r1, #0
 8009384:	5499      	strb	r1, [r3, r2]
    if (DEFAULT_HOMING_ENABLE) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    if (DEFAULT_SOFT_LIMIT_ENABLE) { settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; }
    if (DEFAULT_INVERT_LIMIT_PINS) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
    if (DEFAULT_INVERT_PROBE_PIN) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }

    settings.steps_per_mm[X_AXIS] = DEFAULT_X_STEPS_PER_MM;
 8009386:	4b3c      	ldr	r3, [pc, #240]	; (8009478 <settings_restore+0x174>)
 8009388:	4a41      	ldr	r2, [pc, #260]	; (8009490 <settings_restore+0x18c>)
 800938a:	601a      	str	r2, [r3, #0]
    settings.steps_per_mm[Y_AXIS] = DEFAULT_Y_STEPS_PER_MM;
 800938c:	4b3a      	ldr	r3, [pc, #232]	; (8009478 <settings_restore+0x174>)
 800938e:	4a40      	ldr	r2, [pc, #256]	; (8009490 <settings_restore+0x18c>)
 8009390:	605a      	str	r2, [r3, #4]
    settings.steps_per_mm[Z_AXIS] = DEFAULT_Z_STEPS_PER_MM;
 8009392:	4b39      	ldr	r3, [pc, #228]	; (8009478 <settings_restore+0x174>)
 8009394:	4a3e      	ldr	r2, [pc, #248]	; (8009490 <settings_restore+0x18c>)
 8009396:	609a      	str	r2, [r3, #8]
    settings.max_rate[X_AXIS] = DEFAULT_X_MAX_RATE;
 8009398:	4b37      	ldr	r3, [pc, #220]	; (8009478 <settings_restore+0x174>)
 800939a:	4a3e      	ldr	r2, [pc, #248]	; (8009494 <settings_restore+0x190>)
 800939c:	60da      	str	r2, [r3, #12]
    settings.max_rate[Y_AXIS] = DEFAULT_Y_MAX_RATE;
 800939e:	4b36      	ldr	r3, [pc, #216]	; (8009478 <settings_restore+0x174>)
 80093a0:	4a3c      	ldr	r2, [pc, #240]	; (8009494 <settings_restore+0x190>)
 80093a2:	611a      	str	r2, [r3, #16]
    settings.max_rate[Z_AXIS] = DEFAULT_Z_MAX_RATE;
 80093a4:	4b34      	ldr	r3, [pc, #208]	; (8009478 <settings_restore+0x174>)
 80093a6:	4a3b      	ldr	r2, [pc, #236]	; (8009494 <settings_restore+0x190>)
 80093a8:	615a      	str	r2, [r3, #20]
    settings.acceleration[X_AXIS] = DEFAULT_X_ACCELERATION;
 80093aa:	4b33      	ldr	r3, [pc, #204]	; (8009478 <settings_restore+0x174>)
 80093ac:	4a3a      	ldr	r2, [pc, #232]	; (8009498 <settings_restore+0x194>)
 80093ae:	619a      	str	r2, [r3, #24]
    settings.acceleration[Y_AXIS] = DEFAULT_Y_ACCELERATION;
 80093b0:	4b31      	ldr	r3, [pc, #196]	; (8009478 <settings_restore+0x174>)
 80093b2:	4a39      	ldr	r2, [pc, #228]	; (8009498 <settings_restore+0x194>)
 80093b4:	61da      	str	r2, [r3, #28]
    settings.acceleration[Z_AXIS] = DEFAULT_Z_ACCELERATION;
 80093b6:	4b30      	ldr	r3, [pc, #192]	; (8009478 <settings_restore+0x174>)
 80093b8:	4a37      	ldr	r2, [pc, #220]	; (8009498 <settings_restore+0x194>)
 80093ba:	621a      	str	r2, [r3, #32]
    settings.max_travel[X_AXIS] = (-DEFAULT_X_MAX_TRAVEL);
 80093bc:	4b2e      	ldr	r3, [pc, #184]	; (8009478 <settings_restore+0x174>)
 80093be:	4a37      	ldr	r2, [pc, #220]	; (800949c <settings_restore+0x198>)
 80093c0:	625a      	str	r2, [r3, #36]	; 0x24
    settings.max_travel[Y_AXIS] = (-DEFAULT_Y_MAX_TRAVEL);
 80093c2:	4b2d      	ldr	r3, [pc, #180]	; (8009478 <settings_restore+0x174>)
 80093c4:	4a36      	ldr	r2, [pc, #216]	; (80094a0 <settings_restore+0x19c>)
 80093c6:	629a      	str	r2, [r3, #40]	; 0x28
    settings.max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL);
 80093c8:	4b2b      	ldr	r3, [pc, #172]	; (8009478 <settings_restore+0x174>)
 80093ca:	4a36      	ldr	r2, [pc, #216]	; (80094a4 <settings_restore+0x1a0>)
 80093cc:	62da      	str	r2, [r3, #44]	; 0x2c

    write_global_settings();
 80093ce:	f7ff ff87 	bl	80092e0 <write_global_settings>
  }

  if (restore_flag & SETTINGS_RESTORE_PARAMETERS) {
 80093d2:	1dfb      	adds	r3, r7, #7
 80093d4:	781b      	ldrb	r3, [r3, #0]
 80093d6:	2202      	movs	r2, #2
 80093d8:	4013      	ands	r3, r2
 80093da:	d020      	beq.n	800941e <settings_restore+0x11a>
    uint8_t idx;
    float coord_data[N_AXIS];
    memset(&coord_data, 0, sizeof(coord_data));
 80093dc:	2308      	movs	r3, #8
 80093de:	18fb      	adds	r3, r7, r3
 80093e0:	220c      	movs	r2, #12
 80093e2:	2100      	movs	r1, #0
 80093e4:	0018      	movs	r0, r3
 80093e6:	f002 fe8b 	bl	800c100 <memset>
    for (idx=0; idx <= SETTING_INDEX_NCOORD; idx++) { settings_write_coord_data(idx, coord_data); }
 80093ea:	2317      	movs	r3, #23
 80093ec:	18fb      	adds	r3, r7, r3
 80093ee:	2200      	movs	r2, #0
 80093f0:	701a      	strb	r2, [r3, #0]
 80093f2:	e00f      	b.n	8009414 <settings_restore+0x110>
 80093f4:	2308      	movs	r3, #8
 80093f6:	18fa      	adds	r2, r7, r3
 80093f8:	2317      	movs	r3, #23
 80093fa:	18fb      	adds	r3, r7, r3
 80093fc:	781b      	ldrb	r3, [r3, #0]
 80093fe:	0011      	movs	r1, r2
 8009400:	0018      	movs	r0, r3
 8009402:	f7ff ff4d 	bl	80092a0 <settings_write_coord_data>
 8009406:	2317      	movs	r3, #23
 8009408:	18fb      	adds	r3, r7, r3
 800940a:	781a      	ldrb	r2, [r3, #0]
 800940c:	2317      	movs	r3, #23
 800940e:	18fb      	adds	r3, r7, r3
 8009410:	3201      	adds	r2, #1
 8009412:	701a      	strb	r2, [r3, #0]
 8009414:	2317      	movs	r3, #23
 8009416:	18fb      	adds	r3, r7, r3
 8009418:	781b      	ldrb	r3, [r3, #0]
 800941a:	2b07      	cmp	r3, #7
 800941c:	d9ea      	bls.n	80093f4 <settings_restore+0xf0>
  }

  if (restore_flag & SETTINGS_RESTORE_STARTUP_LINES) {
 800941e:	1dfb      	adds	r3, r7, #7
 8009420:	781b      	ldrb	r3, [r3, #0]
 8009422:	2204      	movs	r2, #4
 8009424:	4013      	ands	r3, r2
 8009426:	d014      	beq.n	8009452 <settings_restore+0x14e>
    #if N_STARTUP_LINE > 0
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);
 8009428:	23c0      	movs	r3, #192	; 0xc0
 800942a:	009b      	lsls	r3, r3, #2
 800942c:	2100      	movs	r1, #0
 800942e:	0018      	movs	r0, r3
 8009430:	f7fa fa3a 	bl	80038a8 <eeprom_put_char>
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+1, 0); // Checksum
 8009434:	4b1c      	ldr	r3, [pc, #112]	; (80094a8 <settings_restore+0x1a4>)
 8009436:	2100      	movs	r1, #0
 8009438:	0018      	movs	r0, r3
 800943a:	f7fa fa35 	bl	80038a8 <eeprom_put_char>
    #endif
    #if N_STARTUP_LINE > 1
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);
 800943e:	4b1b      	ldr	r3, [pc, #108]	; (80094ac <settings_restore+0x1a8>)
 8009440:	2100      	movs	r1, #0
 8009442:	0018      	movs	r0, r3
 8009444:	f7fa fa30 	bl	80038a8 <eeprom_put_char>
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+2), 0); // Checksum
 8009448:	4b19      	ldr	r3, [pc, #100]	; (80094b0 <settings_restore+0x1ac>)
 800944a:	2100      	movs	r1, #0
 800944c:	0018      	movs	r0, r3
 800944e:	f7fa fa2b 	bl	80038a8 <eeprom_put_char>
    #endif
  }

  if (restore_flag & SETTINGS_RESTORE_BUILD_INFO) {
 8009452:	1dfb      	adds	r3, r7, #7
 8009454:	781b      	ldrb	r3, [r3, #0]
 8009456:	2208      	movs	r2, #8
 8009458:	4013      	ands	r3, r2
 800945a:	d009      	beq.n	8009470 <settings_restore+0x16c>
    eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0);
 800945c:	4b15      	ldr	r3, [pc, #84]	; (80094b4 <settings_restore+0x1b0>)
 800945e:	2100      	movs	r1, #0
 8009460:	0018      	movs	r0, r3
 8009462:	f7fa fa21 	bl	80038a8 <eeprom_put_char>
    eeprom_put_char(EEPROM_ADDR_BUILD_INFO+1 , 0); // Checksum
 8009466:	4b14      	ldr	r3, [pc, #80]	; (80094b8 <settings_restore+0x1b4>)
 8009468:	2100      	movs	r1, #0
 800946a:	0018      	movs	r0, r3
 800946c:	f7fa fa1c 	bl	80038a8 <eeprom_put_char>
  }
}
 8009470:	46c0      	nop			; (mov r8, r8)
 8009472:	46bd      	mov	sp, r7
 8009474:	b006      	add	sp, #24
 8009476:	bd80      	pop	{r7, pc}
 8009478:	20000acc 	.word	0x20000acc
 800947c:	3c23d70a 	.word	0x3c23d70a
 8009480:	3b03126f 	.word	0x3b03126f
 8009484:	447a0000 	.word	0x447a0000
 8009488:	41c80000 	.word	0x41c80000
 800948c:	43fa0000 	.word	0x43fa0000
 8009490:	43c80000 	.word	0x43c80000
 8009494:	44160000 	.word	0x44160000
 8009498:	481e3400 	.word	0x481e3400
 800949c:	c3480000 	.word	0xc3480000
 80094a0:	c3960000 	.word	0xc3960000
 80094a4:	c2480000 	.word	0xc2480000
 80094a8:	00000301 	.word	0x00000301
 80094ac:	00000351 	.word	0x00000351
 80094b0:	00000352 	.word	0x00000352
 80094b4:	000003ae 	.word	0x000003ae
 80094b8:	000003af 	.word	0x000003af

080094bc <settings_read_startup_line>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
 80094bc:	b580      	push	{r7, lr}
 80094be:	b084      	sub	sp, #16
 80094c0:	af00      	add	r7, sp, #0
 80094c2:	0002      	movs	r2, r0
 80094c4:	6039      	str	r1, [r7, #0]
 80094c6:	1dfb      	adds	r3, r7, #7
 80094c8:	701a      	strb	r2, [r3, #0]
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
 80094ca:	1dfb      	adds	r3, r7, #7
 80094cc:	781a      	ldrb	r2, [r3, #0]
 80094ce:	0013      	movs	r3, r2
 80094d0:	00db      	lsls	r3, r3, #3
 80094d2:	189b      	adds	r3, r3, r2
 80094d4:	00da      	lsls	r2, r3, #3
 80094d6:	189b      	adds	r3, r3, r2
 80094d8:	22c0      	movs	r2, #192	; 0xc0
 80094da:	0092      	lsls	r2, r2, #2
 80094dc:	4694      	mov	ip, r2
 80094de:	4463      	add	r3, ip
 80094e0:	60fb      	str	r3, [r7, #12]
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
 80094e2:	68f9      	ldr	r1, [r7, #12]
 80094e4:	683b      	ldr	r3, [r7, #0]
 80094e6:	2250      	movs	r2, #80	; 0x50
 80094e8:	0018      	movs	r0, r3
 80094ea:	f7fa fa33 	bl	8003954 <memcpy_from_eeprom_with_checksum>
 80094ee:	1e03      	subs	r3, r0, #0
 80094f0:	d10b      	bne.n	800950a <settings_read_startup_line+0x4e>
    // Reset line with default value
    line[0] = 0; // Empty line
 80094f2:	683b      	ldr	r3, [r7, #0]
 80094f4:	2200      	movs	r2, #0
 80094f6:	701a      	strb	r2, [r3, #0]
    settings_store_startup_line(n, line);
 80094f8:	683a      	ldr	r2, [r7, #0]
 80094fa:	1dfb      	adds	r3, r7, #7
 80094fc:	781b      	ldrb	r3, [r3, #0]
 80094fe:	0011      	movs	r1, r2
 8009500:	0018      	movs	r0, r3
 8009502:	f7ff fe9d 	bl	8009240 <settings_store_startup_line>
    return(false);
 8009506:	2300      	movs	r3, #0
 8009508:	e000      	b.n	800950c <settings_read_startup_line+0x50>
  }
  return(true);
 800950a:	2301      	movs	r3, #1
}
 800950c:	0018      	movs	r0, r3
 800950e:	46bd      	mov	sp, r7
 8009510:	b004      	add	sp, #16
 8009512:	bd80      	pop	{r7, pc}

08009514 <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
 8009514:	b580      	push	{r7, lr}
 8009516:	b082      	sub	sp, #8
 8009518:	af00      	add	r7, sp, #0
 800951a:	6078      	str	r0, [r7, #4]
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
 800951c:	490a      	ldr	r1, [pc, #40]	; (8009548 <settings_read_build_info+0x34>)
 800951e:	687b      	ldr	r3, [r7, #4]
 8009520:	2250      	movs	r2, #80	; 0x50
 8009522:	0018      	movs	r0, r3
 8009524:	f7fa fa16 	bl	8003954 <memcpy_from_eeprom_with_checksum>
 8009528:	1e03      	subs	r3, r0, #0
 800952a:	d108      	bne.n	800953e <settings_read_build_info+0x2a>
    // Reset line with default value
    line[0] = 0; // Empty line
 800952c:	687b      	ldr	r3, [r7, #4]
 800952e:	2200      	movs	r2, #0
 8009530:	701a      	strb	r2, [r3, #0]
    settings_store_build_info(line);
 8009532:	687b      	ldr	r3, [r7, #4]
 8009534:	0018      	movs	r0, r3
 8009536:	f7ff fea3 	bl	8009280 <settings_store_build_info>
    return(false);
 800953a:	2300      	movs	r3, #0
 800953c:	e000      	b.n	8009540 <settings_read_build_info+0x2c>
  }
  return(true);
 800953e:	2301      	movs	r3, #1
}
 8009540:	0018      	movs	r0, r3
 8009542:	46bd      	mov	sp, r7
 8009544:	b002      	add	sp, #8
 8009546:	bd80      	pop	{r7, pc}
 8009548:	000003ae 	.word	0x000003ae

0800954c <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
 800954c:	b580      	push	{r7, lr}
 800954e:	b084      	sub	sp, #16
 8009550:	af00      	add	r7, sp, #0
 8009552:	0002      	movs	r2, r0
 8009554:	6039      	str	r1, [r7, #0]
 8009556:	1dfb      	adds	r3, r7, #7
 8009558:	701a      	strb	r2, [r3, #0]
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
 800955a:	1dfb      	adds	r3, r7, #7
 800955c:	781a      	ldrb	r2, [r3, #0]
 800955e:	0013      	movs	r3, r2
 8009560:	005b      	lsls	r3, r3, #1
 8009562:	189b      	adds	r3, r3, r2
 8009564:	009b      	lsls	r3, r3, #2
 8009566:	189b      	adds	r3, r3, r2
 8009568:	2280      	movs	r2, #128	; 0x80
 800956a:	0092      	lsls	r2, r2, #2
 800956c:	4694      	mov	ip, r2
 800956e:	4463      	add	r3, ip
 8009570:	60fb      	str	r3, [r7, #12]
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
 8009572:	68f9      	ldr	r1, [r7, #12]
 8009574:	683b      	ldr	r3, [r7, #0]
 8009576:	220c      	movs	r2, #12
 8009578:	0018      	movs	r0, r3
 800957a:	f7fa f9eb 	bl	8003954 <memcpy_from_eeprom_with_checksum>
 800957e:	1e03      	subs	r3, r0, #0
 8009580:	d10e      	bne.n	80095a0 <settings_read_coord_data+0x54>
    // Reset with default zero vector
    clear_vector_float(coord_data);
 8009582:	683b      	ldr	r3, [r7, #0]
 8009584:	220c      	movs	r2, #12
 8009586:	2100      	movs	r1, #0
 8009588:	0018      	movs	r0, r3
 800958a:	f002 fdb9 	bl	800c100 <memset>
    settings_write_coord_data(coord_select,coord_data);
 800958e:	683a      	ldr	r2, [r7, #0]
 8009590:	1dfb      	adds	r3, r7, #7
 8009592:	781b      	ldrb	r3, [r3, #0]
 8009594:	0011      	movs	r1, r2
 8009596:	0018      	movs	r0, r3
 8009598:	f7ff fe82 	bl	80092a0 <settings_write_coord_data>
    return(false);
 800959c:	2300      	movs	r3, #0
 800959e:	e000      	b.n	80095a2 <settings_read_coord_data+0x56>
  }
  return(true);
 80095a0:	2301      	movs	r3, #1
}
 80095a2:	0018      	movs	r0, r3
 80095a4:	46bd      	mov	sp, r7
 80095a6:	b004      	add	sp, #16
 80095a8:	bd80      	pop	{r7, pc}
 80095aa:	46c0      	nop			; (mov r8, r8)

080095ac <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
 80095ac:	b590      	push	{r4, r7, lr}
 80095ae:	b083      	sub	sp, #12
 80095b0:	af00      	add	r7, sp, #0
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
 80095b2:	1dfc      	adds	r4, r7, #7
 80095b4:	2000      	movs	r0, #0
 80095b6:	f7fa f969 	bl	800388c <eeprom_get_char>
 80095ba:	0003      	movs	r3, r0
 80095bc:	7023      	strb	r3, [r4, #0]
  if (version == SETTINGS_VERSION) {
 80095be:	1dfb      	adds	r3, r7, #7
 80095c0:	781b      	ldrb	r3, [r3, #0]
 80095c2:	2b0a      	cmp	r3, #10
 80095c4:	d109      	bne.n	80095da <read_global_settings+0x2e>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
 80095c6:	4b08      	ldr	r3, [pc, #32]	; (80095e8 <read_global_settings+0x3c>)
 80095c8:	225c      	movs	r2, #92	; 0x5c
 80095ca:	2101      	movs	r1, #1
 80095cc:	0018      	movs	r0, r3
 80095ce:	f7fa f9c1 	bl	8003954 <memcpy_from_eeprom_with_checksum>
 80095d2:	1e03      	subs	r3, r0, #0
 80095d4:	d103      	bne.n	80095de <read_global_settings+0x32>
      return(false);
 80095d6:	2300      	movs	r3, #0
 80095d8:	e002      	b.n	80095e0 <read_global_settings+0x34>
    }
  } else {
    return(false);
 80095da:	2300      	movs	r3, #0
 80095dc:	e000      	b.n	80095e0 <read_global_settings+0x34>
  }
  return(true);
 80095de:	2301      	movs	r3, #1
}
 80095e0:	0018      	movs	r0, r3
 80095e2:	46bd      	mov	sp, r7
 80095e4:	b003      	add	sp, #12
 80095e6:	bd90      	pop	{r4, r7, pc}
 80095e8:	20000acc 	.word	0x20000acc

080095ec <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
 80095ec:	b590      	push	{r4, r7, lr}
 80095ee:	b085      	sub	sp, #20
 80095f0:	af00      	add	r7, sp, #0
 80095f2:	0002      	movs	r2, r0
 80095f4:	6039      	str	r1, [r7, #0]
 80095f6:	1dfb      	adds	r3, r7, #7
 80095f8:	701a      	strb	r2, [r3, #0]
  if (value < 0.0f) { return(STATUS_NEGATIVE_VALUE); }
 80095fa:	2100      	movs	r1, #0
 80095fc:	6838      	ldr	r0, [r7, #0]
 80095fe:	f7f6 fe69 	bl	80002d4 <__aeabi_fcmplt>
 8009602:	1e03      	subs	r3, r0, #0
 8009604:	d001      	beq.n	800960a <settings_store_global_setting+0x1e>
 8009606:	2304      	movs	r3, #4
 8009608:	e1d5      	b.n	80099b6 <settings_store_global_setting+0x3ca>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
 800960a:	1dfb      	adds	r3, r7, #7
 800960c:	781b      	ldrb	r3, [r3, #0]
 800960e:	2b63      	cmp	r3, #99	; 0x63
 8009610:	d800      	bhi.n	8009614 <settings_store_global_setting+0x28>
 8009612:	e069      	b.n	80096e8 <settings_store_global_setting+0xfc>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
 8009614:	1dfb      	adds	r3, r7, #7
 8009616:	1dfa      	adds	r2, r7, #7
 8009618:	7812      	ldrb	r2, [r2, #0]
 800961a:	3a64      	subs	r2, #100	; 0x64
 800961c:	701a      	strb	r2, [r3, #0]
    uint8_t set_idx = 0;
 800961e:	230f      	movs	r3, #15
 8009620:	18fb      	adds	r3, r7, r3
 8009622:	2200      	movs	r2, #0
 8009624:	701a      	strb	r2, [r3, #0]
    while (set_idx < AXIS_N_SETTINGS) {
 8009626:	e059      	b.n	80096dc <settings_store_global_setting+0xf0>
      if (parameter < N_AXIS) {
 8009628:	1dfb      	adds	r3, r7, #7
 800962a:	781b      	ldrb	r3, [r3, #0]
 800962c:	2b02      	cmp	r3, #2
 800962e:	d83e      	bhi.n	80096ae <settings_store_global_setting+0xc2>
        // Valid axis setting found.
        switch (set_idx) {
 8009630:	230f      	movs	r3, #15
 8009632:	18fb      	adds	r3, r7, r3
 8009634:	781b      	ldrb	r3, [r3, #0]
 8009636:	2b01      	cmp	r3, #1
 8009638:	d00f      	beq.n	800965a <settings_store_global_setting+0x6e>
 800963a:	dc02      	bgt.n	8009642 <settings_store_global_setting+0x56>
 800963c:	2b00      	cmp	r3, #0
 800963e:	d005      	beq.n	800964c <settings_store_global_setting+0x60>
            settings.max_rate[parameter] = value;
            break;
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
 8009640:	e1b6      	b.n	80099b0 <settings_store_global_setting+0x3c4>
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
        // Valid axis setting found.
        switch (set_idx) {
 8009642:	2b02      	cmp	r3, #2
 8009644:	d013      	beq.n	800966e <settings_store_global_setting+0x82>
 8009646:	2b03      	cmp	r3, #3
 8009648:	d023      	beq.n	8009692 <settings_store_global_setting+0xa6>
            settings.max_rate[parameter] = value;
            break;
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
 800964a:	e1b1      	b.n	80099b0 <settings_store_global_setting+0x3c4>
        switch (set_idx) {
          case 0:
            #ifdef MAX_STEP_RATE_HZ
            if (value*settings.max_rate[parameter] >(MAX_STEP_RATE_HZ*60.0f)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.steps_per_mm[parameter] = value;
 800964c:	1dfb      	adds	r3, r7, #7
 800964e:	781a      	ldrb	r2, [r3, #0]
 8009650:	4bd4      	ldr	r3, [pc, #848]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009652:	0092      	lsls	r2, r2, #2
 8009654:	6839      	ldr	r1, [r7, #0]
 8009656:	50d1      	str	r1, [r2, r3]
            break;
 8009658:	e028      	b.n	80096ac <settings_store_global_setting+0xc0>
          case 1:
            #ifdef MAX_STEP_RATE_HZ
            if (value*settings.steps_per_mm[parameter] > (MAX_STEP_RATE_HZ*60.0f)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.max_rate[parameter] = value;
 800965a:	1dfb      	adds	r3, r7, #7
 800965c:	781b      	ldrb	r3, [r3, #0]
 800965e:	4ad1      	ldr	r2, [pc, #836]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009660:	3302      	adds	r3, #2
 8009662:	009b      	lsls	r3, r3, #2
 8009664:	18d3      	adds	r3, r2, r3
 8009666:	3304      	adds	r3, #4
 8009668:	683a      	ldr	r2, [r7, #0]
 800966a:	601a      	str	r2, [r3, #0]
            break;
 800966c:	e01e      	b.n	80096ac <settings_store_global_setting+0xc0>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
 800966e:	1dfb      	adds	r3, r7, #7
 8009670:	781c      	ldrb	r4, [r3, #0]
 8009672:	49cd      	ldr	r1, [pc, #820]	; (80099a8 <settings_store_global_setting+0x3bc>)
 8009674:	6838      	ldr	r0, [r7, #0]
 8009676:	f7f7 f9cb 	bl	8000a10 <__aeabi_fmul>
 800967a:	1c03      	adds	r3, r0, #0
 800967c:	49ca      	ldr	r1, [pc, #808]	; (80099a8 <settings_store_global_setting+0x3bc>)
 800967e:	1c18      	adds	r0, r3, #0
 8009680:	f7f7 f9c6 	bl	8000a10 <__aeabi_fmul>
 8009684:	1c03      	adds	r3, r0, #0
 8009686:	1c19      	adds	r1, r3, #0
 8009688:	4bc6      	ldr	r3, [pc, #792]	; (80099a4 <settings_store_global_setting+0x3b8>)
 800968a:	1da2      	adds	r2, r4, #6
 800968c:	0092      	lsls	r2, r2, #2
 800968e:	50d1      	str	r1, [r2, r3]
 8009690:	e00c      	b.n	80096ac <settings_store_global_setting+0xc0>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
 8009692:	1dfb      	adds	r3, r7, #7
 8009694:	781b      	ldrb	r3, [r3, #0]
 8009696:	683a      	ldr	r2, [r7, #0]
 8009698:	2180      	movs	r1, #128	; 0x80
 800969a:	0609      	lsls	r1, r1, #24
 800969c:	404a      	eors	r2, r1
 800969e:	49c1      	ldr	r1, [pc, #772]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80096a0:	3308      	adds	r3, #8
 80096a2:	009b      	lsls	r3, r3, #2
 80096a4:	18cb      	adds	r3, r1, r3
 80096a6:	3304      	adds	r3, #4
 80096a8:	601a      	str	r2, [r3, #0]
 80096aa:	46c0      	nop			; (mov r8, r8)
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
 80096ac:	e180      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      } else {
        set_idx++;
 80096ae:	230f      	movs	r3, #15
 80096b0:	18fb      	adds	r3, r7, r3
 80096b2:	781a      	ldrb	r2, [r3, #0]
 80096b4:	230f      	movs	r3, #15
 80096b6:	18fb      	adds	r3, r7, r3
 80096b8:	3201      	adds	r2, #1
 80096ba:	701a      	strb	r2, [r3, #0]
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
 80096bc:	1dfb      	adds	r3, r7, #7
 80096be:	781b      	ldrb	r3, [r3, #0]
 80096c0:	2b09      	cmp	r3, #9
 80096c2:	d904      	bls.n	80096ce <settings_store_global_setting+0xe2>
 80096c4:	230f      	movs	r3, #15
 80096c6:	18fb      	adds	r3, r7, r3
 80096c8:	781b      	ldrb	r3, [r3, #0]
 80096ca:	2b04      	cmp	r3, #4
 80096cc:	d101      	bne.n	80096d2 <settings_store_global_setting+0xe6>
 80096ce:	2303      	movs	r3, #3
 80096d0:	e171      	b.n	80099b6 <settings_store_global_setting+0x3ca>
        parameter -= AXIS_SETTINGS_INCREMENT;
 80096d2:	1dfb      	adds	r3, r7, #7
 80096d4:	1dfa      	adds	r2, r7, #7
 80096d6:	7812      	ldrb	r2, [r2, #0]
 80096d8:	3a0a      	subs	r2, #10
 80096da:	701a      	strb	r2, [r3, #0]
  if (parameter >= AXIS_SETTINGS_START_VAL) {
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
 80096dc:	230f      	movs	r3, #15
 80096de:	18fb      	adds	r3, r7, r3
 80096e0:	781b      	ldrb	r3, [r3, #0]
 80096e2:	2b03      	cmp	r3, #3
 80096e4:	d9a0      	bls.n	8009628 <settings_store_global_setting+0x3c>
 80096e6:	e163      	b.n	80099b0 <settings_store_global_setting+0x3c4>
        parameter -= AXIS_SETTINGS_INCREMENT;
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
 80096e8:	6838      	ldr	r0, [r7, #0]
 80096ea:	f7f8 ffc5 	bl	8002678 <__aeabi_f2d>
 80096ee:	0003      	movs	r3, r0
 80096f0:	000c      	movs	r4, r1
 80096f2:	0018      	movs	r0, r3
 80096f4:	0021      	movs	r1, r4
 80096f6:	f002 fd51 	bl	800c19c <trunc>
 80096fa:	0002      	movs	r2, r0
 80096fc:	000b      	movs	r3, r1
 80096fe:	210e      	movs	r1, #14
 8009700:	187c      	adds	r4, r7, r1
 8009702:	0010      	movs	r0, r2
 8009704:	0019      	movs	r1, r3
 8009706:	f7f6 fe25 	bl	8000354 <__aeabi_d2uiz>
 800970a:	0003      	movs	r3, r0
 800970c:	7023      	strb	r3, [r4, #0]
    switch(parameter) {
 800970e:	1dfb      	adds	r3, r7, #7
 8009710:	781b      	ldrb	r3, [r3, #0]
 8009712:	2b20      	cmp	r3, #32
 8009714:	d900      	bls.n	8009718 <settings_store_global_setting+0x12c>
 8009716:	e143      	b.n	80099a0 <settings_store_global_setting+0x3b4>
 8009718:	009a      	lsls	r2, r3, #2
 800971a:	4ba4      	ldr	r3, [pc, #656]	; (80099ac <settings_store_global_setting+0x3c0>)
 800971c:	18d3      	adds	r3, r2, r3
 800971e:	681b      	ldr	r3, [r3, #0]
 8009720:	469f      	mov	pc, r3
      case 0:
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
 8009722:	230e      	movs	r3, #14
 8009724:	18fb      	adds	r3, r7, r3
 8009726:	781b      	ldrb	r3, [r3, #0]
 8009728:	2b02      	cmp	r3, #2
 800972a:	d801      	bhi.n	8009730 <settings_store_global_setting+0x144>
 800972c:	2306      	movs	r3, #6
 800972e:	e142      	b.n	80099b6 <settings_store_global_setting+0x3ca>
        settings.pulse_microseconds = int_value; break;
 8009730:	4b9c      	ldr	r3, [pc, #624]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009732:	220e      	movs	r2, #14
 8009734:	18ba      	adds	r2, r7, r2
 8009736:	2130      	movs	r1, #48	; 0x30
 8009738:	7812      	ldrb	r2, [r2, #0]
 800973a:	545a      	strb	r2, [r3, r1]
 800973c:	e138      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 1: settings.stepper_idle_lock_time = int_value; break;
 800973e:	4b99      	ldr	r3, [pc, #612]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009740:	220e      	movs	r2, #14
 8009742:	18ba      	adds	r2, r7, r2
 8009744:	2133      	movs	r1, #51	; 0x33
 8009746:	7812      	ldrb	r2, [r2, #0]
 8009748:	545a      	strb	r2, [r3, r1]
 800974a:	e131      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 2:
        settings.step_invert_mask = int_value;
 800974c:	4b95      	ldr	r3, [pc, #596]	; (80099a4 <settings_store_global_setting+0x3b8>)
 800974e:	220e      	movs	r2, #14
 8009750:	18ba      	adds	r2, r7, r2
 8009752:	2131      	movs	r1, #49	; 0x31
 8009754:	7812      	ldrb	r2, [r2, #0]
 8009756:	545a      	strb	r2, [r3, r1]
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
 8009758:	f000 fdcc 	bl	800a2f4 <st_generate_step_dir_invert_masks>
        break;
 800975c:	e128      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 3:
        settings.dir_invert_mask = int_value;
 800975e:	4b91      	ldr	r3, [pc, #580]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009760:	220e      	movs	r2, #14
 8009762:	18ba      	adds	r2, r7, r2
 8009764:	2132      	movs	r1, #50	; 0x32
 8009766:	7812      	ldrb	r2, [r2, #0]
 8009768:	545a      	strb	r2, [r3, r1]
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
 800976a:	f000 fdc3 	bl	800a2f4 <st_generate_step_dir_invert_masks>
        break;
 800976e:	e11f      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
 8009770:	230e      	movs	r3, #14
 8009772:	18fb      	adds	r3, r7, r3
 8009774:	781b      	ldrb	r3, [r3, #0]
 8009776:	2b00      	cmp	r3, #0
 8009778:	d009      	beq.n	800978e <settings_store_global_setting+0x1a2>
 800977a:	4b8a      	ldr	r3, [pc, #552]	; (80099a4 <settings_store_global_setting+0x3b8>)
 800977c:	2248      	movs	r2, #72	; 0x48
 800977e:	5c9b      	ldrb	r3, [r3, r2]
 8009780:	2204      	movs	r2, #4
 8009782:	4313      	orrs	r3, r2
 8009784:	b2d9      	uxtb	r1, r3
 8009786:	4b87      	ldr	r3, [pc, #540]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009788:	2248      	movs	r2, #72	; 0x48
 800978a:	5499      	strb	r1, [r3, r2]
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
        break;
 800978c:	e110      	b.n	80099b0 <settings_store_global_setting+0x3c4>
        settings.dir_invert_mask = int_value;
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
        break;
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
 800978e:	4b85      	ldr	r3, [pc, #532]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009790:	2248      	movs	r2, #72	; 0x48
 8009792:	5c9b      	ldrb	r3, [r3, r2]
 8009794:	2204      	movs	r2, #4
 8009796:	4393      	bics	r3, r2
 8009798:	b2d9      	uxtb	r1, r3
 800979a:	4b82      	ldr	r3, [pc, #520]	; (80099a4 <settings_store_global_setting+0x3b8>)
 800979c:	2248      	movs	r2, #72	; 0x48
 800979e:	5499      	strb	r1, [r3, r2]
        break;
 80097a0:	e106      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
 80097a2:	230e      	movs	r3, #14
 80097a4:	18fb      	adds	r3, r7, r3
 80097a6:	781b      	ldrb	r3, [r3, #0]
 80097a8:	2b00      	cmp	r3, #0
 80097aa:	d009      	beq.n	80097c0 <settings_store_global_setting+0x1d4>
 80097ac:	4b7d      	ldr	r3, [pc, #500]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80097ae:	2248      	movs	r2, #72	; 0x48
 80097b0:	5c9b      	ldrb	r3, [r3, r2]
 80097b2:	2240      	movs	r2, #64	; 0x40
 80097b4:	4313      	orrs	r3, r2
 80097b6:	b2d9      	uxtb	r1, r3
 80097b8:	4b7a      	ldr	r3, [pc, #488]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80097ba:	2248      	movs	r2, #72	; 0x48
 80097bc:	5499      	strb	r1, [r3, r2]
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
        break;
 80097be:	e0f7      	b.n	80099b0 <settings_store_global_setting+0x3c4>
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
        break;
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
 80097c0:	4b78      	ldr	r3, [pc, #480]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80097c2:	2248      	movs	r2, #72	; 0x48
 80097c4:	5c9b      	ldrb	r3, [r3, r2]
 80097c6:	2240      	movs	r2, #64	; 0x40
 80097c8:	4393      	bics	r3, r2
 80097ca:	b2d9      	uxtb	r1, r3
 80097cc:	4b75      	ldr	r3, [pc, #468]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80097ce:	2248      	movs	r2, #72	; 0x48
 80097d0:	5499      	strb	r1, [r3, r2]
        break;
 80097d2:	e0ed      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
 80097d4:	230e      	movs	r3, #14
 80097d6:	18fb      	adds	r3, r7, r3
 80097d8:	781b      	ldrb	r3, [r3, #0]
 80097da:	2b00      	cmp	r3, #0
 80097dc:	d00a      	beq.n	80097f4 <settings_store_global_setting+0x208>
 80097de:	4b71      	ldr	r3, [pc, #452]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80097e0:	2248      	movs	r2, #72	; 0x48
 80097e2:	5c9b      	ldrb	r3, [r3, r2]
 80097e4:	2280      	movs	r2, #128	; 0x80
 80097e6:	4252      	negs	r2, r2
 80097e8:	4313      	orrs	r3, r2
 80097ea:	b2d9      	uxtb	r1, r3
 80097ec:	4b6d      	ldr	r3, [pc, #436]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80097ee:	2248      	movs	r2, #72	; 0x48
 80097f0:	5499      	strb	r1, [r3, r2]
 80097f2:	e008      	b.n	8009806 <settings_store_global_setting+0x21a>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
 80097f4:	4b6b      	ldr	r3, [pc, #428]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80097f6:	2248      	movs	r2, #72	; 0x48
 80097f8:	5c9b      	ldrb	r3, [r3, r2]
 80097fa:	227f      	movs	r2, #127	; 0x7f
 80097fc:	4013      	ands	r3, r2
 80097fe:	b2d9      	uxtb	r1, r3
 8009800:	4b68      	ldr	r3, [pc, #416]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009802:	2248      	movs	r2, #72	; 0x48
 8009804:	5499      	strb	r1, [r3, r2]
        probe_configure_invert_mask(false);
 8009806:	2000      	movs	r0, #0
 8009808:	f7fd fede 	bl	80075c8 <probe_configure_invert_mask>
        break;
 800980c:	e0d0      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 10: settings.status_report_mask = int_value; break;
 800980e:	4b65      	ldr	r3, [pc, #404]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009810:	220e      	movs	r2, #14
 8009812:	18ba      	adds	r2, r7, r2
 8009814:	2134      	movs	r1, #52	; 0x34
 8009816:	7812      	ldrb	r2, [r2, #0]
 8009818:	545a      	strb	r2, [r3, r1]
 800981a:	e0c9      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 11: settings.junction_deviation = value; break;
 800981c:	4b61      	ldr	r3, [pc, #388]	; (80099a4 <settings_store_global_setting+0x3b8>)
 800981e:	683a      	ldr	r2, [r7, #0]
 8009820:	639a      	str	r2, [r3, #56]	; 0x38
 8009822:	e0c5      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 12: settings.arc_tolerance = value; break;
 8009824:	4b5f      	ldr	r3, [pc, #380]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009826:	683a      	ldr	r2, [r7, #0]
 8009828:	63da      	str	r2, [r3, #60]	; 0x3c
 800982a:	e0c1      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
 800982c:	230e      	movs	r3, #14
 800982e:	18fb      	adds	r3, r7, r3
 8009830:	781b      	ldrb	r3, [r3, #0]
 8009832:	2b00      	cmp	r3, #0
 8009834:	d009      	beq.n	800984a <settings_store_global_setting+0x25e>
 8009836:	4b5b      	ldr	r3, [pc, #364]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009838:	2248      	movs	r2, #72	; 0x48
 800983a:	5c9b      	ldrb	r3, [r3, r2]
 800983c:	2201      	movs	r2, #1
 800983e:	4313      	orrs	r3, r2
 8009840:	b2d9      	uxtb	r1, r3
 8009842:	4b58      	ldr	r3, [pc, #352]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009844:	2248      	movs	r2, #72	; 0x48
 8009846:	5499      	strb	r1, [r3, r2]
 8009848:	e008      	b.n	800985c <settings_store_global_setting+0x270>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
 800984a:	4b56      	ldr	r3, [pc, #344]	; (80099a4 <settings_store_global_setting+0x3b8>)
 800984c:	2248      	movs	r2, #72	; 0x48
 800984e:	5c9b      	ldrb	r3, [r3, r2]
 8009850:	2201      	movs	r2, #1
 8009852:	4393      	bics	r3, r2
 8009854:	b2d9      	uxtb	r1, r3
 8009856:	4b53      	ldr	r3, [pc, #332]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009858:	2248      	movs	r2, #72	; 0x48
 800985a:	5499      	strb	r1, [r3, r2]
        system_flag_wco_change(); // Make sure WCO is immediately updated.
 800985c:	f002 f832 	bl	800b8c4 <system_flag_wco_change>
        break;
 8009860:	e0a6      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 20:
        if (int_value) {
 8009862:	230e      	movs	r3, #14
 8009864:	18fb      	adds	r3, r7, r3
 8009866:	781b      	ldrb	r3, [r3, #0]
 8009868:	2b00      	cmp	r3, #0
 800986a:	d012      	beq.n	8009892 <settings_store_global_setting+0x2a6>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
 800986c:	4b4d      	ldr	r3, [pc, #308]	; (80099a4 <settings_store_global_setting+0x3b8>)
 800986e:	2248      	movs	r2, #72	; 0x48
 8009870:	5c9b      	ldrb	r3, [r3, r2]
 8009872:	001a      	movs	r2, r3
 8009874:	2310      	movs	r3, #16
 8009876:	4013      	ands	r3, r2
 8009878:	d101      	bne.n	800987e <settings_store_global_setting+0x292>
 800987a:	230a      	movs	r3, #10
 800987c:	e09b      	b.n	80099b6 <settings_store_global_setting+0x3ca>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE;
 800987e:	4b49      	ldr	r3, [pc, #292]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009880:	2248      	movs	r2, #72	; 0x48
 8009882:	5c9b      	ldrb	r3, [r3, r2]
 8009884:	2220      	movs	r2, #32
 8009886:	4313      	orrs	r3, r2
 8009888:	b2d9      	uxtb	r1, r3
 800988a:	4b46      	ldr	r3, [pc, #280]	; (80099a4 <settings_store_global_setting+0x3b8>)
 800988c:	2248      	movs	r2, #72	; 0x48
 800988e:	5499      	strb	r1, [r3, r2]
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
        break;
 8009890:	e08e      	b.n	80099b0 <settings_store_global_setting+0x3c4>
        break;
      case 20:
        if (int_value) {
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE;
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
 8009892:	4b44      	ldr	r3, [pc, #272]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009894:	2248      	movs	r2, #72	; 0x48
 8009896:	5c9b      	ldrb	r3, [r3, r2]
 8009898:	2220      	movs	r2, #32
 800989a:	4393      	bics	r3, r2
 800989c:	b2d9      	uxtb	r1, r3
 800989e:	4b41      	ldr	r3, [pc, #260]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80098a0:	2248      	movs	r2, #72	; 0x48
 80098a2:	5499      	strb	r1, [r3, r2]
        break;
 80098a4:	e084      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
 80098a6:	230e      	movs	r3, #14
 80098a8:	18fb      	adds	r3, r7, r3
 80098aa:	781b      	ldrb	r3, [r3, #0]
 80098ac:	2b00      	cmp	r3, #0
 80098ae:	d009      	beq.n	80098c4 <settings_store_global_setting+0x2d8>
 80098b0:	4b3c      	ldr	r3, [pc, #240]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80098b2:	2248      	movs	r2, #72	; 0x48
 80098b4:	5c9b      	ldrb	r3, [r3, r2]
 80098b6:	2208      	movs	r2, #8
 80098b8:	4313      	orrs	r3, r2
 80098ba:	b2d9      	uxtb	r1, r3
 80098bc:	4b39      	ldr	r3, [pc, #228]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80098be:	2248      	movs	r2, #72	; 0x48
 80098c0:	5499      	strb	r1, [r3, r2]
 80098c2:	e008      	b.n	80098d6 <settings_store_global_setting+0x2ea>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
 80098c4:	4b37      	ldr	r3, [pc, #220]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80098c6:	2248      	movs	r2, #72	; 0x48
 80098c8:	5c9b      	ldrb	r3, [r3, r2]
 80098ca:	2208      	movs	r2, #8
 80098cc:	4393      	bics	r3, r2
 80098ce:	b2d9      	uxtb	r1, r3
 80098d0:	4b34      	ldr	r3, [pc, #208]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80098d2:	2248      	movs	r2, #72	; 0x48
 80098d4:	5499      	strb	r1, [r3, r2]
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
 80098d6:	f7fb fe37 	bl	8005548 <limits_init>
        break;
 80098da:	e069      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
 80098dc:	230e      	movs	r3, #14
 80098de:	18fb      	adds	r3, r7, r3
 80098e0:	781b      	ldrb	r3, [r3, #0]
 80098e2:	2b00      	cmp	r3, #0
 80098e4:	d009      	beq.n	80098fa <settings_store_global_setting+0x30e>
 80098e6:	4b2f      	ldr	r3, [pc, #188]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80098e8:	2248      	movs	r2, #72	; 0x48
 80098ea:	5c9b      	ldrb	r3, [r3, r2]
 80098ec:	2210      	movs	r2, #16
 80098ee:	4313      	orrs	r3, r2
 80098f0:	b2d9      	uxtb	r1, r3
 80098f2:	4b2c      	ldr	r3, [pc, #176]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80098f4:	2248      	movs	r2, #72	; 0x48
 80098f6:	5499      	strb	r1, [r3, r2]
        else {
          settings.flags &= ~BITFLAG_HOMING_ENABLE;
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
        }
        break;
 80098f8:	e05a      	b.n	80099b0 <settings_store_global_setting+0x3c4>
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
        break;
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
        else {
          settings.flags &= ~BITFLAG_HOMING_ENABLE;
 80098fa:	4b2a      	ldr	r3, [pc, #168]	; (80099a4 <settings_store_global_setting+0x3b8>)
 80098fc:	2248      	movs	r2, #72	; 0x48
 80098fe:	5c9b      	ldrb	r3, [r3, r2]
 8009900:	2210      	movs	r2, #16
 8009902:	4393      	bics	r3, r2
 8009904:	b2d9      	uxtb	r1, r3
 8009906:	4b27      	ldr	r3, [pc, #156]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009908:	2248      	movs	r2, #72	; 0x48
 800990a:	5499      	strb	r1, [r3, r2]
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
 800990c:	4b25      	ldr	r3, [pc, #148]	; (80099a4 <settings_store_global_setting+0x3b8>)
 800990e:	2248      	movs	r2, #72	; 0x48
 8009910:	5c9b      	ldrb	r3, [r3, r2]
 8009912:	2220      	movs	r2, #32
 8009914:	4393      	bics	r3, r2
 8009916:	b2d9      	uxtb	r1, r3
 8009918:	4b22      	ldr	r3, [pc, #136]	; (80099a4 <settings_store_global_setting+0x3b8>)
 800991a:	2248      	movs	r2, #72	; 0x48
 800991c:	5499      	strb	r1, [r3, r2]
        }
        break;
 800991e:	e047      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 23: settings.homing_dir_mask = int_value; break;
 8009920:	4b20      	ldr	r3, [pc, #128]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009922:	220e      	movs	r2, #14
 8009924:	18ba      	adds	r2, r7, r2
 8009926:	2149      	movs	r1, #73	; 0x49
 8009928:	7812      	ldrb	r2, [r2, #0]
 800992a:	545a      	strb	r2, [r3, r1]
 800992c:	e040      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 24: settings.homing_feed_rate = value; break;
 800992e:	4b1d      	ldr	r3, [pc, #116]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009930:	683a      	ldr	r2, [r7, #0]
 8009932:	64da      	str	r2, [r3, #76]	; 0x4c
 8009934:	e03c      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 25: settings.homing_seek_rate = value; break;
 8009936:	4b1b      	ldr	r3, [pc, #108]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009938:	683a      	ldr	r2, [r7, #0]
 800993a:	651a      	str	r2, [r3, #80]	; 0x50
 800993c:	e038      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 26: settings.homing_debounce_delay = int_value; break;
 800993e:	230e      	movs	r3, #14
 8009940:	18fb      	adds	r3, r7, r3
 8009942:	781b      	ldrb	r3, [r3, #0]
 8009944:	b299      	uxth	r1, r3
 8009946:	4b17      	ldr	r3, [pc, #92]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009948:	2254      	movs	r2, #84	; 0x54
 800994a:	5299      	strh	r1, [r3, r2]
 800994c:	e030      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 27: settings.homing_pulloff = value; break;
 800994e:	4b15      	ldr	r3, [pc, #84]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009950:	683a      	ldr	r2, [r7, #0]
 8009952:	659a      	str	r2, [r3, #88]	; 0x58
 8009954:	e02c      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 30: settings.rpm_max = value; spindle_init(); break; // Re-initialize spindle rpm calibration
 8009956:	4b13      	ldr	r3, [pc, #76]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009958:	683a      	ldr	r2, [r7, #0]
 800995a:	641a      	str	r2, [r3, #64]	; 0x40
 800995c:	f000 f842 	bl	80099e4 <spindle_init>
 8009960:	e026      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 31: settings.rpm_min = value; spindle_init(); break; // Re-initialize spindle rpm calibration
 8009962:	4b10      	ldr	r3, [pc, #64]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009964:	683a      	ldr	r2, [r7, #0]
 8009966:	645a      	str	r2, [r3, #68]	; 0x44
 8009968:	f000 f83c 	bl	80099e4 <spindle_init>
 800996c:	e020      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 32:
        #ifdef VARIABLE_SPINDLE
          if (int_value) { settings.flags |= BITFLAG_LASER_MODE; }
 800996e:	230e      	movs	r3, #14
 8009970:	18fb      	adds	r3, r7, r3
 8009972:	781b      	ldrb	r3, [r3, #0]
 8009974:	2b00      	cmp	r3, #0
 8009976:	d009      	beq.n	800998c <settings_store_global_setting+0x3a0>
 8009978:	4b0a      	ldr	r3, [pc, #40]	; (80099a4 <settings_store_global_setting+0x3b8>)
 800997a:	2248      	movs	r2, #72	; 0x48
 800997c:	5c9b      	ldrb	r3, [r3, r2]
 800997e:	2202      	movs	r2, #2
 8009980:	4313      	orrs	r3, r2
 8009982:	b2d9      	uxtb	r1, r3
 8009984:	4b07      	ldr	r3, [pc, #28]	; (80099a4 <settings_store_global_setting+0x3b8>)
 8009986:	2248      	movs	r2, #72	; 0x48
 8009988:	5499      	strb	r1, [r3, r2]
          else { settings.flags &= ~BITFLAG_LASER_MODE; }
        #else
          return(STATUS_SETTING_DISABLED);
        #endif
        break;
 800998a:	e011      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      case 30: settings.rpm_max = value; spindle_init(); break; // Re-initialize spindle rpm calibration
      case 31: settings.rpm_min = value; spindle_init(); break; // Re-initialize spindle rpm calibration
      case 32:
        #ifdef VARIABLE_SPINDLE
          if (int_value) { settings.flags |= BITFLAG_LASER_MODE; }
          else { settings.flags &= ~BITFLAG_LASER_MODE; }
 800998c:	4b05      	ldr	r3, [pc, #20]	; (80099a4 <settings_store_global_setting+0x3b8>)
 800998e:	2248      	movs	r2, #72	; 0x48
 8009990:	5c9b      	ldrb	r3, [r3, r2]
 8009992:	2202      	movs	r2, #2
 8009994:	4393      	bics	r3, r2
 8009996:	b2d9      	uxtb	r1, r3
 8009998:	4b02      	ldr	r3, [pc, #8]	; (80099a4 <settings_store_global_setting+0x3b8>)
 800999a:	2248      	movs	r2, #72	; 0x48
 800999c:	5499      	strb	r1, [r3, r2]
        #else
          return(STATUS_SETTING_DISABLED);
        #endif
        break;
 800999e:	e007      	b.n	80099b0 <settings_store_global_setting+0x3c4>
      default:
        return(STATUS_INVALID_STATEMENT);
 80099a0:	2303      	movs	r3, #3
 80099a2:	e008      	b.n	80099b6 <settings_store_global_setting+0x3ca>
 80099a4:	20000acc 	.word	0x20000acc
 80099a8:	42700000 	.word	0x42700000
 80099ac:	0800d9fc 	.word	0x0800d9fc
    }
  }
  write_global_settings();
 80099b0:	f7ff fc96 	bl	80092e0 <write_global_settings>
  return(STATUS_OK);
 80099b4:	2300      	movs	r3, #0
}
 80099b6:	0018      	movs	r0, r3
 80099b8:	46bd      	mov	sp, r7
 80099ba:	b005      	add	sp, #20
 80099bc:	bd90      	pop	{r4, r7, pc}
 80099be:	46c0      	nop			; (mov r8, r8)

080099c0 <settings_init>:


// Initialize the config subsystem
void settings_init() {
 80099c0:	b580      	push	{r7, lr}
 80099c2:	af00      	add	r7, sp, #0
  if(!read_global_settings()) {
 80099c4:	f7ff fdf2 	bl	80095ac <read_global_settings>
 80099c8:	1e03      	subs	r3, r0, #0
 80099ca:	d107      	bne.n	80099dc <settings_init+0x1c>
    report_status_message(STATUS_SETTING_READ_FAIL);
 80099cc:	2007      	movs	r0, #7
 80099ce:	f7fe fcb7 	bl	8008340 <report_status_message>
    settings_restore(SETTINGS_RESTORE_ALL); // Force restore all EEPROM data.
 80099d2:	20ff      	movs	r0, #255	; 0xff
 80099d4:	f7ff fc96 	bl	8009304 <settings_restore>
    report_grbl_settings();
 80099d8:	f7fe fd72 	bl	80084c0 <report_grbl_settings>
  }
}
 80099dc:	46c0      	nop			; (mov r8, r8)
 80099de:	46bd      	mov	sp, r7
 80099e0:	bd80      	pop	{r7, pc}
 80099e2:	46c0      	nop			; (mov r8, r8)

080099e4 <spindle_init>:
  static float pwm_gradient; // Precalulated value to speed up rpm to PWM conversions.
#endif


void spindle_init()
{
 80099e4:	b580      	push	{r7, lr}
 80099e6:	b08a      	sub	sp, #40	; 0x28
 80099e8:	af00      	add	r7, sp, #0
#ifdef VARIABLE_SPINDLE
  pwm_gradient = SPINDLE_PWM_RANGE / (settings.rpm_max - settings.rpm_min);
 80099ea:	4b55      	ldr	r3, [pc, #340]	; (8009b40 <spindle_init+0x15c>)
 80099ec:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80099ee:	4b54      	ldr	r3, [pc, #336]	; (8009b40 <spindle_init+0x15c>)
 80099f0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80099f2:	1c19      	adds	r1, r3, #0
 80099f4:	1c10      	adds	r0, r2, #0
 80099f6:	f7f7 f91f 	bl	8000c38 <__aeabi_fsub>
 80099fa:	1c03      	adds	r3, r0, #0
 80099fc:	1c19      	adds	r1, r3, #0
 80099fe:	4851      	ldr	r0, [pc, #324]	; (8009b44 <spindle_init+0x160>)
 8009a00:	f7f6 fe3c 	bl	800067c <__aeabi_fdiv>
 8009a04:	1c03      	adds	r3, r0, #0
 8009a06:	1c1a      	adds	r2, r3, #0
 8009a08:	4b4f      	ldr	r3, [pc, #316]	; (8009b48 <spindle_init+0x164>)
 8009a0a:	601a      	str	r2, [r3, #0]

#endif
#endif
#if defined (STM32F0DISCOVERY)
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_SPINDLE_ENABLE_PORT, ENABLE);
 8009a0c:	2380      	movs	r3, #128	; 0x80
 8009a0e:	02db      	lsls	r3, r3, #11
 8009a10:	2101      	movs	r1, #1
 8009a12:	0018      	movs	r0, r3
 8009a14:	f7f9 fb3c 	bl	8003090 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8009a18:	2320      	movs	r3, #32
 8009a1a:	18fb      	adds	r3, r7, r3
 8009a1c:	2203      	movs	r2, #3
 8009a1e:	715a      	strb	r2, [r3, #5]
	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8009a20:	2320      	movs	r3, #32
 8009a22:	18fb      	adds	r3, r7, r3
 8009a24:	2201      	movs	r2, #1
 8009a26:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8009a28:	2320      	movs	r3, #32
 8009a2a:	18fb      	adds	r3, r7, r3
 8009a2c:	2200      	movs	r2, #0
 8009a2e:	719a      	strb	r2, [r3, #6]
#ifdef USE_SPINDLE_DIR_AS_ENABLE_PIN
  GPIO_InitStructure.GPIO_Pin = 1 << SPINDLE_ENABLE_BIT;
#else
  GPIO_InitStructure.GPIO_Pin = 1 << SPINDLE_DIRECTION_BIT;
 8009a30:	2320      	movs	r3, #32
 8009a32:	18fb      	adds	r3, r7, r3
 8009a34:	2202      	movs	r2, #2
 8009a36:	601a      	str	r2, [r3, #0]
#endif
  GPIO_Init(SPINDLE_ENABLE_PORT, &GPIO_InitStructure);
 8009a38:	2320      	movs	r3, #32
 8009a3a:	18fb      	adds	r3, r7, r3
 8009a3c:	4a43      	ldr	r2, [pc, #268]	; (8009b4c <spindle_init+0x168>)
 8009a3e:	0019      	movs	r1, r3
 8009a40:	0010      	movs	r0, r2
 8009a42:	f7f8 ff87 	bl	8002954 <GPIO_Init>


#ifdef VARIABLE_SPINDLE
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
 8009a46:	2380      	movs	r3, #128	; 0x80
 8009a48:	011b      	lsls	r3, r3, #4
 8009a4a:	2101      	movs	r1, #1
 8009a4c:	0018      	movs	r0, r3
 8009a4e:	f7f9 fb1f 	bl	8003090 <RCC_APB2PeriphClockCmd>
  TIM_TimeBaseInitTypeDef timerInitStructure;
  TIM_OCInitTypeDef outputChannelInit = { 0 };
 8009a52:	003b      	movs	r3, r7
 8009a54:	0018      	movs	r0, r3
 8009a56:	2314      	movs	r3, #20
 8009a58:	001a      	movs	r2, r3
 8009a5a:	2100      	movs	r1, #0
 8009a5c:	f002 fb50 	bl	800c100 <memset>
  TIM_TimeBaseStructInit(&timerInitStructure);
 8009a60:	2314      	movs	r3, #20
 8009a62:	18fb      	adds	r3, r7, r3
 8009a64:	0018      	movs	r0, r3
 8009a66:	f7f9 fbf5 	bl	8003254 <TIM_TimeBaseStructInit>

  timerInitStructure.TIM_Prescaler = F_CPU / 1000000 - 1; // 1000K
 8009a6a:	4b39      	ldr	r3, [pc, #228]	; (8009b50 <spindle_init+0x16c>)
 8009a6c:	681b      	ldr	r3, [r3, #0]
 8009a6e:	4939      	ldr	r1, [pc, #228]	; (8009b54 <spindle_init+0x170>)
 8009a70:	0018      	movs	r0, r3
 8009a72:	f7f6 fb53 	bl	800011c <__aeabi_uidiv>
 8009a76:	0003      	movs	r3, r0
 8009a78:	b29b      	uxth	r3, r3
 8009a7a:	3b01      	subs	r3, #1
 8009a7c:	b29a      	uxth	r2, r3
 8009a7e:	2314      	movs	r3, #20
 8009a80:	18fb      	adds	r3, r7, r3
 8009a82:	801a      	strh	r2, [r3, #0]
  timerInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8009a84:	2314      	movs	r3, #20
 8009a86:	18fb      	adds	r3, r7, r3
 8009a88:	2200      	movs	r2, #0
 8009a8a:	805a      	strh	r2, [r3, #2]
  timerInitStructure.TIM_Period = SPINDLE_PWM_MAX_VALUE - 1;
 8009a8c:	2314      	movs	r3, #20
 8009a8e:	18fb      	adds	r3, r7, r3
 8009a90:	2263      	movs	r2, #99	; 0x63
 8009a92:	605a      	str	r2, [r3, #4]
  timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
 8009a94:	2314      	movs	r3, #20
 8009a96:	18fb      	adds	r3, r7, r3
 8009a98:	2200      	movs	r2, #0
 8009a9a:	811a      	strh	r2, [r3, #8]
  timerInitStructure.TIM_RepetitionCounter = 0;
 8009a9c:	2314      	movs	r3, #20
 8009a9e:	18fb      	adds	r3, r7, r3
 8009aa0:	2200      	movs	r2, #0
 8009aa2:	729a      	strb	r2, [r3, #10]
  TIM_TimeBaseInit(TIM1, &timerInitStructure);
 8009aa4:	2314      	movs	r3, #20
 8009aa6:	18fb      	adds	r3, r7, r3
 8009aa8:	4a2b      	ldr	r2, [pc, #172]	; (8009b58 <spindle_init+0x174>)
 8009aaa:	0019      	movs	r1, r3
 8009aac:	0010      	movs	r0, r2
 8009aae:	f7f9 fb59 	bl	8003164 <TIM_TimeBaseInit>

  outputChannelInit.TIM_OCMode = TIM_OCMode_PWM1;
 8009ab2:	003b      	movs	r3, r7
 8009ab4:	2260      	movs	r2, #96	; 0x60
 8009ab6:	801a      	strh	r2, [r3, #0]
  outputChannelInit.TIM_Pulse = 0;     // initi speed is 0
 8009ab8:	003b      	movs	r3, r7
 8009aba:	2200      	movs	r2, #0
 8009abc:	609a      	str	r2, [r3, #8]
  outputChannelInit.TIM_OutputState = TIM_OutputState_Enable;
 8009abe:	003b      	movs	r3, r7
 8009ac0:	2201      	movs	r2, #1
 8009ac2:	805a      	strh	r2, [r3, #2]
  outputChannelInit.TIM_OCPolarity = TIM_OCPolarity_High;
 8009ac4:	003b      	movs	r3, r7
 8009ac6:	2200      	movs	r2, #0
 8009ac8:	819a      	strh	r2, [r3, #12]

  TIM_OC1Init(TIM1, &outputChannelInit);
 8009aca:	003b      	movs	r3, r7
 8009acc:	4a22      	ldr	r2, [pc, #136]	; (8009b58 <spindle_init+0x174>)
 8009ace:	0019      	movs	r1, r3
 8009ad0:	0010      	movs	r0, r2
 8009ad2:	f7f9 fc1d 	bl	8003310 <TIM_OC1Init>
  TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
 8009ad6:	4b20      	ldr	r3, [pc, #128]	; (8009b58 <spindle_init+0x174>)
 8009ad8:	2108      	movs	r1, #8
 8009ada:	0018      	movs	r0, r3
 8009adc:	f7f9 fcea 	bl	80034b4 <TIM_OC1PreloadConfig>
  TIM_CtrlPWMOutputs(TIM1, DISABLE);
 8009ae0:	4b1d      	ldr	r3, [pc, #116]	; (8009b58 <spindle_init+0x174>)
 8009ae2:	2100      	movs	r1, #0
 8009ae4:	0018      	movs	r0, r3
 8009ae6:	f7f9 fbed 	bl	80032c4 <TIM_CtrlPWMOutputs>
  TIM_Cmd(TIM1, ENABLE);
 8009aea:	4b1b      	ldr	r3, [pc, #108]	; (8009b58 <spindle_init+0x174>)
 8009aec:	2101      	movs	r1, #1
 8009aee:	0018      	movs	r0, r3
 8009af0:	f7f9 fbc8 	bl	8003284 <TIM_Cmd>

  RCC_APB2PeriphClockCmd(RCC_SPINDLE_PWM_PORT, ENABLE);
 8009af4:	2380      	movs	r3, #128	; 0x80
 8009af6:	029b      	lsls	r3, r3, #10
 8009af8:	2101      	movs	r1, #1
 8009afa:	0018      	movs	r0, r3
 8009afc:	f7f9 fac8 	bl	8003090 <RCC_APB2PeriphClockCmd>
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8009b00:	2320      	movs	r3, #32
 8009b02:	18fb      	adds	r3, r7, r3
 8009b04:	2203      	movs	r2, #3
 8009b06:	715a      	strb	r2, [r3, #5]
  //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8009b08:	2320      	movs	r3, #32
 8009b0a:	18fb      	adds	r3, r7, r3
 8009b0c:	2202      	movs	r2, #2
 8009b0e:	711a      	strb	r2, [r3, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8009b10:	2320      	movs	r3, #32
 8009b12:	18fb      	adds	r3, r7, r3
 8009b14:	2200      	movs	r2, #0
 8009b16:	719a      	strb	r2, [r3, #6]
  GPIO_InitStructure.GPIO_Pin = 1 << SPINDLE_PWM_BIT;
 8009b18:	2320      	movs	r3, #32
 8009b1a:	18fb      	adds	r3, r7, r3
 8009b1c:	2280      	movs	r2, #128	; 0x80
 8009b1e:	0052      	lsls	r2, r2, #1
 8009b20:	601a      	str	r2, [r3, #0]
  GPIO_Init(SPINDLE_PWM_PORT, &GPIO_InitStructure);
 8009b22:	2320      	movs	r3, #32
 8009b24:	18fa      	adds	r2, r7, r3
 8009b26:	2390      	movs	r3, #144	; 0x90
 8009b28:	05db      	lsls	r3, r3, #23
 8009b2a:	0011      	movs	r1, r2
 8009b2c:	0018      	movs	r0, r3
 8009b2e:	f7f8 ff11 	bl	8002954 <GPIO_Init>


#endif
#endif
  spindle_stop();
 8009b32:	f000 f82f 	bl	8009b94 <spindle_stop>
}
 8009b36:	46c0      	nop			; (mov r8, r8)
 8009b38:	46bd      	mov	sp, r7
 8009b3a:	b00a      	add	sp, #40	; 0x28
 8009b3c:	bd80      	pop	{r7, pc}
 8009b3e:	46c0      	nop			; (mov r8, r8)
 8009b40:	20000acc 	.word	0x20000acc
 8009b44:	42c60000 	.word	0x42c60000
 8009b48:	2000044c 	.word	0x2000044c
 8009b4c:	48000400 	.word	0x48000400
 8009b50:	20000010 	.word	0x20000010
 8009b54:	000f4240 	.word	0x000f4240
 8009b58:	40012c00 	.word	0x40012c00

08009b5c <spindle_get_state>:


uint8_t spindle_get_state()
{
 8009b5c:	b580      	push	{r7, lr}
 8009b5e:	b082      	sub	sp, #8
 8009b60:	af00      	add	r7, sp, #0
  uint8_t pin = 0;
 8009b62:	1dfb      	adds	r3, r7, #7
 8009b64:	2200      	movs	r2, #0
 8009b66:	701a      	strb	r2, [r3, #0]
#endif
#if defined (STM32F103C8)
      pin = GPIO_ReadInputData(SPINDLE_DIRECTION_PORT);
#endif
#if defined (STM32F0DISCOVERY)
      pin = GPIO_ReadInputData(SPINDLE_DIRECTION_PORT);
 8009b68:	4b09      	ldr	r3, [pc, #36]	; (8009b90 <spindle_get_state+0x34>)
 8009b6a:	0018      	movs	r0, r3
 8009b6c:	f7f8 ff8a 	bl	8002a84 <GPIO_ReadInputData>
 8009b70:	0003      	movs	r3, r0
 8009b72:	001a      	movs	r2, r3
 8009b74:	1dfb      	adds	r3, r7, #7
 8009b76:	701a      	strb	r2, [r3, #0]
#endif
     {
        if (pin & (1<<SPINDLE_DIRECTION_BIT)) { return(SPINDLE_STATE_CCW); }
 8009b78:	1dfb      	adds	r3, r7, #7
 8009b7a:	781b      	ldrb	r3, [r3, #0]
 8009b7c:	2202      	movs	r2, #2
 8009b7e:	4013      	ands	r3, r2
 8009b80:	d001      	beq.n	8009b86 <spindle_get_state+0x2a>
 8009b82:	2302      	movs	r3, #2
 8009b84:	e000      	b.n	8009b88 <spindle_get_state+0x2c>
        else { return(SPINDLE_STATE_CW); }
 8009b86:	2301      	movs	r3, #1
		  if (pin & (1 << SPINDLE_DIRECTION_BIT)) { return(SPINDLE_STATE_CCW); }
		  else { return(SPINDLE_STATE_CW); }
		}
	#endif
	return(SPINDLE_STATE_DISABLE);
}
 8009b88:	0018      	movs	r0, r3
 8009b8a:	46bd      	mov	sp, r7
 8009b8c:	b002      	add	sp, #8
 8009b8e:	bd80      	pop	{r7, pc}
 8009b90:	48000400 	.word	0x48000400

08009b94 <spindle_stop>:

// Disables the spindle and sets PWM output to zero when PWM variable spindle speed is enabled.
// Called by various main program and ISR routines. Keep routine small, fast, and efficient.
// Called by spindle_init(), spindle_set_speed(), spindle_set_state(), and mc_reset().
void spindle_stop()
{
 8009b94:	b580      	push	{r7, lr}
 8009b96:	af00      	add	r7, sp, #0
#endif
#if defined (STM32F103C8)
    TIM_CtrlPWMOutputs(TIM1, DISABLE);
#endif
#if defined (STM32F0DISCOVERY)
    TIM_CtrlPWMOutputs(TIM1, DISABLE);
 8009b98:	4b03      	ldr	r3, [pc, #12]	; (8009ba8 <spindle_stop+0x14>)
 8009b9a:	2100      	movs	r1, #0
 8009b9c:	0018      	movs	r0, r3
 8009b9e:	f7f9 fb91 	bl	80032c4 <TIM_CtrlPWMOutputs>
      SetSpindleEnablebit();
    #else
      ResetSpindleEnablebit();
    #endif
#endif
}
 8009ba2:	46c0      	nop			; (mov r8, r8)
 8009ba4:	46bd      	mov	sp, r7
 8009ba6:	bd80      	pop	{r7, pc}
 8009ba8:	40012c00 	.word	0x40012c00

08009bac <spindle_set_speed>:

#ifdef VARIABLE_SPINDLE
  // Sets spindle speed PWM output and enable pin, if configured. Called by spindle_set_state()
  // and stepper ISR. Keep routine small and efficient.
  void spindle_set_speed(SPINDLE_PWM_TYPE pwm_value)
  {
 8009bac:	b580      	push	{r7, lr}
 8009bae:	b082      	sub	sp, #8
 8009bb0:	af00      	add	r7, sp, #0
 8009bb2:	0002      	movs	r2, r0
 8009bb4:	1dfb      	adds	r3, r7, #7
 8009bb6:	701a      	strb	r2, [r3, #0]
#endif
#if defined (STM32F103C8)
		TIM1->CCR1 = pwm_value;
#endif
#if defined (STM32F0DISCOVERY)
		TIM1->CCR1 = pwm_value;
 8009bb8:	4b0b      	ldr	r3, [pc, #44]	; (8009be8 <spindle_set_speed+0x3c>)
 8009bba:	1dfa      	adds	r2, r7, #7
 8009bbc:	7812      	ldrb	r2, [r2, #0]
 8009bbe:	635a      	str	r2, [r3, #52]	; 0x34
				#else
					SetSpindleEnablebit();
				#endif
		 }
		#else
			if (pwm_value == SPINDLE_PWM_OFF_VALUE) {
 8009bc0:	1dfb      	adds	r3, r7, #7
 8009bc2:	781b      	ldrb	r3, [r3, #0]
 8009bc4:	2b00      	cmp	r3, #0
 8009bc6:	d105      	bne.n	8009bd4 <spindle_set_speed+0x28>
			#endif
			#if defined (STM32F103C8)
				TIM_CtrlPWMOutputs(TIM1, DISABLE);
			#endif
			#if defined (STM32F0DISCOVERY)
				TIM_CtrlPWMOutputs(TIM1, DISABLE);
 8009bc8:	4b07      	ldr	r3, [pc, #28]	; (8009be8 <spindle_set_speed+0x3c>)
 8009bca:	2100      	movs	r1, #0
 8009bcc:	0018      	movs	r0, r3
 8009bce:	f7f9 fb79 	bl	80032c4 <TIM_CtrlPWMOutputs>
			#if defined (STM32F0DISCOVERY)
      TIM_CtrlPWMOutputs(TIM1, ENABLE);
			#endif
			}
		#endif
  }
 8009bd2:	e004      	b.n	8009bde <spindle_set_speed+0x32>
			#endif
			#if defined (STM32F103C8)
      TIM_CtrlPWMOutputs(TIM1, ENABLE);
			#endif
			#if defined (STM32F0DISCOVERY)
      TIM_CtrlPWMOutputs(TIM1, ENABLE);
 8009bd4:	4b04      	ldr	r3, [pc, #16]	; (8009be8 <spindle_set_speed+0x3c>)
 8009bd6:	2101      	movs	r1, #1
 8009bd8:	0018      	movs	r0, r3
 8009bda:	f7f9 fb73 	bl	80032c4 <TIM_CtrlPWMOutputs>
			#endif
			}
		#endif
  }
 8009bde:	46c0      	nop			; (mov r8, r8)
 8009be0:	46bd      	mov	sp, r7
 8009be2:	b002      	add	sp, #8
 8009be4:	bd80      	pop	{r7, pc}
 8009be6:	46c0      	nop			; (mov r8, r8)
 8009be8:	40012c00 	.word	0x40012c00

08009bec <spindle_compute_pwm_value>:


  // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
  SPINDLE_PWM_TYPE spindle_compute_pwm_value(float rpm) // 328p PWM register is 8-bit.
  {
 8009bec:	b580      	push	{r7, lr}
 8009bee:	b084      	sub	sp, #16
 8009bf0:	af00      	add	r7, sp, #0
 8009bf2:	6078      	str	r0, [r7, #4]
    SPINDLE_PWM_TYPE pwm_value;
    rpm *= (0.010f*sys.spindle_speed_ovr); // Scale by spindle speed override value.
 8009bf4:	4b38      	ldr	r3, [pc, #224]	; (8009cd8 <spindle_compute_pwm_value+0xec>)
 8009bf6:	7a5b      	ldrb	r3, [r3, #9]
 8009bf8:	0018      	movs	r0, r3
 8009bfa:	f7f7 f9dd 	bl	8000fb8 <__aeabi_i2f>
 8009bfe:	1c03      	adds	r3, r0, #0
 8009c00:	4936      	ldr	r1, [pc, #216]	; (8009cdc <spindle_compute_pwm_value+0xf0>)
 8009c02:	1c18      	adds	r0, r3, #0
 8009c04:	f7f6 ff04 	bl	8000a10 <__aeabi_fmul>
 8009c08:	1c03      	adds	r3, r0, #0
 8009c0a:	1c19      	adds	r1, r3, #0
 8009c0c:	6878      	ldr	r0, [r7, #4]
 8009c0e:	f7f6 feff 	bl	8000a10 <__aeabi_fmul>
 8009c12:	1c03      	adds	r3, r0, #0
 8009c14:	607b      	str	r3, [r7, #4]
    // Calculate PWM register value based on rpm max/min settings and programmed rpm.
    if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
 8009c16:	4b32      	ldr	r3, [pc, #200]	; (8009ce0 <spindle_compute_pwm_value+0xf4>)
 8009c18:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009c1a:	4b31      	ldr	r3, [pc, #196]	; (8009ce0 <spindle_compute_pwm_value+0xf4>)
 8009c1c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009c1e:	1c19      	adds	r1, r3, #0
 8009c20:	1c10      	adds	r0, r2, #0
 8009c22:	f7f6 fb75 	bl	8000310 <__aeabi_fcmpge>
 8009c26:	1e03      	subs	r3, r0, #0
 8009c28:	d107      	bne.n	8009c3a <spindle_compute_pwm_value+0x4e>
 8009c2a:	4b2d      	ldr	r3, [pc, #180]	; (8009ce0 <spindle_compute_pwm_value+0xf4>)
 8009c2c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009c2e:	6879      	ldr	r1, [r7, #4]
 8009c30:	1c18      	adds	r0, r3, #0
 8009c32:	f7f6 fb59 	bl	80002e8 <__aeabi_fcmple>
 8009c36:	1e03      	subs	r3, r0, #0
 8009c38:	d008      	beq.n	8009c4c <spindle_compute_pwm_value+0x60>
      // No PWM range possible. Set simple on/off spindle control pin state.
      sys.spindle_speed = settings.rpm_max;
 8009c3a:	4b29      	ldr	r3, [pc, #164]	; (8009ce0 <spindle_compute_pwm_value+0xf4>)
 8009c3c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8009c3e:	4b26      	ldr	r3, [pc, #152]	; (8009cd8 <spindle_compute_pwm_value+0xec>)
 8009c40:	611a      	str	r2, [r3, #16]
      pwm_value = SPINDLE_PWM_MAX_VALUE;
 8009c42:	230f      	movs	r3, #15
 8009c44:	18fb      	adds	r3, r7, r3
 8009c46:	2264      	movs	r2, #100	; 0x64
 8009c48:	701a      	strb	r2, [r3, #0]
 8009c4a:	e03d      	b.n	8009cc8 <spindle_compute_pwm_value+0xdc>
    } else if (rpm <= settings.rpm_min) {
 8009c4c:	4b24      	ldr	r3, [pc, #144]	; (8009ce0 <spindle_compute_pwm_value+0xf4>)
 8009c4e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009c50:	6879      	ldr	r1, [r7, #4]
 8009c52:	1c18      	adds	r0, r3, #0
 8009c54:	f7f6 fb5c 	bl	8000310 <__aeabi_fcmpge>
 8009c58:	1e03      	subs	r3, r0, #0
 8009c5a:	d016      	beq.n	8009c8a <spindle_compute_pwm_value+0x9e>
      if (rpm == 0.0f) { // S0 disables spindle
 8009c5c:	2100      	movs	r1, #0
 8009c5e:	6878      	ldr	r0, [r7, #4]
 8009c60:	f7f6 fb32 	bl	80002c8 <__aeabi_fcmpeq>
 8009c64:	1e03      	subs	r3, r0, #0
 8009c66:	d007      	beq.n	8009c78 <spindle_compute_pwm_value+0x8c>
        sys.spindle_speed = 0.0f;
 8009c68:	4b1b      	ldr	r3, [pc, #108]	; (8009cd8 <spindle_compute_pwm_value+0xec>)
 8009c6a:	2200      	movs	r2, #0
 8009c6c:	611a      	str	r2, [r3, #16]
        pwm_value = SPINDLE_PWM_OFF_VALUE;
 8009c6e:	230f      	movs	r3, #15
 8009c70:	18fb      	adds	r3, r7, r3
 8009c72:	2200      	movs	r2, #0
 8009c74:	701a      	strb	r2, [r3, #0]
 8009c76:	e027      	b.n	8009cc8 <spindle_compute_pwm_value+0xdc>
      } else { // Set minimum PWM output
        sys.spindle_speed = settings.rpm_min;
 8009c78:	4b19      	ldr	r3, [pc, #100]	; (8009ce0 <spindle_compute_pwm_value+0xf4>)
 8009c7a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009c7c:	4b16      	ldr	r3, [pc, #88]	; (8009cd8 <spindle_compute_pwm_value+0xec>)
 8009c7e:	611a      	str	r2, [r3, #16]
        pwm_value = SPINDLE_PWM_MIN_VALUE;
 8009c80:	230f      	movs	r3, #15
 8009c82:	18fb      	adds	r3, r7, r3
 8009c84:	2201      	movs	r2, #1
 8009c86:	701a      	strb	r2, [r3, #0]
 8009c88:	e01e      	b.n	8009cc8 <spindle_compute_pwm_value+0xdc>
      }
    } else { 
      // Compute intermediate PWM value with linear spindle speed model.
      // NOTE: A nonlinear model could be installed here, if required, but keep it VERY light-weight.
      sys.spindle_speed = rpm;
 8009c8a:	4b13      	ldr	r3, [pc, #76]	; (8009cd8 <spindle_compute_pwm_value+0xec>)
 8009c8c:	687a      	ldr	r2, [r7, #4]
 8009c8e:	611a      	str	r2, [r3, #16]
	    pwm_value = (SPINDLE_PWM_TYPE)floorf((rpm - settings.rpm_min)*pwm_gradient) + SPINDLE_PWM_MIN_VALUE;
 8009c90:	4b13      	ldr	r3, [pc, #76]	; (8009ce0 <spindle_compute_pwm_value+0xf4>)
 8009c92:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009c94:	1c19      	adds	r1, r3, #0
 8009c96:	6878      	ldr	r0, [r7, #4]
 8009c98:	f7f6 ffce 	bl	8000c38 <__aeabi_fsub>
 8009c9c:	1c03      	adds	r3, r0, #0
 8009c9e:	1c1a      	adds	r2, r3, #0
 8009ca0:	4b10      	ldr	r3, [pc, #64]	; (8009ce4 <spindle_compute_pwm_value+0xf8>)
 8009ca2:	681b      	ldr	r3, [r3, #0]
 8009ca4:	1c19      	adds	r1, r3, #0
 8009ca6:	1c10      	adds	r0, r2, #0
 8009ca8:	f7f6 feb2 	bl	8000a10 <__aeabi_fmul>
 8009cac:	1c03      	adds	r3, r0, #0
 8009cae:	1c18      	adds	r0, r3, #0
 8009cb0:	f002 fb1a 	bl	800c2e8 <floorf>
 8009cb4:	1c03      	adds	r3, r0, #0
 8009cb6:	1c18      	adds	r0, r3, #0
 8009cb8:	f7f6 fb34 	bl	8000324 <__aeabi_f2uiz>
 8009cbc:	0003      	movs	r3, r0
 8009cbe:	b2da      	uxtb	r2, r3
 8009cc0:	230f      	movs	r3, #15
 8009cc2:	18fb      	adds	r3, r7, r3
 8009cc4:	3201      	adds	r2, #1
 8009cc6:	701a      	strb	r2, [r3, #0]
    }
    return(pwm_value);
 8009cc8:	230f      	movs	r3, #15
 8009cca:	18fb      	adds	r3, r7, r3
 8009ccc:	781b      	ldrb	r3, [r3, #0]
  }
 8009cce:	0018      	movs	r0, r3
 8009cd0:	46bd      	mov	sp, r7
 8009cd2:	b004      	add	sp, #16
 8009cd4:	bd80      	pop	{r7, pc}
 8009cd6:	46c0      	nop			; (mov r8, r8)
 8009cd8:	20000b2c 	.word	0x20000b2c
 8009cdc:	3c23d70a 	.word	0x3c23d70a
 8009ce0:	20000acc 	.word	0x20000acc
 8009ce4:	2000044c 	.word	0x2000044c

08009ce8 <spindle_set_state>:
#ifdef VARIABLE_SPINDLE
  void spindle_set_state(uint8_t state, float rpm)
#else
  void _spindle_set_state(uint8_t state)
#endif
{
 8009ce8:	b580      	push	{r7, lr}
 8009cea:	b082      	sub	sp, #8
 8009cec:	af00      	add	r7, sp, #0
 8009cee:	0002      	movs	r2, r0
 8009cf0:	6039      	str	r1, [r7, #0]
 8009cf2:	1dfb      	adds	r3, r7, #7
 8009cf4:	701a      	strb	r2, [r3, #0]
  if (sys.abort) { return; } // Block during abort.
 8009cf6:	4b1e      	ldr	r3, [pc, #120]	; (8009d70 <spindle_set_state+0x88>)
 8009cf8:	785b      	ldrb	r3, [r3, #1]
 8009cfa:	2b00      	cmp	r3, #0
 8009cfc:	d133      	bne.n	8009d66 <spindle_set_state+0x7e>
  if (state == SPINDLE_DISABLE) { // Halt or set spindle direction and rpm.
 8009cfe:	1dfb      	adds	r3, r7, #7
 8009d00:	781b      	ldrb	r3, [r3, #0]
 8009d02:	2b00      	cmp	r3, #0
 8009d04:	d105      	bne.n	8009d12 <spindle_set_state+0x2a>
  
    #ifdef VARIABLE_SPINDLE
      sys.spindle_speed = 0.0f;
 8009d06:	4b1a      	ldr	r3, [pc, #104]	; (8009d70 <spindle_set_state+0x88>)
 8009d08:	2200      	movs	r2, #0
 8009d0a:	611a      	str	r2, [r3, #16]
    #endif
    spindle_stop();
 8009d0c:	f7ff ff42 	bl	8009b94 <spindle_stop>
 8009d10:	e025      	b.n	8009d5e <spindle_set_state+0x76>
  
  } else {
    #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
      if (state == SPINDLE_ENABLE_CW) {
 8009d12:	1dfb      	adds	r3, r7, #7
 8009d14:	781b      	ldrb	r3, [r3, #0]
 8009d16:	2b10      	cmp	r3, #16
 8009d18:	d106      	bne.n	8009d28 <spindle_set_state+0x40>
        ResetSpindleDirectionBit();
 8009d1a:	4b16      	ldr	r3, [pc, #88]	; (8009d74 <spindle_set_state+0x8c>)
 8009d1c:	2200      	movs	r2, #0
 8009d1e:	2102      	movs	r1, #2
 8009d20:	0018      	movs	r0, r3
 8009d22:	f7f8 fee7 	bl	8002af4 <GPIO_WriteBit>
 8009d26:	e005      	b.n	8009d34 <spindle_set_state+0x4c>
	  }
	  else {
      SetSpindleDirectionBit();
 8009d28:	4b12      	ldr	r3, [pc, #72]	; (8009d74 <spindle_set_state+0x8c>)
 8009d2a:	2201      	movs	r2, #1
 8009d2c:	2102      	movs	r1, #2
 8009d2e:	0018      	movs	r0, r3
 8009d30:	f7f8 fee0 	bl	8002af4 <GPIO_WriteBit>
      }
    #endif
  
    #ifdef VARIABLE_SPINDLE
      // NOTE: Assumes all calls to this function is when Grbl is not moving or must remain off.
      if (settings.flags & BITFLAG_LASER_MODE) {
 8009d34:	4b10      	ldr	r3, [pc, #64]	; (8009d78 <spindle_set_state+0x90>)
 8009d36:	2248      	movs	r2, #72	; 0x48
 8009d38:	5c9b      	ldrb	r3, [r3, r2]
 8009d3a:	001a      	movs	r2, r3
 8009d3c:	2302      	movs	r3, #2
 8009d3e:	4013      	ands	r3, r2
 8009d40:	d005      	beq.n	8009d4e <spindle_set_state+0x66>
        if (state == SPINDLE_ENABLE_CCW) { rpm = 0.0f; } // TODO: May need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE);
 8009d42:	1dfb      	adds	r3, r7, #7
 8009d44:	781b      	ldrb	r3, [r3, #0]
 8009d46:	2b20      	cmp	r3, #32
 8009d48:	d101      	bne.n	8009d4e <spindle_set_state+0x66>
 8009d4a:	2300      	movs	r3, #0
 8009d4c:	603b      	str	r3, [r7, #0]
      }
    spindle_set_speed(spindle_compute_pwm_value(rpm));
 8009d4e:	683b      	ldr	r3, [r7, #0]
 8009d50:	1c18      	adds	r0, r3, #0
 8009d52:	f7ff ff4b 	bl	8009bec <spindle_compute_pwm_value>
 8009d56:	0003      	movs	r3, r0
 8009d58:	0018      	movs	r0, r3
 8009d5a:	f7ff ff27 	bl	8009bac <spindle_set_speed>
        SetSpindleEnablebit();
      #endif    
    #endif
  }
  
  sys.report_ovr_counter = 0; // Set to report change immediately
 8009d5e:	4b04      	ldr	r3, [pc, #16]	; (8009d70 <spindle_set_state+0x88>)
 8009d60:	2200      	movs	r2, #0
 8009d62:	72da      	strb	r2, [r3, #11]
 8009d64:	e000      	b.n	8009d68 <spindle_set_state+0x80>
  void spindle_set_state(uint8_t state, float rpm)
#else
  void _spindle_set_state(uint8_t state)
#endif
{
  if (sys.abort) { return; } // Block during abort.
 8009d66:	46c0      	nop			; (mov r8, r8)
      #endif    
    #endif
  }
  
  sys.report_ovr_counter = 0; // Set to report change immediately
}
 8009d68:	46bd      	mov	sp, r7
 8009d6a:	b002      	add	sp, #8
 8009d6c:	bd80      	pop	{r7, pc}
 8009d6e:	46c0      	nop			; (mov r8, r8)
 8009d70:	20000b2c 	.word	0x20000b2c
 8009d74:	48000400 	.word	0x48000400
 8009d78:	20000acc 	.word	0x20000acc

08009d7c <spindle_sync>:

// G-code parser entry-point for setting spindle state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
#ifdef VARIABLE_SPINDLE
  void spindle_sync(uint8_t state, float rpm)
  {
 8009d7c:	b580      	push	{r7, lr}
 8009d7e:	b082      	sub	sp, #8
 8009d80:	af00      	add	r7, sp, #0
 8009d82:	0002      	movs	r2, r0
 8009d84:	6039      	str	r1, [r7, #0]
 8009d86:	1dfb      	adds	r3, r7, #7
 8009d88:	701a      	strb	r2, [r3, #0]
    if (sys.state == STATE_CHECK_MODE) { return; }
 8009d8a:	4b09      	ldr	r3, [pc, #36]	; (8009db0 <spindle_sync+0x34>)
 8009d8c:	781b      	ldrb	r3, [r3, #0]
 8009d8e:	2b02      	cmp	r3, #2
 8009d90:	d009      	beq.n	8009da6 <spindle_sync+0x2a>
    protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.
 8009d92:	f7fd fda3 	bl	80078dc <protocol_buffer_synchronize>
    spindle_set_state(state,rpm);
 8009d96:	683a      	ldr	r2, [r7, #0]
 8009d98:	1dfb      	adds	r3, r7, #7
 8009d9a:	781b      	ldrb	r3, [r3, #0]
 8009d9c:	1c11      	adds	r1, r2, #0
 8009d9e:	0018      	movs	r0, r3
 8009da0:	f7ff ffa2 	bl	8009ce8 <spindle_set_state>
 8009da4:	e000      	b.n	8009da8 <spindle_sync+0x2c>
// G-code parser entry-point for setting spindle state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
#ifdef VARIABLE_SPINDLE
  void spindle_sync(uint8_t state, float rpm)
  {
    if (sys.state == STATE_CHECK_MODE) { return; }
 8009da6:	46c0      	nop			; (mov r8, r8)
    protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.
    spindle_set_state(state,rpm);
  }
 8009da8:	46bd      	mov	sp, r7
 8009daa:	b002      	add	sp, #8
 8009dac:	bd80      	pop	{r7, pc}
 8009dae:	46c0      	nop			; (mov r8, r8)
 8009db0:	20000b2c 	.word	0x20000b2c

08009db4 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8009db4:	b580      	push	{r7, lr}
 8009db6:	b082      	sub	sp, #8
 8009db8:	af00      	add	r7, sp, #0
 8009dba:	0002      	movs	r2, r0
 8009dbc:	1dfb      	adds	r3, r7, #7
 8009dbe:	701a      	strb	r2, [r3, #0]
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 8009dc0:	4b06      	ldr	r3, [pc, #24]	; (8009ddc <NVIC_EnableIRQ+0x28>)
 8009dc2:	1dfa      	adds	r2, r7, #7
 8009dc4:	7812      	ldrb	r2, [r2, #0]
 8009dc6:	0011      	movs	r1, r2
 8009dc8:	221f      	movs	r2, #31
 8009dca:	400a      	ands	r2, r1
 8009dcc:	2101      	movs	r1, #1
 8009dce:	4091      	lsls	r1, r2
 8009dd0:	000a      	movs	r2, r1
 8009dd2:	601a      	str	r2, [r3, #0]
}
 8009dd4:	46c0      	nop			; (mov r8, r8)
 8009dd6:	46bd      	mov	sp, r7
 8009dd8:	b002      	add	sp, #8
 8009dda:	bd80      	pop	{r7, pc}
 8009ddc:	e000e100 	.word	0xe000e100

08009de0 <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8009de0:	b580      	push	{r7, lr}
 8009de2:	b082      	sub	sp, #8
 8009de4:	af00      	add	r7, sp, #0
 8009de6:	0002      	movs	r2, r0
 8009de8:	1dfb      	adds	r3, r7, #7
 8009dea:	701a      	strb	r2, [r3, #0]
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 8009dec:	4a07      	ldr	r2, [pc, #28]	; (8009e0c <NVIC_DisableIRQ+0x2c>)
 8009dee:	1dfb      	adds	r3, r7, #7
 8009df0:	781b      	ldrb	r3, [r3, #0]
 8009df2:	0019      	movs	r1, r3
 8009df4:	231f      	movs	r3, #31
 8009df6:	400b      	ands	r3, r1
 8009df8:	2101      	movs	r1, #1
 8009dfa:	4099      	lsls	r1, r3
 8009dfc:	000b      	movs	r3, r1
 8009dfe:	0019      	movs	r1, r3
 8009e00:	2380      	movs	r3, #128	; 0x80
 8009e02:	50d1      	str	r1, [r2, r3]
}
 8009e04:	46c0      	nop			; (mov r8, r8)
 8009e06:	46bd      	mov	sp, r7
 8009e08:	b002      	add	sp, #8
 8009e0a:	bd80      	pop	{r7, pc}
 8009e0c:	e000e100 	.word	0xe000e100

08009e10 <st_wake_up>:


// Stepper state initialization. Cycle should only start if the st.cycle_start flag is
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up()
{
 8009e10:	b580      	push	{r7, lr}
 8009e12:	af00      	add	r7, sp, #0
  // Enable stepper drivers.
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) 
 8009e14:	4b0d      	ldr	r3, [pc, #52]	; (8009e4c <st_wake_up+0x3c>)
 8009e16:	2248      	movs	r2, #72	; 0x48
 8009e18:	5c9b      	ldrb	r3, [r3, r2]
 8009e1a:	001a      	movs	r2, r3
 8009e1c:	2304      	movs	r3, #4
 8009e1e:	4013      	ands	r3, r2
 8009e20:	d006      	beq.n	8009e30 <st_wake_up+0x20>
  { 
	  SetStepperDisableBit();
 8009e22:	2390      	movs	r3, #144	; 0x90
 8009e24:	05db      	lsls	r3, r3, #23
 8009e26:	2140      	movs	r1, #64	; 0x40
 8009e28:	0018      	movs	r0, r3
 8009e2a:	f7f8 fe43 	bl	8002ab4 <GPIO_SetBits>
 8009e2e:	e005      	b.n	8009e3c <st_wake_up+0x2c>
  }
  else 
  { 
	  ResetStepperDisableBit(); 
 8009e30:	2390      	movs	r3, #144	; 0x90
 8009e32:	05db      	lsls	r3, r3, #23
 8009e34:	2140      	movs	r1, #64	; 0x40
 8009e36:	0018      	movs	r0, r3
 8009e38:	f7f8 fe4c 	bl	8002ad4 <GPIO_ResetBits>
  }

  // Initialize stepper output bits to ensure first ISR call does not step.
  st.step_outbits = step_port_invert_mask;
 8009e3c:	4b04      	ldr	r3, [pc, #16]	; (8009e50 <st_wake_up+0x40>)
 8009e3e:	881a      	ldrh	r2, [r3, #0]
 8009e40:	4b04      	ldr	r3, [pc, #16]	; (8009e54 <st_wake_up+0x44>)
 8009e42:	81da      	strh	r2, [r3, #14]
  TIM2->PSC = st.exec_segment->prescaler;
#endif
  TIM2->EGR = TIM_PSCReloadMode_Immediate;
  NVIC_EnableIRQ(TIM2_IRQn);
#endif
}
 8009e44:	46c0      	nop			; (mov r8, r8)
 8009e46:	46bd      	mov	sp, r7
 8009e48:	bd80      	pop	{r7, pc}
 8009e4a:	46c0      	nop			; (mov r8, r8)
 8009e4c:	20000acc 	.word	0x20000acc
 8009e50:	20000514 	.word	0x20000514
 8009e54:	200004e4 	.word	0x200004e4

08009e58 <st_go_idle>:


// Stepper shutdown
void st_go_idle()
{
 8009e58:	b580      	push	{r7, lr}
 8009e5a:	b082      	sub	sp, #8
 8009e5c:	af00      	add	r7, sp, #0
#endif
#ifdef STM32F103C8
  NVIC_DisableIRQ(TIM2_IRQn);
#endif
#ifdef STM32F0DISCOVERY
  NVIC_DisableIRQ(TIM2_IRQn);
 8009e5e:	200f      	movs	r0, #15
 8009e60:	f7ff ffbe 	bl	8009de0 <NVIC_DisableIRQ>
#endif

  busy = false;
 8009e64:	4b1f      	ldr	r3, [pc, #124]	; (8009ee4 <st_go_idle+0x8c>)
 8009e66:	2200      	movs	r2, #0
 8009e68:	701a      	strb	r2, [r3, #0]

  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
 8009e6a:	2300      	movs	r3, #0
 8009e6c:	607b      	str	r3, [r7, #4]
  if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
 8009e6e:	4b1e      	ldr	r3, [pc, #120]	; (8009ee8 <st_go_idle+0x90>)
 8009e70:	2233      	movs	r2, #51	; 0x33
 8009e72:	5c9b      	ldrb	r3, [r3, r2]
 8009e74:	2bff      	cmp	r3, #255	; 0xff
 8009e76:	d108      	bne.n	8009e8a <st_go_idle+0x32>
 8009e78:	4b1c      	ldr	r3, [pc, #112]	; (8009eec <st_go_idle+0x94>)
 8009e7a:	781b      	ldrb	r3, [r3, #0]
 8009e7c:	b2db      	uxtb	r3, r3
 8009e7e:	2b00      	cmp	r3, #0
 8009e80:	d103      	bne.n	8009e8a <st_go_idle+0x32>
 8009e82:	4b1b      	ldr	r3, [pc, #108]	; (8009ef0 <st_go_idle+0x98>)
 8009e84:	781b      	ldrb	r3, [r3, #0]
 8009e86:	2b80      	cmp	r3, #128	; 0x80
 8009e88:	d10c      	bne.n	8009ea4 <st_go_idle+0x4c>
 8009e8a:	4b19      	ldr	r3, [pc, #100]	; (8009ef0 <st_go_idle+0x98>)
 8009e8c:	781b      	ldrb	r3, [r3, #0]
 8009e8e:	2b04      	cmp	r3, #4
 8009e90:	d008      	beq.n	8009ea4 <st_go_idle+0x4c>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
 8009e92:	4b15      	ldr	r3, [pc, #84]	; (8009ee8 <st_go_idle+0x90>)
 8009e94:	2233      	movs	r2, #51	; 0x33
 8009e96:	5c9b      	ldrb	r3, [r3, r2]
 8009e98:	b29b      	uxth	r3, r3
 8009e9a:	0018      	movs	r0, r3
 8009e9c:	f7fc fba2 	bl	80065e4 <delay_ms>
    pin_state = true; // Override. Disable steppers.
 8009ea0:	2301      	movs	r3, #1
 8009ea2:	607b      	str	r3, [r7, #4]
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
 8009ea4:	4b10      	ldr	r3, [pc, #64]	; (8009ee8 <st_go_idle+0x90>)
 8009ea6:	2248      	movs	r2, #72	; 0x48
 8009ea8:	5c9b      	ldrb	r3, [r3, r2]
 8009eaa:	001a      	movs	r2, r3
 8009eac:	2304      	movs	r3, #4
 8009eae:	4013      	ands	r3, r2
 8009eb0:	d004      	beq.n	8009ebc <st_go_idle+0x64>
 8009eb2:	687b      	ldr	r3, [r7, #4]
 8009eb4:	425a      	negs	r2, r3
 8009eb6:	4153      	adcs	r3, r2
 8009eb8:	b2db      	uxtb	r3, r3
 8009eba:	607b      	str	r3, [r7, #4]
  if (pin_state) 
 8009ebc:	687b      	ldr	r3, [r7, #4]
 8009ebe:	2b00      	cmp	r3, #0
 8009ec0:	d006      	beq.n	8009ed0 <st_go_idle+0x78>
  { 
	  SetStepperDisableBit();
 8009ec2:	2390      	movs	r3, #144	; 0x90
 8009ec4:	05db      	lsls	r3, r3, #23
 8009ec6:	2140      	movs	r1, #64	; 0x40
 8009ec8:	0018      	movs	r0, r3
 8009eca:	f7f8 fdf3 	bl	8002ab4 <GPIO_SetBits>
  }
  else 
  { 
	  ResetStepperDisableBit();
  }
}
 8009ece:	e005      	b.n	8009edc <st_go_idle+0x84>
  { 
	  SetStepperDisableBit();
  }
  else 
  { 
	  ResetStepperDisableBit();
 8009ed0:	2390      	movs	r3, #144	; 0x90
 8009ed2:	05db      	lsls	r3, r3, #23
 8009ed4:	2140      	movs	r1, #64	; 0x40
 8009ed6:	0018      	movs	r0, r3
 8009ed8:	f7f8 fdfc 	bl	8002ad4 <GPIO_ResetBits>
  }
}
 8009edc:	46c0      	nop			; (mov r8, r8)
 8009ede:	46bd      	mov	sp, r7
 8009ee0:	b002      	add	sp, #8
 8009ee2:	bd80      	pop	{r7, pc}
 8009ee4:	20000518 	.word	0x20000518
 8009ee8:	20000acc 	.word	0x20000acc
 8009eec:	20000b5c 	.word	0x20000b5c
 8009ef0:	20000b2c 	.word	0x20000b2c

08009ef4 <TIM2_IRQHandler>:
ISR(TIMER1_COMPA_vect)
#endif
#ifdef WIN32
void Timer1Proc()
#endif
{
 8009ef4:	b580      	push	{r7, lr}
 8009ef6:	b082      	sub	sp, #8
 8009ef8:	af00      	add	r7, sp, #0
	{
		return;
	}
#endif
#ifdef STM32F0DISCOVERY
	if ((TIM2->SR & 0x0001) != 0)                  // check interrupt source
 8009efa:	2380      	movs	r3, #128	; 0x80
 8009efc:	05db      	lsls	r3, r3, #23
 8009efe:	8a1b      	ldrh	r3, [r3, #16]
 8009f00:	b29b      	uxth	r3, r3
 8009f02:	001a      	movs	r2, r3
 8009f04:	2301      	movs	r3, #1
 8009f06:	4013      	ands	r3, r2
 8009f08:	d100      	bne.n	8009f0c <TIM2_IRQHandler+0x18>
 8009f0a:	e19d      	b.n	800a248 <TIM2_IRQHandler+0x354>
	{
		TIM2->SR &= ~(1 << 0);                          // clear UIF flag
 8009f0c:	2380      	movs	r3, #128	; 0x80
 8009f0e:	05db      	lsls	r3, r3, #23
 8009f10:	2280      	movs	r2, #128	; 0x80
 8009f12:	05d2      	lsls	r2, r2, #23
 8009f14:	8a12      	ldrh	r2, [r2, #16]
 8009f16:	b292      	uxth	r2, r2
 8009f18:	2101      	movs	r1, #1
 8009f1a:	438a      	bics	r2, r1
 8009f1c:	b292      	uxth	r2, r2
 8009f1e:	821a      	strh	r2, [r3, #16]
		TIM2->CNT = 0;
 8009f20:	2380      	movs	r3, #128	; 0x80
 8009f22:	05db      	lsls	r3, r3, #23
 8009f24:	2200      	movs	r2, #0
 8009f26:	625a      	str	r2, [r3, #36]	; 0x24
	{
		return;
	}
#endif

  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
 8009f28:	4bca      	ldr	r3, [pc, #808]	; (800a254 <TIM2_IRQHandler+0x360>)
 8009f2a:	781b      	ldrb	r3, [r3, #0]
 8009f2c:	b2db      	uxtb	r3, r3
 8009f2e:	2b00      	cmp	r3, #0
 8009f30:	d000      	beq.n	8009f34 <TIM2_IRQHandler+0x40>
 8009f32:	e18b      	b.n	800a24c <TIM2_IRQHandler+0x358>
#ifdef STM32F103C8
  GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK));
  TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
#endif
#ifdef STM32F0DISCOVERY
  GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK));
 8009f34:	2390      	movs	r3, #144	; 0x90
 8009f36:	05db      	lsls	r3, r3, #23
 8009f38:	0018      	movs	r0, r3
 8009f3a:	f7f8 fdaf 	bl	8002a9c <GPIO_ReadOutputData>
 8009f3e:	0003      	movs	r3, r0
 8009f40:	b21b      	sxth	r3, r3
 8009f42:	2238      	movs	r2, #56	; 0x38
 8009f44:	4393      	bics	r3, r2
 8009f46:	b21a      	sxth	r2, r3
 8009f48:	4bc3      	ldr	r3, [pc, #780]	; (800a258 <TIM2_IRQHandler+0x364>)
 8009f4a:	8a1b      	ldrh	r3, [r3, #16]
 8009f4c:	b21b      	sxth	r3, r3
 8009f4e:	2138      	movs	r1, #56	; 0x38
 8009f50:	400b      	ands	r3, r1
 8009f52:	b21b      	sxth	r3, r3
 8009f54:	4313      	orrs	r3, r2
 8009f56:	b21b      	sxth	r3, r3
 8009f58:	b29a      	uxth	r2, r3
 8009f5a:	2390      	movs	r3, #144	; 0x90
 8009f5c:	05db      	lsls	r3, r3, #23
 8009f5e:	0011      	movs	r1, r2
 8009f60:	0018      	movs	r0, r3
 8009f62:	f7f8 fde5 	bl	8002b30 <GPIO_Write>
  TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
 8009f66:	4bbd      	ldr	r3, [pc, #756]	; (800a25c <TIM2_IRQHandler+0x368>)
 8009f68:	2101      	movs	r1, #1
 8009f6a:	0018      	movs	r0, r3
 8009f6c:	f7f9 faf6 	bl	800355c <TIM_ClearITPendingBit>
#endif
#ifdef STM32F103C8
	GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | st.step_outbits);
#endif
#ifdef STM32F0DISCOVERY
	GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | st.step_outbits);
 8009f70:	2390      	movs	r3, #144	; 0x90
 8009f72:	05db      	lsls	r3, r3, #23
 8009f74:	0018      	movs	r0, r3
 8009f76:	f7f8 fd91 	bl	8002a9c <GPIO_ReadOutputData>
 8009f7a:	0003      	movs	r3, r0
 8009f7c:	b21b      	sxth	r3, r3
 8009f7e:	2207      	movs	r2, #7
 8009f80:	4393      	bics	r3, r2
 8009f82:	b21a      	sxth	r2, r3
 8009f84:	4bb4      	ldr	r3, [pc, #720]	; (800a258 <TIM2_IRQHandler+0x364>)
 8009f86:	89db      	ldrh	r3, [r3, #14]
 8009f88:	b21b      	sxth	r3, r3
 8009f8a:	4313      	orrs	r3, r2
 8009f8c:	b21b      	sxth	r3, r3
 8009f8e:	b29a      	uxth	r2, r3
 8009f90:	2390      	movs	r3, #144	; 0x90
 8009f92:	05db      	lsls	r3, r3, #23
 8009f94:	0011      	movs	r1, r2
 8009f96:	0018      	movs	r0, r3
 8009f98:	f7f8 fdca 	bl	8002b30 <GPIO_Write>
#endif
#ifdef STM32F103C8
  NVIC_EnableIRQ(TIM3_IRQn);
#endif
#ifdef STM32F0DISCOVERY
  NVIC_EnableIRQ(TIM3_IRQn);
 8009f9c:	2010      	movs	r0, #16
 8009f9e:	f7ff ff09 	bl	8009db4 <NVIC_EnableIRQ>
#endif

  busy = true;
 8009fa2:	4bac      	ldr	r3, [pc, #688]	; (800a254 <TIM2_IRQHandler+0x360>)
 8009fa4:	2201      	movs	r2, #1
 8009fa6:	701a      	strb	r2, [r3, #0]
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time.
         // NOTE: The remaining code in this ISR will finish before returning to main program.
#endif

  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
 8009fa8:	4bab      	ldr	r3, [pc, #684]	; (800a258 <TIM2_IRQHandler+0x364>)
 8009faa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009fac:	2b00      	cmp	r3, #0
 8009fae:	d000      	beq.n	8009fb2 <TIM2_IRQHandler+0xbe>
 8009fb0:	e07c      	b.n	800a0ac <TIM2_IRQHandler+0x1b8>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
 8009fb2:	4bab      	ldr	r3, [pc, #684]	; (800a260 <TIM2_IRQHandler+0x36c>)
 8009fb4:	781a      	ldrb	r2, [r3, #0]
 8009fb6:	4bab      	ldr	r3, [pc, #684]	; (800a264 <TIM2_IRQHandler+0x370>)
 8009fb8:	781b      	ldrb	r3, [r3, #0]
 8009fba:	b2db      	uxtb	r3, r3
 8009fbc:	429a      	cmp	r2, r3
 8009fbe:	d067      	beq.n	800a090 <TIM2_IRQHandler+0x19c>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
 8009fc0:	4ba8      	ldr	r3, [pc, #672]	; (800a264 <TIM2_IRQHandler+0x370>)
 8009fc2:	781b      	ldrb	r3, [r3, #0]
 8009fc4:	b2db      	uxtb	r3, r3
 8009fc6:	00da      	lsls	r2, r3, #3
 8009fc8:	4ba7      	ldr	r3, [pc, #668]	; (800a268 <TIM2_IRQHandler+0x374>)
 8009fca:	18d2      	adds	r2, r2, r3
 8009fcc:	4ba2      	ldr	r3, [pc, #648]	; (800a258 <TIM2_IRQHandler+0x364>)
 8009fce:	629a      	str	r2, [r3, #40]	; 0x28
#ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
	  TIM2->PSC = st.exec_segment->prescaler;
#endif
#endif
#ifdef STM32F0DISCOVERY
	  TIM2->ARR = st.exec_segment->cycles_per_tick - 1;
 8009fd0:	2380      	movs	r3, #128	; 0x80
 8009fd2:	05db      	lsls	r3, r3, #23
 8009fd4:	4aa0      	ldr	r2, [pc, #640]	; (800a258 <TIM2_IRQHandler+0x364>)
 8009fd6:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8009fd8:	8852      	ldrh	r2, [r2, #2]
 8009fda:	3a01      	subs	r2, #1
 8009fdc:	62da      	str	r2, [r3, #44]	; 0x2c
	  /* Set the Autoreload value */
#ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
	  TIM2->PSC = st.exec_segment->prescaler;
#endif
#endif
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
 8009fde:	4b9e      	ldr	r3, [pc, #632]	; (800a258 <TIM2_IRQHandler+0x364>)
 8009fe0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009fe2:	881a      	ldrh	r2, [r3, #0]
 8009fe4:	4b9c      	ldr	r3, [pc, #624]	; (800a258 <TIM2_IRQHandler+0x364>)
 8009fe6:	841a      	strh	r2, [r3, #32]
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
 8009fe8:	4b9b      	ldr	r3, [pc, #620]	; (800a258 <TIM2_IRQHandler+0x364>)
 8009fea:	2222      	movs	r2, #34	; 0x22
 8009fec:	5c9a      	ldrb	r2, [r3, r2]
 8009fee:	4b9a      	ldr	r3, [pc, #616]	; (800a258 <TIM2_IRQHandler+0x364>)
 8009ff0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009ff2:	791b      	ldrb	r3, [r3, #4]
 8009ff4:	429a      	cmp	r2, r3
 8009ff6:	d01f      	beq.n	800a038 <TIM2_IRQHandler+0x144>
        st.exec_block_index = st.exec_segment->st_block_index;
 8009ff8:	4b97      	ldr	r3, [pc, #604]	; (800a258 <TIM2_IRQHandler+0x364>)
 8009ffa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009ffc:	7919      	ldrb	r1, [r3, #4]
 8009ffe:	4b96      	ldr	r3, [pc, #600]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a000:	2222      	movs	r2, #34	; 0x22
 800a002:	5499      	strb	r1, [r3, r2]
        st.exec_block = &st_block_buffer[st.exec_block_index];
 800a004:	4b94      	ldr	r3, [pc, #592]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a006:	2222      	movs	r2, #34	; 0x22
 800a008:	5c9b      	ldrb	r3, [r3, r2]
 800a00a:	001a      	movs	r2, r3
 800a00c:	0013      	movs	r3, r2
 800a00e:	009b      	lsls	r3, r3, #2
 800a010:	189b      	adds	r3, r3, r2
 800a012:	009b      	lsls	r3, r3, #2
 800a014:	4a95      	ldr	r2, [pc, #596]	; (800a26c <TIM2_IRQHandler+0x378>)
 800a016:	189a      	adds	r2, r3, r2
 800a018:	4b8f      	ldr	r3, [pc, #572]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a01a:	625a      	str	r2, [r3, #36]	; 0x24

        // Initialize Bresenham line and distance counters
        st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
 800a01c:	4b8e      	ldr	r3, [pc, #568]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a01e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a020:	68db      	ldr	r3, [r3, #12]
 800a022:	085a      	lsrs	r2, r3, #1
 800a024:	4b8c      	ldr	r3, [pc, #560]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a026:	609a      	str	r2, [r3, #8]
 800a028:	4b8b      	ldr	r3, [pc, #556]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a02a:	689a      	ldr	r2, [r3, #8]
 800a02c:	4b8a      	ldr	r3, [pc, #552]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a02e:	605a      	str	r2, [r3, #4]
 800a030:	4b89      	ldr	r3, [pc, #548]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a032:	685a      	ldr	r2, [r3, #4]
 800a034:	4b88      	ldr	r3, [pc, #544]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a036:	601a      	str	r2, [r3, #0]
      }
      st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask;
 800a038:	4b87      	ldr	r3, [pc, #540]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a03a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a03c:	7c1b      	ldrb	r3, [r3, #16]
 800a03e:	b29a      	uxth	r2, r3
 800a040:	4b8b      	ldr	r3, [pc, #556]	; (800a270 <TIM2_IRQHandler+0x37c>)
 800a042:	881b      	ldrh	r3, [r3, #0]
 800a044:	4053      	eors	r3, r2
 800a046:	b29a      	uxth	r2, r3
 800a048:	4b83      	ldr	r3, [pc, #524]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a04a:	821a      	strh	r2, [r3, #16]

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
 800a04c:	4b82      	ldr	r3, [pc, #520]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a04e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a050:	681a      	ldr	r2, [r3, #0]
 800a052:	4b81      	ldr	r3, [pc, #516]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a054:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a056:	795b      	ldrb	r3, [r3, #5]
 800a058:	40da      	lsrs	r2, r3
 800a05a:	4b7f      	ldr	r3, [pc, #508]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a05c:	615a      	str	r2, [r3, #20]
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
 800a05e:	4b7e      	ldr	r3, [pc, #504]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a060:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a062:	685a      	ldr	r2, [r3, #4]
 800a064:	4b7c      	ldr	r3, [pc, #496]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a066:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a068:	795b      	ldrb	r3, [r3, #5]
 800a06a:	40da      	lsrs	r2, r3
 800a06c:	4b7a      	ldr	r3, [pc, #488]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a06e:	619a      	str	r2, [r3, #24]
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
 800a070:	4b79      	ldr	r3, [pc, #484]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a072:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a074:	689a      	ldr	r2, [r3, #8]
 800a076:	4b78      	ldr	r3, [pc, #480]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a078:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a07a:	795b      	ldrb	r3, [r3, #5]
 800a07c:	40da      	lsrs	r2, r3
 800a07e:	4b76      	ldr	r3, [pc, #472]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a080:	61da      	str	r2, [r3, #28]
      #endif

      #ifdef VARIABLE_SPINDLE
        // Set real-time spindle output as segment is loaded, just prior to the first step.
        spindle_set_speed(st.exec_segment->spindle_pwm);
 800a082:	4b75      	ldr	r3, [pc, #468]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a084:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a086:	799b      	ldrb	r3, [r3, #6]
 800a088:	0018      	movs	r0, r3
 800a08a:	f7ff fd8f 	bl	8009bac <spindle_set_speed>
 800a08e:	e00d      	b.n	800a0ac <TIM2_IRQHandler+0x1b8>
      #endif

    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
 800a090:	f7ff fee2 	bl	8009e58 <st_go_idle>
      // Ensure pwm is set properly upon completion of rate-controlled motion.
      #ifdef VARIABLE_SPINDLE
      if (st.exec_block->is_pwm_rate_adjusted) { spindle_set_speed(SPINDLE_PWM_OFF_VALUE); }
 800a094:	4b70      	ldr	r3, [pc, #448]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a096:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a098:	7c5b      	ldrb	r3, [r3, #17]
 800a09a:	2b00      	cmp	r3, #0
 800a09c:	d002      	beq.n	800a0a4 <TIM2_IRQHandler+0x1b0>
 800a09e:	2000      	movs	r0, #0
 800a0a0:	f7ff fd84 	bl	8009bac <spindle_set_speed>
      #endif
      system_set_exec_state_flag(EXEC_CYCLE_STOP); // Flag main program for cycle end
 800a0a4:	2004      	movs	r0, #4
 800a0a6:	f001 fca5 	bl	800b9f4 <system_set_exec_state_flag>
      return; // Nothing to do but exit.
 800a0aa:	e0d0      	b.n	800a24e <TIM2_IRQHandler+0x35a>
    }
  }


  // Check probing state.
  if (sys_probe_state == PROBE_ACTIVE) { probe_state_monitor(); }
 800a0ac:	4b71      	ldr	r3, [pc, #452]	; (800a274 <TIM2_IRQHandler+0x380>)
 800a0ae:	781b      	ldrb	r3, [r3, #0]
 800a0b0:	b2db      	uxtb	r3, r3
 800a0b2:	2b01      	cmp	r3, #1
 800a0b4:	d101      	bne.n	800a0ba <TIM2_IRQHandler+0x1c6>
 800a0b6:	f7fd fac3 	bl	8007640 <probe_state_monitor>

  // Reset step out bits.
  st.step_outbits = 0;
 800a0ba:	4b67      	ldr	r3, [pc, #412]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a0bc:	2200      	movs	r2, #0
 800a0be:	81da      	strh	r2, [r3, #14]

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
 800a0c0:	4b65      	ldr	r3, [pc, #404]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a0c2:	681a      	ldr	r2, [r3, #0]
 800a0c4:	4b64      	ldr	r3, [pc, #400]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a0c6:	695b      	ldr	r3, [r3, #20]
 800a0c8:	18d2      	adds	r2, r2, r3
 800a0ca:	4b63      	ldr	r3, [pc, #396]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a0cc:	601a      	str	r2, [r3, #0]
  #else
    st.counter_x += st.exec_block->steps[X_AXIS];
  #endif
  if (st.counter_x > st.exec_block->step_event_count) {
 800a0ce:	4b62      	ldr	r3, [pc, #392]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a0d0:	681a      	ldr	r2, [r3, #0]
 800a0d2:	4b61      	ldr	r3, [pc, #388]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a0d4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a0d6:	68db      	ldr	r3, [r3, #12]
 800a0d8:	429a      	cmp	r2, r3
 800a0da:	d920      	bls.n	800a11e <TIM2_IRQHandler+0x22a>
    st.step_outbits |= (1<<X_STEP_BIT);
 800a0dc:	4b5e      	ldr	r3, [pc, #376]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a0de:	89db      	ldrh	r3, [r3, #14]
 800a0e0:	2201      	movs	r2, #1
 800a0e2:	4313      	orrs	r3, r2
 800a0e4:	b29a      	uxth	r2, r3
 800a0e6:	4b5c      	ldr	r3, [pc, #368]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a0e8:	81da      	strh	r2, [r3, #14]
    st.counter_x -= st.exec_block->step_event_count;
 800a0ea:	4b5b      	ldr	r3, [pc, #364]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a0ec:	681a      	ldr	r2, [r3, #0]
 800a0ee:	4b5a      	ldr	r3, [pc, #360]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a0f0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a0f2:	68db      	ldr	r3, [r3, #12]
 800a0f4:	1ad2      	subs	r2, r2, r3
 800a0f6:	4b58      	ldr	r3, [pc, #352]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a0f8:	601a      	str	r2, [r3, #0]
    if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys_position[X_AXIS]--; }
 800a0fa:	4b57      	ldr	r3, [pc, #348]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a0fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a0fe:	7c1b      	ldrb	r3, [r3, #16]
 800a100:	001a      	movs	r2, r3
 800a102:	2308      	movs	r3, #8
 800a104:	4013      	ands	r3, r2
 800a106:	d005      	beq.n	800a114 <TIM2_IRQHandler+0x220>
 800a108:	4b5b      	ldr	r3, [pc, #364]	; (800a278 <TIM2_IRQHandler+0x384>)
 800a10a:	681b      	ldr	r3, [r3, #0]
 800a10c:	1e5a      	subs	r2, r3, #1
 800a10e:	4b5a      	ldr	r3, [pc, #360]	; (800a278 <TIM2_IRQHandler+0x384>)
 800a110:	601a      	str	r2, [r3, #0]
 800a112:	e004      	b.n	800a11e <TIM2_IRQHandler+0x22a>
    else { sys_position[X_AXIS]++; }
 800a114:	4b58      	ldr	r3, [pc, #352]	; (800a278 <TIM2_IRQHandler+0x384>)
 800a116:	681b      	ldr	r3, [r3, #0]
 800a118:	1c5a      	adds	r2, r3, #1
 800a11a:	4b57      	ldr	r3, [pc, #348]	; (800a278 <TIM2_IRQHandler+0x384>)
 800a11c:	601a      	str	r2, [r3, #0]
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
 800a11e:	4b4e      	ldr	r3, [pc, #312]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a120:	685a      	ldr	r2, [r3, #4]
 800a122:	4b4d      	ldr	r3, [pc, #308]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a124:	699b      	ldr	r3, [r3, #24]
 800a126:	18d2      	adds	r2, r2, r3
 800a128:	4b4b      	ldr	r3, [pc, #300]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a12a:	605a      	str	r2, [r3, #4]
  #else
    st.counter_y += st.exec_block->steps[Y_AXIS];
  #endif
  if (st.counter_y > st.exec_block->step_event_count) {
 800a12c:	4b4a      	ldr	r3, [pc, #296]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a12e:	685a      	ldr	r2, [r3, #4]
 800a130:	4b49      	ldr	r3, [pc, #292]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a132:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a134:	68db      	ldr	r3, [r3, #12]
 800a136:	429a      	cmp	r2, r3
 800a138:	d920      	bls.n	800a17c <TIM2_IRQHandler+0x288>
    st.step_outbits |= (1<<Y_STEP_BIT);
 800a13a:	4b47      	ldr	r3, [pc, #284]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a13c:	89db      	ldrh	r3, [r3, #14]
 800a13e:	2202      	movs	r2, #2
 800a140:	4313      	orrs	r3, r2
 800a142:	b29a      	uxth	r2, r3
 800a144:	4b44      	ldr	r3, [pc, #272]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a146:	81da      	strh	r2, [r3, #14]
    st.counter_y -= st.exec_block->step_event_count;
 800a148:	4b43      	ldr	r3, [pc, #268]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a14a:	685a      	ldr	r2, [r3, #4]
 800a14c:	4b42      	ldr	r3, [pc, #264]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a14e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a150:	68db      	ldr	r3, [r3, #12]
 800a152:	1ad2      	subs	r2, r2, r3
 800a154:	4b40      	ldr	r3, [pc, #256]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a156:	605a      	str	r2, [r3, #4]
    if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys_position[Y_AXIS]--; }
 800a158:	4b3f      	ldr	r3, [pc, #252]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a15a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a15c:	7c1b      	ldrb	r3, [r3, #16]
 800a15e:	001a      	movs	r2, r3
 800a160:	2310      	movs	r3, #16
 800a162:	4013      	ands	r3, r2
 800a164:	d005      	beq.n	800a172 <TIM2_IRQHandler+0x27e>
 800a166:	4b44      	ldr	r3, [pc, #272]	; (800a278 <TIM2_IRQHandler+0x384>)
 800a168:	685b      	ldr	r3, [r3, #4]
 800a16a:	1e5a      	subs	r2, r3, #1
 800a16c:	4b42      	ldr	r3, [pc, #264]	; (800a278 <TIM2_IRQHandler+0x384>)
 800a16e:	605a      	str	r2, [r3, #4]
 800a170:	e004      	b.n	800a17c <TIM2_IRQHandler+0x288>
    else { sys_position[Y_AXIS]++; }
 800a172:	4b41      	ldr	r3, [pc, #260]	; (800a278 <TIM2_IRQHandler+0x384>)
 800a174:	685b      	ldr	r3, [r3, #4]
 800a176:	1c5a      	adds	r2, r3, #1
 800a178:	4b3f      	ldr	r3, [pc, #252]	; (800a278 <TIM2_IRQHandler+0x384>)
 800a17a:	605a      	str	r2, [r3, #4]
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
 800a17c:	4b36      	ldr	r3, [pc, #216]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a17e:	689a      	ldr	r2, [r3, #8]
 800a180:	4b35      	ldr	r3, [pc, #212]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a182:	69db      	ldr	r3, [r3, #28]
 800a184:	18d2      	adds	r2, r2, r3
 800a186:	4b34      	ldr	r3, [pc, #208]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a188:	609a      	str	r2, [r3, #8]
  #else
    st.counter_z += st.exec_block->steps[Z_AXIS];
  #endif
  if (st.counter_z > st.exec_block->step_event_count) {
 800a18a:	4b33      	ldr	r3, [pc, #204]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a18c:	689a      	ldr	r2, [r3, #8]
 800a18e:	4b32      	ldr	r3, [pc, #200]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a190:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a192:	68db      	ldr	r3, [r3, #12]
 800a194:	429a      	cmp	r2, r3
 800a196:	d920      	bls.n	800a1da <TIM2_IRQHandler+0x2e6>
    st.step_outbits |= (1<<Z_STEP_BIT);
 800a198:	4b2f      	ldr	r3, [pc, #188]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a19a:	89db      	ldrh	r3, [r3, #14]
 800a19c:	2204      	movs	r2, #4
 800a19e:	4313      	orrs	r3, r2
 800a1a0:	b29a      	uxth	r2, r3
 800a1a2:	4b2d      	ldr	r3, [pc, #180]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a1a4:	81da      	strh	r2, [r3, #14]
    st.counter_z -= st.exec_block->step_event_count;
 800a1a6:	4b2c      	ldr	r3, [pc, #176]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a1a8:	689a      	ldr	r2, [r3, #8]
 800a1aa:	4b2b      	ldr	r3, [pc, #172]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a1ac:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a1ae:	68db      	ldr	r3, [r3, #12]
 800a1b0:	1ad2      	subs	r2, r2, r3
 800a1b2:	4b29      	ldr	r3, [pc, #164]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a1b4:	609a      	str	r2, [r3, #8]
    if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys_position[Z_AXIS]--; }
 800a1b6:	4b28      	ldr	r3, [pc, #160]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a1b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a1ba:	7c1b      	ldrb	r3, [r3, #16]
 800a1bc:	001a      	movs	r2, r3
 800a1be:	2320      	movs	r3, #32
 800a1c0:	4013      	ands	r3, r2
 800a1c2:	d005      	beq.n	800a1d0 <TIM2_IRQHandler+0x2dc>
 800a1c4:	4b2c      	ldr	r3, [pc, #176]	; (800a278 <TIM2_IRQHandler+0x384>)
 800a1c6:	689b      	ldr	r3, [r3, #8]
 800a1c8:	1e5a      	subs	r2, r3, #1
 800a1ca:	4b2b      	ldr	r3, [pc, #172]	; (800a278 <TIM2_IRQHandler+0x384>)
 800a1cc:	609a      	str	r2, [r3, #8]
 800a1ce:	e004      	b.n	800a1da <TIM2_IRQHandler+0x2e6>
    else { sys_position[Z_AXIS]++; }
 800a1d0:	4b29      	ldr	r3, [pc, #164]	; (800a278 <TIM2_IRQHandler+0x384>)
 800a1d2:	689b      	ldr	r3, [r3, #8]
 800a1d4:	1c5a      	adds	r2, r3, #1
 800a1d6:	4b28      	ldr	r3, [pc, #160]	; (800a278 <TIM2_IRQHandler+0x384>)
 800a1d8:	609a      	str	r2, [r3, #8]
  }

  // During a homing cycle, lock out and prevent desired axes from moving.
  if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }
 800a1da:	4b28      	ldr	r3, [pc, #160]	; (800a27c <TIM2_IRQHandler+0x388>)
 800a1dc:	781b      	ldrb	r3, [r3, #0]
 800a1de:	2b04      	cmp	r3, #4
 800a1e0:	d108      	bne.n	800a1f4 <TIM2_IRQHandler+0x300>
 800a1e2:	4b1d      	ldr	r3, [pc, #116]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a1e4:	89db      	ldrh	r3, [r3, #14]
 800a1e6:	4a25      	ldr	r2, [pc, #148]	; (800a27c <TIM2_IRQHandler+0x388>)
 800a1e8:	7992      	ldrb	r2, [r2, #6]
 800a1ea:	b292      	uxth	r2, r2
 800a1ec:	4013      	ands	r3, r2
 800a1ee:	b29a      	uxth	r2, r3
 800a1f0:	4b19      	ldr	r3, [pc, #100]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a1f2:	81da      	strh	r2, [r3, #14]

  st.step_count--; // Decrement step events count
 800a1f4:	4b18      	ldr	r3, [pc, #96]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a1f6:	8c1b      	ldrh	r3, [r3, #32]
 800a1f8:	3b01      	subs	r3, #1
 800a1fa:	b29a      	uxth	r2, r3
 800a1fc:	4b16      	ldr	r3, [pc, #88]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a1fe:	841a      	strh	r2, [r3, #32]
  if (st.step_count == 0) {
 800a200:	4b15      	ldr	r3, [pc, #84]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a202:	8c1b      	ldrh	r3, [r3, #32]
 800a204:	2b00      	cmp	r3, #0
 800a206:	d113      	bne.n	800a230 <TIM2_IRQHandler+0x33c>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
 800a208:	4b13      	ldr	r3, [pc, #76]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a20a:	2200      	movs	r2, #0
 800a20c:	629a      	str	r2, [r3, #40]	; 0x28
#ifndef WIN32
	uint8_t segment_tail_next = segment_buffer_tail + 1;
 800a20e:	4b15      	ldr	r3, [pc, #84]	; (800a264 <TIM2_IRQHandler+0x370>)
 800a210:	781b      	ldrb	r3, [r3, #0]
 800a212:	b2da      	uxtb	r2, r3
 800a214:	1dfb      	adds	r3, r7, #7
 800a216:	3201      	adds	r2, #1
 800a218:	701a      	strb	r2, [r3, #0]
	if (segment_tail_next == SEGMENT_BUFFER_SIZE)
 800a21a:	1dfb      	adds	r3, r7, #7
 800a21c:	781b      	ldrb	r3, [r3, #0]
 800a21e:	2b06      	cmp	r3, #6
 800a220:	d102      	bne.n	800a228 <TIM2_IRQHandler+0x334>
		segment_tail_next = 0;
 800a222:	1dfb      	adds	r3, r7, #7
 800a224:	2200      	movs	r2, #0
 800a226:	701a      	strb	r2, [r3, #0]
	segment_buffer_tail = segment_tail_next;
 800a228:	4b0e      	ldr	r3, [pc, #56]	; (800a264 <TIM2_IRQHandler+0x370>)
 800a22a:	1dfa      	adds	r2, r7, #7
 800a22c:	7812      	ldrb	r2, [r2, #0]
 800a22e:	701a      	strb	r2, [r3, #0]
		segment_buffer_tail = 0; 
	}
#endif
  }

  st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
 800a230:	4b09      	ldr	r3, [pc, #36]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a232:	89da      	ldrh	r2, [r3, #14]
 800a234:	4b12      	ldr	r3, [pc, #72]	; (800a280 <TIM2_IRQHandler+0x38c>)
 800a236:	881b      	ldrh	r3, [r3, #0]
 800a238:	4053      	eors	r3, r2
 800a23a:	b29a      	uxth	r2, r3
 800a23c:	4b06      	ldr	r3, [pc, #24]	; (800a258 <TIM2_IRQHandler+0x364>)
 800a23e:	81da      	strh	r2, [r3, #14]
  busy = false;
 800a240:	4b04      	ldr	r3, [pc, #16]	; (800a254 <TIM2_IRQHandler+0x360>)
 800a242:	2200      	movs	r2, #0
 800a244:	701a      	strb	r2, [r3, #0]
 800a246:	e002      	b.n	800a24e <TIM2_IRQHandler+0x35a>
		TIM2->SR &= ~(1 << 0);                          // clear UIF flag
		TIM2->CNT = 0;
	}
	else
	{
		return;
 800a248:	46c0      	nop			; (mov r8, r8)
 800a24a:	e000      	b.n	800a24e <TIM2_IRQHandler+0x35a>
	}
#endif

  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
 800a24c:	46c0      	nop			; (mov r8, r8)
#endif
  }

  st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
  busy = false;
}
 800a24e:	46bd      	mov	sp, r7
 800a250:	b002      	add	sp, #8
 800a252:	bd80      	pop	{r7, pc}
 800a254:	20000518 	.word	0x20000518
 800a258:	200004e4 	.word	0x200004e4
 800a25c:	40000400 	.word	0x40000400
 800a260:	20000511 	.word	0x20000511
 800a264:	20000510 	.word	0x20000510
 800a268:	200004b4 	.word	0x200004b4
 800a26c:	20000450 	.word	0x20000450
 800a270:	20000516 	.word	0x20000516
 800a274:	20000b42 	.word	0x20000b42
 800a278:	20000b50 	.word	0x20000b50
 800a27c:	20000b2c 	.word	0x20000b2c
 800a280:	20000514 	.word	0x20000514

0800a284 <TIM3_IRQHandler>:
ISR(TIMER0_OVF_vect)
#endif
#ifdef WIN32
void Timer0Proc()
#endif
{
 800a284:	b580      	push	{r7, lr}
 800a286:	af00      	add	r7, sp, #0
		NVIC_DisableIRQ(TIM3_IRQn);
		GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
	}
#endif
#ifdef STM32F0DISCOVERY
	if ((TIM3->SR & 0x0001) != 0)                  // check interrupt source
 800a288:	4b18      	ldr	r3, [pc, #96]	; (800a2ec <TIM3_IRQHandler+0x68>)
 800a28a:	8a1b      	ldrh	r3, [r3, #16]
 800a28c:	b29b      	uxth	r3, r3
 800a28e:	001a      	movs	r2, r3
 800a290:	2301      	movs	r3, #1
 800a292:	4013      	ands	r3, r2
 800a294:	d026      	beq.n	800a2e4 <TIM3_IRQHandler+0x60>
	{
		TIM3->SR &= ~(1<<0);                          // clear UIF flag
 800a296:	4a15      	ldr	r2, [pc, #84]	; (800a2ec <TIM3_IRQHandler+0x68>)
 800a298:	4b14      	ldr	r3, [pc, #80]	; (800a2ec <TIM3_IRQHandler+0x68>)
 800a29a:	8a1b      	ldrh	r3, [r3, #16]
 800a29c:	b29b      	uxth	r3, r3
 800a29e:	2101      	movs	r1, #1
 800a2a0:	438b      	bics	r3, r1
 800a2a2:	b29b      	uxth	r3, r3
 800a2a4:	8213      	strh	r3, [r2, #16]
		TIM3->CNT = 0;
 800a2a6:	4b11      	ldr	r3, [pc, #68]	; (800a2ec <TIM3_IRQHandler+0x68>)
 800a2a8:	2200      	movs	r2, #0
 800a2aa:	625a      	str	r2, [r3, #36]	; 0x24
		NVIC_DisableIRQ(TIM3_IRQn);
 800a2ac:	2010      	movs	r0, #16
 800a2ae:	f7ff fd97 	bl	8009de0 <NVIC_DisableIRQ>
		GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
 800a2b2:	2390      	movs	r3, #144	; 0x90
 800a2b4:	05db      	lsls	r3, r3, #23
 800a2b6:	0018      	movs	r0, r3
 800a2b8:	f7f8 fbf0 	bl	8002a9c <GPIO_ReadOutputData>
 800a2bc:	0003      	movs	r3, r0
 800a2be:	b21b      	sxth	r3, r3
 800a2c0:	2207      	movs	r2, #7
 800a2c2:	4393      	bics	r3, r2
 800a2c4:	b21a      	sxth	r2, r3
 800a2c6:	4b0a      	ldr	r3, [pc, #40]	; (800a2f0 <TIM3_IRQHandler+0x6c>)
 800a2c8:	881b      	ldrh	r3, [r3, #0]
 800a2ca:	b21b      	sxth	r3, r3
 800a2cc:	2107      	movs	r1, #7
 800a2ce:	400b      	ands	r3, r1
 800a2d0:	b21b      	sxth	r3, r3
 800a2d2:	4313      	orrs	r3, r2
 800a2d4:	b21b      	sxth	r3, r3
 800a2d6:	b29a      	uxth	r2, r3
 800a2d8:	2390      	movs	r3, #144	; 0x90
 800a2da:	05db      	lsls	r3, r3, #23
 800a2dc:	0011      	movs	r1, r2
 800a2de:	0018      	movs	r0, r3
 800a2e0:	f7f8 fc26 	bl	8002b30 <GPIO_Write>
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed.
#endif
#ifdef WIN32
  nTimer0Out = 0;
#endif
}
 800a2e4:	46c0      	nop			; (mov r8, r8)
 800a2e6:	46bd      	mov	sp, r7
 800a2e8:	bd80      	pop	{r7, pc}
 800a2ea:	46c0      	nop			; (mov r8, r8)
 800a2ec:	40000400 	.word	0x40000400
 800a2f0:	20000514 	.word	0x20000514

0800a2f4 <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{
 800a2f4:	b580      	push	{r7, lr}
 800a2f6:	b082      	sub	sp, #8
 800a2f8:	af00      	add	r7, sp, #0
  uint8_t idx;
  step_port_invert_mask = 0;
 800a2fa:	4b21      	ldr	r3, [pc, #132]	; (800a380 <st_generate_step_dir_invert_masks+0x8c>)
 800a2fc:	2200      	movs	r2, #0
 800a2fe:	801a      	strh	r2, [r3, #0]
  dir_port_invert_mask = 0;
 800a300:	4b20      	ldr	r3, [pc, #128]	; (800a384 <st_generate_step_dir_invert_masks+0x90>)
 800a302:	2200      	movs	r2, #0
 800a304:	801a      	strh	r2, [r3, #0]
  for (idx=0; idx<N_AXIS; idx++) {
 800a306:	1dfb      	adds	r3, r7, #7
 800a308:	2200      	movs	r2, #0
 800a30a:	701a      	strb	r2, [r3, #0]
 800a30c:	e030      	b.n	800a370 <st_generate_step_dir_invert_masks+0x7c>
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= step_pin_mask[idx]; }
 800a30e:	4b1e      	ldr	r3, [pc, #120]	; (800a388 <st_generate_step_dir_invert_masks+0x94>)
 800a310:	2231      	movs	r2, #49	; 0x31
 800a312:	5c9b      	ldrb	r3, [r3, r2]
 800a314:	001a      	movs	r2, r3
 800a316:	1dfb      	adds	r3, r7, #7
 800a318:	781b      	ldrb	r3, [r3, #0]
 800a31a:	411a      	asrs	r2, r3
 800a31c:	0013      	movs	r3, r2
 800a31e:	2201      	movs	r2, #1
 800a320:	4013      	ands	r3, r2
 800a322:	d00a      	beq.n	800a33a <st_generate_step_dir_invert_masks+0x46>
 800a324:	1dfb      	adds	r3, r7, #7
 800a326:	781a      	ldrb	r2, [r3, #0]
 800a328:	4b18      	ldr	r3, [pc, #96]	; (800a38c <st_generate_step_dir_invert_masks+0x98>)
 800a32a:	0052      	lsls	r2, r2, #1
 800a32c:	5ad2      	ldrh	r2, [r2, r3]
 800a32e:	4b14      	ldr	r3, [pc, #80]	; (800a380 <st_generate_step_dir_invert_masks+0x8c>)
 800a330:	881b      	ldrh	r3, [r3, #0]
 800a332:	4313      	orrs	r3, r2
 800a334:	b29a      	uxth	r2, r3
 800a336:	4b12      	ldr	r3, [pc, #72]	; (800a380 <st_generate_step_dir_invert_masks+0x8c>)
 800a338:	801a      	strh	r2, [r3, #0]
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= direction_pin_mask[idx]; }
 800a33a:	4b13      	ldr	r3, [pc, #76]	; (800a388 <st_generate_step_dir_invert_masks+0x94>)
 800a33c:	2232      	movs	r2, #50	; 0x32
 800a33e:	5c9b      	ldrb	r3, [r3, r2]
 800a340:	001a      	movs	r2, r3
 800a342:	1dfb      	adds	r3, r7, #7
 800a344:	781b      	ldrb	r3, [r3, #0]
 800a346:	411a      	asrs	r2, r3
 800a348:	0013      	movs	r3, r2
 800a34a:	2201      	movs	r2, #1
 800a34c:	4013      	ands	r3, r2
 800a34e:	d00a      	beq.n	800a366 <st_generate_step_dir_invert_masks+0x72>
 800a350:	1dfb      	adds	r3, r7, #7
 800a352:	781a      	ldrb	r2, [r3, #0]
 800a354:	4b0e      	ldr	r3, [pc, #56]	; (800a390 <st_generate_step_dir_invert_masks+0x9c>)
 800a356:	0052      	lsls	r2, r2, #1
 800a358:	5ad2      	ldrh	r2, [r2, r3]
 800a35a:	4b0a      	ldr	r3, [pc, #40]	; (800a384 <st_generate_step_dir_invert_masks+0x90>)
 800a35c:	881b      	ldrh	r3, [r3, #0]
 800a35e:	4313      	orrs	r3, r2
 800a360:	b29a      	uxth	r2, r3
 800a362:	4b08      	ldr	r3, [pc, #32]	; (800a384 <st_generate_step_dir_invert_masks+0x90>)
 800a364:	801a      	strh	r2, [r3, #0]
void st_generate_step_dir_invert_masks()
{
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
 800a366:	1dfb      	adds	r3, r7, #7
 800a368:	781a      	ldrb	r2, [r3, #0]
 800a36a:	1dfb      	adds	r3, r7, #7
 800a36c:	3201      	adds	r2, #1
 800a36e:	701a      	strb	r2, [r3, #0]
 800a370:	1dfb      	adds	r3, r7, #7
 800a372:	781b      	ldrb	r3, [r3, #0]
 800a374:	2b02      	cmp	r3, #2
 800a376:	d9ca      	bls.n	800a30e <st_generate_step_dir_invert_masks+0x1a>
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= step_pin_mask[idx]; }
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= direction_pin_mask[idx]; }
  }
}
 800a378:	46c0      	nop			; (mov r8, r8)
 800a37a:	46bd      	mov	sp, r7
 800a37c:	b002      	add	sp, #8
 800a37e:	bd80      	pop	{r7, pc}
 800a380:	20000514 	.word	0x20000514
 800a384:	20000516 	.word	0x20000516
 800a388:	20000acc 	.word	0x20000acc
 800a38c:	0800da80 	.word	0x0800da80
 800a390:	0800da88 	.word	0x0800da88

0800a394 <st_reset>:


// Reset and clear stepper subsystem variables
void st_reset()
{
 800a394:	b580      	push	{r7, lr}
 800a396:	af00      	add	r7, sp, #0
  // Initialize stepper driver idle state.
  st_go_idle();
 800a398:	f7ff fd5e 	bl	8009e58 <st_go_idle>

  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(st_prep_t));
 800a39c:	4b2c      	ldr	r3, [pc, #176]	; (800a450 <st_reset+0xbc>)
 800a39e:	2238      	movs	r2, #56	; 0x38
 800a3a0:	2100      	movs	r1, #0
 800a3a2:	0018      	movs	r0, r3
 800a3a4:	f001 feac 	bl	800c100 <memset>
  memset(&st, 0, sizeof(stepper_t));
 800a3a8:	4b2a      	ldr	r3, [pc, #168]	; (800a454 <st_reset+0xc0>)
 800a3aa:	222c      	movs	r2, #44	; 0x2c
 800a3ac:	2100      	movs	r1, #0
 800a3ae:	0018      	movs	r0, r3
 800a3b0:	f001 fea6 	bl	800c100 <memset>
  st.exec_segment = NULL;
 800a3b4:	4b27      	ldr	r3, [pc, #156]	; (800a454 <st_reset+0xc0>)
 800a3b6:	2200      	movs	r2, #0
 800a3b8:	629a      	str	r2, [r3, #40]	; 0x28
  pl_block = NULL;  // Planner block pointer used by segment buffer
 800a3ba:	4b27      	ldr	r3, [pc, #156]	; (800a458 <st_reset+0xc4>)
 800a3bc:	2200      	movs	r2, #0
 800a3be:	601a      	str	r2, [r3, #0]
  segment_buffer_tail = 0;
 800a3c0:	4b26      	ldr	r3, [pc, #152]	; (800a45c <st_reset+0xc8>)
 800a3c2:	2200      	movs	r2, #0
 800a3c4:	701a      	strb	r2, [r3, #0]
  segment_buffer_head = 0; // empty = tail
 800a3c6:	4b26      	ldr	r3, [pc, #152]	; (800a460 <st_reset+0xcc>)
 800a3c8:	2200      	movs	r2, #0
 800a3ca:	701a      	strb	r2, [r3, #0]
  segment_next_head = 1;
 800a3cc:	4b25      	ldr	r3, [pc, #148]	; (800a464 <st_reset+0xd0>)
 800a3ce:	2201      	movs	r2, #1
 800a3d0:	701a      	strb	r2, [r3, #0]
  busy = false;
 800a3d2:	4b25      	ldr	r3, [pc, #148]	; (800a468 <st_reset+0xd4>)
 800a3d4:	2200      	movs	r2, #0
 800a3d6:	701a      	strb	r2, [r3, #0]

  st_generate_step_dir_invert_masks();
 800a3d8:	f7ff ff8c 	bl	800a2f4 <st_generate_step_dir_invert_masks>
  st.dir_outbits = dir_port_invert_mask; // Initialize direction bits to default.
 800a3dc:	4b23      	ldr	r3, [pc, #140]	; (800a46c <st_reset+0xd8>)
 800a3de:	881a      	ldrh	r2, [r3, #0]
 800a3e0:	4b1c      	ldr	r3, [pc, #112]	; (800a454 <st_reset+0xc0>)
 800a3e2:	821a      	strh	r2, [r3, #16]
#ifdef STM32F103C8
  GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
  GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (dir_port_invert_mask & DIRECTION_MASK));
#endif
#ifdef STM32F0DISCOVERY
  GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
 800a3e4:	2390      	movs	r3, #144	; 0x90
 800a3e6:	05db      	lsls	r3, r3, #23
 800a3e8:	0018      	movs	r0, r3
 800a3ea:	f7f8 fb57 	bl	8002a9c <GPIO_ReadOutputData>
 800a3ee:	0003      	movs	r3, r0
 800a3f0:	b21b      	sxth	r3, r3
 800a3f2:	2207      	movs	r2, #7
 800a3f4:	4393      	bics	r3, r2
 800a3f6:	b21a      	sxth	r2, r3
 800a3f8:	4b1d      	ldr	r3, [pc, #116]	; (800a470 <st_reset+0xdc>)
 800a3fa:	881b      	ldrh	r3, [r3, #0]
 800a3fc:	b21b      	sxth	r3, r3
 800a3fe:	2107      	movs	r1, #7
 800a400:	400b      	ands	r3, r1
 800a402:	b21b      	sxth	r3, r3
 800a404:	4313      	orrs	r3, r2
 800a406:	b21b      	sxth	r3, r3
 800a408:	b29a      	uxth	r2, r3
 800a40a:	2390      	movs	r3, #144	; 0x90
 800a40c:	05db      	lsls	r3, r3, #23
 800a40e:	0011      	movs	r1, r2
 800a410:	0018      	movs	r0, r3
 800a412:	f7f8 fb8d 	bl	8002b30 <GPIO_Write>
  GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (dir_port_invert_mask & DIRECTION_MASK));
 800a416:	2390      	movs	r3, #144	; 0x90
 800a418:	05db      	lsls	r3, r3, #23
 800a41a:	0018      	movs	r0, r3
 800a41c:	f7f8 fb3e 	bl	8002a9c <GPIO_ReadOutputData>
 800a420:	0003      	movs	r3, r0
 800a422:	b21b      	sxth	r3, r3
 800a424:	2238      	movs	r2, #56	; 0x38
 800a426:	4393      	bics	r3, r2
 800a428:	b21a      	sxth	r2, r3
 800a42a:	4b10      	ldr	r3, [pc, #64]	; (800a46c <st_reset+0xd8>)
 800a42c:	881b      	ldrh	r3, [r3, #0]
 800a42e:	b21b      	sxth	r3, r3
 800a430:	2138      	movs	r1, #56	; 0x38
 800a432:	400b      	ands	r3, r1
 800a434:	b21b      	sxth	r3, r3
 800a436:	4313      	orrs	r3, r2
 800a438:	b21b      	sxth	r3, r3
 800a43a:	b29a      	uxth	r2, r3
 800a43c:	2390      	movs	r3, #144	; 0x90
 800a43e:	05db      	lsls	r3, r3, #23
 800a440:	0011      	movs	r1, r2
 800a442:	0018      	movs	r0, r3
 800a444:	f7f8 fb74 	bl	8002b30 <GPIO_Write>
#endif
}
 800a448:	46c0      	nop			; (mov r8, r8)
 800a44a:	46bd      	mov	sp, r7
 800a44c:	bd80      	pop	{r7, pc}
 800a44e:	46c0      	nop			; (mov r8, r8)
 800a450:	20000524 	.word	0x20000524
 800a454:	200004e4 	.word	0x200004e4
 800a458:	2000051c 	.word	0x2000051c
 800a45c:	20000510 	.word	0x20000510
 800a460:	20000511 	.word	0x20000511
 800a464:	20000512 	.word	0x20000512
 800a468:	20000518 	.word	0x20000518
 800a46c:	20000516 	.word	0x20000516
 800a470:	20000514 	.word	0x20000514

0800a474 <stepper_init>:

#endif

// Initialize and start the stepper motor subsystem
void stepper_init()
{
 800a474:	b580      	push	{r7, lr}
 800a476:	b082      	sub	sp, #8
 800a478:	af00      	add	r7, sp, #0
	NVIC_DisableIRQ(TIM3_IRQn);
	NVIC_DisableIRQ(TIM2_IRQn);
#endif
#ifdef STM32F0DISCOVERY
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_STEPPERS_DISABLE_PORT, ENABLE);
 800a47a:	2380      	movs	r3, #128	; 0x80
 800a47c:	029b      	lsls	r3, r3, #10
 800a47e:	2101      	movs	r1, #1
 800a480:	0018      	movs	r0, r3
 800a482:	f7f8 fe05 	bl	8003090 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800a486:	003b      	movs	r3, r7
 800a488:	2203      	movs	r2, #3
 800a48a:	715a      	strb	r2, [r3, #5]
	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800a48c:	003b      	movs	r3, r7
 800a48e:	2201      	movs	r2, #1
 800a490:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800a492:	003b      	movs	r3, r7
 800a494:	2200      	movs	r2, #0
 800a496:	719a      	strb	r2, [r3, #6]
	GPIO_InitStructure.GPIO_Pin = STEPPERS_DISABLE_MASK;
 800a498:	003b      	movs	r3, r7
 800a49a:	2240      	movs	r2, #64	; 0x40
 800a49c:	601a      	str	r2, [r3, #0]
	GPIO_Init(STEPPERS_DISABLE_PORT, &GPIO_InitStructure);
 800a49e:	003a      	movs	r2, r7
 800a4a0:	2390      	movs	r3, #144	; 0x90
 800a4a2:	05db      	lsls	r3, r3, #23
 800a4a4:	0011      	movs	r1, r2
 800a4a6:	0018      	movs	r0, r3
 800a4a8:	f7f8 fa54 	bl	8002954 <GPIO_Init>

	RCC_APB2PeriphClockCmd(RCC_STEP_PORT, ENABLE);
 800a4ac:	2380      	movs	r3, #128	; 0x80
 800a4ae:	029b      	lsls	r3, r3, #10
 800a4b0:	2101      	movs	r1, #1
 800a4b2:	0018      	movs	r0, r3
 800a4b4:	f7f8 fdec 	bl	8003090 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Pin = STEP_MASK;
 800a4b8:	003b      	movs	r3, r7
 800a4ba:	2207      	movs	r2, #7
 800a4bc:	601a      	str	r2, [r3, #0]
	GPIO_Init(STEP_PORT, &GPIO_InitStructure);
 800a4be:	003a      	movs	r2, r7
 800a4c0:	2390      	movs	r3, #144	; 0x90
 800a4c2:	05db      	lsls	r3, r3, #23
 800a4c4:	0011      	movs	r1, r2
 800a4c6:	0018      	movs	r0, r3
 800a4c8:	f7f8 fa44 	bl	8002954 <GPIO_Init>

	RCC_APB2PeriphClockCmd(RCC_DIRECTION_PORT, ENABLE);
 800a4cc:	2380      	movs	r3, #128	; 0x80
 800a4ce:	029b      	lsls	r3, r3, #10
 800a4d0:	2101      	movs	r1, #1
 800a4d2:	0018      	movs	r0, r3
 800a4d4:	f7f8 fddc 	bl	8003090 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Pin = DIRECTION_MASK;
 800a4d8:	003b      	movs	r3, r7
 800a4da:	2238      	movs	r2, #56	; 0x38
 800a4dc:	601a      	str	r2, [r3, #0]
	GPIO_Init(DIRECTION_PORT, &GPIO_InitStructure);
 800a4de:	003a      	movs	r2, r7
 800a4e0:	2390      	movs	r3, #144	; 0x90
 800a4e2:	05db      	lsls	r3, r3, #23
 800a4e4:	0011      	movs	r1, r2
 800a4e6:	0018      	movs	r0, r3
 800a4e8:	f7f8 fa34 	bl	8002954 <GPIO_Init>

	RCC->APB1ENR |= RCC_APB1Periph_TIM2;
 800a4ec:	4b11      	ldr	r3, [pc, #68]	; (800a534 <stepper_init+0xc0>)
 800a4ee:	4a11      	ldr	r2, [pc, #68]	; (800a534 <stepper_init+0xc0>)
 800a4f0:	69d2      	ldr	r2, [r2, #28]
 800a4f2:	2101      	movs	r1, #1
 800a4f4:	430a      	orrs	r2, r1
 800a4f6:	61da      	str	r2, [r3, #28]
	TIM_Configuration(TIM2, 1, 1, 1);
 800a4f8:	2380      	movs	r3, #128	; 0x80
 800a4fa:	05d8      	lsls	r0, r3, #23
 800a4fc:	2301      	movs	r3, #1
 800a4fe:	2201      	movs	r2, #1
 800a500:	2101      	movs	r1, #1
 800a502:	f000 fe21 	bl	800b148 <TIM_Configuration>
	RCC->APB1ENR |= RCC_APB1Periph_TIM3;
 800a506:	4b0b      	ldr	r3, [pc, #44]	; (800a534 <stepper_init+0xc0>)
 800a508:	4a0a      	ldr	r2, [pc, #40]	; (800a534 <stepper_init+0xc0>)
 800a50a:	69d2      	ldr	r2, [r2, #28]
 800a50c:	2102      	movs	r1, #2
 800a50e:	430a      	orrs	r2, r1
 800a510:	61da      	str	r2, [r3, #28]
	TIM_Configuration(TIM3, 1, 1, 1);
 800a512:	4809      	ldr	r0, [pc, #36]	; (800a538 <stepper_init+0xc4>)
 800a514:	2301      	movs	r3, #1
 800a516:	2201      	movs	r2, #1
 800a518:	2101      	movs	r1, #1
 800a51a:	f000 fe15 	bl	800b148 <TIM_Configuration>
	NVIC_DisableIRQ(TIM3_IRQn);
 800a51e:	2010      	movs	r0, #16
 800a520:	f7ff fc5e 	bl	8009de0 <NVIC_DisableIRQ>
	NVIC_DisableIRQ(TIM2_IRQn);
 800a524:	200f      	movs	r0, #15
 800a526:	f7ff fc5b 	bl	8009de0 <NVIC_DisableIRQ>
	QueryPerformanceFrequency(&Win32Frequency);

	_beginthread(Timer1Thread, 0, NULL);
	_beginthread(Timer0Thread, 0, NULL);
#endif
}
 800a52a:	46c0      	nop			; (mov r8, r8)
 800a52c:	46bd      	mov	sp, r7
 800a52e:	b002      	add	sp, #8
 800a530:	bd80      	pop	{r7, pc}
 800a532:	46c0      	nop			; (mov r8, r8)
 800a534:	40021000 	.word	0x40021000
 800a538:	40000400 	.word	0x40000400

0800a53c <st_update_plan_block_parameters>:


// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{
 800a53c:	b5b0      	push	{r4, r5, r7, lr}
 800a53e:	af00      	add	r7, sp, #0
  if (pl_block != NULL) { // Ignore if at start of a new block.
 800a540:	4b0e      	ldr	r3, [pc, #56]	; (800a57c <st_update_plan_block_parameters+0x40>)
 800a542:	681b      	ldr	r3, [r3, #0]
 800a544:	2b00      	cmp	r3, #0
 800a546:	d015      	beq.n	800a574 <st_update_plan_block_parameters+0x38>
    prep.recalculate_flag |= PREP_FLAG_RECALCULATE;
 800a548:	4b0d      	ldr	r3, [pc, #52]	; (800a580 <st_update_plan_block_parameters+0x44>)
 800a54a:	785b      	ldrb	r3, [r3, #1]
 800a54c:	2201      	movs	r2, #1
 800a54e:	4313      	orrs	r3, r2
 800a550:	b2da      	uxtb	r2, r3
 800a552:	4b0b      	ldr	r3, [pc, #44]	; (800a580 <st_update_plan_block_parameters+0x44>)
 800a554:	705a      	strb	r2, [r3, #1]
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
 800a556:	4b09      	ldr	r3, [pc, #36]	; (800a57c <st_update_plan_block_parameters+0x40>)
 800a558:	681c      	ldr	r4, [r3, #0]
 800a55a:	4b09      	ldr	r3, [pc, #36]	; (800a580 <st_update_plan_block_parameters+0x44>)
 800a55c:	69da      	ldr	r2, [r3, #28]
 800a55e:	4b08      	ldr	r3, [pc, #32]	; (800a580 <st_update_plan_block_parameters+0x44>)
 800a560:	69db      	ldr	r3, [r3, #28]
 800a562:	1c19      	adds	r1, r3, #0
 800a564:	1c10      	adds	r0, r2, #0
 800a566:	f7f6 fa53 	bl	8000a10 <__aeabi_fmul>
 800a56a:	1c03      	adds	r3, r0, #0
 800a56c:	6163      	str	r3, [r4, #20]
    pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
 800a56e:	4b03      	ldr	r3, [pc, #12]	; (800a57c <st_update_plan_block_parameters+0x40>)
 800a570:	2200      	movs	r2, #0
 800a572:	601a      	str	r2, [r3, #0]
  }
}
 800a574:	46c0      	nop			; (mov r8, r8)
 800a576:	46bd      	mov	sp, r7
 800a578:	bdb0      	pop	{r4, r5, r7, pc}
 800a57a:	46c0      	nop			; (mov r8, r8)
 800a57c:	2000051c 	.word	0x2000051c
 800a580:	20000524 	.word	0x20000524

0800a584 <st_next_block_index>:


// Increments the step segment buffer block data ring buffer.
static uint8_t st_next_block_index(uint8_t block_index)
{
 800a584:	b580      	push	{r7, lr}
 800a586:	b082      	sub	sp, #8
 800a588:	af00      	add	r7, sp, #0
 800a58a:	0002      	movs	r2, r0
 800a58c:	1dfb      	adds	r3, r7, #7
 800a58e:	701a      	strb	r2, [r3, #0]
  block_index++;
 800a590:	1dfb      	adds	r3, r7, #7
 800a592:	781a      	ldrb	r2, [r3, #0]
 800a594:	1dfb      	adds	r3, r7, #7
 800a596:	3201      	adds	r2, #1
 800a598:	701a      	strb	r2, [r3, #0]
  if ( block_index == (SEGMENT_BUFFER_SIZE-1) ) { return(0); }
 800a59a:	1dfb      	adds	r3, r7, #7
 800a59c:	781b      	ldrb	r3, [r3, #0]
 800a59e:	2b05      	cmp	r3, #5
 800a5a0:	d101      	bne.n	800a5a6 <st_next_block_index+0x22>
 800a5a2:	2300      	movs	r3, #0
 800a5a4:	e001      	b.n	800a5aa <st_next_block_index+0x26>
  return(block_index);
 800a5a6:	1dfb      	adds	r3, r7, #7
 800a5a8:	781b      	ldrb	r3, [r3, #0]
}
 800a5aa:	0018      	movs	r0, r3
 800a5ac:	46bd      	mov	sp, r7
 800a5ae:	b002      	add	sp, #8
 800a5b0:	bd80      	pop	{r7, pc}
 800a5b2:	46c0      	nop			; (mov r8, r8)

0800a5b4 <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it.
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
 800a5b4:	b590      	push	{r4, r7, lr}
 800a5b6:	b097      	sub	sp, #92	; 0x5c
 800a5b8:	af00      	add	r7, sp, #0
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
 800a5ba:	4ba5      	ldr	r3, [pc, #660]	; (800a850 <st_prep_buffer+0x29c>)
 800a5bc:	791b      	ldrb	r3, [r3, #4]
 800a5be:	001a      	movs	r2, r3
 800a5c0:	2301      	movs	r3, #1
 800a5c2:	4013      	ands	r3, r2
 800a5c4:	d001      	beq.n	800a5ca <st_prep_buffer+0x16>
 800a5c6:	f000 fd90 	bl	800b0ea <st_prep_buffer+0xb36>

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
 800a5ca:	f000 fd84 	bl	800b0d6 <st_prep_buffer+0xb22>

    // Determine if we need to load a new planner block or if the block needs to be recomputed.
    if (pl_block == NULL) {
 800a5ce:	4ba1      	ldr	r3, [pc, #644]	; (800a854 <st_prep_buffer+0x2a0>)
 800a5d0:	681b      	ldr	r3, [r3, #0]
 800a5d2:	2b00      	cmp	r3, #0
 800a5d4:	d000      	beq.n	800a5d8 <st_prep_buffer+0x24>
 800a5d6:	e261      	b.n	800aa9c <st_prep_buffer+0x4e8>

      // Query planner for a queued block
      if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
 800a5d8:	4b9d      	ldr	r3, [pc, #628]	; (800a850 <st_prep_buffer+0x29c>)
 800a5da:	791b      	ldrb	r3, [r3, #4]
 800a5dc:	001a      	movs	r2, r3
 800a5de:	2304      	movs	r3, #4
 800a5e0:	4013      	ands	r3, r2
 800a5e2:	d005      	beq.n	800a5f0 <st_prep_buffer+0x3c>
 800a5e4:	f7fc faba 	bl	8006b5c <plan_get_system_motion_block>
 800a5e8:	0002      	movs	r2, r0
 800a5ea:	4b9a      	ldr	r3, [pc, #616]	; (800a854 <st_prep_buffer+0x2a0>)
 800a5ec:	601a      	str	r2, [r3, #0]
 800a5ee:	e004      	b.n	800a5fa <st_prep_buffer+0x46>
      else { pl_block = plan_get_current_block(); }
 800a5f0:	f7fc fac4 	bl	8006b7c <plan_get_current_block>
 800a5f4:	0002      	movs	r2, r0
 800a5f6:	4b97      	ldr	r3, [pc, #604]	; (800a854 <st_prep_buffer+0x2a0>)
 800a5f8:	601a      	str	r2, [r3, #0]
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
 800a5fa:	4b96      	ldr	r3, [pc, #600]	; (800a854 <st_prep_buffer+0x2a0>)
 800a5fc:	681b      	ldr	r3, [r3, #0]
 800a5fe:	2b00      	cmp	r3, #0
 800a600:	d101      	bne.n	800a606 <st_prep_buffer+0x52>
 800a602:	f000 fd74 	bl	800b0ee <st_prep_buffer+0xb3a>

      // Check if we need to only recompute the velocity profile or load a new block.
      if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
 800a606:	4b94      	ldr	r3, [pc, #592]	; (800a858 <st_prep_buffer+0x2a4>)
 800a608:	785b      	ldrb	r3, [r3, #1]
 800a60a:	001a      	movs	r2, r3
 800a60c:	2301      	movs	r3, #1
 800a60e:	4013      	ands	r3, r2
 800a610:	d003      	beq.n	800a61a <st_prep_buffer+0x66>

        #ifdef PARKING_ENABLE
          if (prep.recalculate_flag & PREP_FLAG_PARKING) { prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE); }
          else { prep.recalculate_flag = false; }
        #else
          prep.recalculate_flag = false;
 800a612:	4b91      	ldr	r3, [pc, #580]	; (800a858 <st_prep_buffer+0x2a4>)
 800a614:	2200      	movs	r2, #0
 800a616:	705a      	strb	r2, [r3, #1]
 800a618:	e0b2      	b.n	800a780 <st_prep_buffer+0x1cc>
        #endif

      } else {

        // Load the Bresenham stepping data for the block.
        prep.st_block_index = st_next_block_index(prep.st_block_index);
 800a61a:	4b8f      	ldr	r3, [pc, #572]	; (800a858 <st_prep_buffer+0x2a4>)
 800a61c:	781b      	ldrb	r3, [r3, #0]
 800a61e:	0018      	movs	r0, r3
 800a620:	f7ff ffb0 	bl	800a584 <st_next_block_index>
 800a624:	0003      	movs	r3, r0
 800a626:	001a      	movs	r2, r3
 800a628:	4b8b      	ldr	r3, [pc, #556]	; (800a858 <st_prep_buffer+0x2a4>)
 800a62a:	701a      	strb	r2, [r3, #0]

        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it.
        st_prep_block = &st_block_buffer[prep.st_block_index];
 800a62c:	4b8a      	ldr	r3, [pc, #552]	; (800a858 <st_prep_buffer+0x2a4>)
 800a62e:	781b      	ldrb	r3, [r3, #0]
 800a630:	001a      	movs	r2, r3
 800a632:	0013      	movs	r3, r2
 800a634:	009b      	lsls	r3, r3, #2
 800a636:	189b      	adds	r3, r3, r2
 800a638:	009b      	lsls	r3, r3, #2
 800a63a:	4a88      	ldr	r2, [pc, #544]	; (800a85c <st_prep_buffer+0x2a8>)
 800a63c:	189a      	adds	r2, r3, r2
 800a63e:	4b88      	ldr	r3, [pc, #544]	; (800a860 <st_prep_buffer+0x2ac>)
 800a640:	601a      	str	r2, [r3, #0]
        st_prep_block->direction_bits = pl_block->direction_bits;
 800a642:	4b87      	ldr	r3, [pc, #540]	; (800a860 <st_prep_buffer+0x2ac>)
 800a644:	681a      	ldr	r2, [r3, #0]
 800a646:	4b83      	ldr	r3, [pc, #524]	; (800a854 <st_prep_buffer+0x2a0>)
 800a648:	681b      	ldr	r3, [r3, #0]
 800a64a:	7c1b      	ldrb	r3, [r3, #16]
 800a64c:	7413      	strb	r3, [r2, #16]
          st_prep_block->step_event_count = (pl_block->step_event_count << 1);
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL; }
 800a64e:	2357      	movs	r3, #87	; 0x57
 800a650:	18fb      	adds	r3, r7, r3
 800a652:	2200      	movs	r2, #0
 800a654:	701a      	strb	r2, [r3, #0]
 800a656:	e015      	b.n	800a684 <st_prep_buffer+0xd0>
 800a658:	4b81      	ldr	r3, [pc, #516]	; (800a860 <st_prep_buffer+0x2ac>)
 800a65a:	681a      	ldr	r2, [r3, #0]
 800a65c:	2357      	movs	r3, #87	; 0x57
 800a65e:	18fb      	adds	r3, r7, r3
 800a660:	7818      	ldrb	r0, [r3, #0]
 800a662:	4b7c      	ldr	r3, [pc, #496]	; (800a854 <st_prep_buffer+0x2a0>)
 800a664:	681b      	ldr	r3, [r3, #0]
 800a666:	2157      	movs	r1, #87	; 0x57
 800a668:	1879      	adds	r1, r7, r1
 800a66a:	7809      	ldrb	r1, [r1, #0]
 800a66c:	0089      	lsls	r1, r1, #2
 800a66e:	58cb      	ldr	r3, [r1, r3]
 800a670:	00d9      	lsls	r1, r3, #3
 800a672:	0083      	lsls	r3, r0, #2
 800a674:	5099      	str	r1, [r3, r2]
 800a676:	2357      	movs	r3, #87	; 0x57
 800a678:	18fb      	adds	r3, r7, r3
 800a67a:	781a      	ldrb	r2, [r3, #0]
 800a67c:	2357      	movs	r3, #87	; 0x57
 800a67e:	18fb      	adds	r3, r7, r3
 800a680:	3201      	adds	r2, #1
 800a682:	701a      	strb	r2, [r3, #0]
 800a684:	2357      	movs	r3, #87	; 0x57
 800a686:	18fb      	adds	r3, r7, r3
 800a688:	781b      	ldrb	r3, [r3, #0]
 800a68a:	2b02      	cmp	r3, #2
 800a68c:	d9e4      	bls.n	800a658 <st_prep_buffer+0xa4>
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
 800a68e:	4b74      	ldr	r3, [pc, #464]	; (800a860 <st_prep_buffer+0x2ac>)
 800a690:	681b      	ldr	r3, [r3, #0]
 800a692:	4a70      	ldr	r2, [pc, #448]	; (800a854 <st_prep_buffer+0x2a0>)
 800a694:	6812      	ldr	r2, [r2, #0]
 800a696:	68d2      	ldr	r2, [r2, #12]
 800a698:	00d2      	lsls	r2, r2, #3
 800a69a:	60da      	str	r2, [r3, #12]
        #endif

        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = (float)pl_block->step_event_count;
 800a69c:	4b6d      	ldr	r3, [pc, #436]	; (800a854 <st_prep_buffer+0x2a0>)
 800a69e:	681b      	ldr	r3, [r3, #0]
 800a6a0:	68db      	ldr	r3, [r3, #12]
 800a6a2:	0018      	movs	r0, r3
 800a6a4:	f7f6 fcd0 	bl	8001048 <__aeabi_ui2f>
 800a6a8:	1c02      	adds	r2, r0, #0
 800a6aa:	4b6b      	ldr	r3, [pc, #428]	; (800a858 <st_prep_buffer+0x2a4>)
 800a6ac:	609a      	str	r2, [r3, #8]
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
 800a6ae:	4b6a      	ldr	r3, [pc, #424]	; (800a858 <st_prep_buffer+0x2a4>)
 800a6b0:	689a      	ldr	r2, [r3, #8]
 800a6b2:	4b68      	ldr	r3, [pc, #416]	; (800a854 <st_prep_buffer+0x2a0>)
 800a6b4:	681b      	ldr	r3, [r3, #0]
 800a6b6:	6a1b      	ldr	r3, [r3, #32]
 800a6b8:	1c19      	adds	r1, r3, #0
 800a6ba:	1c10      	adds	r0, r2, #0
 800a6bc:	f7f5 ffde 	bl	800067c <__aeabi_fdiv>
 800a6c0:	1c03      	adds	r3, r0, #0
 800a6c2:	1c1a      	adds	r2, r3, #0
 800a6c4:	4b64      	ldr	r3, [pc, #400]	; (800a858 <st_prep_buffer+0x2a4>)
 800a6c6:	60da      	str	r2, [r3, #12]
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
 800a6c8:	4b63      	ldr	r3, [pc, #396]	; (800a858 <st_prep_buffer+0x2a4>)
 800a6ca:	68db      	ldr	r3, [r3, #12]
 800a6cc:	1c19      	adds	r1, r3, #0
 800a6ce:	4865      	ldr	r0, [pc, #404]	; (800a864 <st_prep_buffer+0x2b0>)
 800a6d0:	f7f5 ffd4 	bl	800067c <__aeabi_fdiv>
 800a6d4:	1c03      	adds	r3, r0, #0
 800a6d6:	1c1a      	adds	r2, r3, #0
 800a6d8:	4b5f      	ldr	r3, [pc, #380]	; (800a858 <st_prep_buffer+0x2a4>)
 800a6da:	611a      	str	r2, [r3, #16]
        prep.dt_remainder = 0.0f; // Reset for new segment block
 800a6dc:	4b5e      	ldr	r3, [pc, #376]	; (800a858 <st_prep_buffer+0x2a4>)
 800a6de:	2200      	movs	r2, #0
 800a6e0:	605a      	str	r2, [r3, #4]

        if ((sys.step_control & STEP_CONTROL_EXECUTE_HOLD) || (prep.recalculate_flag & PREP_FLAG_DECEL_OVERRIDE)) {
 800a6e2:	4b5b      	ldr	r3, [pc, #364]	; (800a850 <st_prep_buffer+0x29c>)
 800a6e4:	791b      	ldrb	r3, [r3, #4]
 800a6e6:	001a      	movs	r2, r3
 800a6e8:	2302      	movs	r3, #2
 800a6ea:	4013      	ands	r3, r2
 800a6ec:	d105      	bne.n	800a6fa <st_prep_buffer+0x146>
 800a6ee:	4b5a      	ldr	r3, [pc, #360]	; (800a858 <st_prep_buffer+0x2a4>)
 800a6f0:	785b      	ldrb	r3, [r3, #1]
 800a6f2:	001a      	movs	r2, r3
 800a6f4:	2308      	movs	r3, #8
 800a6f6:	4013      	ands	r3, r2
 800a6f8:	d017      	beq.n	800a72a <st_prep_buffer+0x176>
          // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
          prep.current_speed = prep.exit_speed;
 800a6fa:	4b57      	ldr	r3, [pc, #348]	; (800a858 <st_prep_buffer+0x2a4>)
 800a6fc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a6fe:	4b56      	ldr	r3, [pc, #344]	; (800a858 <st_prep_buffer+0x2a4>)
 800a700:	61da      	str	r2, [r3, #28]
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed;
 800a702:	4b54      	ldr	r3, [pc, #336]	; (800a854 <st_prep_buffer+0x2a0>)
 800a704:	681c      	ldr	r4, [r3, #0]
 800a706:	4b54      	ldr	r3, [pc, #336]	; (800a858 <st_prep_buffer+0x2a4>)
 800a708:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a70a:	4b53      	ldr	r3, [pc, #332]	; (800a858 <st_prep_buffer+0x2a4>)
 800a70c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a70e:	1c19      	adds	r1, r3, #0
 800a710:	1c10      	adds	r0, r2, #0
 800a712:	f7f6 f97d 	bl	8000a10 <__aeabi_fmul>
 800a716:	1c03      	adds	r3, r0, #0
 800a718:	6163      	str	r3, [r4, #20]
          prep.recalculate_flag &= ~(PREP_FLAG_DECEL_OVERRIDE);
 800a71a:	4b4f      	ldr	r3, [pc, #316]	; (800a858 <st_prep_buffer+0x2a4>)
 800a71c:	785b      	ldrb	r3, [r3, #1]
 800a71e:	2208      	movs	r2, #8
 800a720:	4393      	bics	r3, r2
 800a722:	b2da      	uxtb	r2, r3
 800a724:	4b4c      	ldr	r3, [pc, #304]	; (800a858 <st_prep_buffer+0x2a4>)
 800a726:	705a      	strb	r2, [r3, #1]
 800a728:	e008      	b.n	800a73c <st_prep_buffer+0x188>
        } else {
          prep.current_speed = sqrtf(pl_block->entry_speed_sqr);
 800a72a:	4b4a      	ldr	r3, [pc, #296]	; (800a854 <st_prep_buffer+0x2a0>)
 800a72c:	681b      	ldr	r3, [r3, #0]
 800a72e:	695b      	ldr	r3, [r3, #20]
 800a730:	1c18      	adds	r0, r3, #0
 800a732:	f001 fe79 	bl	800c428 <sqrtf>
 800a736:	1c02      	adds	r2, r0, #0
 800a738:	4b47      	ldr	r3, [pc, #284]	; (800a858 <st_prep_buffer+0x2a4>)
 800a73a:	61da      	str	r2, [r3, #28]
        }
#ifdef VARIABLE_SPINDLE
        // Setup laser mode variables. PWM rate adjusted motions will always complete a motion with the
        // spindle off. 
        st_prep_block->is_pwm_rate_adjusted = false;
 800a73c:	4b48      	ldr	r3, [pc, #288]	; (800a860 <st_prep_buffer+0x2ac>)
 800a73e:	681b      	ldr	r3, [r3, #0]
 800a740:	2200      	movs	r2, #0
 800a742:	745a      	strb	r2, [r3, #17]
        if (settings.flags & BITFLAG_LASER_MODE) {
 800a744:	4b48      	ldr	r3, [pc, #288]	; (800a868 <st_prep_buffer+0x2b4>)
 800a746:	2248      	movs	r2, #72	; 0x48
 800a748:	5c9b      	ldrb	r3, [r3, r2]
 800a74a:	001a      	movs	r2, r3
 800a74c:	2302      	movs	r3, #2
 800a74e:	4013      	ands	r3, r2
 800a750:	d016      	beq.n	800a780 <st_prep_buffer+0x1cc>
          if (pl_block->condition & PL_COND_FLAG_SPINDLE_CCW) {
 800a752:	4b40      	ldr	r3, [pc, #256]	; (800a854 <st_prep_buffer+0x2a0>)
 800a754:	681b      	ldr	r3, [r3, #0]
 800a756:	7c5b      	ldrb	r3, [r3, #17]
 800a758:	001a      	movs	r2, r3
 800a75a:	2320      	movs	r3, #32
 800a75c:	4013      	ands	r3, r2
 800a75e:	d00f      	beq.n	800a780 <st_prep_buffer+0x1cc>
            // Pre-compute inverse programmed rate to speed up PWM updating per step segment.
            prep.inv_rate = 1.0 / pl_block->programmed_rate;
 800a760:	4b3c      	ldr	r3, [pc, #240]	; (800a854 <st_prep_buffer+0x2a0>)
 800a762:	681b      	ldr	r3, [r3, #0]
 800a764:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a766:	1c19      	adds	r1, r3, #0
 800a768:	20fe      	movs	r0, #254	; 0xfe
 800a76a:	0580      	lsls	r0, r0, #22
 800a76c:	f7f5 ff86 	bl	800067c <__aeabi_fdiv>
 800a770:	1c03      	adds	r3, r0, #0
 800a772:	1c1a      	adds	r2, r3, #0
 800a774:	4b38      	ldr	r3, [pc, #224]	; (800a858 <st_prep_buffer+0x2a4>)
 800a776:	631a      	str	r2, [r3, #48]	; 0x30
            st_prep_block->is_pwm_rate_adjusted = true;
 800a778:	4b39      	ldr	r3, [pc, #228]	; (800a860 <st_prep_buffer+0x2ac>)
 800a77a:	681b      	ldr	r3, [r3, #0]
 800a77c:	2201      	movs	r2, #1
 800a77e:	745a      	strb	r2, [r3, #17]
			 Compute the velocity profile of a new planner block based on its entry and exit
			 speeds, or recompute the profile of a partially-completed planner block if the
			 planner has updated it. For a commanded forced-deceleration, such as from a feed
			 hold, override the planner velocities and decelerate to the target exit speed.
			*/
			prep.mm_complete = 0.0f; // Default velocity profile complete at 0.0mm from end of block.
 800a780:	4b35      	ldr	r3, [pc, #212]	; (800a858 <st_prep_buffer+0x2a4>)
 800a782:	2200      	movs	r2, #0
 800a784:	619a      	str	r2, [r3, #24]
			float inv_2_accel = 0.5f/pl_block->acceleration;
 800a786:	4b33      	ldr	r3, [pc, #204]	; (800a854 <st_prep_buffer+0x2a0>)
 800a788:	681b      	ldr	r3, [r3, #0]
 800a78a:	69db      	ldr	r3, [r3, #28]
 800a78c:	1c19      	adds	r1, r3, #0
 800a78e:	20fc      	movs	r0, #252	; 0xfc
 800a790:	0580      	lsls	r0, r0, #22
 800a792:	f7f5 ff73 	bl	800067c <__aeabi_fdiv>
 800a796:	1c03      	adds	r3, r0, #0
 800a798:	617b      	str	r3, [r7, #20]
			if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { // [Forced Deceleration to Zero Velocity]
 800a79a:	4b2d      	ldr	r3, [pc, #180]	; (800a850 <st_prep_buffer+0x29c>)
 800a79c:	791b      	ldrb	r3, [r3, #4]
 800a79e:	001a      	movs	r2, r3
 800a7a0:	2302      	movs	r3, #2
 800a7a2:	4013      	ands	r3, r2
 800a7a4:	d040      	beq.n	800a828 <st_prep_buffer+0x274>
				// Compute velocity profile parameters for a feed hold in-progress. This profile overrides
				// the planner block profile, enforcing a deceleration to zero speed.
				prep.ramp_type = RAMP_DECEL;
 800a7a6:	4b2c      	ldr	r3, [pc, #176]	; (800a858 <st_prep_buffer+0x2a4>)
 800a7a8:	2202      	movs	r2, #2
 800a7aa:	751a      	strb	r2, [r3, #20]
				// Compute decelerate distance relative to end of block.
				float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
 800a7ac:	4b29      	ldr	r3, [pc, #164]	; (800a854 <st_prep_buffer+0x2a0>)
 800a7ae:	681b      	ldr	r3, [r3, #0]
 800a7b0:	6a1c      	ldr	r4, [r3, #32]
 800a7b2:	4b28      	ldr	r3, [pc, #160]	; (800a854 <st_prep_buffer+0x2a0>)
 800a7b4:	681b      	ldr	r3, [r3, #0]
 800a7b6:	695b      	ldr	r3, [r3, #20]
 800a7b8:	6979      	ldr	r1, [r7, #20]
 800a7ba:	1c18      	adds	r0, r3, #0
 800a7bc:	f7f6 f928 	bl	8000a10 <__aeabi_fmul>
 800a7c0:	1c03      	adds	r3, r0, #0
 800a7c2:	1c19      	adds	r1, r3, #0
 800a7c4:	1c20      	adds	r0, r4, #0
 800a7c6:	f7f6 fa37 	bl	8000c38 <__aeabi_fsub>
 800a7ca:	1c03      	adds	r3, r0, #0
 800a7cc:	613b      	str	r3, [r7, #16]
				if (decel_dist < 0.0f) {
 800a7ce:	2100      	movs	r1, #0
 800a7d0:	6938      	ldr	r0, [r7, #16]
 800a7d2:	f7f5 fd7f 	bl	80002d4 <__aeabi_fcmplt>
 800a7d6:	1e03      	subs	r3, r0, #0
 800a7d8:	d01f      	beq.n	800a81a <st_prep_buffer+0x266>
					// Deceleration through entire planner block. End of feed hold is not in this block.
					prep.exit_speed = sqrtf(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
 800a7da:	4b1e      	ldr	r3, [pc, #120]	; (800a854 <st_prep_buffer+0x2a0>)
 800a7dc:	681b      	ldr	r3, [r3, #0]
 800a7de:	695c      	ldr	r4, [r3, #20]
 800a7e0:	4b1c      	ldr	r3, [pc, #112]	; (800a854 <st_prep_buffer+0x2a0>)
 800a7e2:	681b      	ldr	r3, [r3, #0]
 800a7e4:	69db      	ldr	r3, [r3, #28]
 800a7e6:	1c19      	adds	r1, r3, #0
 800a7e8:	1c18      	adds	r0, r3, #0
 800a7ea:	f7f5 fdd1 	bl	8000390 <__aeabi_fadd>
 800a7ee:	1c03      	adds	r3, r0, #0
 800a7f0:	1c1a      	adds	r2, r3, #0
 800a7f2:	4b18      	ldr	r3, [pc, #96]	; (800a854 <st_prep_buffer+0x2a0>)
 800a7f4:	681b      	ldr	r3, [r3, #0]
 800a7f6:	6a1b      	ldr	r3, [r3, #32]
 800a7f8:	1c19      	adds	r1, r3, #0
 800a7fa:	1c10      	adds	r0, r2, #0
 800a7fc:	f7f6 f908 	bl	8000a10 <__aeabi_fmul>
 800a800:	1c03      	adds	r3, r0, #0
 800a802:	1c19      	adds	r1, r3, #0
 800a804:	1c20      	adds	r0, r4, #0
 800a806:	f7f6 fa17 	bl	8000c38 <__aeabi_fsub>
 800a80a:	1c03      	adds	r3, r0, #0
 800a80c:	1c18      	adds	r0, r3, #0
 800a80e:	f001 fe0b 	bl	800c428 <sqrtf>
 800a812:	1c02      	adds	r2, r0, #0
 800a814:	4b10      	ldr	r3, [pc, #64]	; (800a858 <st_prep_buffer+0x2a4>)
 800a816:	625a      	str	r2, [r3, #36]	; 0x24
 800a818:	e139      	b.n	800aa8e <st_prep_buffer+0x4da>
				} else {
					prep.mm_complete = decel_dist; // End of feed hold.
 800a81a:	4b0f      	ldr	r3, [pc, #60]	; (800a858 <st_prep_buffer+0x2a4>)
 800a81c:	693a      	ldr	r2, [r7, #16]
 800a81e:	619a      	str	r2, [r3, #24]
					prep.exit_speed = 0.0f;
 800a820:	4b0d      	ldr	r3, [pc, #52]	; (800a858 <st_prep_buffer+0x2a4>)
 800a822:	2200      	movs	r2, #0
 800a824:	625a      	str	r2, [r3, #36]	; 0x24
 800a826:	e132      	b.n	800aa8e <st_prep_buffer+0x4da>
				}
			} else { // [Normal Operation]
				// Compute or recompute velocity profile parameters of the prepped planner block.
				prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
 800a828:	4b0b      	ldr	r3, [pc, #44]	; (800a858 <st_prep_buffer+0x2a4>)
 800a82a:	2200      	movs	r2, #0
 800a82c:	751a      	strb	r2, [r3, #20]
				prep.accelerate_until = pl_block->millimeters;
 800a82e:	4b09      	ldr	r3, [pc, #36]	; (800a854 <st_prep_buffer+0x2a0>)
 800a830:	681b      	ldr	r3, [r3, #0]
 800a832:	6a1a      	ldr	r2, [r3, #32]
 800a834:	4b08      	ldr	r3, [pc, #32]	; (800a858 <st_prep_buffer+0x2a4>)
 800a836:	629a      	str	r2, [r3, #40]	; 0x28

				float exit_speed_sqr;
				float nominal_speed;
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
 800a838:	4b05      	ldr	r3, [pc, #20]	; (800a850 <st_prep_buffer+0x29c>)
 800a83a:	791b      	ldrb	r3, [r3, #4]
 800a83c:	001a      	movs	r2, r3
 800a83e:	2304      	movs	r3, #4
 800a840:	4013      	ands	r3, r2
 800a842:	d013      	beq.n	800a86c <st_prep_buffer+0x2b8>
          prep.exit_speed = exit_speed_sqr = 0.0f; // Enforce stop at end of system motion.
 800a844:	2300      	movs	r3, #0
 800a846:	653b      	str	r3, [r7, #80]	; 0x50
 800a848:	4b03      	ldr	r3, [pc, #12]	; (800a858 <st_prep_buffer+0x2a4>)
 800a84a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800a84c:	625a      	str	r2, [r3, #36]	; 0x24
 800a84e:	e018      	b.n	800a882 <st_prep_buffer+0x2ce>
 800a850:	20000b2c 	.word	0x20000b2c
 800a854:	2000051c 	.word	0x2000051c
 800a858:	20000524 	.word	0x20000524
 800a85c:	20000450 	.word	0x20000450
 800a860:	20000520 	.word	0x20000520
 800a864:	3fa00000 	.word	0x3fa00000
 800a868:	20000acc 	.word	0x20000acc
        } else {
          exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
 800a86c:	f7fc f9a0 	bl	8006bb0 <plan_get_exec_block_exit_speed_sqr>
 800a870:	1c03      	adds	r3, r0, #0
 800a872:	653b      	str	r3, [r7, #80]	; 0x50
          prep.exit_speed = sqrtf(exit_speed_sqr);
 800a874:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a876:	1c18      	adds	r0, r3, #0
 800a878:	f001 fdd6 	bl	800c428 <sqrtf>
 800a87c:	1c02      	adds	r2, r0, #0
 800a87e:	4bd0      	ldr	r3, [pc, #832]	; (800abc0 <st_prep_buffer+0x60c>)
 800a880:	625a      	str	r2, [r3, #36]	; 0x24
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
 800a882:	4bd0      	ldr	r3, [pc, #832]	; (800abc4 <st_prep_buffer+0x610>)
 800a884:	681b      	ldr	r3, [r3, #0]
 800a886:	0018      	movs	r0, r3
 800a888:	f7fc f9ca 	bl	8006c20 <plan_compute_profile_nominal_speed>
 800a88c:	1c03      	adds	r3, r0, #0
 800a88e:	60fb      	str	r3, [r7, #12]
				float nominal_speed_sqr = nominal_speed*nominal_speed;
 800a890:	68f9      	ldr	r1, [r7, #12]
 800a892:	68f8      	ldr	r0, [r7, #12]
 800a894:	f7f6 f8bc 	bl	8000a10 <__aeabi_fmul>
 800a898:	1c03      	adds	r3, r0, #0
 800a89a:	60bb      	str	r3, [r7, #8]
				float intersect_distance =
								0.5f*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
 800a89c:	4bc9      	ldr	r3, [pc, #804]	; (800abc4 <st_prep_buffer+0x610>)
 800a89e:	681b      	ldr	r3, [r3, #0]
 800a8a0:	6a1c      	ldr	r4, [r3, #32]
 800a8a2:	4bc8      	ldr	r3, [pc, #800]	; (800abc4 <st_prep_buffer+0x610>)
 800a8a4:	681b      	ldr	r3, [r3, #0]
 800a8a6:	695b      	ldr	r3, [r3, #20]
 800a8a8:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800a8aa:	1c18      	adds	r0, r3, #0
 800a8ac:	f7f6 f9c4 	bl	8000c38 <__aeabi_fsub>
 800a8b0:	1c03      	adds	r3, r0, #0
 800a8b2:	6979      	ldr	r1, [r7, #20]
 800a8b4:	1c18      	adds	r0, r3, #0
 800a8b6:	f7f6 f8ab 	bl	8000a10 <__aeabi_fmul>
 800a8ba:	1c03      	adds	r3, r0, #0
 800a8bc:	1c19      	adds	r1, r3, #0
 800a8be:	1c20      	adds	r0, r4, #0
 800a8c0:	f7f5 fd66 	bl	8000390 <__aeabi_fadd>
 800a8c4:	1c03      	adds	r3, r0, #0
          prep.exit_speed = sqrtf(exit_speed_sqr);
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
				float nominal_speed_sqr = nominal_speed*nominal_speed;
				float intersect_distance =
 800a8c6:	21fc      	movs	r1, #252	; 0xfc
 800a8c8:	0589      	lsls	r1, r1, #22
 800a8ca:	1c18      	adds	r0, r3, #0
 800a8cc:	f7f6 f8a0 	bl	8000a10 <__aeabi_fmul>
 800a8d0:	1c03      	adds	r3, r0, #0
 800a8d2:	607b      	str	r3, [r7, #4]
								0.5f*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));

        if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
 800a8d4:	4bbb      	ldr	r3, [pc, #748]	; (800abc4 <st_prep_buffer+0x610>)
 800a8d6:	681b      	ldr	r3, [r3, #0]
 800a8d8:	695b      	ldr	r3, [r3, #20]
 800a8da:	68b9      	ldr	r1, [r7, #8]
 800a8dc:	1c18      	adds	r0, r3, #0
 800a8de:	f7f5 fd0d 	bl	80002fc <__aeabi_fcmpgt>
 800a8e2:	1e03      	subs	r3, r0, #0
 800a8e4:	d05d      	beq.n	800a9a2 <st_prep_buffer+0x3ee>
          prep.accelerate_until = pl_block->millimeters - inv_2_accel*(pl_block->entry_speed_sqr-nominal_speed_sqr);
 800a8e6:	4bb7      	ldr	r3, [pc, #732]	; (800abc4 <st_prep_buffer+0x610>)
 800a8e8:	681b      	ldr	r3, [r3, #0]
 800a8ea:	6a1c      	ldr	r4, [r3, #32]
 800a8ec:	4bb5      	ldr	r3, [pc, #724]	; (800abc4 <st_prep_buffer+0x610>)
 800a8ee:	681b      	ldr	r3, [r3, #0]
 800a8f0:	695b      	ldr	r3, [r3, #20]
 800a8f2:	68b9      	ldr	r1, [r7, #8]
 800a8f4:	1c18      	adds	r0, r3, #0
 800a8f6:	f7f6 f99f 	bl	8000c38 <__aeabi_fsub>
 800a8fa:	1c03      	adds	r3, r0, #0
 800a8fc:	6979      	ldr	r1, [r7, #20]
 800a8fe:	1c18      	adds	r0, r3, #0
 800a900:	f7f6 f886 	bl	8000a10 <__aeabi_fmul>
 800a904:	1c03      	adds	r3, r0, #0
 800a906:	1c19      	adds	r1, r3, #0
 800a908:	1c20      	adds	r0, r4, #0
 800a90a:	f7f6 f995 	bl	8000c38 <__aeabi_fsub>
 800a90e:	1c03      	adds	r3, r0, #0
 800a910:	1c1a      	adds	r2, r3, #0
 800a912:	4bab      	ldr	r3, [pc, #684]	; (800abc0 <st_prep_buffer+0x60c>)
 800a914:	629a      	str	r2, [r3, #40]	; 0x28
          if (prep.accelerate_until <= 0.0f) { // Deceleration-only.
 800a916:	4baa      	ldr	r3, [pc, #680]	; (800abc0 <st_prep_buffer+0x60c>)
 800a918:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a91a:	2100      	movs	r1, #0
 800a91c:	1c18      	adds	r0, r3, #0
 800a91e:	f7f5 fce3 	bl	80002e8 <__aeabi_fcmple>
 800a922:	1e03      	subs	r3, r0, #0
 800a924:	d029      	beq.n	800a97a <st_prep_buffer+0x3c6>
            prep.ramp_type = RAMP_DECEL;
 800a926:	4ba6      	ldr	r3, [pc, #664]	; (800abc0 <st_prep_buffer+0x60c>)
 800a928:	2202      	movs	r2, #2
 800a92a:	751a      	strb	r2, [r3, #20]
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;

            // Compute override block exit speed since it doesn't match the planner exit speed.
            prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2*pl_block->acceleration*pl_block->millimeters);
 800a92c:	4ba5      	ldr	r3, [pc, #660]	; (800abc4 <st_prep_buffer+0x610>)
 800a92e:	681b      	ldr	r3, [r3, #0]
 800a930:	695c      	ldr	r4, [r3, #20]
 800a932:	4ba4      	ldr	r3, [pc, #656]	; (800abc4 <st_prep_buffer+0x610>)
 800a934:	681b      	ldr	r3, [r3, #0]
 800a936:	69db      	ldr	r3, [r3, #28]
 800a938:	1c19      	adds	r1, r3, #0
 800a93a:	1c18      	adds	r0, r3, #0
 800a93c:	f7f5 fd28 	bl	8000390 <__aeabi_fadd>
 800a940:	1c03      	adds	r3, r0, #0
 800a942:	1c1a      	adds	r2, r3, #0
 800a944:	4b9f      	ldr	r3, [pc, #636]	; (800abc4 <st_prep_buffer+0x610>)
 800a946:	681b      	ldr	r3, [r3, #0]
 800a948:	6a1b      	ldr	r3, [r3, #32]
 800a94a:	1c19      	adds	r1, r3, #0
 800a94c:	1c10      	adds	r0, r2, #0
 800a94e:	f7f6 f85f 	bl	8000a10 <__aeabi_fmul>
 800a952:	1c03      	adds	r3, r0, #0
 800a954:	1c19      	adds	r1, r3, #0
 800a956:	1c20      	adds	r0, r4, #0
 800a958:	f7f6 f96e 	bl	8000c38 <__aeabi_fsub>
 800a95c:	1c03      	adds	r3, r0, #0
 800a95e:	1c18      	adds	r0, r3, #0
 800a960:	f001 fd62 	bl	800c428 <sqrtf>
 800a964:	1c02      	adds	r2, r0, #0
 800a966:	4b96      	ldr	r3, [pc, #600]	; (800abc0 <st_prep_buffer+0x60c>)
 800a968:	625a      	str	r2, [r3, #36]	; 0x24
            prep.recalculate_flag |= PREP_FLAG_DECEL_OVERRIDE; // Flag to load next block as deceleration override.
 800a96a:	4b95      	ldr	r3, [pc, #596]	; (800abc0 <st_prep_buffer+0x60c>)
 800a96c:	785b      	ldrb	r3, [r3, #1]
 800a96e:	2208      	movs	r2, #8
 800a970:	4313      	orrs	r3, r2
 800a972:	b2da      	uxtb	r2, r3
 800a974:	4b92      	ldr	r3, [pc, #584]	; (800abc0 <st_prep_buffer+0x60c>)
 800a976:	705a      	strb	r2, [r3, #1]
 800a978:	e089      	b.n	800aa8e <st_prep_buffer+0x4da>
            // Can be tricky since entry speed will be current speed, as in feed holds.
            // Also, look into near-zero speed handling issues with this.

          } else {
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
 800a97a:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800a97c:	68b8      	ldr	r0, [r7, #8]
 800a97e:	f7f6 f95b 	bl	8000c38 <__aeabi_fsub>
 800a982:	1c03      	adds	r3, r0, #0
 800a984:	6979      	ldr	r1, [r7, #20]
 800a986:	1c18      	adds	r0, r3, #0
 800a988:	f7f6 f842 	bl	8000a10 <__aeabi_fmul>
 800a98c:	1c03      	adds	r3, r0, #0
 800a98e:	1c1a      	adds	r2, r3, #0
 800a990:	4b8b      	ldr	r3, [pc, #556]	; (800abc0 <st_prep_buffer+0x60c>)
 800a992:	62da      	str	r2, [r3, #44]	; 0x2c
            prep.maximum_speed = nominal_speed;
 800a994:	4b8a      	ldr	r3, [pc, #552]	; (800abc0 <st_prep_buffer+0x60c>)
 800a996:	68fa      	ldr	r2, [r7, #12]
 800a998:	621a      	str	r2, [r3, #32]
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
 800a99a:	4b89      	ldr	r3, [pc, #548]	; (800abc0 <st_prep_buffer+0x60c>)
 800a99c:	2203      	movs	r2, #3
 800a99e:	751a      	strb	r2, [r3, #20]
 800a9a0:	e075      	b.n	800aa8e <st_prep_buffer+0x4da>
          }
				} else if (intersect_distance > 0.0f) {
 800a9a2:	2100      	movs	r1, #0
 800a9a4:	6878      	ldr	r0, [r7, #4]
 800a9a6:	f7f5 fca9 	bl	80002fc <__aeabi_fcmpgt>
 800a9aa:	1e03      	subs	r3, r0, #0
 800a9ac:	d068      	beq.n	800aa80 <st_prep_buffer+0x4cc>
					if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
 800a9ae:	4b85      	ldr	r3, [pc, #532]	; (800abc4 <st_prep_buffer+0x610>)
 800a9b0:	681b      	ldr	r3, [r3, #0]
 800a9b2:	6a1b      	ldr	r3, [r3, #32]
 800a9b4:	6879      	ldr	r1, [r7, #4]
 800a9b6:	1c18      	adds	r0, r3, #0
 800a9b8:	f7f5 fca0 	bl	80002fc <__aeabi_fcmpgt>
 800a9bc:	1e03      	subs	r3, r0, #0
 800a9be:	d05b      	beq.n	800aa78 <st_prep_buffer+0x4c4>
						// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
						prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
 800a9c0:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800a9c2:	68b8      	ldr	r0, [r7, #8]
 800a9c4:	f7f6 f938 	bl	8000c38 <__aeabi_fsub>
 800a9c8:	1c03      	adds	r3, r0, #0
 800a9ca:	6979      	ldr	r1, [r7, #20]
 800a9cc:	1c18      	adds	r0, r3, #0
 800a9ce:	f7f6 f81f 	bl	8000a10 <__aeabi_fmul>
 800a9d2:	1c03      	adds	r3, r0, #0
 800a9d4:	1c1a      	adds	r2, r3, #0
 800a9d6:	4b7a      	ldr	r3, [pc, #488]	; (800abc0 <st_prep_buffer+0x60c>)
 800a9d8:	62da      	str	r2, [r3, #44]	; 0x2c
						if (prep.decelerate_after < intersect_distance) { // Trapezoid type
 800a9da:	4b79      	ldr	r3, [pc, #484]	; (800abc0 <st_prep_buffer+0x60c>)
 800a9dc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a9de:	6879      	ldr	r1, [r7, #4]
 800a9e0:	1c18      	adds	r0, r3, #0
 800a9e2:	f7f5 fc77 	bl	80002d4 <__aeabi_fcmplt>
 800a9e6:	1e03      	subs	r3, r0, #0
 800a9e8:	d027      	beq.n	800aa3a <st_prep_buffer+0x486>
							prep.maximum_speed = nominal_speed;
 800a9ea:	4b75      	ldr	r3, [pc, #468]	; (800abc0 <st_prep_buffer+0x60c>)
 800a9ec:	68fa      	ldr	r2, [r7, #12]
 800a9ee:	621a      	str	r2, [r3, #32]
							if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
 800a9f0:	4b74      	ldr	r3, [pc, #464]	; (800abc4 <st_prep_buffer+0x610>)
 800a9f2:	681b      	ldr	r3, [r3, #0]
 800a9f4:	695b      	ldr	r3, [r3, #20]
 800a9f6:	68b9      	ldr	r1, [r7, #8]
 800a9f8:	1c18      	adds	r0, r3, #0
 800a9fa:	f7f5 fc65 	bl	80002c8 <__aeabi_fcmpeq>
 800a9fe:	1e03      	subs	r3, r0, #0
 800aa00:	d003      	beq.n	800aa0a <st_prep_buffer+0x456>
								// Cruise-deceleration or cruise-only type.
								prep.ramp_type = RAMP_CRUISE;
 800aa02:	4b6f      	ldr	r3, [pc, #444]	; (800abc0 <st_prep_buffer+0x60c>)
 800aa04:	2201      	movs	r2, #1
 800aa06:	751a      	strb	r2, [r3, #20]
 800aa08:	e041      	b.n	800aa8e <st_prep_buffer+0x4da>
							} else {
								// Full-trapezoid or acceleration-cruise types
								prep.accelerate_until -= inv_2_accel*(nominal_speed_sqr-pl_block->entry_speed_sqr);
 800aa0a:	4b6d      	ldr	r3, [pc, #436]	; (800abc0 <st_prep_buffer+0x60c>)
 800aa0c:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 800aa0e:	4b6d      	ldr	r3, [pc, #436]	; (800abc4 <st_prep_buffer+0x610>)
 800aa10:	681b      	ldr	r3, [r3, #0]
 800aa12:	695b      	ldr	r3, [r3, #20]
 800aa14:	1c19      	adds	r1, r3, #0
 800aa16:	68b8      	ldr	r0, [r7, #8]
 800aa18:	f7f6 f90e 	bl	8000c38 <__aeabi_fsub>
 800aa1c:	1c03      	adds	r3, r0, #0
 800aa1e:	6979      	ldr	r1, [r7, #20]
 800aa20:	1c18      	adds	r0, r3, #0
 800aa22:	f7f5 fff5 	bl	8000a10 <__aeabi_fmul>
 800aa26:	1c03      	adds	r3, r0, #0
 800aa28:	1c19      	adds	r1, r3, #0
 800aa2a:	1c20      	adds	r0, r4, #0
 800aa2c:	f7f6 f904 	bl	8000c38 <__aeabi_fsub>
 800aa30:	1c03      	adds	r3, r0, #0
 800aa32:	1c1a      	adds	r2, r3, #0
 800aa34:	4b62      	ldr	r3, [pc, #392]	; (800abc0 <st_prep_buffer+0x60c>)
 800aa36:	629a      	str	r2, [r3, #40]	; 0x28
 800aa38:	e029      	b.n	800aa8e <st_prep_buffer+0x4da>
							}
						} else { // Triangle type
							prep.accelerate_until = intersect_distance;
 800aa3a:	4b61      	ldr	r3, [pc, #388]	; (800abc0 <st_prep_buffer+0x60c>)
 800aa3c:	687a      	ldr	r2, [r7, #4]
 800aa3e:	629a      	str	r2, [r3, #40]	; 0x28
							prep.decelerate_after = intersect_distance;
 800aa40:	4b5f      	ldr	r3, [pc, #380]	; (800abc0 <st_prep_buffer+0x60c>)
 800aa42:	687a      	ldr	r2, [r7, #4]
 800aa44:	62da      	str	r2, [r3, #44]	; 0x2c
							prep.maximum_speed = sqrtf(2.0f*pl_block->acceleration*intersect_distance+exit_speed_sqr);
 800aa46:	4b5f      	ldr	r3, [pc, #380]	; (800abc4 <st_prep_buffer+0x610>)
 800aa48:	681b      	ldr	r3, [r3, #0]
 800aa4a:	69db      	ldr	r3, [r3, #28]
 800aa4c:	1c19      	adds	r1, r3, #0
 800aa4e:	1c18      	adds	r0, r3, #0
 800aa50:	f7f5 fc9e 	bl	8000390 <__aeabi_fadd>
 800aa54:	1c03      	adds	r3, r0, #0
 800aa56:	6879      	ldr	r1, [r7, #4]
 800aa58:	1c18      	adds	r0, r3, #0
 800aa5a:	f7f5 ffd9 	bl	8000a10 <__aeabi_fmul>
 800aa5e:	1c03      	adds	r3, r0, #0
 800aa60:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800aa62:	1c18      	adds	r0, r3, #0
 800aa64:	f7f5 fc94 	bl	8000390 <__aeabi_fadd>
 800aa68:	1c03      	adds	r3, r0, #0
 800aa6a:	1c18      	adds	r0, r3, #0
 800aa6c:	f001 fcdc 	bl	800c428 <sqrtf>
 800aa70:	1c02      	adds	r2, r0, #0
 800aa72:	4b53      	ldr	r3, [pc, #332]	; (800abc0 <st_prep_buffer+0x60c>)
 800aa74:	621a      	str	r2, [r3, #32]
 800aa76:	e00a      	b.n	800aa8e <st_prep_buffer+0x4da>
						}
					} else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
 800aa78:	4b51      	ldr	r3, [pc, #324]	; (800abc0 <st_prep_buffer+0x60c>)
 800aa7a:	2202      	movs	r2, #2
 800aa7c:	751a      	strb	r2, [r3, #20]
 800aa7e:	e006      	b.n	800aa8e <st_prep_buffer+0x4da>
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;
					}
				} else { // Acceleration-only type
					prep.accelerate_until = 0.0f;
 800aa80:	4b4f      	ldr	r3, [pc, #316]	; (800abc0 <st_prep_buffer+0x60c>)
 800aa82:	2200      	movs	r2, #0
 800aa84:	629a      	str	r2, [r3, #40]	; 0x28
					// prep.decelerate_after = 0.0f;
					prep.maximum_speed = prep.exit_speed;
 800aa86:	4b4e      	ldr	r3, [pc, #312]	; (800abc0 <st_prep_buffer+0x60c>)
 800aa88:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800aa8a:	4b4d      	ldr	r3, [pc, #308]	; (800abc0 <st_prep_buffer+0x60c>)
 800aa8c:	621a      	str	r2, [r3, #32]
				}
			}
      
      #ifdef VARIABLE_SPINDLE
        bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); // Force update whenever updating block.
 800aa8e:	4b4e      	ldr	r3, [pc, #312]	; (800abc8 <st_prep_buffer+0x614>)
 800aa90:	791b      	ldrb	r3, [r3, #4]
 800aa92:	2208      	movs	r2, #8
 800aa94:	4313      	orrs	r3, r2
 800aa96:	b2da      	uxtb	r2, r3
 800aa98:	4b4b      	ldr	r3, [pc, #300]	; (800abc8 <st_prep_buffer+0x614>)
 800aa9a:	711a      	strb	r2, [r3, #4]
      #endif
    }
    
    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
 800aa9c:	4b4b      	ldr	r3, [pc, #300]	; (800abcc <st_prep_buffer+0x618>)
 800aa9e:	781b      	ldrb	r3, [r3, #0]
 800aaa0:	00da      	lsls	r2, r3, #3
 800aaa2:	4b4b      	ldr	r3, [pc, #300]	; (800abd0 <st_prep_buffer+0x61c>)
 800aaa4:	18d3      	adds	r3, r2, r3
 800aaa6:	633b      	str	r3, [r7, #48]	; 0x30

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
 800aaa8:	4b45      	ldr	r3, [pc, #276]	; (800abc0 <st_prep_buffer+0x60c>)
 800aaaa:	781a      	ldrb	r2, [r3, #0]
 800aaac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aaae:	711a      	strb	r2, [r3, #4]
      acceleration ramp, cruising state, and deceleration ramp. Each ramp's travel distance
      may range from zero to the length of the block. Velocity profiles can end either at
      the end of planner block (typical) or mid-block at the end of a forced deceleration,
      such as from a feed hold.
    */
    float dt_max = DT_SEGMENT; // Maximum segment time
 800aab0:	4b48      	ldr	r3, [pc, #288]	; (800abd4 <st_prep_buffer+0x620>)
 800aab2:	64fb      	str	r3, [r7, #76]	; 0x4c
    float dt = 0.0f; // Initialize segment time
 800aab4:	2300      	movs	r3, #0
 800aab6:	64bb      	str	r3, [r7, #72]	; 0x48
    float time_var = dt_max; // Time worker variable
 800aab8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aaba:	647b      	str	r3, [r7, #68]	; 0x44
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
 800aabc:	4b41      	ldr	r3, [pc, #260]	; (800abc4 <st_prep_buffer+0x610>)
 800aabe:	681b      	ldr	r3, [r3, #0]
 800aac0:	6a1b      	ldr	r3, [r3, #32]
 800aac2:	643b      	str	r3, [r7, #64]	; 0x40
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
 800aac4:	4b3e      	ldr	r3, [pc, #248]	; (800abc0 <st_prep_buffer+0x60c>)
 800aac6:	691b      	ldr	r3, [r3, #16]
 800aac8:	1c19      	adds	r1, r3, #0
 800aaca:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800aacc:	f7f6 f8b4 	bl	8000c38 <__aeabi_fsub>
 800aad0:	1c03      	adds	r3, r0, #0
 800aad2:	63fb      	str	r3, [r7, #60]	; 0x3c
    if (minimum_mm < 0.0f) { minimum_mm = 0.0f; }
 800aad4:	2100      	movs	r1, #0
 800aad6:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800aad8:	f7f5 fbfc 	bl	80002d4 <__aeabi_fcmplt>
 800aadc:	1e03      	subs	r3, r0, #0
 800aade:	d100      	bne.n	800aae2 <st_prep_buffer+0x52e>
 800aae0:	e001      	b.n	800aae6 <st_prep_buffer+0x532>
 800aae2:	2300      	movs	r3, #0
 800aae4:	63fb      	str	r3, [r7, #60]	; 0x3c

    do {
      switch (prep.ramp_type) {
 800aae6:	4b36      	ldr	r3, [pc, #216]	; (800abc0 <st_prep_buffer+0x60c>)
 800aae8:	7d1b      	ldrb	r3, [r3, #20]
 800aaea:	2b01      	cmp	r3, #1
 800aaec:	d100      	bne.n	800aaf0 <st_prep_buffer+0x53c>
 800aaee:	e0db      	b.n	800aca8 <st_prep_buffer+0x6f4>
 800aaf0:	2b03      	cmp	r3, #3
 800aaf2:	d002      	beq.n	800aafa <st_prep_buffer+0x546>
 800aaf4:	2b00      	cmp	r3, #0
 800aaf6:	d06f      	beq.n	800abd8 <st_prep_buffer+0x624>
 800aaf8:	e105      	b.n	800ad06 <st_prep_buffer+0x752>
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
 800aafa:	4b32      	ldr	r3, [pc, #200]	; (800abc4 <st_prep_buffer+0x610>)
 800aafc:	681b      	ldr	r3, [r3, #0]
 800aafe:	69db      	ldr	r3, [r3, #28]
 800ab00:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800ab02:	1c18      	adds	r0, r3, #0
 800ab04:	f7f5 ff84 	bl	8000a10 <__aeabi_fmul>
 800ab08:	1c03      	adds	r3, r0, #0
 800ab0a:	62fb      	str	r3, [r7, #44]	; 0x2c
          mm_var = time_var*(prep.current_speed - 0.5f*speed_var);
 800ab0c:	4b2c      	ldr	r3, [pc, #176]	; (800abc0 <st_prep_buffer+0x60c>)
 800ab0e:	69dc      	ldr	r4, [r3, #28]
 800ab10:	21fc      	movs	r1, #252	; 0xfc
 800ab12:	0589      	lsls	r1, r1, #22
 800ab14:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800ab16:	f7f5 ff7b 	bl	8000a10 <__aeabi_fmul>
 800ab1a:	1c03      	adds	r3, r0, #0
 800ab1c:	1c19      	adds	r1, r3, #0
 800ab1e:	1c20      	adds	r0, r4, #0
 800ab20:	f7f6 f88a 	bl	8000c38 <__aeabi_fsub>
 800ab24:	1c03      	adds	r3, r0, #0
 800ab26:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800ab28:	1c18      	adds	r0, r3, #0
 800ab2a:	f7f5 ff71 	bl	8000a10 <__aeabi_fmul>
 800ab2e:	1c03      	adds	r3, r0, #0
 800ab30:	62bb      	str	r3, [r7, #40]	; 0x28
          mm_remaining -= mm_var;
 800ab32:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800ab34:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800ab36:	f7f6 f87f 	bl	8000c38 <__aeabi_fsub>
 800ab3a:	1c03      	adds	r3, r0, #0
 800ab3c:	643b      	str	r3, [r7, #64]	; 0x40
          if ((mm_remaining < prep.accelerate_until) || (mm_var <= 0)) {
 800ab3e:	4b20      	ldr	r3, [pc, #128]	; (800abc0 <st_prep_buffer+0x60c>)
 800ab40:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ab42:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800ab44:	1c18      	adds	r0, r3, #0
 800ab46:	f7f5 fbd9 	bl	80002fc <__aeabi_fcmpgt>
 800ab4a:	1e03      	subs	r3, r0, #0
 800ab4c:	d105      	bne.n	800ab5a <st_prep_buffer+0x5a6>
 800ab4e:	2100      	movs	r1, #0
 800ab50:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800ab52:	f7f5 fbc9 	bl	80002e8 <__aeabi_fcmple>
 800ab56:	1e03      	subs	r3, r0, #0
 800ab58:	d027      	beq.n	800abaa <st_prep_buffer+0x5f6>
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
 800ab5a:	4b19      	ldr	r3, [pc, #100]	; (800abc0 <st_prep_buffer+0x60c>)
 800ab5c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ab5e:	643b      	str	r3, [r7, #64]	; 0x40
            time_var = 2.0f*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
 800ab60:	4b18      	ldr	r3, [pc, #96]	; (800abc4 <st_prep_buffer+0x610>)
 800ab62:	681b      	ldr	r3, [r3, #0]
 800ab64:	6a1b      	ldr	r3, [r3, #32]
 800ab66:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800ab68:	1c18      	adds	r0, r3, #0
 800ab6a:	f7f6 f865 	bl	8000c38 <__aeabi_fsub>
 800ab6e:	1c03      	adds	r3, r0, #0
 800ab70:	1c19      	adds	r1, r3, #0
 800ab72:	1c18      	adds	r0, r3, #0
 800ab74:	f7f5 fc0c 	bl	8000390 <__aeabi_fadd>
 800ab78:	1c03      	adds	r3, r0, #0
 800ab7a:	1c1c      	adds	r4, r3, #0
 800ab7c:	4b10      	ldr	r3, [pc, #64]	; (800abc0 <st_prep_buffer+0x60c>)
 800ab7e:	69da      	ldr	r2, [r3, #28]
 800ab80:	4b0f      	ldr	r3, [pc, #60]	; (800abc0 <st_prep_buffer+0x60c>)
 800ab82:	6a1b      	ldr	r3, [r3, #32]
 800ab84:	1c19      	adds	r1, r3, #0
 800ab86:	1c10      	adds	r0, r2, #0
 800ab88:	f7f5 fc02 	bl	8000390 <__aeabi_fadd>
 800ab8c:	1c03      	adds	r3, r0, #0
 800ab8e:	1c19      	adds	r1, r3, #0
 800ab90:	1c20      	adds	r0, r4, #0
 800ab92:	f7f5 fd73 	bl	800067c <__aeabi_fdiv>
 800ab96:	1c03      	adds	r3, r0, #0
 800ab98:	647b      	str	r3, [r7, #68]	; 0x44
            prep.ramp_type = RAMP_CRUISE;
 800ab9a:	4b09      	ldr	r3, [pc, #36]	; (800abc0 <st_prep_buffer+0x60c>)
 800ab9c:	2201      	movs	r2, #1
 800ab9e:	751a      	strb	r2, [r3, #20]
            prep.current_speed = prep.maximum_speed;
 800aba0:	4b07      	ldr	r3, [pc, #28]	; (800abc0 <st_prep_buffer+0x60c>)
 800aba2:	6a1a      	ldr	r2, [r3, #32]
 800aba4:	4b06      	ldr	r3, [pc, #24]	; (800abc0 <st_prep_buffer+0x60c>)
 800aba6:	61da      	str	r2, [r3, #28]
          } else { // Mid-deceleration override ramp.
            prep.current_speed -= speed_var;
          }
          break;
 800aba8:	e10e      	b.n	800adc8 <st_prep_buffer+0x814>
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0f*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            prep.ramp_type = RAMP_CRUISE;
            prep.current_speed = prep.maximum_speed;
          } else { // Mid-deceleration override ramp.
            prep.current_speed -= speed_var;
 800abaa:	4b05      	ldr	r3, [pc, #20]	; (800abc0 <st_prep_buffer+0x60c>)
 800abac:	69db      	ldr	r3, [r3, #28]
 800abae:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800abb0:	1c18      	adds	r0, r3, #0
 800abb2:	f7f6 f841 	bl	8000c38 <__aeabi_fsub>
 800abb6:	1c03      	adds	r3, r0, #0
 800abb8:	1c1a      	adds	r2, r3, #0
 800abba:	4b01      	ldr	r3, [pc, #4]	; (800abc0 <st_prep_buffer+0x60c>)
 800abbc:	61da      	str	r2, [r3, #28]
          }
          break;
 800abbe:	e103      	b.n	800adc8 <st_prep_buffer+0x814>
 800abc0:	20000524 	.word	0x20000524
 800abc4:	2000051c 	.word	0x2000051c
 800abc8:	20000b2c 	.word	0x20000b2c
 800abcc:	20000511 	.word	0x20000511
 800abd0:	200004b4 	.word	0x200004b4
 800abd4:	392ec33e 	.word	0x392ec33e
        case RAMP_ACCEL:
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
 800abd8:	4bd0      	ldr	r3, [pc, #832]	; (800af1c <st_prep_buffer+0x968>)
 800abda:	681b      	ldr	r3, [r3, #0]
 800abdc:	69db      	ldr	r3, [r3, #28]
 800abde:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800abe0:	1c18      	adds	r0, r3, #0
 800abe2:	f7f5 ff15 	bl	8000a10 <__aeabi_fmul>
 800abe6:	1c03      	adds	r3, r0, #0
 800abe8:	62fb      	str	r3, [r7, #44]	; 0x2c
          mm_remaining -= time_var*(prep.current_speed + 0.5f*speed_var);
 800abea:	4bcd      	ldr	r3, [pc, #820]	; (800af20 <st_prep_buffer+0x96c>)
 800abec:	69dc      	ldr	r4, [r3, #28]
 800abee:	21fc      	movs	r1, #252	; 0xfc
 800abf0:	0589      	lsls	r1, r1, #22
 800abf2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800abf4:	f7f5 ff0c 	bl	8000a10 <__aeabi_fmul>
 800abf8:	1c03      	adds	r3, r0, #0
 800abfa:	1c19      	adds	r1, r3, #0
 800abfc:	1c20      	adds	r0, r4, #0
 800abfe:	f7f5 fbc7 	bl	8000390 <__aeabi_fadd>
 800ac02:	1c03      	adds	r3, r0, #0
 800ac04:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800ac06:	1c18      	adds	r0, r3, #0
 800ac08:	f7f5 ff02 	bl	8000a10 <__aeabi_fmul>
 800ac0c:	1c03      	adds	r3, r0, #0
 800ac0e:	1c19      	adds	r1, r3, #0
 800ac10:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800ac12:	f7f6 f811 	bl	8000c38 <__aeabi_fsub>
 800ac16:	1c03      	adds	r3, r0, #0
 800ac18:	643b      	str	r3, [r7, #64]	; 0x40
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
 800ac1a:	4bc1      	ldr	r3, [pc, #772]	; (800af20 <st_prep_buffer+0x96c>)
 800ac1c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ac1e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800ac20:	1c18      	adds	r0, r3, #0
 800ac22:	f7f5 fb6b 	bl	80002fc <__aeabi_fcmpgt>
 800ac26:	1e03      	subs	r3, r0, #0
 800ac28:	d033      	beq.n	800ac92 <st_prep_buffer+0x6de>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
 800ac2a:	4bbd      	ldr	r3, [pc, #756]	; (800af20 <st_prep_buffer+0x96c>)
 800ac2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ac2e:	643b      	str	r3, [r7, #64]	; 0x40
            time_var = 2.0f*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
 800ac30:	4bba      	ldr	r3, [pc, #744]	; (800af1c <st_prep_buffer+0x968>)
 800ac32:	681b      	ldr	r3, [r3, #0]
 800ac34:	6a1b      	ldr	r3, [r3, #32]
 800ac36:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800ac38:	1c18      	adds	r0, r3, #0
 800ac3a:	f7f5 fffd 	bl	8000c38 <__aeabi_fsub>
 800ac3e:	1c03      	adds	r3, r0, #0
 800ac40:	1c19      	adds	r1, r3, #0
 800ac42:	1c18      	adds	r0, r3, #0
 800ac44:	f7f5 fba4 	bl	8000390 <__aeabi_fadd>
 800ac48:	1c03      	adds	r3, r0, #0
 800ac4a:	1c1c      	adds	r4, r3, #0
 800ac4c:	4bb4      	ldr	r3, [pc, #720]	; (800af20 <st_prep_buffer+0x96c>)
 800ac4e:	69da      	ldr	r2, [r3, #28]
 800ac50:	4bb3      	ldr	r3, [pc, #716]	; (800af20 <st_prep_buffer+0x96c>)
 800ac52:	6a1b      	ldr	r3, [r3, #32]
 800ac54:	1c19      	adds	r1, r3, #0
 800ac56:	1c10      	adds	r0, r2, #0
 800ac58:	f7f5 fb9a 	bl	8000390 <__aeabi_fadd>
 800ac5c:	1c03      	adds	r3, r0, #0
 800ac5e:	1c19      	adds	r1, r3, #0
 800ac60:	1c20      	adds	r0, r4, #0
 800ac62:	f7f5 fd0b 	bl	800067c <__aeabi_fdiv>
 800ac66:	1c03      	adds	r3, r0, #0
 800ac68:	647b      	str	r3, [r7, #68]	; 0x44
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
 800ac6a:	4bad      	ldr	r3, [pc, #692]	; (800af20 <st_prep_buffer+0x96c>)
 800ac6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ac6e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800ac70:	1c18      	adds	r0, r3, #0
 800ac72:	f7f5 fb29 	bl	80002c8 <__aeabi_fcmpeq>
 800ac76:	1e03      	subs	r3, r0, #0
 800ac78:	d003      	beq.n	800ac82 <st_prep_buffer+0x6ce>
 800ac7a:	4ba9      	ldr	r3, [pc, #676]	; (800af20 <st_prep_buffer+0x96c>)
 800ac7c:	2202      	movs	r2, #2
 800ac7e:	751a      	strb	r2, [r3, #20]
 800ac80:	e002      	b.n	800ac88 <st_prep_buffer+0x6d4>
            else { prep.ramp_type = RAMP_CRUISE; }
 800ac82:	4ba7      	ldr	r3, [pc, #668]	; (800af20 <st_prep_buffer+0x96c>)
 800ac84:	2201      	movs	r2, #1
 800ac86:	751a      	strb	r2, [r3, #20]
            prep.current_speed = prep.maximum_speed;
 800ac88:	4ba5      	ldr	r3, [pc, #660]	; (800af20 <st_prep_buffer+0x96c>)
 800ac8a:	6a1a      	ldr	r2, [r3, #32]
 800ac8c:	4ba4      	ldr	r3, [pc, #656]	; (800af20 <st_prep_buffer+0x96c>)
 800ac8e:	61da      	str	r2, [r3, #28]
          } else { // Acceleration only.
            prep.current_speed += speed_var;
          }
          break;
 800ac90:	e09a      	b.n	800adc8 <st_prep_buffer+0x814>
            time_var = 2.0f*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only.
            prep.current_speed += speed_var;
 800ac92:	4ba3      	ldr	r3, [pc, #652]	; (800af20 <st_prep_buffer+0x96c>)
 800ac94:	69db      	ldr	r3, [r3, #28]
 800ac96:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800ac98:	1c18      	adds	r0, r3, #0
 800ac9a:	f7f5 fb79 	bl	8000390 <__aeabi_fadd>
 800ac9e:	1c03      	adds	r3, r0, #0
 800aca0:	1c1a      	adds	r2, r3, #0
 800aca2:	4b9f      	ldr	r3, [pc, #636]	; (800af20 <st_prep_buffer+0x96c>)
 800aca4:	61da      	str	r2, [r3, #28]
          }
          break;
 800aca6:	e08f      	b.n	800adc8 <st_prep_buffer+0x814>
        case RAMP_CRUISE:
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
 800aca8:	4b9d      	ldr	r3, [pc, #628]	; (800af20 <st_prep_buffer+0x96c>)
 800acaa:	6a1b      	ldr	r3, [r3, #32]
 800acac:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800acae:	1c18      	adds	r0, r3, #0
 800acb0:	f7f5 feae 	bl	8000a10 <__aeabi_fmul>
 800acb4:	1c03      	adds	r3, r0, #0
 800acb6:	1c19      	adds	r1, r3, #0
 800acb8:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800acba:	f7f5 ffbd 	bl	8000c38 <__aeabi_fsub>
 800acbe:	1c03      	adds	r3, r0, #0
 800acc0:	62bb      	str	r3, [r7, #40]	; 0x28
          if (mm_var < prep.decelerate_after) { // End of cruise.
 800acc2:	4b97      	ldr	r3, [pc, #604]	; (800af20 <st_prep_buffer+0x96c>)
 800acc4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800acc6:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800acc8:	1c18      	adds	r0, r3, #0
 800acca:	f7f5 fb17 	bl	80002fc <__aeabi_fcmpgt>
 800acce:	1e03      	subs	r3, r0, #0
 800acd0:	d016      	beq.n	800ad00 <st_prep_buffer+0x74c>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
 800acd2:	4b93      	ldr	r3, [pc, #588]	; (800af20 <st_prep_buffer+0x96c>)
 800acd4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800acd6:	1c19      	adds	r1, r3, #0
 800acd8:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800acda:	f7f5 ffad 	bl	8000c38 <__aeabi_fsub>
 800acde:	1c03      	adds	r3, r0, #0
 800ace0:	1c1a      	adds	r2, r3, #0
 800ace2:	4b8f      	ldr	r3, [pc, #572]	; (800af20 <st_prep_buffer+0x96c>)
 800ace4:	6a1b      	ldr	r3, [r3, #32]
 800ace6:	1c19      	adds	r1, r3, #0
 800ace8:	1c10      	adds	r0, r2, #0
 800acea:	f7f5 fcc7 	bl	800067c <__aeabi_fdiv>
 800acee:	1c03      	adds	r3, r0, #0
 800acf0:	647b      	str	r3, [r7, #68]	; 0x44
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
 800acf2:	4b8b      	ldr	r3, [pc, #556]	; (800af20 <st_prep_buffer+0x96c>)
 800acf4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800acf6:	643b      	str	r3, [r7, #64]	; 0x40
            prep.ramp_type = RAMP_DECEL;
 800acf8:	4b89      	ldr	r3, [pc, #548]	; (800af20 <st_prep_buffer+0x96c>)
 800acfa:	2202      	movs	r2, #2
 800acfc:	751a      	strb	r2, [r3, #20]
          } else { // Cruising only.
            mm_remaining = mm_var;
          }
          break;
 800acfe:	e063      	b.n	800adc8 <st_prep_buffer+0x814>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.
            mm_remaining = mm_var;
 800ad00:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ad02:	643b      	str	r3, [r7, #64]	; 0x40
          }
          break;
 800ad04:	e060      	b.n	800adc8 <st_prep_buffer+0x814>
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
 800ad06:	4b85      	ldr	r3, [pc, #532]	; (800af1c <st_prep_buffer+0x968>)
 800ad08:	681b      	ldr	r3, [r3, #0]
 800ad0a:	69db      	ldr	r3, [r3, #28]
 800ad0c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800ad0e:	1c18      	adds	r0, r3, #0
 800ad10:	f7f5 fe7e 	bl	8000a10 <__aeabi_fmul>
 800ad14:	1c03      	adds	r3, r0, #0
 800ad16:	62fb      	str	r3, [r7, #44]	; 0x2c
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
 800ad18:	4b81      	ldr	r3, [pc, #516]	; (800af20 <st_prep_buffer+0x96c>)
 800ad1a:	69db      	ldr	r3, [r3, #28]
 800ad1c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800ad1e:	1c18      	adds	r0, r3, #0
 800ad20:	f7f5 faec 	bl	80002fc <__aeabi_fcmpgt>
 800ad24:	1e03      	subs	r3, r0, #0
 800ad26:	d02c      	beq.n	800ad82 <st_prep_buffer+0x7ce>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5f*speed_var); // (mm)
 800ad28:	4b7d      	ldr	r3, [pc, #500]	; (800af20 <st_prep_buffer+0x96c>)
 800ad2a:	69dc      	ldr	r4, [r3, #28]
 800ad2c:	21fc      	movs	r1, #252	; 0xfc
 800ad2e:	0589      	lsls	r1, r1, #22
 800ad30:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800ad32:	f7f5 fe6d 	bl	8000a10 <__aeabi_fmul>
 800ad36:	1c03      	adds	r3, r0, #0
 800ad38:	1c19      	adds	r1, r3, #0
 800ad3a:	1c20      	adds	r0, r4, #0
 800ad3c:	f7f5 ff7c 	bl	8000c38 <__aeabi_fsub>
 800ad40:	1c03      	adds	r3, r0, #0
 800ad42:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800ad44:	1c18      	adds	r0, r3, #0
 800ad46:	f7f5 fe63 	bl	8000a10 <__aeabi_fmul>
 800ad4a:	1c03      	adds	r3, r0, #0
 800ad4c:	1c19      	adds	r1, r3, #0
 800ad4e:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800ad50:	f7f5 ff72 	bl	8000c38 <__aeabi_fsub>
 800ad54:	1c03      	adds	r3, r0, #0
 800ad56:	62bb      	str	r3, [r7, #40]	; 0x28
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
 800ad58:	4b71      	ldr	r3, [pc, #452]	; (800af20 <st_prep_buffer+0x96c>)
 800ad5a:	699b      	ldr	r3, [r3, #24]
 800ad5c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800ad5e:	1c18      	adds	r0, r3, #0
 800ad60:	f7f5 fab8 	bl	80002d4 <__aeabi_fcmplt>
 800ad64:	1e03      	subs	r3, r0, #0
 800ad66:	d00c      	beq.n	800ad82 <st_prep_buffer+0x7ce>
              mm_remaining = mm_var;
 800ad68:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ad6a:	643b      	str	r3, [r7, #64]	; 0x40
              prep.current_speed -= speed_var;
 800ad6c:	4b6c      	ldr	r3, [pc, #432]	; (800af20 <st_prep_buffer+0x96c>)
 800ad6e:	69db      	ldr	r3, [r3, #28]
 800ad70:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800ad72:	1c18      	adds	r0, r3, #0
 800ad74:	f7f5 ff60 	bl	8000c38 <__aeabi_fsub>
 800ad78:	1c03      	adds	r3, r0, #0
 800ad7a:	1c1a      	adds	r2, r3, #0
 800ad7c:	4b68      	ldr	r3, [pc, #416]	; (800af20 <st_prep_buffer+0x96c>)
 800ad7e:	61da      	str	r2, [r3, #28]
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
 800ad80:	e022      	b.n	800adc8 <st_prep_buffer+0x814>
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0f*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
 800ad82:	4b67      	ldr	r3, [pc, #412]	; (800af20 <st_prep_buffer+0x96c>)
 800ad84:	699b      	ldr	r3, [r3, #24]
 800ad86:	1c19      	adds	r1, r3, #0
 800ad88:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800ad8a:	f7f5 ff55 	bl	8000c38 <__aeabi_fsub>
 800ad8e:	1c03      	adds	r3, r0, #0
 800ad90:	1c19      	adds	r1, r3, #0
 800ad92:	1c18      	adds	r0, r3, #0
 800ad94:	f7f5 fafc 	bl	8000390 <__aeabi_fadd>
 800ad98:	1c03      	adds	r3, r0, #0
 800ad9a:	1c1c      	adds	r4, r3, #0
 800ad9c:	4b60      	ldr	r3, [pc, #384]	; (800af20 <st_prep_buffer+0x96c>)
 800ad9e:	69da      	ldr	r2, [r3, #28]
 800ada0:	4b5f      	ldr	r3, [pc, #380]	; (800af20 <st_prep_buffer+0x96c>)
 800ada2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ada4:	1c19      	adds	r1, r3, #0
 800ada6:	1c10      	adds	r0, r2, #0
 800ada8:	f7f5 faf2 	bl	8000390 <__aeabi_fadd>
 800adac:	1c03      	adds	r3, r0, #0
 800adae:	1c19      	adds	r1, r3, #0
 800adb0:	1c20      	adds	r0, r4, #0
 800adb2:	f7f5 fc63 	bl	800067c <__aeabi_fdiv>
 800adb6:	1c03      	adds	r3, r0, #0
 800adb8:	647b      	str	r3, [r7, #68]	; 0x44
          mm_remaining = prep.mm_complete;
 800adba:	4b59      	ldr	r3, [pc, #356]	; (800af20 <st_prep_buffer+0x96c>)
 800adbc:	699b      	ldr	r3, [r3, #24]
 800adbe:	643b      	str	r3, [r7, #64]	; 0x40
          prep.current_speed = prep.exit_speed;
 800adc0:	4b57      	ldr	r3, [pc, #348]	; (800af20 <st_prep_buffer+0x96c>)
 800adc2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800adc4:	4b56      	ldr	r3, [pc, #344]	; (800af20 <st_prep_buffer+0x96c>)
 800adc6:	61da      	str	r2, [r3, #28]
      }
      dt += time_var; // Add computed ramp time to total segment time.
 800adc8:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800adca:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 800adcc:	f7f5 fae0 	bl	8000390 <__aeabi_fadd>
 800add0:	1c03      	adds	r3, r0, #0
 800add2:	64bb      	str	r3, [r7, #72]	; 0x48
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
 800add4:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800add6:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 800add8:	f7f5 fa7c 	bl	80002d4 <__aeabi_fcmplt>
 800addc:	1e03      	subs	r3, r0, #0
 800adde:	d006      	beq.n	800adee <st_prep_buffer+0x83a>
 800ade0:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800ade2:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800ade4:	f7f5 ff28 	bl	8000c38 <__aeabi_fsub>
 800ade8:	1c03      	adds	r3, r0, #0
 800adea:	647b      	str	r3, [r7, #68]	; 0x44
 800adec:	e012      	b.n	800ae14 <st_prep_buffer+0x860>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
 800adee:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800adf0:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800adf2:	f7f5 fa83 	bl	80002fc <__aeabi_fcmpgt>
 800adf6:	1e03      	subs	r3, r0, #0
 800adf8:	d100      	bne.n	800adfc <st_prep_buffer+0x848>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
          time_var = dt_max - dt;
        } else {
          break; // **Complete** Exit loop. Segment execution time maxed.
 800adfa:	e014      	b.n	800ae26 <st_prep_buffer+0x872>
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
 800adfc:	4949      	ldr	r1, [pc, #292]	; (800af24 <st_prep_buffer+0x970>)
 800adfe:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800ae00:	f7f5 fac6 	bl	8000390 <__aeabi_fadd>
 800ae04:	1c03      	adds	r3, r0, #0
 800ae06:	64fb      	str	r3, [r7, #76]	; 0x4c
          time_var = dt_max - dt;
 800ae08:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800ae0a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800ae0c:	f7f5 ff14 	bl	8000c38 <__aeabi_fsub>
 800ae10:	1c03      	adds	r3, r0, #0
 800ae12:	647b      	str	r3, [r7, #68]	; 0x44
        } else {
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
 800ae14:	4b42      	ldr	r3, [pc, #264]	; (800af20 <st_prep_buffer+0x96c>)
 800ae16:	699b      	ldr	r3, [r3, #24]
 800ae18:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800ae1a:	1c18      	adds	r0, r3, #0
 800ae1c:	f7f5 fa5a 	bl	80002d4 <__aeabi_fcmplt>
 800ae20:	1e03      	subs	r3, r0, #0
 800ae22:	d000      	beq.n	800ae26 <st_prep_buffer+0x872>
 800ae24:	e65f      	b.n	800aae6 <st_prep_buffer+0x532>
    #ifdef VARIABLE_SPINDLE
      /* -----------------------------------------------------------------------------------
        Compute spindle speed PWM output for step segment
      */

      if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
 800ae26:	4b40      	ldr	r3, [pc, #256]	; (800af28 <st_prep_buffer+0x974>)
 800ae28:	681b      	ldr	r3, [r3, #0]
 800ae2a:	7c5b      	ldrb	r3, [r3, #17]
 800ae2c:	2b00      	cmp	r3, #0
 800ae2e:	d105      	bne.n	800ae3c <st_prep_buffer+0x888>
 800ae30:	4b3e      	ldr	r3, [pc, #248]	; (800af2c <st_prep_buffer+0x978>)
 800ae32:	791b      	ldrb	r3, [r3, #4]
 800ae34:	001a      	movs	r2, r3
 800ae36:	2308      	movs	r3, #8
 800ae38:	4013      	ands	r3, r2
 800ae3a:	d036      	beq.n	800aeaa <st_prep_buffer+0x8f6>
        if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
 800ae3c:	4b37      	ldr	r3, [pc, #220]	; (800af1c <st_prep_buffer+0x968>)
 800ae3e:	681b      	ldr	r3, [r3, #0]
 800ae40:	7c5b      	ldrb	r3, [r3, #17]
 800ae42:	001a      	movs	r2, r3
 800ae44:	2330      	movs	r3, #48	; 0x30
 800ae46:	4013      	ands	r3, r2
 800ae48:	d021      	beq.n	800ae8e <st_prep_buffer+0x8da>
          float rpm = pl_block->spindle_speed;
 800ae4a:	4b34      	ldr	r3, [pc, #208]	; (800af1c <st_prep_buffer+0x968>)
 800ae4c:	681b      	ldr	r3, [r3, #0]
 800ae4e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ae50:	63bb      	str	r3, [r7, #56]	; 0x38
          // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
          if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
 800ae52:	4b35      	ldr	r3, [pc, #212]	; (800af28 <st_prep_buffer+0x974>)
 800ae54:	681b      	ldr	r3, [r3, #0]
 800ae56:	7c5b      	ldrb	r3, [r3, #17]
 800ae58:	2b00      	cmp	r3, #0
 800ae5a:	d00e      	beq.n	800ae7a <st_prep_buffer+0x8c6>
 800ae5c:	4b30      	ldr	r3, [pc, #192]	; (800af20 <st_prep_buffer+0x96c>)
 800ae5e:	69da      	ldr	r2, [r3, #28]
 800ae60:	4b2f      	ldr	r3, [pc, #188]	; (800af20 <st_prep_buffer+0x96c>)
 800ae62:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ae64:	1c19      	adds	r1, r3, #0
 800ae66:	1c10      	adds	r0, r2, #0
 800ae68:	f7f5 fdd2 	bl	8000a10 <__aeabi_fmul>
 800ae6c:	1c03      	adds	r3, r0, #0
 800ae6e:	1c19      	adds	r1, r3, #0
 800ae70:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800ae72:	f7f5 fdcd 	bl	8000a10 <__aeabi_fmul>
 800ae76:	1c03      	adds	r3, r0, #0
 800ae78:	63bb      	str	r3, [r7, #56]	; 0x38
          // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE)
          // but this would be instantaneous only and during a motion. May not matter at all.
          prep.current_spindle_pwm = spindle_compute_pwm_value(rpm);
 800ae7a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ae7c:	1c18      	adds	r0, r3, #0
 800ae7e:	f7fe feb5 	bl	8009bec <spindle_compute_pwm_value>
 800ae82:	0003      	movs	r3, r0
 800ae84:	0019      	movs	r1, r3
 800ae86:	4b26      	ldr	r3, [pc, #152]	; (800af20 <st_prep_buffer+0x96c>)
 800ae88:	2234      	movs	r2, #52	; 0x34
 800ae8a:	5499      	strb	r1, [r3, r2]
 800ae8c:	e006      	b.n	800ae9c <st_prep_buffer+0x8e8>
        }
        else {
          sys.spindle_speed = 0.0;
 800ae8e:	4b27      	ldr	r3, [pc, #156]	; (800af2c <st_prep_buffer+0x978>)
 800ae90:	2200      	movs	r2, #0
 800ae92:	611a      	str	r2, [r3, #16]
          prep.current_spindle_pwm = SPINDLE_PWM_OFF_VALUE;
 800ae94:	4b22      	ldr	r3, [pc, #136]	; (800af20 <st_prep_buffer+0x96c>)
 800ae96:	2234      	movs	r2, #52	; 0x34
 800ae98:	2100      	movs	r1, #0
 800ae9a:	5499      	strb	r1, [r3, r2]
        }
        bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 800ae9c:	4b23      	ldr	r3, [pc, #140]	; (800af2c <st_prep_buffer+0x978>)
 800ae9e:	791b      	ldrb	r3, [r3, #4]
 800aea0:	2208      	movs	r2, #8
 800aea2:	4393      	bics	r3, r2
 800aea4:	b2da      	uxtb	r2, r3
 800aea6:	4b21      	ldr	r3, [pc, #132]	; (800af2c <st_prep_buffer+0x978>)
 800aea8:	711a      	strb	r2, [r3, #4]
      }
      prep_segment->spindle_pwm = prep.current_spindle_pwm; // Reload segment PWM value
 800aeaa:	4b1d      	ldr	r3, [pc, #116]	; (800af20 <st_prep_buffer+0x96c>)
 800aeac:	2234      	movs	r2, #52	; 0x34
 800aeae:	5c9a      	ldrb	r2, [r3, r2]
 800aeb0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aeb2:	719a      	strb	r2, [r3, #6]
       However, since floats have only 7.2 significant digits, long moves with extremely
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float step_dist_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
 800aeb4:	4b1a      	ldr	r3, [pc, #104]	; (800af20 <st_prep_buffer+0x96c>)
 800aeb6:	68db      	ldr	r3, [r3, #12]
 800aeb8:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800aeba:	1c18      	adds	r0, r3, #0
 800aebc:	f7f5 fda8 	bl	8000a10 <__aeabi_fmul>
 800aec0:	1c03      	adds	r3, r0, #0
 800aec2:	627b      	str	r3, [r7, #36]	; 0x24
    float n_steps_remaining = ceilf(step_dist_remaining); // Round-up current steps remaining
 800aec4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800aec6:	1c18      	adds	r0, r3, #0
 800aec8:	f001 f998 	bl	800c1fc <ceilf>
 800aecc:	1c03      	adds	r3, r0, #0
 800aece:	623b      	str	r3, [r7, #32]
    float last_n_steps_remaining = ceilf(prep.steps_remaining); // Round-up last steps remaining
 800aed0:	4b13      	ldr	r3, [pc, #76]	; (800af20 <st_prep_buffer+0x96c>)
 800aed2:	689b      	ldr	r3, [r3, #8]
 800aed4:	1c18      	adds	r0, r3, #0
 800aed6:	f001 f991 	bl	800c1fc <ceilf>
 800aeda:	1c03      	adds	r3, r0, #0
 800aedc:	61fb      	str	r3, [r7, #28]
	prep_segment->n_step = (uint16_t)(last_n_steps_remaining - n_steps_remaining); // Compute number of steps to execute.
 800aede:	6a39      	ldr	r1, [r7, #32]
 800aee0:	69f8      	ldr	r0, [r7, #28]
 800aee2:	f7f5 fea9 	bl	8000c38 <__aeabi_fsub>
 800aee6:	1c03      	adds	r3, r0, #0
 800aee8:	1c18      	adds	r0, r3, #0
 800aeea:	f7f5 fa1b 	bl	8000324 <__aeabi_f2uiz>
 800aeee:	0003      	movs	r3, r0
 800aef0:	b29a      	uxth	r2, r3
 800aef2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aef4:	801a      	strh	r2, [r3, #0]

    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
 800aef6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aef8:	881b      	ldrh	r3, [r3, #0]
 800aefa:	2b00      	cmp	r3, #0
 800aefc:	d118      	bne.n	800af30 <st_prep_buffer+0x97c>
      if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) {
 800aefe:	4b0b      	ldr	r3, [pc, #44]	; (800af2c <st_prep_buffer+0x978>)
 800af00:	791b      	ldrb	r3, [r3, #4]
 800af02:	001a      	movs	r2, r3
 800af04:	2302      	movs	r3, #2
 800af06:	4013      	ands	r3, r2
 800af08:	d012      	beq.n	800af30 <st_prep_buffer+0x97c>
        // Less than one step to decelerate to zero speed, but already very close. AMASS
        // requires full steps to execute. So, just bail.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
 800af0a:	4b08      	ldr	r3, [pc, #32]	; (800af2c <st_prep_buffer+0x978>)
 800af0c:	791b      	ldrb	r3, [r3, #4]
 800af0e:	2201      	movs	r2, #1
 800af10:	4313      	orrs	r3, r2
 800af12:	b2da      	uxtb	r2, r3
 800af14:	4b05      	ldr	r3, [pc, #20]	; (800af2c <st_prep_buffer+0x978>)
 800af16:	711a      	strb	r2, [r3, #4]
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Segment not generated, but current step data still retained.
 800af18:	e0ea      	b.n	800b0f0 <st_prep_buffer+0xb3c>
 800af1a:	46c0      	nop			; (mov r8, r8)
 800af1c:	2000051c 	.word	0x2000051c
 800af20:	20000524 	.word	0x20000524
 800af24:	392ec33e 	.word	0x392ec33e
 800af28:	20000520 	.word	0x20000520
 800af2c:	20000b2c 	.word	0x20000b2c
    // compensate, we track the time to execute the previous segment's partial step and simply
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
 800af30:	4b71      	ldr	r3, [pc, #452]	; (800b0f8 <st_prep_buffer+0xb44>)
 800af32:	685b      	ldr	r3, [r3, #4]
 800af34:	1c19      	adds	r1, r3, #0
 800af36:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 800af38:	f7f5 fa2a 	bl	8000390 <__aeabi_fadd>
 800af3c:	1c03      	adds	r3, r0, #0
 800af3e:	64bb      	str	r3, [r7, #72]	; 0x48
    float inv_rate = dt/(last_n_steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
 800af40:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800af42:	69f8      	ldr	r0, [r7, #28]
 800af44:	f7f5 fe78 	bl	8000c38 <__aeabi_fsub>
 800af48:	1c03      	adds	r3, r0, #0
 800af4a:	1c19      	adds	r1, r3, #0
 800af4c:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 800af4e:	f7f5 fb95 	bl	800067c <__aeabi_fdiv>
 800af52:	1c03      	adds	r3, r0, #0
 800af54:	61bb      	str	r3, [r7, #24]

    // Compute CPU cycles per step for the prepped segment.
	uint32_t cycles = (uint32_t)ceilf((TICKS_PER_MICROSECOND * 1000000) *inv_rate * 60); // (cycles/step)
 800af56:	4b69      	ldr	r3, [pc, #420]	; (800b0fc <st_prep_buffer+0xb48>)
 800af58:	681b      	ldr	r3, [r3, #0]
 800af5a:	4969      	ldr	r1, [pc, #420]	; (800b100 <st_prep_buffer+0xb4c>)
 800af5c:	0018      	movs	r0, r3
 800af5e:	f7f5 f8dd 	bl	800011c <__aeabi_uidiv>
 800af62:	0003      	movs	r3, r0
 800af64:	001a      	movs	r2, r3
 800af66:	4b66      	ldr	r3, [pc, #408]	; (800b100 <st_prep_buffer+0xb4c>)
 800af68:	4353      	muls	r3, r2
 800af6a:	0018      	movs	r0, r3
 800af6c:	f7f6 f86c 	bl	8001048 <__aeabi_ui2f>
 800af70:	1c03      	adds	r3, r0, #0
 800af72:	69b9      	ldr	r1, [r7, #24]
 800af74:	1c18      	adds	r0, r3, #0
 800af76:	f7f5 fd4b 	bl	8000a10 <__aeabi_fmul>
 800af7a:	1c03      	adds	r3, r0, #0
 800af7c:	4961      	ldr	r1, [pc, #388]	; (800b104 <st_prep_buffer+0xb50>)
 800af7e:	1c18      	adds	r0, r3, #0
 800af80:	f7f5 fd46 	bl	8000a10 <__aeabi_fmul>
 800af84:	1c03      	adds	r3, r0, #0
 800af86:	1c18      	adds	r0, r3, #0
 800af88:	f001 f938 	bl	800c1fc <ceilf>
 800af8c:	1c03      	adds	r3, r0, #0
 800af8e:	1c18      	adds	r0, r3, #0
 800af90:	f7f5 f9c8 	bl	8000324 <__aeabi_f2uiz>
 800af94:	0003      	movs	r3, r0
 800af96:	637b      	str	r3, [r7, #52]	; 0x34

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
 800af98:	4b58      	ldr	r3, [pc, #352]	; (800b0fc <st_prep_buffer+0xb48>)
 800af9a:	681a      	ldr	r2, [r3, #0]
 800af9c:	23fa      	movs	r3, #250	; 0xfa
 800af9e:	0159      	lsls	r1, r3, #5
 800afa0:	0010      	movs	r0, r2
 800afa2:	f7f5 f8bb 	bl	800011c <__aeabi_uidiv>
 800afa6:	0003      	movs	r3, r0
 800afa8:	1e1a      	subs	r2, r3, #0
 800afaa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800afac:	429a      	cmp	r2, r3
 800afae:	d903      	bls.n	800afb8 <st_prep_buffer+0xa04>
 800afb0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800afb2:	2200      	movs	r2, #0
 800afb4:	715a      	strb	r2, [r3, #5]
 800afb6:	e032      	b.n	800b01e <st_prep_buffer+0xa6a>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
 800afb8:	4b50      	ldr	r3, [pc, #320]	; (800b0fc <st_prep_buffer+0xb48>)
 800afba:	681a      	ldr	r2, [r3, #0]
 800afbc:	23fa      	movs	r3, #250	; 0xfa
 800afbe:	0119      	lsls	r1, r3, #4
 800afc0:	0010      	movs	r0, r2
 800afc2:	f7f5 f8ab 	bl	800011c <__aeabi_uidiv>
 800afc6:	0003      	movs	r3, r0
 800afc8:	1e1a      	subs	r2, r3, #0
 800afca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800afcc:	429a      	cmp	r2, r3
 800afce:	d903      	bls.n	800afd8 <st_prep_buffer+0xa24>
 800afd0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800afd2:	2201      	movs	r2, #1
 800afd4:	715a      	strb	r2, [r3, #5]
 800afd6:	e012      	b.n	800affe <st_prep_buffer+0xa4a>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
 800afd8:	4b48      	ldr	r3, [pc, #288]	; (800b0fc <st_prep_buffer+0xb48>)
 800afda:	681a      	ldr	r2, [r3, #0]
 800afdc:	23fa      	movs	r3, #250	; 0xfa
 800afde:	00d9      	lsls	r1, r3, #3
 800afe0:	0010      	movs	r0, r2
 800afe2:	f7f5 f89b 	bl	800011c <__aeabi_uidiv>
 800afe6:	0003      	movs	r3, r0
 800afe8:	1e1a      	subs	r2, r3, #0
 800afea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800afec:	429a      	cmp	r2, r3
 800afee:	d903      	bls.n	800aff8 <st_prep_buffer+0xa44>
 800aff0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aff2:	2202      	movs	r2, #2
 800aff4:	715a      	strb	r2, [r3, #5]
 800aff6:	e002      	b.n	800affe <st_prep_buffer+0xa4a>
        else { prep_segment->amass_level = 3; }
 800aff8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800affa:	2203      	movs	r2, #3
 800affc:	715a      	strb	r2, [r3, #5]
        cycles >>= prep_segment->amass_level;
 800affe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b000:	795b      	ldrb	r3, [r3, #5]
 800b002:	001a      	movs	r2, r3
 800b004:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b006:	40d3      	lsrs	r3, r2
 800b008:	637b      	str	r3, [r7, #52]	; 0x34
        prep_segment->n_step <<= prep_segment->amass_level;
 800b00a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b00c:	881b      	ldrh	r3, [r3, #0]
 800b00e:	001a      	movs	r2, r3
 800b010:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b012:	795b      	ldrb	r3, [r3, #5]
 800b014:	409a      	lsls	r2, r3
 800b016:	0013      	movs	r3, r2
 800b018:	b29a      	uxth	r2, r3
 800b01a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b01c:	801a      	strh	r2, [r3, #0]
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
 800b01e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b020:	4a39      	ldr	r2, [pc, #228]	; (800b108 <st_prep_buffer+0xb54>)
 800b022:	4293      	cmp	r3, r2
 800b024:	d804      	bhi.n	800b030 <st_prep_buffer+0xa7c>
 800b026:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b028:	b29a      	uxth	r2, r3
 800b02a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b02c:	805a      	strh	r2, [r3, #2]
 800b02e:	e003      	b.n	800b038 <st_prep_buffer+0xa84>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
 800b030:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b032:	2201      	movs	r2, #1
 800b034:	4252      	negs	r2, r2
 800b036:	805a      	strh	r2, [r3, #2]
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute it.
    segment_buffer_head = segment_next_head;
 800b038:	4b34      	ldr	r3, [pc, #208]	; (800b10c <st_prep_buffer+0xb58>)
 800b03a:	781a      	ldrb	r2, [r3, #0]
 800b03c:	4b34      	ldr	r3, [pc, #208]	; (800b110 <st_prep_buffer+0xb5c>)
 800b03e:	701a      	strb	r2, [r3, #0]
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
 800b040:	4b32      	ldr	r3, [pc, #200]	; (800b10c <st_prep_buffer+0xb58>)
 800b042:	781b      	ldrb	r3, [r3, #0]
 800b044:	3301      	adds	r3, #1
 800b046:	b2da      	uxtb	r2, r3
 800b048:	4b30      	ldr	r3, [pc, #192]	; (800b10c <st_prep_buffer+0xb58>)
 800b04a:	701a      	strb	r2, [r3, #0]
 800b04c:	4b2f      	ldr	r3, [pc, #188]	; (800b10c <st_prep_buffer+0xb58>)
 800b04e:	781b      	ldrb	r3, [r3, #0]
 800b050:	2b06      	cmp	r3, #6
 800b052:	d102      	bne.n	800b05a <st_prep_buffer+0xaa6>
 800b054:	4b2d      	ldr	r3, [pc, #180]	; (800b10c <st_prep_buffer+0xb58>)
 800b056:	2200      	movs	r2, #0
 800b058:	701a      	strb	r2, [r3, #0]

    // Update the appropriate planner and segment data.
    pl_block->millimeters = mm_remaining;
 800b05a:	4b2e      	ldr	r3, [pc, #184]	; (800b114 <st_prep_buffer+0xb60>)
 800b05c:	681b      	ldr	r3, [r3, #0]
 800b05e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800b060:	621a      	str	r2, [r3, #32]
    prep.steps_remaining = n_steps_remaining;
 800b062:	4b25      	ldr	r3, [pc, #148]	; (800b0f8 <st_prep_buffer+0xb44>)
 800b064:	6a3a      	ldr	r2, [r7, #32]
 800b066:	609a      	str	r2, [r3, #8]
    prep.dt_remainder = (n_steps_remaining - step_dist_remaining)*inv_rate;
 800b068:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800b06a:	6a38      	ldr	r0, [r7, #32]
 800b06c:	f7f5 fde4 	bl	8000c38 <__aeabi_fsub>
 800b070:	1c03      	adds	r3, r0, #0
 800b072:	69b9      	ldr	r1, [r7, #24]
 800b074:	1c18      	adds	r0, r3, #0
 800b076:	f7f5 fccb 	bl	8000a10 <__aeabi_fmul>
 800b07a:	1c03      	adds	r3, r0, #0
 800b07c:	1c1a      	adds	r2, r3, #0
 800b07e:	4b1e      	ldr	r3, [pc, #120]	; (800b0f8 <st_prep_buffer+0xb44>)
 800b080:	605a      	str	r2, [r3, #4]

    // Check for exit conditions and flag to load next planner block.
    if (mm_remaining == prep.mm_complete) {
 800b082:	4b1d      	ldr	r3, [pc, #116]	; (800b0f8 <st_prep_buffer+0xb44>)
 800b084:	699b      	ldr	r3, [r3, #24]
 800b086:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800b088:	1c18      	adds	r0, r3, #0
 800b08a:	f7f5 f91d 	bl	80002c8 <__aeabi_fcmpeq>
 800b08e:	1e03      	subs	r3, r0, #0
 800b090:	d100      	bne.n	800b094 <st_prep_buffer+0xae0>
 800b092:	e020      	b.n	800b0d6 <st_prep_buffer+0xb22>
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0f) { // At end of forced-termination.
 800b094:	2100      	movs	r1, #0
 800b096:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800b098:	f7f5 f930 	bl	80002fc <__aeabi_fcmpgt>
 800b09c:	1e03      	subs	r3, r0, #0
 800b09e:	d007      	beq.n	800b0b0 <st_prep_buffer+0xafc>
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
 800b0a0:	4b1d      	ldr	r3, [pc, #116]	; (800b118 <st_prep_buffer+0xb64>)
 800b0a2:	791b      	ldrb	r3, [r3, #4]
 800b0a4:	2201      	movs	r2, #1
 800b0a6:	4313      	orrs	r3, r2
 800b0a8:	b2da      	uxtb	r2, r3
 800b0aa:	4b1b      	ldr	r3, [pc, #108]	; (800b118 <st_prep_buffer+0xb64>)
 800b0ac:	711a      	strb	r2, [r3, #4]
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Bail!
 800b0ae:	e01f      	b.n	800b0f0 <st_prep_buffer+0xb3c>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
 800b0b0:	4b19      	ldr	r3, [pc, #100]	; (800b118 <st_prep_buffer+0xb64>)
 800b0b2:	791b      	ldrb	r3, [r3, #4]
 800b0b4:	001a      	movs	r2, r3
 800b0b6:	2304      	movs	r3, #4
 800b0b8:	4013      	ands	r3, r2
 800b0ba:	d007      	beq.n	800b0cc <st_prep_buffer+0xb18>
          bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
 800b0bc:	4b16      	ldr	r3, [pc, #88]	; (800b118 <st_prep_buffer+0xb64>)
 800b0be:	791b      	ldrb	r3, [r3, #4]
 800b0c0:	2201      	movs	r2, #1
 800b0c2:	4313      	orrs	r3, r2
 800b0c4:	b2da      	uxtb	r2, r3
 800b0c6:	4b14      	ldr	r3, [pc, #80]	; (800b118 <st_prep_buffer+0xb64>)
 800b0c8:	711a      	strb	r2, [r3, #4]
          return;
 800b0ca:	e011      	b.n	800b0f0 <st_prep_buffer+0xb3c>
        }
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
 800b0cc:	4b11      	ldr	r3, [pc, #68]	; (800b114 <st_prep_buffer+0xb60>)
 800b0ce:	2200      	movs	r2, #0
 800b0d0:	601a      	str	r2, [r3, #0]
        plan_discard_current_block();
 800b0d2:	f7fb fd19 	bl	8006b08 <plan_discard_current_block>
void st_prep_buffer()
{
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
 800b0d6:	4b11      	ldr	r3, [pc, #68]	; (800b11c <st_prep_buffer+0xb68>)
 800b0d8:	781b      	ldrb	r3, [r3, #0]
 800b0da:	b2da      	uxtb	r2, r3
 800b0dc:	4b0b      	ldr	r3, [pc, #44]	; (800b10c <st_prep_buffer+0xb58>)
 800b0de:	781b      	ldrb	r3, [r3, #0]
 800b0e0:	429a      	cmp	r2, r3
 800b0e2:	d001      	beq.n	800b0e8 <st_prep_buffer+0xb34>
 800b0e4:	f7ff fa73 	bl	800a5ce <st_prep_buffer+0x1a>
 800b0e8:	e002      	b.n	800b0f0 <st_prep_buffer+0xb3c>
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
 800b0ea:	46c0      	nop			; (mov r8, r8)
 800b0ec:	e000      	b.n	800b0f0 <st_prep_buffer+0xb3c>
    if (pl_block == NULL) {

      // Query planner for a queued block
      if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
      else { pl_block = plan_get_current_block(); }
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
 800b0ee:	46c0      	nop			; (mov r8, r8)
        plan_discard_current_block();
      }
    }

  }
}
 800b0f0:	46bd      	mov	sp, r7
 800b0f2:	b017      	add	sp, #92	; 0x5c
 800b0f4:	bd90      	pop	{r4, r7, pc}
 800b0f6:	46c0      	nop			; (mov r8, r8)
 800b0f8:	20000524 	.word	0x20000524
 800b0fc:	20000010 	.word	0x20000010
 800b100:	000f4240 	.word	0x000f4240
 800b104:	42700000 	.word	0x42700000
 800b108:	0000ffff 	.word	0x0000ffff
 800b10c:	20000512 	.word	0x20000512
 800b110:	20000511 	.word	0x20000511
 800b114:	2000051c 	.word	0x2000051c
 800b118:	20000b2c 	.word	0x20000b2c
 800b11c:	20000510 	.word	0x20000510

0800b120 <st_get_realtime_rate>:
// Called by realtime status reporting to fetch the current speed being executed. This value
// however is not exactly the current speed, but the speed computed in the last step segment
// in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
// divided by the ACCELERATION TICKS PER SECOND in seconds.
float st_get_realtime_rate()
{
 800b120:	b580      	push	{r7, lr}
 800b122:	af00      	add	r7, sp, #0
  if (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)){
 800b124:	4b06      	ldr	r3, [pc, #24]	; (800b140 <st_get_realtime_rate+0x20>)
 800b126:	781b      	ldrb	r3, [r3, #0]
 800b128:	001a      	movs	r2, r3
 800b12a:	237c      	movs	r3, #124	; 0x7c
 800b12c:	4013      	ands	r3, r2
 800b12e:	d002      	beq.n	800b136 <st_get_realtime_rate+0x16>
    return prep.current_speed;
 800b130:	4b04      	ldr	r3, [pc, #16]	; (800b144 <st_get_realtime_rate+0x24>)
 800b132:	69db      	ldr	r3, [r3, #28]
 800b134:	e000      	b.n	800b138 <st_get_realtime_rate+0x18>
  }
  return 0.0f;
 800b136:	2300      	movs	r3, #0
}
 800b138:	1c18      	adds	r0, r3, #0
 800b13a:	46bd      	mov	sp, r7
 800b13c:	bd80      	pop	{r7, pc}
 800b13e:	46c0      	nop			; (mov r8, r8)
 800b140:	20000b2c 	.word	0x20000b2c
 800b144:	20000524 	.word	0x20000524

0800b148 <TIM_Configuration>:
	NVIC_Init(&NVIC_InitStructure);
}
#endif
#ifdef STM32F0DISCOVERY
void TIM_Configuration(TIM_TypeDef* TIMER, uint16_t Period, uint16_t Prescaler, uint8_t PP)
{
 800b148:	b590      	push	{r4, r7, lr}
 800b14a:	b089      	sub	sp, #36	; 0x24
 800b14c:	af00      	add	r7, sp, #0
 800b14e:	60f8      	str	r0, [r7, #12]
 800b150:	000c      	movs	r4, r1
 800b152:	0010      	movs	r0, r2
 800b154:	0019      	movs	r1, r3
 800b156:	230a      	movs	r3, #10
 800b158:	18fb      	adds	r3, r7, r3
 800b15a:	1c22      	adds	r2, r4, #0
 800b15c:	801a      	strh	r2, [r3, #0]
 800b15e:	2308      	movs	r3, #8
 800b160:	18fb      	adds	r3, r7, r3
 800b162:	1c02      	adds	r2, r0, #0
 800b164:	801a      	strh	r2, [r3, #0]
 800b166:	1dfb      	adds	r3, r7, #7
 800b168:	1c0a      	adds	r2, r1, #0
 800b16a:	701a      	strb	r2, [r3, #0]
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	TIM_TimeBaseStructure.TIM_Period = Period - 1;
 800b16c:	230a      	movs	r3, #10
 800b16e:	18fb      	adds	r3, r7, r3
 800b170:	881b      	ldrh	r3, [r3, #0]
 800b172:	3b01      	subs	r3, #1
 800b174:	001a      	movs	r2, r3
 800b176:	2314      	movs	r3, #20
 800b178:	18fb      	adds	r3, r7, r3
 800b17a:	605a      	str	r2, [r3, #4]
	TIM_TimeBaseStructure.TIM_Prescaler = Prescaler - 1;
 800b17c:	2308      	movs	r3, #8
 800b17e:	18fb      	adds	r3, r7, r3
 800b180:	881b      	ldrh	r3, [r3, #0]
 800b182:	3b01      	subs	r3, #1
 800b184:	b29a      	uxth	r2, r3
 800b186:	2314      	movs	r3, #20
 800b188:	18fb      	adds	r3, r7, r3
 800b18a:	801a      	strh	r2, [r3, #0]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 800b18c:	2314      	movs	r3, #20
 800b18e:	18fb      	adds	r3, r7, r3
 800b190:	2200      	movs	r2, #0
 800b192:	811a      	strh	r2, [r3, #8]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 800b194:	2314      	movs	r3, #20
 800b196:	18fb      	adds	r3, r7, r3
 800b198:	2200      	movs	r2, #0
 800b19a:	805a      	strh	r2, [r3, #2]
	TIM_TimeBaseInit(TIMER, &TIM_TimeBaseStructure);
 800b19c:	2314      	movs	r3, #20
 800b19e:	18fa      	adds	r2, r7, r3
 800b1a0:	68fb      	ldr	r3, [r7, #12]
 800b1a2:	0011      	movs	r1, r2
 800b1a4:	0018      	movs	r0, r3
 800b1a6:	f7f7 ffdd 	bl	8003164 <TIM_TimeBaseInit>

	TIM_ClearITPendingBit(TIMER, TIM_IT_Update);
 800b1aa:	68fb      	ldr	r3, [r7, #12]
 800b1ac:	2101      	movs	r1, #1
 800b1ae:	0018      	movs	r0, r3
 800b1b0:	f7f8 f9d4 	bl	800355c <TIM_ClearITPendingBit>
	TIM_ITConfig(TIMER, TIM_IT_Update, ENABLE);
 800b1b4:	68fb      	ldr	r3, [r7, #12]
 800b1b6:	2201      	movs	r2, #1
 800b1b8:	2101      	movs	r1, #1
 800b1ba:	0018      	movs	r0, r3
 800b1bc:	f7f8 f9a4 	bl	8003508 <TIM_ITConfig>
	TIM_Cmd(TIMER, ENABLE);
 800b1c0:	68fb      	ldr	r3, [r7, #12]
 800b1c2:	2101      	movs	r1, #1
 800b1c4:	0018      	movs	r0, r3
 800b1c6:	f7f8 f85d 	bl	8003284 <TIM_Cmd>

	//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
	if (TIMER == TIM2) { NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; }
 800b1ca:	68fa      	ldr	r2, [r7, #12]
 800b1cc:	2380      	movs	r3, #128	; 0x80
 800b1ce:	05db      	lsls	r3, r3, #23
 800b1d0:	429a      	cmp	r2, r3
 800b1d2:	d104      	bne.n	800b1de <TIM_Configuration+0x96>
 800b1d4:	2310      	movs	r3, #16
 800b1d6:	18fb      	adds	r3, r7, r3
 800b1d8:	220f      	movs	r2, #15
 800b1da:	701a      	strb	r2, [r3, #0]
 800b1dc:	e010      	b.n	800b200 <TIM_Configuration+0xb8>
	else if (TIMER == TIM3) { NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn; }
 800b1de:	68fb      	ldr	r3, [r7, #12]
 800b1e0:	4a10      	ldr	r2, [pc, #64]	; (800b224 <TIM_Configuration+0xdc>)
 800b1e2:	4293      	cmp	r3, r2
 800b1e4:	d104      	bne.n	800b1f0 <TIM_Configuration+0xa8>
 800b1e6:	2310      	movs	r3, #16
 800b1e8:	18fb      	adds	r3, r7, r3
 800b1ea:	2210      	movs	r2, #16
 800b1ec:	701a      	strb	r2, [r3, #0]
 800b1ee:	e007      	b.n	800b200 <TIM_Configuration+0xb8>
	else if (TIMER == TIM6) { NVIC_InitStructure.NVIC_IRQChannel = TIM6_DAC_IRQn; } // Was TIM4
 800b1f0:	68fb      	ldr	r3, [r7, #12]
 800b1f2:	4a0d      	ldr	r2, [pc, #52]	; (800b228 <TIM_Configuration+0xe0>)
 800b1f4:	4293      	cmp	r3, r2
 800b1f6:	d103      	bne.n	800b200 <TIM_Configuration+0xb8>
 800b1f8:	2310      	movs	r3, #16
 800b1fa:	18fb      	adds	r3, r7, r3
 800b1fc:	2211      	movs	r2, #17
 800b1fe:	701a      	strb	r2, [r3, #0]

	//NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = PP;
	//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelPriority = PP;
 800b200:	2310      	movs	r3, #16
 800b202:	18fb      	adds	r3, r7, r3
 800b204:	1dfa      	adds	r2, r7, #7
 800b206:	7812      	ldrb	r2, [r2, #0]
 800b208:	705a      	strb	r2, [r3, #1]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800b20a:	2310      	movs	r3, #16
 800b20c:	18fb      	adds	r3, r7, r3
 800b20e:	2201      	movs	r2, #1
 800b210:	709a      	strb	r2, [r3, #2]
	NVIC_Init(&NVIC_InitStructure);
 800b212:	2310      	movs	r3, #16
 800b214:	18fb      	adds	r3, r7, r3
 800b216:	0018      	movs	r0, r3
 800b218:	f7f7 fc9a 	bl	8002b50 <NVIC_Init>
}
 800b21c:	46c0      	nop			; (mov r8, r8)
 800b21e:	46bd      	mov	sp, r7
 800b220:	b009      	add	sp, #36	; 0x24
 800b222:	bd90      	pop	{r4, r7, pc}
 800b224:	40000400 	.word	0x40000400
 800b228:	40001000 	.word	0x40001000

0800b22c <system_init>:

#include "grbl.h"


void system_init()
{
 800b22c:	b580      	push	{r7, lr}
 800b22e:	b086      	sub	sp, #24
 800b230:	af00      	add	r7, sp, #0
  NVIC_Init(&NVIC_InitStructure);
#endif
#ifdef STM32F0DISCOVERY
  GPIO_InitTypeDef GPIO_InitStructure;
  //RCC_APB2PeriphClockCmd(RCC_CONTROL_PORT | RCC_APB2Periph_AFIO, ENABLE);
  RCC_AHBPeriphClockCmd(RCC_CONTROL_PORT, ENABLE);
 800b232:	2380      	movs	r3, #128	; 0x80
 800b234:	02db      	lsls	r3, r3, #11
 800b236:	2101      	movs	r1, #1
 800b238:	0018      	movs	r0, r3
 800b23a:	f7f7 ff09 	bl	8003050 <RCC_AHBPeriphClockCmd>
  /* Enable SYSCFG's APB interface clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 800b23e:	2101      	movs	r1, #1
 800b240:	2001      	movs	r0, #1
 800b242:	f7f7 ff25 	bl	8003090 <RCC_APB2PeriphClockCmd>
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800b246:	2310      	movs	r3, #16
 800b248:	18fb      	adds	r3, r7, r3
 800b24a:	2203      	movs	r2, #3
 800b24c:	715a      	strb	r2, [r3, #5]
#ifdef DISABLE_CONTROL_PIN_PULL_UP
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
#else
  //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 800b24e:	2310      	movs	r3, #16
 800b250:	18fb      	adds	r3, r7, r3
 800b252:	2200      	movs	r2, #0
 800b254:	711a      	strb	r2, [r3, #4]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 800b256:	2310      	movs	r3, #16
 800b258:	18fb      	adds	r3, r7, r3
 800b25a:	2201      	movs	r2, #1
 800b25c:	71da      	strb	r2, [r3, #7]
#endif
  GPIO_InitStructure.GPIO_Pin = CONTROL_MASK;
 800b25e:	2310      	movs	r3, #16
 800b260:	18fb      	adds	r3, r7, r3
 800b262:	22f0      	movs	r2, #240	; 0xf0
 800b264:	0052      	lsls	r2, r2, #1
 800b266:	601a      	str	r2, [r3, #0]
  GPIO_Init(CONTROL_PORT, &GPIO_InitStructure);
 800b268:	2310      	movs	r3, #16
 800b26a:	18fb      	adds	r3, r7, r3
 800b26c:	4a1d      	ldr	r2, [pc, #116]	; (800b2e4 <system_init+0xb8>)
 800b26e:	0019      	movs	r1, r3
 800b270:	0010      	movs	r0, r2
 800b272:	f7f7 fb6f 	bl	8002954 <GPIO_Init>

  SYSCFG_EXTILineConfig(GPIO_CONTROL_PORT, CONTROL_RESET_BIT);
 800b276:	2105      	movs	r1, #5
 800b278:	2001      	movs	r0, #1
 800b27a:	f7f7 ff29 	bl	80030d0 <SYSCFG_EXTILineConfig>
  SYSCFG_EXTILineConfig(GPIO_CONTROL_PORT, CONTROL_FEED_HOLD_BIT);
 800b27e:	2106      	movs	r1, #6
 800b280:	2001      	movs	r0, #1
 800b282:	f7f7 ff25 	bl	80030d0 <SYSCFG_EXTILineConfig>
  SYSCFG_EXTILineConfig(GPIO_CONTROL_PORT, CONTROL_CYCLE_START_BIT);
 800b286:	2107      	movs	r1, #7
 800b288:	2001      	movs	r0, #1
 800b28a:	f7f7 ff21 	bl	80030d0 <SYSCFG_EXTILineConfig>
  SYSCFG_EXTILineConfig(GPIO_CONTROL_PORT, CONTROL_SAFETY_DOOR_BIT);
 800b28e:	2108      	movs	r1, #8
 800b290:	2001      	movs	r0, #1
 800b292:	f7f7 ff1d 	bl	80030d0 <SYSCFG_EXTILineConfig>

  EXTI_InitTypeDef EXTI_InitStructure;
  EXTI_InitStructure.EXTI_Line = CONTROL_MASK;    //
 800b296:	2308      	movs	r3, #8
 800b298:	18fb      	adds	r3, r7, r3
 800b29a:	22f0      	movs	r2, #240	; 0xf0
 800b29c:	0052      	lsls	r2, r2, #1
 800b29e:	601a      	str	r2, [r3, #0]
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; //Interrupt mode, optional values for the interrupt EXTI_Mode_Interrupt and event EXTI_Mode_Event.
 800b2a0:	2308      	movs	r3, #8
 800b2a2:	18fb      	adds	r3, r7, r3
 800b2a4:	2200      	movs	r2, #0
 800b2a6:	711a      	strb	r2, [r3, #4]
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; //Trigger mode, can be a falling edge trigger EXTI_Trigger_Falling, the rising edge triggered EXTI_Trigger_Rising, or any level (rising edge and falling edge trigger EXTI_Trigger_Rising_Falling)
 800b2a8:	2308      	movs	r3, #8
 800b2aa:	18fb      	adds	r3, r7, r3
 800b2ac:	220c      	movs	r2, #12
 800b2ae:	715a      	strb	r2, [r3, #5]
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 800b2b0:	2308      	movs	r3, #8
 800b2b2:	18fb      	adds	r3, r7, r3
 800b2b4:	2201      	movs	r2, #1
 800b2b6:	719a      	strb	r2, [r3, #6]
  EXTI_Init(&EXTI_InitStructure);
 800b2b8:	2308      	movs	r3, #8
 800b2ba:	18fb      	adds	r3, r7, r3
 800b2bc:	0018      	movs	r0, r3
 800b2be:	f7f7 fad9 	bl	8002874 <EXTI_Init>

  NVIC_InitTypeDef NVIC_InitStructure;
  NVIC_InitStructure.NVIC_IRQChannel = EXTI4_15_IRQn; //Enable keypad external interrupt channel
 800b2c2:	1d3b      	adds	r3, r7, #4
 800b2c4:	2207      	movs	r2, #7
 800b2c6:	701a      	strb	r2, [r3, #0]
  //NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //Priority 2,
  //NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //Sub priority 2
  NVIC_InitStructure.NVIC_IRQChannelPriority = 0x02; // Priority 2
 800b2c8:	1d3b      	adds	r3, r7, #4
 800b2ca:	2202      	movs	r2, #2
 800b2cc:	705a      	strb	r2, [r3, #1]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //Enable external interrupt channel
 800b2ce:	1d3b      	adds	r3, r7, #4
 800b2d0:	2201      	movs	r2, #1
 800b2d2:	709a      	strb	r2, [r3, #2]
  NVIC_Init(&NVIC_InitStructure);
 800b2d4:	1d3b      	adds	r3, r7, #4
 800b2d6:	0018      	movs	r0, r3
 800b2d8:	f7f7 fc3a 	bl	8002b50 <NVIC_Init>
#endif
}
 800b2dc:	46c0      	nop			; (mov r8, r8)
 800b2de:	46bd      	mov	sp, r7
 800b2e0:	b006      	add	sp, #24
 800b2e2:	bd80      	pop	{r7, pc}
 800b2e4:	48000400 	.word	0x48000400

0800b2e8 <system_control_get_state>:

// Returns control pin state as a uint8 bitfield. Each bit indicates the input pin state, where
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
 800b2e8:	b590      	push	{r4, r7, lr}
 800b2ea:	b083      	sub	sp, #12
 800b2ec:	af00      	add	r7, sp, #0
  uint8_t control_state = 0;
 800b2ee:	1dfb      	adds	r3, r7, #7
 800b2f0:	2200      	movs	r2, #0
 800b2f2:	701a      	strb	r2, [r3, #0]
#endif
#ifdef STM32F103C8
  uint16_t pin= GPIO_ReadInputData(CONTROL_PIN_PORT);
#endif
#ifdef STM32F0DISCOVERY
  uint16_t pin= GPIO_ReadInputData(CONTROL_PIN_PORT);
 800b2f4:	1d3c      	adds	r4, r7, #4
 800b2f6:	4b18      	ldr	r3, [pc, #96]	; (800b358 <system_control_get_state+0x70>)
 800b2f8:	0018      	movs	r0, r3
 800b2fa:	f7f7 fbc3 	bl	8002a84 <GPIO_ReadInputData>
 800b2fe:	0003      	movs	r3, r0
 800b300:	8023      	strh	r3, [r4, #0]
#endif
  #ifdef INVERT_CONTROL_PIN_MASK
    pin ^= INVERT_CONTROL_PIN_MASK;
  #endif
  if (pin) {
 800b302:	1d3b      	adds	r3, r7, #4
 800b304:	881b      	ldrh	r3, [r3, #0]
 800b306:	2b00      	cmp	r3, #0
 800b308:	d020      	beq.n	800b34c <system_control_get_state+0x64>
    #ifdef ENABLE_SAFETY_DOOR_INPUT_PIN
      if (bit_isfalse(pin,(1<<CONTROL_SAFETY_DOOR_BIT))) { control_state |= CONTROL_PIN_INDEX_SAFETY_DOOR; }
    #endif
    if (bit_isfalse(pin,(1<<CONTROL_RESET_BIT))) { control_state |= CONTROL_PIN_INDEX_RESET; }
 800b30a:	1d3b      	adds	r3, r7, #4
 800b30c:	881b      	ldrh	r3, [r3, #0]
 800b30e:	2220      	movs	r2, #32
 800b310:	4013      	ands	r3, r2
 800b312:	d105      	bne.n	800b320 <system_control_get_state+0x38>
 800b314:	1dfb      	adds	r3, r7, #7
 800b316:	1dfa      	adds	r2, r7, #7
 800b318:	7812      	ldrb	r2, [r2, #0]
 800b31a:	2101      	movs	r1, #1
 800b31c:	430a      	orrs	r2, r1
 800b31e:	701a      	strb	r2, [r3, #0]
    if (bit_isfalse(pin,(1<<CONTROL_FEED_HOLD_BIT))) { control_state |= CONTROL_PIN_INDEX_FEED_HOLD; }
 800b320:	1d3b      	adds	r3, r7, #4
 800b322:	881b      	ldrh	r3, [r3, #0]
 800b324:	2240      	movs	r2, #64	; 0x40
 800b326:	4013      	ands	r3, r2
 800b328:	d105      	bne.n	800b336 <system_control_get_state+0x4e>
 800b32a:	1dfb      	adds	r3, r7, #7
 800b32c:	1dfa      	adds	r2, r7, #7
 800b32e:	7812      	ldrb	r2, [r2, #0]
 800b330:	2102      	movs	r1, #2
 800b332:	430a      	orrs	r2, r1
 800b334:	701a      	strb	r2, [r3, #0]
    if (bit_isfalse(pin,(1<<CONTROL_CYCLE_START_BIT))) { control_state |= CONTROL_PIN_INDEX_CYCLE_START; }
 800b336:	1d3b      	adds	r3, r7, #4
 800b338:	881b      	ldrh	r3, [r3, #0]
 800b33a:	2280      	movs	r2, #128	; 0x80
 800b33c:	4013      	ands	r3, r2
 800b33e:	d105      	bne.n	800b34c <system_control_get_state+0x64>
 800b340:	1dfb      	adds	r3, r7, #7
 800b342:	1dfa      	adds	r2, r7, #7
 800b344:	7812      	ldrb	r2, [r2, #0]
 800b346:	2104      	movs	r1, #4
 800b348:	430a      	orrs	r2, r1
 800b34a:	701a      	strb	r2, [r3, #0]
  }
  return(control_state);
 800b34c:	1dfb      	adds	r3, r7, #7
 800b34e:	781b      	ldrb	r3, [r3, #0]
}
 800b350:	0018      	movs	r0, r3
 800b352:	46bd      	mov	sp, r7
 800b354:	b003      	add	sp, #12
 800b356:	bd90      	pop	{r4, r7, pc}
 800b358:	48000400 	.word	0x48000400

0800b35c <system_check_safety_door_ajar>:
}
#endif

// Returns if safety door is ajar(T) or closed(F), based on pin state.
uint8_t system_check_safety_door_ajar()
{
 800b35c:	b580      	push	{r7, lr}
 800b35e:	af00      	add	r7, sp, #0
  #ifdef ENABLE_SAFETY_DOOR_INPUT_PIN
    return(system_control_get_state() & CONTROL_PIN_INDEX_SAFETY_DOOR);
  #else
    return(false); // Input pin not enabled, so just return that it's closed.
 800b360:	2300      	movs	r3, #0
  #endif
}
 800b362:	0018      	movs	r0, r3
 800b364:	46bd      	mov	sp, r7
 800b366:	bd80      	pop	{r7, pc}

0800b368 <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line)
{
 800b368:	b590      	push	{r4, r7, lr}
 800b36a:	b085      	sub	sp, #20
 800b36c:	af00      	add	r7, sp, #0
 800b36e:	6078      	str	r0, [r7, #4]
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
 800b370:	230f      	movs	r3, #15
 800b372:	18fb      	adds	r3, r7, r3
 800b374:	2200      	movs	r2, #0
 800b376:	701a      	strb	r2, [r3, #0]
 800b378:	e02d      	b.n	800b3d6 <system_execute_startup+0x6e>
    if (!(settings_read_startup_line(n, line))) {
 800b37a:	687a      	ldr	r2, [r7, #4]
 800b37c:	230f      	movs	r3, #15
 800b37e:	18fb      	adds	r3, r7, r3
 800b380:	781b      	ldrb	r3, [r3, #0]
 800b382:	0011      	movs	r1, r2
 800b384:	0018      	movs	r0, r3
 800b386:	f7fe f899 	bl	80094bc <settings_read_startup_line>
 800b38a:	1e03      	subs	r3, r0, #0
 800b38c:	d108      	bne.n	800b3a0 <system_execute_startup+0x38>
      line[0] = 0;
 800b38e:	687b      	ldr	r3, [r7, #4]
 800b390:	2200      	movs	r2, #0
 800b392:	701a      	strb	r2, [r3, #0]
      report_execute_startup_message(line,STATUS_SETTING_READ_FAIL);
 800b394:	687b      	ldr	r3, [r7, #4]
 800b396:	2107      	movs	r1, #7
 800b398:	0018      	movs	r0, r3
 800b39a:	f7fd fb4f 	bl	8008a3c <report_execute_startup_message>
 800b39e:	e013      	b.n	800b3c8 <system_execute_startup+0x60>
    } else {
      if (line[0] != 0) {
 800b3a0:	687b      	ldr	r3, [r7, #4]
 800b3a2:	781b      	ldrb	r3, [r3, #0]
 800b3a4:	2b00      	cmp	r3, #0
 800b3a6:	d00f      	beq.n	800b3c8 <system_execute_startup+0x60>
        uint8_t status_code = gc_execute_line(line);
 800b3a8:	230e      	movs	r3, #14
 800b3aa:	18fc      	adds	r4, r7, r3
 800b3ac:	687b      	ldr	r3, [r7, #4]
 800b3ae:	0018      	movs	r0, r3
 800b3b0:	f7f8 fb4a 	bl	8003a48 <gc_execute_line>
 800b3b4:	0003      	movs	r3, r0
 800b3b6:	7023      	strb	r3, [r4, #0]
        report_execute_startup_message(line,status_code);
 800b3b8:	230e      	movs	r3, #14
 800b3ba:	18fb      	adds	r3, r7, r3
 800b3bc:	781a      	ldrb	r2, [r3, #0]
 800b3be:	687b      	ldr	r3, [r7, #4]
 800b3c0:	0011      	movs	r1, r2
 800b3c2:	0018      	movs	r0, r3
 800b3c4:	f7fd fb3a 	bl	8008a3c <report_execute_startup_message>

// Executes user startup script, if stored.
void system_execute_startup(char *line)
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
 800b3c8:	230f      	movs	r3, #15
 800b3ca:	18fb      	adds	r3, r7, r3
 800b3cc:	781a      	ldrb	r2, [r3, #0]
 800b3ce:	230f      	movs	r3, #15
 800b3d0:	18fb      	adds	r3, r7, r3
 800b3d2:	3201      	adds	r2, #1
 800b3d4:	701a      	strb	r2, [r3, #0]
 800b3d6:	230f      	movs	r3, #15
 800b3d8:	18fb      	adds	r3, r7, r3
 800b3da:	781b      	ldrb	r3, [r3, #0]
 800b3dc:	2b01      	cmp	r3, #1
 800b3de:	d9cc      	bls.n	800b37a <system_execute_startup+0x12>
        uint8_t status_code = gc_execute_line(line);
        report_execute_startup_message(line,status_code);
      }
    }
  }
}
 800b3e0:	46c0      	nop			; (mov r8, r8)
 800b3e2:	46bd      	mov	sp, r7
 800b3e4:	b005      	add	sp, #20
 800b3e6:	bd90      	pop	{r4, r7, pc}

0800b3e8 <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle,
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line)
{
 800b3e8:	b590      	push	{r4, r7, lr}
 800b3ea:	b087      	sub	sp, #28
 800b3ec:	af00      	add	r7, sp, #0
 800b3ee:	6078      	str	r0, [r7, #4]
  uint8_t char_counter = 1;
 800b3f0:	2316      	movs	r3, #22
 800b3f2:	18fb      	adds	r3, r7, r3
 800b3f4:	2201      	movs	r2, #1
 800b3f6:	701a      	strb	r2, [r3, #0]
  uint8_t helper_var = 0; // Helper variable
 800b3f8:	2317      	movs	r3, #23
 800b3fa:	18fb      	adds	r3, r7, r3
 800b3fc:	2200      	movs	r2, #0
 800b3fe:	701a      	strb	r2, [r3, #0]
  float parameter, value;
  switch( line[char_counter] ) {
 800b400:	2316      	movs	r3, #22
 800b402:	18fb      	adds	r3, r7, r3
 800b404:	781b      	ldrb	r3, [r3, #0]
 800b406:	001a      	movs	r2, r3
 800b408:	687b      	ldr	r3, [r7, #4]
 800b40a:	189b      	adds	r3, r3, r2
 800b40c:	781b      	ldrb	r3, [r3, #0]
 800b40e:	2b43      	cmp	r3, #67	; 0x43
 800b410:	d026      	beq.n	800b460 <system_execute_line+0x78>
 800b412:	dc04      	bgt.n	800b41e <system_execute_line+0x36>
 800b414:	2b00      	cmp	r3, #0
 800b416:	d009      	beq.n	800b42c <system_execute_line+0x44>
 800b418:	2b24      	cmp	r3, #36	; 0x24
 800b41a:	d021      	beq.n	800b460 <system_execute_line+0x78>
 800b41c:	e06c      	b.n	800b4f8 <system_execute_line+0x110>
 800b41e:	2b4a      	cmp	r3, #74	; 0x4a
 800b420:	d007      	beq.n	800b432 <system_execute_line+0x4a>
 800b422:	2b58      	cmp	r3, #88	; 0x58
 800b424:	d01c      	beq.n	800b460 <system_execute_line+0x78>
 800b426:	2b47      	cmp	r3, #71	; 0x47
 800b428:	d01a      	beq.n	800b460 <system_execute_line+0x78>
 800b42a:	e065      	b.n	800b4f8 <system_execute_line+0x110>
    case 0 : report_grbl_help(); break;
 800b42c:	f7fd f83c 	bl	80084a8 <report_grbl_help>
 800b430:	e23f      	b.n	800b8b2 <system_execute_line+0x4ca>
    case 'J' : // Jogging
      // Execute only if in IDLE or JOG states.
      if (sys.state != STATE_IDLE && sys.state != STATE_JOG) { return(STATUS_IDLE_ERROR); }
 800b432:	4bbc      	ldr	r3, [pc, #752]	; (800b724 <system_execute_line+0x33c>)
 800b434:	781b      	ldrb	r3, [r3, #0]
 800b436:	2b00      	cmp	r3, #0
 800b438:	d005      	beq.n	800b446 <system_execute_line+0x5e>
 800b43a:	4bba      	ldr	r3, [pc, #744]	; (800b724 <system_execute_line+0x33c>)
 800b43c:	781b      	ldrb	r3, [r3, #0]
 800b43e:	2b20      	cmp	r3, #32
 800b440:	d001      	beq.n	800b446 <system_execute_line+0x5e>
 800b442:	2308      	movs	r3, #8
 800b444:	e236      	b.n	800b8b4 <system_execute_line+0x4cc>
      if(line[2] != '=') { return(STATUS_INVALID_STATEMENT); }
 800b446:	687b      	ldr	r3, [r7, #4]
 800b448:	3302      	adds	r3, #2
 800b44a:	781b      	ldrb	r3, [r3, #0]
 800b44c:	2b3d      	cmp	r3, #61	; 0x3d
 800b44e:	d001      	beq.n	800b454 <system_execute_line+0x6c>
 800b450:	2303      	movs	r3, #3
 800b452:	e22f      	b.n	800b8b4 <system_execute_line+0x4cc>
      return(gc_execute_line(line)); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
 800b454:	687b      	ldr	r3, [r7, #4]
 800b456:	0018      	movs	r0, r3
 800b458:	f7f8 faf6 	bl	8003a48 <gc_execute_line>
 800b45c:	0003      	movs	r3, r0
 800b45e:	e229      	b.n	800b8b4 <system_execute_line+0x4cc>
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
 800b460:	687b      	ldr	r3, [r7, #4]
 800b462:	3302      	adds	r3, #2
 800b464:	781b      	ldrb	r3, [r3, #0]
 800b466:	2b00      	cmp	r3, #0
 800b468:	d001      	beq.n	800b46e <system_execute_line+0x86>
 800b46a:	2303      	movs	r3, #3
 800b46c:	e222      	b.n	800b8b4 <system_execute_line+0x4cc>
      switch( line[1] ) {
 800b46e:	687b      	ldr	r3, [r7, #4]
 800b470:	3301      	adds	r3, #1
 800b472:	781b      	ldrb	r3, [r3, #0]
 800b474:	2b43      	cmp	r3, #67	; 0x43
 800b476:	d016      	beq.n	800b4a6 <system_execute_line+0xbe>
 800b478:	dc02      	bgt.n	800b480 <system_execute_line+0x98>
 800b47a:	2b24      	cmp	r3, #36	; 0x24
 800b47c:	d005      	beq.n	800b48a <system_execute_line+0xa2>
            sys.state = STATE_IDLE;
            // Don't run startup script. Prevents stored moves in startup from causing accidents.
          } // Otherwise, no effect.
          break;
      }
      break;
 800b47e:	e218      	b.n	800b8b2 <system_execute_line+0x4ca>
      if(line[2] != '=') { return(STATUS_INVALID_STATEMENT); }
      return(gc_execute_line(line)); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      switch( line[1] ) {
 800b480:	2b47      	cmp	r3, #71	; 0x47
 800b482:	d00d      	beq.n	800b4a0 <system_execute_line+0xb8>
 800b484:	2b58      	cmp	r3, #88	; 0x58
 800b486:	d025      	beq.n	800b4d4 <system_execute_line+0xec>
            sys.state = STATE_IDLE;
            // Don't run startup script. Prevents stored moves in startup from causing accidents.
          } // Otherwise, no effect.
          break;
      }
      break;
 800b488:	e213      	b.n	800b8b2 <system_execute_line+0x4ca>
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      switch( line[1] ) {
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
 800b48a:	4ba6      	ldr	r3, [pc, #664]	; (800b724 <system_execute_line+0x33c>)
 800b48c:	781b      	ldrb	r3, [r3, #0]
 800b48e:	001a      	movs	r2, r3
 800b490:	2318      	movs	r3, #24
 800b492:	4013      	ands	r3, r2
 800b494:	d001      	beq.n	800b49a <system_execute_line+0xb2>
 800b496:	2308      	movs	r3, #8
 800b498:	e20c      	b.n	800b8b4 <system_execute_line+0x4cc>
          else { report_grbl_settings(); }
 800b49a:	f7fd f811 	bl	80084c0 <report_grbl_settings>
          break;
 800b49e:	e02a      	b.n	800b4f6 <system_execute_line+0x10e>
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
 800b4a0:	f7fd f9f8 	bl	8008894 <report_gcode_modes>
          break;
 800b4a4:	e027      	b.n	800b4f6 <system_execute_line+0x10e>
        case 'C' : // Set check g-code mode [IDLE/CHECK]
          // Perform reset when toggling off. Check g-code mode should only work if Grbl
          // is idle and ready, regardless of alarm locks. This is mainly to keep things
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
 800b4a6:	4b9f      	ldr	r3, [pc, #636]	; (800b724 <system_execute_line+0x33c>)
 800b4a8:	781b      	ldrb	r3, [r3, #0]
 800b4aa:	2b02      	cmp	r3, #2
 800b4ac:	d105      	bne.n	800b4ba <system_execute_line+0xd2>
            mc_reset();
 800b4ae:	f7fa ff25 	bl	80062fc <mc_reset>
            report_feedback_message(MESSAGE_DISABLED);
 800b4b2:	2005      	movs	r0, #5
 800b4b4:	f7fc ff82 	bl	80083bc <report_feedback_message>
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
            sys.state = STATE_CHECK_MODE;
            report_feedback_message(MESSAGE_ENABLED);
          }
          break;
 800b4b8:	e01d      	b.n	800b4f6 <system_execute_line+0x10e>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) {
            mc_reset();
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
 800b4ba:	4b9a      	ldr	r3, [pc, #616]	; (800b724 <system_execute_line+0x33c>)
 800b4bc:	781b      	ldrb	r3, [r3, #0]
 800b4be:	2b00      	cmp	r3, #0
 800b4c0:	d001      	beq.n	800b4c6 <system_execute_line+0xde>
 800b4c2:	2308      	movs	r3, #8
 800b4c4:	e1f6      	b.n	800b8b4 <system_execute_line+0x4cc>
            sys.state = STATE_CHECK_MODE;
 800b4c6:	4b97      	ldr	r3, [pc, #604]	; (800b724 <system_execute_line+0x33c>)
 800b4c8:	2202      	movs	r2, #2
 800b4ca:	701a      	strb	r2, [r3, #0]
            report_feedback_message(MESSAGE_ENABLED);
 800b4cc:	2004      	movs	r0, #4
 800b4ce:	f7fc ff75 	bl	80083bc <report_feedback_message>
          }
          break;
 800b4d2:	e010      	b.n	800b4f6 <system_execute_line+0x10e>
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) {
 800b4d4:	4b93      	ldr	r3, [pc, #588]	; (800b724 <system_execute_line+0x33c>)
 800b4d6:	781b      	ldrb	r3, [r3, #0]
 800b4d8:	2b01      	cmp	r3, #1
 800b4da:	d10b      	bne.n	800b4f4 <system_execute_line+0x10c>
            // Block if safety door is ajar.
            if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); }
 800b4dc:	f7ff ff3e 	bl	800b35c <system_check_safety_door_ajar>
 800b4e0:	1e03      	subs	r3, r0, #0
 800b4e2:	d001      	beq.n	800b4e8 <system_execute_line+0x100>
 800b4e4:	230d      	movs	r3, #13
 800b4e6:	e1e5      	b.n	800b8b4 <system_execute_line+0x4cc>
            report_feedback_message(MESSAGE_ALARM_UNLOCK);
 800b4e8:	2003      	movs	r0, #3
 800b4ea:	f7fc ff67 	bl	80083bc <report_feedback_message>
            sys.state = STATE_IDLE;
 800b4ee:	4b8d      	ldr	r3, [pc, #564]	; (800b724 <system_execute_line+0x33c>)
 800b4f0:	2200      	movs	r2, #0
 800b4f2:	701a      	strb	r2, [r3, #0]
            // Don't run startup script. Prevents stored moves in startup from causing accidents.
          } // Otherwise, no effect.
          break;
 800b4f4:	46c0      	nop			; (mov r8, r8)
      }
      break;
 800b4f6:	e1dc      	b.n	800b8b2 <system_execute_line+0x4ca>
    default :
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
 800b4f8:	4b8a      	ldr	r3, [pc, #552]	; (800b724 <system_execute_line+0x33c>)
 800b4fa:	781b      	ldrb	r3, [r3, #0]
 800b4fc:	2b00      	cmp	r3, #0
 800b4fe:	d005      	beq.n	800b50c <system_execute_line+0x124>
 800b500:	4b88      	ldr	r3, [pc, #544]	; (800b724 <system_execute_line+0x33c>)
 800b502:	781b      	ldrb	r3, [r3, #0]
 800b504:	2b01      	cmp	r3, #1
 800b506:	d001      	beq.n	800b50c <system_execute_line+0x124>
 800b508:	2308      	movs	r3, #8
 800b50a:	e1d3      	b.n	800b8b4 <system_execute_line+0x4cc>
      switch( line[1] ) {
 800b50c:	687b      	ldr	r3, [r7, #4]
 800b50e:	3301      	adds	r3, #1
 800b510:	781b      	ldrb	r3, [r3, #0]
 800b512:	3b23      	subs	r3, #35	; 0x23
 800b514:	2b30      	cmp	r3, #48	; 0x30
 800b516:	d900      	bls.n	800b51a <system_execute_line+0x132>
 800b518:	e129      	b.n	800b76e <system_execute_line+0x386>
 800b51a:	009a      	lsls	r2, r3, #2
 800b51c:	4b82      	ldr	r3, [pc, #520]	; (800b728 <system_execute_line+0x340>)
 800b51e:	18d3      	adds	r3, r2, r3
 800b520:	681b      	ldr	r3, [r3, #0]
 800b522:	469f      	mov	pc, r3
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
 800b524:	687b      	ldr	r3, [r7, #4]
 800b526:	3302      	adds	r3, #2
 800b528:	781b      	ldrb	r3, [r3, #0]
 800b52a:	2b00      	cmp	r3, #0
 800b52c:	d001      	beq.n	800b532 <system_execute_line+0x14a>
 800b52e:	2303      	movs	r3, #3
 800b530:	e1c0      	b.n	800b8b4 <system_execute_line+0x4cc>
          else { report_ngc_parameters(); }
 800b532:	f7fd f93d 	bl	80087b0 <report_ngc_parameters>
          break;
 800b536:	e1bc      	b.n	800b8b2 <system_execute_line+0x4ca>
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_isfalse(settings.flags,BITFLAG_HOMING_ENABLE)) {return(STATUS_SETTING_DISABLED); }
 800b538:	4b7c      	ldr	r3, [pc, #496]	; (800b72c <system_execute_line+0x344>)
 800b53a:	2248      	movs	r2, #72	; 0x48
 800b53c:	5c9b      	ldrb	r3, [r3, r2]
 800b53e:	001a      	movs	r2, r3
 800b540:	2310      	movs	r3, #16
 800b542:	4013      	ands	r3, r2
 800b544:	d101      	bne.n	800b54a <system_execute_line+0x162>
 800b546:	2305      	movs	r3, #5
 800b548:	e1b4      	b.n	800b8b4 <system_execute_line+0x4cc>
          if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); } // Block if safety door is ajar.
 800b54a:	f7ff ff07 	bl	800b35c <system_check_safety_door_ajar>
 800b54e:	1e03      	subs	r3, r0, #0
 800b550:	d001      	beq.n	800b556 <system_execute_line+0x16e>
 800b552:	230d      	movs	r3, #13
 800b554:	e1ae      	b.n	800b8b4 <system_execute_line+0x4cc>
          sys.state = STATE_HOMING; // Set system state variable
 800b556:	4b73      	ldr	r3, [pc, #460]	; (800b724 <system_execute_line+0x33c>)
 800b558:	2204      	movs	r2, #4
 800b55a:	701a      	strb	r2, [r3, #0]
          if (line[2] == 0) {
 800b55c:	687b      	ldr	r3, [r7, #4]
 800b55e:	3302      	adds	r3, #2
 800b560:	781b      	ldrb	r3, [r3, #0]
 800b562:	2b00      	cmp	r3, #0
 800b564:	d108      	bne.n	800b578 <system_execute_line+0x190>
            mc_homing_cycle(HOMING_CYCLE_ALL);
 800b566:	2000      	movs	r0, #0
 800b568:	f7fa fe14 	bl	8006194 <mc_homing_cycle>
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
                default: return(STATUS_INVALID_STATEMENT);
              }
          #endif
          } else { return(STATUS_INVALID_STATEMENT); }
          if (!sys.abort) {  // Execute startup scripts after successful homing.
 800b56c:	4b6d      	ldr	r3, [pc, #436]	; (800b724 <system_execute_line+0x33c>)
 800b56e:	785b      	ldrb	r3, [r3, #1]
 800b570:	2b00      	cmp	r3, #0
 800b572:	d000      	beq.n	800b576 <system_execute_line+0x18e>
 800b574:	e19c      	b.n	800b8b0 <system_execute_line+0x4c8>
 800b576:	e001      	b.n	800b57c <system_execute_line+0x194>
                case 'Y': mc_homing_cycle(HOMING_CYCLE_Y); break;
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
                default: return(STATUS_INVALID_STATEMENT);
              }
          #endif
          } else { return(STATUS_INVALID_STATEMENT); }
 800b578:	2303      	movs	r3, #3
 800b57a:	e19b      	b.n	800b8b4 <system_execute_line+0x4cc>
          if (!sys.abort) {  // Execute startup scripts after successful homing.
            sys.state = STATE_IDLE; // Set to IDLE when complete.
 800b57c:	4b69      	ldr	r3, [pc, #420]	; (800b724 <system_execute_line+0x33c>)
 800b57e:	2200      	movs	r2, #0
 800b580:	701a      	strb	r2, [r3, #0]
            st_go_idle(); // Set steppers to the settings idle state before returning.
 800b582:	f7fe fc69 	bl	8009e58 <st_go_idle>
            if (line[2] == 0) { system_execute_startup(line); }
 800b586:	687b      	ldr	r3, [r7, #4]
 800b588:	3302      	adds	r3, #2
 800b58a:	781b      	ldrb	r3, [r3, #0]
 800b58c:	2b00      	cmp	r3, #0
 800b58e:	d000      	beq.n	800b592 <system_execute_line+0x1aa>
 800b590:	e18e      	b.n	800b8b0 <system_execute_line+0x4c8>
 800b592:	687b      	ldr	r3, [r7, #4]
 800b594:	0018      	movs	r0, r3
 800b596:	f7ff fee7 	bl	800b368 <system_execute_startup>
          }
          break;
 800b59a:	e189      	b.n	800b8b0 <system_execute_line+0x4c8>
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
 800b59c:	687b      	ldr	r3, [r7, #4]
 800b59e:	3302      	adds	r3, #2
 800b5a0:	781b      	ldrb	r3, [r3, #0]
 800b5a2:	2b4c      	cmp	r3, #76	; 0x4c
 800b5a4:	d109      	bne.n	800b5ba <system_execute_line+0x1d2>
 800b5a6:	687b      	ldr	r3, [r7, #4]
 800b5a8:	3303      	adds	r3, #3
 800b5aa:	781b      	ldrb	r3, [r3, #0]
 800b5ac:	2b50      	cmp	r3, #80	; 0x50
 800b5ae:	d104      	bne.n	800b5ba <system_execute_line+0x1d2>
 800b5b0:	687b      	ldr	r3, [r7, #4]
 800b5b2:	3304      	adds	r3, #4
 800b5b4:	781b      	ldrb	r3, [r3, #0]
 800b5b6:	2b00      	cmp	r3, #0
 800b5b8:	d001      	beq.n	800b5be <system_execute_line+0x1d6>
 800b5ba:	2303      	movs	r3, #3
 800b5bc:	e17a      	b.n	800b8b4 <system_execute_line+0x4cc>
          system_set_exec_state_flag(EXEC_SLEEP); // Set to execute sleep mode immediately
 800b5be:	2080      	movs	r0, #128	; 0x80
 800b5c0:	f000 fa18 	bl	800b9f4 <system_set_exec_state_flag>
          break;
 800b5c4:	e175      	b.n	800b8b2 <system_execute_line+0x4ca>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) {
 800b5c6:	2316      	movs	r3, #22
 800b5c8:	18fb      	adds	r3, r7, r3
 800b5ca:	781b      	ldrb	r3, [r3, #0]
 800b5cc:	3301      	adds	r3, #1
 800b5ce:	b2da      	uxtb	r2, r3
 800b5d0:	2316      	movs	r3, #22
 800b5d2:	18fb      	adds	r3, r7, r3
 800b5d4:	701a      	strb	r2, [r3, #0]
 800b5d6:	2316      	movs	r3, #22
 800b5d8:	18fb      	adds	r3, r7, r3
 800b5da:	781b      	ldrb	r3, [r3, #0]
 800b5dc:	001a      	movs	r2, r3
 800b5de:	687b      	ldr	r3, [r7, #4]
 800b5e0:	189b      	adds	r3, r3, r2
 800b5e2:	781b      	ldrb	r3, [r3, #0]
 800b5e4:	2b00      	cmp	r3, #0
 800b5e6:	d108      	bne.n	800b5fa <system_execute_line+0x212>
            settings_read_build_info(line);
 800b5e8:	687b      	ldr	r3, [r7, #4]
 800b5ea:	0018      	movs	r0, r3
 800b5ec:	f7fd ff92 	bl	8009514 <settings_read_build_info>
            report_build_info(line);
 800b5f0:	687b      	ldr	r3, [r7, #4]
 800b5f2:	0018      	movs	r0, r3
 800b5f4:	f7fd fa3c 	bl	8008a70 <report_build_info>
                line[char_counter-helper_var] = line[char_counter];
              } while (line[char_counter++] != 0);
              settings_store_build_info(line);
          #endif
          }
          break;
 800b5f8:	e15b      	b.n	800b8b2 <system_execute_line+0x4ca>
          if ( line[++char_counter] == 0 ) {
            settings_read_build_info(line);
            report_build_info(line);
          #ifdef ENABLE_BUILD_INFO_WRITE_COMMAND
            } else { // Store startup line [IDLE/ALARM]
              if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
 800b5fa:	2316      	movs	r3, #22
 800b5fc:	18fb      	adds	r3, r7, r3
 800b5fe:	781b      	ldrb	r3, [r3, #0]
 800b600:	1c5a      	adds	r2, r3, #1
 800b602:	b2d1      	uxtb	r1, r2
 800b604:	2216      	movs	r2, #22
 800b606:	18ba      	adds	r2, r7, r2
 800b608:	7011      	strb	r1, [r2, #0]
 800b60a:	001a      	movs	r2, r3
 800b60c:	687b      	ldr	r3, [r7, #4]
 800b60e:	189b      	adds	r3, r3, r2
 800b610:	781b      	ldrb	r3, [r3, #0]
 800b612:	2b3d      	cmp	r3, #61	; 0x3d
 800b614:	d001      	beq.n	800b61a <system_execute_line+0x232>
 800b616:	2303      	movs	r3, #3
 800b618:	e14c      	b.n	800b8b4 <system_execute_line+0x4cc>
              helper_var = char_counter; // Set helper variable as counter to start of user info line.
 800b61a:	2317      	movs	r3, #23
 800b61c:	18fb      	adds	r3, r7, r3
 800b61e:	2216      	movs	r2, #22
 800b620:	18ba      	adds	r2, r7, r2
 800b622:	7812      	ldrb	r2, [r2, #0]
 800b624:	701a      	strb	r2, [r3, #0]
              do {
                line[char_counter-helper_var] = line[char_counter];
 800b626:	2316      	movs	r3, #22
 800b628:	18fb      	adds	r3, r7, r3
 800b62a:	781b      	ldrb	r3, [r3, #0]
 800b62c:	001a      	movs	r2, r3
 800b62e:	2317      	movs	r3, #23
 800b630:	18fb      	adds	r3, r7, r3
 800b632:	781b      	ldrb	r3, [r3, #0]
 800b634:	1ad3      	subs	r3, r2, r3
 800b636:	001a      	movs	r2, r3
 800b638:	687b      	ldr	r3, [r7, #4]
 800b63a:	189b      	adds	r3, r3, r2
 800b63c:	2216      	movs	r2, #22
 800b63e:	18ba      	adds	r2, r7, r2
 800b640:	7812      	ldrb	r2, [r2, #0]
 800b642:	0011      	movs	r1, r2
 800b644:	687a      	ldr	r2, [r7, #4]
 800b646:	1852      	adds	r2, r2, r1
 800b648:	7812      	ldrb	r2, [r2, #0]
 800b64a:	701a      	strb	r2, [r3, #0]
              } while (line[char_counter++] != 0);
 800b64c:	2316      	movs	r3, #22
 800b64e:	18fb      	adds	r3, r7, r3
 800b650:	781b      	ldrb	r3, [r3, #0]
 800b652:	1c5a      	adds	r2, r3, #1
 800b654:	b2d1      	uxtb	r1, r2
 800b656:	2216      	movs	r2, #22
 800b658:	18ba      	adds	r2, r7, r2
 800b65a:	7011      	strb	r1, [r2, #0]
 800b65c:	001a      	movs	r2, r3
 800b65e:	687b      	ldr	r3, [r7, #4]
 800b660:	189b      	adds	r3, r3, r2
 800b662:	781b      	ldrb	r3, [r3, #0]
 800b664:	2b00      	cmp	r3, #0
 800b666:	d1de      	bne.n	800b626 <system_execute_line+0x23e>
              settings_store_build_info(line);
 800b668:	687b      	ldr	r3, [r7, #4]
 800b66a:	0018      	movs	r0, r3
 800b66c:	f7fd fe08 	bl	8009280 <settings_store_build_info>
          #endif
          }
          break;
 800b670:	e11f      	b.n	800b8b2 <system_execute_line+0x4ca>
        case 'R' : // Restore defaults [IDLE/ALARM]
          if ((line[2] != 'S') || (line[3] != 'T') || (line[4] != '=') || (line[6] != 0)) { return(STATUS_INVALID_STATEMENT); }
 800b672:	687b      	ldr	r3, [r7, #4]
 800b674:	3302      	adds	r3, #2
 800b676:	781b      	ldrb	r3, [r3, #0]
 800b678:	2b53      	cmp	r3, #83	; 0x53
 800b67a:	d10e      	bne.n	800b69a <system_execute_line+0x2b2>
 800b67c:	687b      	ldr	r3, [r7, #4]
 800b67e:	3303      	adds	r3, #3
 800b680:	781b      	ldrb	r3, [r3, #0]
 800b682:	2b54      	cmp	r3, #84	; 0x54
 800b684:	d109      	bne.n	800b69a <system_execute_line+0x2b2>
 800b686:	687b      	ldr	r3, [r7, #4]
 800b688:	3304      	adds	r3, #4
 800b68a:	781b      	ldrb	r3, [r3, #0]
 800b68c:	2b3d      	cmp	r3, #61	; 0x3d
 800b68e:	d104      	bne.n	800b69a <system_execute_line+0x2b2>
 800b690:	687b      	ldr	r3, [r7, #4]
 800b692:	3306      	adds	r3, #6
 800b694:	781b      	ldrb	r3, [r3, #0]
 800b696:	2b00      	cmp	r3, #0
 800b698:	d001      	beq.n	800b69e <system_execute_line+0x2b6>
 800b69a:	2303      	movs	r3, #3
 800b69c:	e10a      	b.n	800b8b4 <system_execute_line+0x4cc>
          switch (line[5]) {
 800b69e:	687b      	ldr	r3, [r7, #4]
 800b6a0:	3305      	adds	r3, #5
 800b6a2:	781b      	ldrb	r3, [r3, #0]
 800b6a4:	2b24      	cmp	r3, #36	; 0x24
 800b6a6:	d004      	beq.n	800b6b2 <system_execute_line+0x2ca>
 800b6a8:	2b2a      	cmp	r3, #42	; 0x2a
 800b6aa:	d00a      	beq.n	800b6c2 <system_execute_line+0x2da>
 800b6ac:	2b23      	cmp	r3, #35	; 0x23
 800b6ae:	d004      	beq.n	800b6ba <system_execute_line+0x2d2>
 800b6b0:	e00b      	b.n	800b6ca <system_execute_line+0x2e2>
            #ifdef ENABLE_RESTORE_EEPROM_DEFAULT_SETTINGS
              case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
 800b6b2:	2001      	movs	r0, #1
 800b6b4:	f7fd fe26 	bl	8009304 <settings_restore>
 800b6b8:	e009      	b.n	800b6ce <system_execute_line+0x2e6>
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_CLEAR_PARAMETERS
              case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
 800b6ba:	2002      	movs	r0, #2
 800b6bc:	f7fd fe22 	bl	8009304 <settings_restore>
 800b6c0:	e005      	b.n	800b6ce <system_execute_line+0x2e6>
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_WIPE_ALL
              case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
 800b6c2:	20ff      	movs	r0, #255	; 0xff
 800b6c4:	f7fd fe1e 	bl	8009304 <settings_restore>
 800b6c8:	e001      	b.n	800b6ce <system_execute_line+0x2e6>
            #endif
            default: return(STATUS_INVALID_STATEMENT);
 800b6ca:	2303      	movs	r3, #3
 800b6cc:	e0f2      	b.n	800b8b4 <system_execute_line+0x4cc>
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
 800b6ce:	2009      	movs	r0, #9
 800b6d0:	f7fc fe74 	bl	80083bc <report_feedback_message>
          mc_reset(); // Force reset to ensure settings are initialized correctly.
 800b6d4:	f7fa fe12 	bl	80062fc <mc_reset>
          break;
 800b6d8:	e0eb      	b.n	800b8b2 <system_execute_line+0x4ca>
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
 800b6da:	2316      	movs	r3, #22
 800b6dc:	18fb      	adds	r3, r7, r3
 800b6de:	781b      	ldrb	r3, [r3, #0]
 800b6e0:	3301      	adds	r3, #1
 800b6e2:	b2da      	uxtb	r2, r3
 800b6e4:	2316      	movs	r3, #22
 800b6e6:	18fb      	adds	r3, r7, r3
 800b6e8:	701a      	strb	r2, [r3, #0]
 800b6ea:	2316      	movs	r3, #22
 800b6ec:	18fb      	adds	r3, r7, r3
 800b6ee:	781b      	ldrb	r3, [r3, #0]
 800b6f0:	001a      	movs	r2, r3
 800b6f2:	687b      	ldr	r3, [r7, #4]
 800b6f4:	189b      	adds	r3, r3, r2
 800b6f6:	781b      	ldrb	r3, [r3, #0]
 800b6f8:	2b00      	cmp	r3, #0
 800b6fa:	d12e      	bne.n	800b75a <system_execute_line+0x372>
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
 800b6fc:	2317      	movs	r3, #23
 800b6fe:	18fb      	adds	r3, r7, r3
 800b700:	2200      	movs	r2, #0
 800b702:	701a      	strb	r2, [r3, #0]
 800b704:	e023      	b.n	800b74e <system_execute_line+0x366>
              if (!(settings_read_startup_line(helper_var, line))) {
 800b706:	687a      	ldr	r2, [r7, #4]
 800b708:	2317      	movs	r3, #23
 800b70a:	18fb      	adds	r3, r7, r3
 800b70c:	781b      	ldrb	r3, [r3, #0]
 800b70e:	0011      	movs	r1, r2
 800b710:	0018      	movs	r0, r3
 800b712:	f7fd fed3 	bl	80094bc <settings_read_startup_line>
 800b716:	1e03      	subs	r3, r0, #0
 800b718:	d10a      	bne.n	800b730 <system_execute_line+0x348>
                report_status_message(STATUS_SETTING_READ_FAIL);
 800b71a:	2007      	movs	r0, #7
 800b71c:	f7fc fe10 	bl	8008340 <report_status_message>
 800b720:	e00e      	b.n	800b740 <system_execute_line+0x358>
 800b722:	46c0      	nop			; (mov r8, r8)
 800b724:	20000b2c 	.word	0x20000b2c
 800b728:	0800da98 	.word	0x0800da98
 800b72c:	20000acc 	.word	0x20000acc
              } else {
                report_startup_line(helper_var,line);
 800b730:	687a      	ldr	r2, [r7, #4]
 800b732:	2317      	movs	r3, #23
 800b734:	18fb      	adds	r3, r7, r3
 800b736:	781b      	ldrb	r3, [r3, #0]
 800b738:	0011      	movs	r1, r2
 800b73a:	0018      	movs	r0, r3
 800b73c:	f7fd f95e 	bl	80089fc <report_startup_line>
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
 800b740:	2317      	movs	r3, #23
 800b742:	18fb      	adds	r3, r7, r3
 800b744:	781a      	ldrb	r2, [r3, #0]
 800b746:	2317      	movs	r3, #23
 800b748:	18fb      	adds	r3, r7, r3
 800b74a:	3201      	adds	r2, #1
 800b74c:	701a      	strb	r2, [r3, #0]
 800b74e:	2317      	movs	r3, #23
 800b750:	18fb      	adds	r3, r7, r3
 800b752:	781b      	ldrb	r3, [r3, #0]
 800b754:	2b01      	cmp	r3, #1
 800b756:	d9d6      	bls.n	800b706 <system_execute_line+0x31e>
                report_status_message(STATUS_SETTING_READ_FAIL);
              } else {
                report_startup_line(helper_var,line);
              }
            }
            break;
 800b758:	e0ab      	b.n	800b8b2 <system_execute_line+0x4ca>
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
 800b75a:	4b58      	ldr	r3, [pc, #352]	; (800b8bc <system_execute_line+0x4d4>)
 800b75c:	781b      	ldrb	r3, [r3, #0]
 800b75e:	2b00      	cmp	r3, #0
 800b760:	d001      	beq.n	800b766 <system_execute_line+0x37e>
 800b762:	2308      	movs	r3, #8
 800b764:	e0a6      	b.n	800b8b4 <system_execute_line+0x4cc>
            helper_var = true;  // Set helper_var to flag storing method.
 800b766:	2317      	movs	r3, #23
 800b768:	18fb      	adds	r3, r7, r3
 800b76a:	2201      	movs	r2, #1
 800b76c:	701a      	strb	r2, [r3, #0]
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
 800b76e:	2310      	movs	r3, #16
 800b770:	18fa      	adds	r2, r7, r3
 800b772:	2316      	movs	r3, #22
 800b774:	18f9      	adds	r1, r7, r3
 800b776:	687b      	ldr	r3, [r7, #4]
 800b778:	0018      	movs	r0, r3
 800b77a:	f7fa fdf7 	bl	800636c <read_float>
 800b77e:	1e03      	subs	r3, r0, #0
 800b780:	d101      	bne.n	800b786 <system_execute_line+0x39e>
 800b782:	2302      	movs	r3, #2
 800b784:	e096      	b.n	800b8b4 <system_execute_line+0x4cc>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
 800b786:	2316      	movs	r3, #22
 800b788:	18fb      	adds	r3, r7, r3
 800b78a:	781b      	ldrb	r3, [r3, #0]
 800b78c:	1c5a      	adds	r2, r3, #1
 800b78e:	b2d1      	uxtb	r1, r2
 800b790:	2216      	movs	r2, #22
 800b792:	18ba      	adds	r2, r7, r2
 800b794:	7011      	strb	r1, [r2, #0]
 800b796:	001a      	movs	r2, r3
 800b798:	687b      	ldr	r3, [r7, #4]
 800b79a:	189b      	adds	r3, r3, r2
 800b79c:	781b      	ldrb	r3, [r3, #0]
 800b79e:	2b3d      	cmp	r3, #61	; 0x3d
 800b7a0:	d001      	beq.n	800b7a6 <system_execute_line+0x3be>
 800b7a2:	2303      	movs	r3, #3
 800b7a4:	e086      	b.n	800b8b4 <system_execute_line+0x4cc>
          if (helper_var) { // Store startup line
 800b7a6:	2317      	movs	r3, #23
 800b7a8:	18fb      	adds	r3, r7, r3
 800b7aa:	781b      	ldrb	r3, [r3, #0]
 800b7ac:	2b00      	cmp	r3, #0
 800b7ae:	d054      	beq.n	800b85a <system_execute_line+0x472>
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
 800b7b0:	2317      	movs	r3, #23
 800b7b2:	18fb      	adds	r3, r7, r3
 800b7b4:	2216      	movs	r2, #22
 800b7b6:	18ba      	adds	r2, r7, r2
 800b7b8:	7812      	ldrb	r2, [r2, #0]
 800b7ba:	701a      	strb	r2, [r3, #0]
            do {
              line[char_counter-helper_var] = line[char_counter];
 800b7bc:	2316      	movs	r3, #22
 800b7be:	18fb      	adds	r3, r7, r3
 800b7c0:	781b      	ldrb	r3, [r3, #0]
 800b7c2:	001a      	movs	r2, r3
 800b7c4:	2317      	movs	r3, #23
 800b7c6:	18fb      	adds	r3, r7, r3
 800b7c8:	781b      	ldrb	r3, [r3, #0]
 800b7ca:	1ad3      	subs	r3, r2, r3
 800b7cc:	001a      	movs	r2, r3
 800b7ce:	687b      	ldr	r3, [r7, #4]
 800b7d0:	189b      	adds	r3, r3, r2
 800b7d2:	2216      	movs	r2, #22
 800b7d4:	18ba      	adds	r2, r7, r2
 800b7d6:	7812      	ldrb	r2, [r2, #0]
 800b7d8:	0011      	movs	r1, r2
 800b7da:	687a      	ldr	r2, [r7, #4]
 800b7dc:	1852      	adds	r2, r2, r1
 800b7de:	7812      	ldrb	r2, [r2, #0]
 800b7e0:	701a      	strb	r2, [r3, #0]
            } while (line[char_counter++] != 0);
 800b7e2:	2316      	movs	r3, #22
 800b7e4:	18fb      	adds	r3, r7, r3
 800b7e6:	781b      	ldrb	r3, [r3, #0]
 800b7e8:	1c5a      	adds	r2, r3, #1
 800b7ea:	b2d1      	uxtb	r1, r2
 800b7ec:	2216      	movs	r2, #22
 800b7ee:	18ba      	adds	r2, r7, r2
 800b7f0:	7011      	strb	r1, [r2, #0]
 800b7f2:	001a      	movs	r2, r3
 800b7f4:	687b      	ldr	r3, [r7, #4]
 800b7f6:	189b      	adds	r3, r3, r2
 800b7f8:	781b      	ldrb	r3, [r3, #0]
 800b7fa:	2b00      	cmp	r3, #0
 800b7fc:	d1de      	bne.n	800b7bc <system_execute_line+0x3d4>
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
 800b7fe:	2317      	movs	r3, #23
 800b800:	18fc      	adds	r4, r7, r3
 800b802:	687b      	ldr	r3, [r7, #4]
 800b804:	0018      	movs	r0, r3
 800b806:	f7f8 f91f 	bl	8003a48 <gc_execute_line>
 800b80a:	0003      	movs	r3, r0
 800b80c:	7023      	strb	r3, [r4, #0]
            if (helper_var) { return(helper_var); }
 800b80e:	2317      	movs	r3, #23
 800b810:	18fb      	adds	r3, r7, r3
 800b812:	781b      	ldrb	r3, [r3, #0]
 800b814:	2b00      	cmp	r3, #0
 800b816:	d003      	beq.n	800b820 <system_execute_line+0x438>
 800b818:	2317      	movs	r3, #23
 800b81a:	18fb      	adds	r3, r7, r3
 800b81c:	781b      	ldrb	r3, [r3, #0]
 800b81e:	e049      	b.n	800b8b4 <system_execute_line+0x4cc>
            else {
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
 800b820:	693b      	ldr	r3, [r7, #16]
 800b822:	1c18      	adds	r0, r3, #0
 800b824:	f7f6 ff28 	bl	8002678 <__aeabi_f2d>
 800b828:	0003      	movs	r3, r0
 800b82a:	000c      	movs	r4, r1
 800b82c:	0018      	movs	r0, r3
 800b82e:	0021      	movs	r1, r4
 800b830:	f000 fcb4 	bl	800c19c <trunc>
 800b834:	0002      	movs	r2, r0
 800b836:	000b      	movs	r3, r1
 800b838:	2117      	movs	r1, #23
 800b83a:	187c      	adds	r4, r7, r1
 800b83c:	0010      	movs	r0, r2
 800b83e:	0019      	movs	r1, r3
 800b840:	f7f4 fd88 	bl	8000354 <__aeabi_d2uiz>
 800b844:	0003      	movs	r3, r0
 800b846:	7023      	strb	r3, [r4, #0]
              settings_store_startup_line(helper_var,line);
 800b848:	687a      	ldr	r2, [r7, #4]
 800b84a:	2317      	movs	r3, #23
 800b84c:	18fb      	adds	r3, r7, r3
 800b84e:	781b      	ldrb	r3, [r3, #0]
 800b850:	0011      	movs	r1, r2
 800b852:	0018      	movs	r0, r3
 800b854:	f7fd fcf4 	bl	8009240 <settings_store_startup_line>
 800b858:	e02b      	b.n	800b8b2 <system_execute_line+0x4ca>
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
 800b85a:	230c      	movs	r3, #12
 800b85c:	18fa      	adds	r2, r7, r3
 800b85e:	2316      	movs	r3, #22
 800b860:	18f9      	adds	r1, r7, r3
 800b862:	687b      	ldr	r3, [r7, #4]
 800b864:	0018      	movs	r0, r3
 800b866:	f7fa fd81 	bl	800636c <read_float>
 800b86a:	1e03      	subs	r3, r0, #0
 800b86c:	d101      	bne.n	800b872 <system_execute_line+0x48a>
 800b86e:	2302      	movs	r3, #2
 800b870:	e020      	b.n	800b8b4 <system_execute_line+0x4cc>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
 800b872:	2316      	movs	r3, #22
 800b874:	18fb      	adds	r3, r7, r3
 800b876:	781b      	ldrb	r3, [r3, #0]
 800b878:	001a      	movs	r2, r3
 800b87a:	687b      	ldr	r3, [r7, #4]
 800b87c:	189b      	adds	r3, r3, r2
 800b87e:	781b      	ldrb	r3, [r3, #0]
 800b880:	2b00      	cmp	r3, #0
 800b882:	d106      	bne.n	800b892 <system_execute_line+0x4aa>
 800b884:	693b      	ldr	r3, [r7, #16]
 800b886:	490e      	ldr	r1, [pc, #56]	; (800b8c0 <system_execute_line+0x4d8>)
 800b888:	1c18      	adds	r0, r3, #0
 800b88a:	f7f4 fd37 	bl	80002fc <__aeabi_fcmpgt>
 800b88e:	1e03      	subs	r3, r0, #0
 800b890:	d001      	beq.n	800b896 <system_execute_line+0x4ae>
 800b892:	2303      	movs	r3, #3
 800b894:	e00e      	b.n	800b8b4 <system_execute_line+0x4cc>
            return(settings_store_global_setting((uint8_t)parameter, value));
 800b896:	693b      	ldr	r3, [r7, #16]
 800b898:	1c18      	adds	r0, r3, #0
 800b89a:	f7f4 fd43 	bl	8000324 <__aeabi_f2uiz>
 800b89e:	0003      	movs	r3, r0
 800b8a0:	b2db      	uxtb	r3, r3
 800b8a2:	68fa      	ldr	r2, [r7, #12]
 800b8a4:	1c11      	adds	r1, r2, #0
 800b8a6:	0018      	movs	r0, r3
 800b8a8:	f7fd fea0 	bl	80095ec <settings_store_global_setting>
 800b8ac:	0003      	movs	r3, r0
 800b8ae:	e001      	b.n	800b8b4 <system_execute_line+0x4cc>
          if (!sys.abort) {  // Execute startup scripts after successful homing.
            sys.state = STATE_IDLE; // Set to IDLE when complete.
            st_go_idle(); // Set steppers to the settings idle state before returning.
            if (line[2] == 0) { system_execute_startup(line); }
          }
          break;
 800b8b0:	46c0      	nop			; (mov r8, r8)
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
 800b8b2:	2300      	movs	r3, #0
}
 800b8b4:	0018      	movs	r0, r3
 800b8b6:	46bd      	mov	sp, r7
 800b8b8:	b007      	add	sp, #28
 800b8ba:	bd90      	pop	{r4, r7, pc}
 800b8bc:	20000b2c 	.word	0x20000b2c
 800b8c0:	437f0000 	.word	0x437f0000

0800b8c4 <system_flag_wco_change>:



void system_flag_wco_change()
{
 800b8c4:	b580      	push	{r7, lr}
 800b8c6:	af00      	add	r7, sp, #0
  #ifdef FORCE_BUFFER_SYNC_DURING_WCO_CHANGE
    protocol_buffer_synchronize();
 800b8c8:	f7fc f808 	bl	80078dc <protocol_buffer_synchronize>
  #endif
  sys.report_wco_counter = 0;
 800b8cc:	4b02      	ldr	r3, [pc, #8]	; (800b8d8 <system_flag_wco_change+0x14>)
 800b8ce:	2200      	movs	r2, #0
 800b8d0:	731a      	strb	r2, [r3, #12]
}
 800b8d2:	46c0      	nop			; (mov r8, r8)
 800b8d4:	46bd      	mov	sp, r7
 800b8d6:	bd80      	pop	{r7, pc}
 800b8d8:	20000b2c 	.word	0x20000b2c

0800b8dc <system_convert_axis_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//   serves as a central place to compute the transformation.
float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
{
 800b8dc:	b580      	push	{r7, lr}
 800b8de:	b084      	sub	sp, #16
 800b8e0:	af00      	add	r7, sp, #0
 800b8e2:	6078      	str	r0, [r7, #4]
 800b8e4:	000a      	movs	r2, r1
 800b8e6:	1cfb      	adds	r3, r7, #3
 800b8e8:	701a      	strb	r2, [r3, #0]
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[idx];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
 800b8ea:	1cfb      	adds	r3, r7, #3
 800b8ec:	781b      	ldrb	r3, [r3, #0]
 800b8ee:	009b      	lsls	r3, r3, #2
 800b8f0:	687a      	ldr	r2, [r7, #4]
 800b8f2:	18d3      	adds	r3, r2, r3
 800b8f4:	681b      	ldr	r3, [r3, #0]
 800b8f6:	0018      	movs	r0, r3
 800b8f8:	f7f5 fb5e 	bl	8000fb8 <__aeabi_i2f>
 800b8fc:	1cfb      	adds	r3, r7, #3
 800b8fe:	781a      	ldrb	r2, [r3, #0]
 800b900:	4b06      	ldr	r3, [pc, #24]	; (800b91c <system_convert_axis_steps_to_mpos+0x40>)
 800b902:	0092      	lsls	r2, r2, #2
 800b904:	58d3      	ldr	r3, [r2, r3]
 800b906:	1c19      	adds	r1, r3, #0
 800b908:	f7f4 feb8 	bl	800067c <__aeabi_fdiv>
 800b90c:	1c03      	adds	r3, r0, #0
 800b90e:	60fb      	str	r3, [r7, #12]
  #endif
  return(pos);
 800b910:	68fb      	ldr	r3, [r7, #12]
}
 800b912:	1c18      	adds	r0, r3, #0
 800b914:	46bd      	mov	sp, r7
 800b916:	b004      	add	sp, #16
 800b918:	bd80      	pop	{r7, pc}
 800b91a:	46c0      	nop			; (mov r8, r8)
 800b91c:	20000acc 	.word	0x20000acc

0800b920 <system_convert_array_steps_to_mpos>:


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
 800b920:	b590      	push	{r4, r7, lr}
 800b922:	b085      	sub	sp, #20
 800b924:	af00      	add	r7, sp, #0
 800b926:	6078      	str	r0, [r7, #4]
 800b928:	6039      	str	r1, [r7, #0]
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 800b92a:	230f      	movs	r3, #15
 800b92c:	18fb      	adds	r3, r7, r3
 800b92e:	2200      	movs	r2, #0
 800b930:	701a      	strb	r2, [r3, #0]
 800b932:	e016      	b.n	800b962 <system_convert_array_steps_to_mpos+0x42>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
 800b934:	230f      	movs	r3, #15
 800b936:	18fb      	adds	r3, r7, r3
 800b938:	781b      	ldrb	r3, [r3, #0]
 800b93a:	009b      	lsls	r3, r3, #2
 800b93c:	687a      	ldr	r2, [r7, #4]
 800b93e:	18d4      	adds	r4, r2, r3
 800b940:	230f      	movs	r3, #15
 800b942:	18fb      	adds	r3, r7, r3
 800b944:	781a      	ldrb	r2, [r3, #0]
 800b946:	683b      	ldr	r3, [r7, #0]
 800b948:	0011      	movs	r1, r2
 800b94a:	0018      	movs	r0, r3
 800b94c:	f7ff ffc6 	bl	800b8dc <system_convert_axis_steps_to_mpos>
 800b950:	1c03      	adds	r3, r0, #0
 800b952:	6023      	str	r3, [r4, #0]


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 800b954:	230f      	movs	r3, #15
 800b956:	18fb      	adds	r3, r7, r3
 800b958:	781a      	ldrb	r2, [r3, #0]
 800b95a:	230f      	movs	r3, #15
 800b95c:	18fb      	adds	r3, r7, r3
 800b95e:	3201      	adds	r2, #1
 800b960:	701a      	strb	r2, [r3, #0]
 800b962:	230f      	movs	r3, #15
 800b964:	18fb      	adds	r3, r7, r3
 800b966:	781b      	ldrb	r3, [r3, #0]
 800b968:	2b02      	cmp	r3, #2
 800b96a:	d9e3      	bls.n	800b934 <system_convert_array_steps_to_mpos+0x14>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
  }
  return;
 800b96c:	46c0      	nop			; (mov r8, r8)
}
 800b96e:	46bd      	mov	sp, r7
 800b970:	b005      	add	sp, #20
 800b972:	bd90      	pop	{r4, r7, pc}

0800b974 <system_check_travel_limits>:
#endif


// Checks and reports if target array exceeds machine travel limits.
uint8_t system_check_travel_limits(float *target)
{
 800b974:	b580      	push	{r7, lr}
 800b976:	b084      	sub	sp, #16
 800b978:	af00      	add	r7, sp, #0
 800b97a:	6078      	str	r0, [r7, #4]
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 800b97c:	230f      	movs	r3, #15
 800b97e:	18fb      	adds	r3, r7, r3
 800b980:	2200      	movs	r2, #0
 800b982:	701a      	strb	r2, [r3, #0]
 800b984:	e02a      	b.n	800b9dc <system_check_travel_limits+0x68>
      } else {
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
      }
    #else
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
 800b986:	230f      	movs	r3, #15
 800b988:	18fb      	adds	r3, r7, r3
 800b98a:	781b      	ldrb	r3, [r3, #0]
 800b98c:	009b      	lsls	r3, r3, #2
 800b98e:	687a      	ldr	r2, [r7, #4]
 800b990:	18d3      	adds	r3, r2, r3
 800b992:	681b      	ldr	r3, [r3, #0]
 800b994:	2100      	movs	r1, #0
 800b996:	1c18      	adds	r0, r3, #0
 800b998:	f7f4 fcb0 	bl	80002fc <__aeabi_fcmpgt>
 800b99c:	1e03      	subs	r3, r0, #0
 800b99e:	d114      	bne.n	800b9ca <system_check_travel_limits+0x56>
 800b9a0:	230f      	movs	r3, #15
 800b9a2:	18fb      	adds	r3, r7, r3
 800b9a4:	781b      	ldrb	r3, [r3, #0]
 800b9a6:	009b      	lsls	r3, r3, #2
 800b9a8:	687a      	ldr	r2, [r7, #4]
 800b9aa:	18d3      	adds	r3, r2, r3
 800b9ac:	6818      	ldr	r0, [r3, #0]
 800b9ae:	230f      	movs	r3, #15
 800b9b0:	18fb      	adds	r3, r7, r3
 800b9b2:	781b      	ldrb	r3, [r3, #0]
 800b9b4:	4a0e      	ldr	r2, [pc, #56]	; (800b9f0 <system_check_travel_limits+0x7c>)
 800b9b6:	3308      	adds	r3, #8
 800b9b8:	009b      	lsls	r3, r3, #2
 800b9ba:	18d3      	adds	r3, r2, r3
 800b9bc:	3304      	adds	r3, #4
 800b9be:	681b      	ldr	r3, [r3, #0]
 800b9c0:	1c19      	adds	r1, r3, #0
 800b9c2:	f7f4 fc87 	bl	80002d4 <__aeabi_fcmplt>
 800b9c6:	1e03      	subs	r3, r0, #0
 800b9c8:	d001      	beq.n	800b9ce <system_check_travel_limits+0x5a>
 800b9ca:	2301      	movs	r3, #1
 800b9cc:	e00c      	b.n	800b9e8 <system_check_travel_limits+0x74>

// Checks and reports if target array exceeds machine travel limits.
uint8_t system_check_travel_limits(float *target)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 800b9ce:	230f      	movs	r3, #15
 800b9d0:	18fb      	adds	r3, r7, r3
 800b9d2:	781a      	ldrb	r2, [r3, #0]
 800b9d4:	230f      	movs	r3, #15
 800b9d6:	18fb      	adds	r3, r7, r3
 800b9d8:	3201      	adds	r2, #1
 800b9da:	701a      	strb	r2, [r3, #0]
 800b9dc:	230f      	movs	r3, #15
 800b9de:	18fb      	adds	r3, r7, r3
 800b9e0:	781b      	ldrb	r3, [r3, #0]
 800b9e2:	2b02      	cmp	r3, #2
 800b9e4:	d9cf      	bls.n	800b986 <system_check_travel_limits+0x12>
    #else
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
    #endif
  }
  return(false);
 800b9e6:	2300      	movs	r3, #0
}
 800b9e8:	0018      	movs	r0, r3
 800b9ea:	46bd      	mov	sp, r7
 800b9ec:	b004      	add	sp, #16
 800b9ee:	bd80      	pop	{r7, pc}
 800b9f0:	20000acc 	.word	0x20000acc

0800b9f4 <system_set_exec_state_flag>:
#ifdef WIN32
extern CRITICAL_SECTION CriticalSection;
#endif

// Special handlers for setting and clearing Grbl's real-time execution flags.
void system_set_exec_state_flag(uint8_t mask) {
 800b9f4:	b580      	push	{r7, lr}
 800b9f6:	b082      	sub	sp, #8
 800b9f8:	af00      	add	r7, sp, #0
 800b9fa:	0002      	movs	r2, r0
 800b9fc:	1dfb      	adds	r3, r7, #7
 800b9fe:	701a      	strb	r2, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800ba00:	b672      	cpsid	i
  sys_rt_exec_state |= (mask);
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_state |= (mask);
 800ba02:	4b07      	ldr	r3, [pc, #28]	; (800ba20 <system_set_exec_state_flag+0x2c>)
 800ba04:	781b      	ldrb	r3, [r3, #0]
 800ba06:	b2da      	uxtb	r2, r3
 800ba08:	1dfb      	adds	r3, r7, #7
 800ba0a:	781b      	ldrb	r3, [r3, #0]
 800ba0c:	4313      	orrs	r3, r2
 800ba0e:	b2da      	uxtb	r2, r3
 800ba10:	4b03      	ldr	r3, [pc, #12]	; (800ba20 <system_set_exec_state_flag+0x2c>)
 800ba12:	701a      	strb	r2, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800ba14:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800ba16:	46c0      	nop			; (mov r8, r8)
 800ba18:	46bd      	mov	sp, r7
 800ba1a:	b002      	add	sp, #8
 800ba1c:	bd80      	pop	{r7, pc}
 800ba1e:	46c0      	nop			; (mov r8, r8)
 800ba20:	20000b41 	.word	0x20000b41

0800ba24 <system_clear_exec_state_flag>:

void system_clear_exec_state_flag(uint8_t mask) {
 800ba24:	b580      	push	{r7, lr}
 800ba26:	b082      	sub	sp, #8
 800ba28:	af00      	add	r7, sp, #0
 800ba2a:	0002      	movs	r2, r0
 800ba2c:	1dfb      	adds	r3, r7, #7
 800ba2e:	701a      	strb	r2, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800ba30:	b672      	cpsid	i
  sys_rt_exec_state &= ~(mask);
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_state &= ~(mask);
 800ba32:	1dfb      	adds	r3, r7, #7
 800ba34:	781b      	ldrb	r3, [r3, #0]
 800ba36:	b25b      	sxtb	r3, r3
 800ba38:	43db      	mvns	r3, r3
 800ba3a:	b25b      	sxtb	r3, r3
 800ba3c:	4a06      	ldr	r2, [pc, #24]	; (800ba58 <system_clear_exec_state_flag+0x34>)
 800ba3e:	7812      	ldrb	r2, [r2, #0]
 800ba40:	b2d2      	uxtb	r2, r2
 800ba42:	b252      	sxtb	r2, r2
 800ba44:	4013      	ands	r3, r2
 800ba46:	b25b      	sxtb	r3, r3
 800ba48:	b2da      	uxtb	r2, r3
 800ba4a:	4b03      	ldr	r3, [pc, #12]	; (800ba58 <system_clear_exec_state_flag+0x34>)
 800ba4c:	701a      	strb	r2, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800ba4e:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800ba50:	46c0      	nop			; (mov r8, r8)
 800ba52:	46bd      	mov	sp, r7
 800ba54:	b002      	add	sp, #8
 800ba56:	bd80      	pop	{r7, pc}
 800ba58:	20000b41 	.word	0x20000b41

0800ba5c <system_set_exec_alarm>:

void system_set_exec_alarm(uint8_t code) {
 800ba5c:	b580      	push	{r7, lr}
 800ba5e:	b082      	sub	sp, #8
 800ba60:	af00      	add	r7, sp, #0
 800ba62:	0002      	movs	r2, r0
 800ba64:	1dfb      	adds	r3, r7, #7
 800ba66:	701a      	strb	r2, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800ba68:	b672      	cpsid	i
  sys_rt_exec_alarm |= (code);
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_alarm |= (code);
 800ba6a:	4b07      	ldr	r3, [pc, #28]	; (800ba88 <system_set_exec_alarm+0x2c>)
 800ba6c:	781b      	ldrb	r3, [r3, #0]
 800ba6e:	b2da      	uxtb	r2, r3
 800ba70:	1dfb      	adds	r3, r7, #7
 800ba72:	781b      	ldrb	r3, [r3, #0]
 800ba74:	4313      	orrs	r3, r2
 800ba76:	b2da      	uxtb	r2, r3
 800ba78:	4b03      	ldr	r3, [pc, #12]	; (800ba88 <system_set_exec_alarm+0x2c>)
 800ba7a:	701a      	strb	r2, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800ba7c:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800ba7e:	46c0      	nop			; (mov r8, r8)
 800ba80:	46bd      	mov	sp, r7
 800ba82:	b002      	add	sp, #8
 800ba84:	bd80      	pop	{r7, pc}
 800ba86:	46c0      	nop			; (mov r8, r8)
 800ba88:	20000b5c 	.word	0x20000b5c

0800ba8c <system_clear_exec_alarm>:

void system_clear_exec_alarm() {
 800ba8c:	b580      	push	{r7, lr}
 800ba8e:	af00      	add	r7, sp, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800ba90:	b672      	cpsid	i
  sys_rt_exec_alarm = 0;
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_alarm = 0;
 800ba92:	4b03      	ldr	r3, [pc, #12]	; (800baa0 <system_clear_exec_alarm+0x14>)
 800ba94:	2200      	movs	r2, #0
 800ba96:	701a      	strb	r2, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800ba98:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800ba9a:	46c0      	nop			; (mov r8, r8)
 800ba9c:	46bd      	mov	sp, r7
 800ba9e:	bd80      	pop	{r7, pc}
 800baa0:	20000b5c 	.word	0x20000b5c

0800baa4 <system_set_exec_motion_override_flag>:

void system_set_exec_motion_override_flag(uint8_t mask) {
 800baa4:	b580      	push	{r7, lr}
 800baa6:	b082      	sub	sp, #8
 800baa8:	af00      	add	r7, sp, #0
 800baaa:	0002      	movs	r2, r0
 800baac:	1dfb      	adds	r3, r7, #7
 800baae:	701a      	strb	r2, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800bab0:	b672      	cpsid	i
  sys_rt_exec_motion_override |= (mask);
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_motion_override |= (mask);
 800bab2:	4b07      	ldr	r3, [pc, #28]	; (800bad0 <system_set_exec_motion_override_flag+0x2c>)
 800bab4:	781b      	ldrb	r3, [r3, #0]
 800bab6:	b2da      	uxtb	r2, r3
 800bab8:	1dfb      	adds	r3, r7, #7
 800baba:	781b      	ldrb	r3, [r3, #0]
 800babc:	4313      	orrs	r3, r2
 800babe:	b2da      	uxtb	r2, r3
 800bac0:	4b03      	ldr	r3, [pc, #12]	; (800bad0 <system_set_exec_motion_override_flag+0x2c>)
 800bac2:	701a      	strb	r2, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800bac4:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800bac6:	46c0      	nop			; (mov r8, r8)
 800bac8:	46bd      	mov	sp, r7
 800baca:	b002      	add	sp, #8
 800bacc:	bd80      	pop	{r7, pc}
 800bace:	46c0      	nop			; (mov r8, r8)
 800bad0:	20000b28 	.word	0x20000b28

0800bad4 <system_set_exec_accessory_override_flag>:

void system_set_exec_accessory_override_flag(uint8_t mask) {
 800bad4:	b580      	push	{r7, lr}
 800bad6:	b082      	sub	sp, #8
 800bad8:	af00      	add	r7, sp, #0
 800bada:	0002      	movs	r2, r0
 800badc:	1dfb      	adds	r3, r7, #7
 800bade:	701a      	strb	r2, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800bae0:	b672      	cpsid	i
  sys_rt_exec_accessory_override |= (mask);
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_accessory_override |= (mask);
 800bae2:	4b07      	ldr	r3, [pc, #28]	; (800bb00 <system_set_exec_accessory_override_flag+0x2c>)
 800bae4:	781b      	ldrb	r3, [r3, #0]
 800bae6:	b2da      	uxtb	r2, r3
 800bae8:	1dfb      	adds	r3, r7, #7
 800baea:	781b      	ldrb	r3, [r3, #0]
 800baec:	4313      	orrs	r3, r2
 800baee:	b2da      	uxtb	r2, r3
 800baf0:	4b03      	ldr	r3, [pc, #12]	; (800bb00 <system_set_exec_accessory_override_flag+0x2c>)
 800baf2:	701a      	strb	r2, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800baf4:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800baf6:	46c0      	nop			; (mov r8, r8)
 800baf8:	46bd      	mov	sp, r7
 800bafa:	b002      	add	sp, #8
 800bafc:	bd80      	pop	{r7, pc}
 800bafe:	46c0      	nop			; (mov r8, r8)
 800bb00:	20000b40 	.word	0x20000b40

0800bb04 <system_clear_exec_motion_overrides>:

void system_clear_exec_motion_overrides() {
 800bb04:	b580      	push	{r7, lr}
 800bb06:	af00      	add	r7, sp, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800bb08:	b672      	cpsid	i
  sys_rt_exec_motion_override = 0;
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_motion_override = 0;
 800bb0a:	4b03      	ldr	r3, [pc, #12]	; (800bb18 <system_clear_exec_motion_overrides+0x14>)
 800bb0c:	2200      	movs	r2, #0
 800bb0e:	701a      	strb	r2, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800bb10:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800bb12:	46c0      	nop			; (mov r8, r8)
 800bb14:	46bd      	mov	sp, r7
 800bb16:	bd80      	pop	{r7, pc}
 800bb18:	20000b28 	.word	0x20000b28

0800bb1c <system_clear_exec_accessory_overrides>:

void system_clear_exec_accessory_overrides() {
 800bb1c:	b580      	push	{r7, lr}
 800bb1e:	af00      	add	r7, sp, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800bb20:	b672      	cpsid	i
  sys_rt_exec_accessory_override = 0;
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_accessory_override = 0;
 800bb22:	4b03      	ldr	r3, [pc, #12]	; (800bb30 <system_clear_exec_accessory_overrides+0x14>)
 800bb24:	2200      	movs	r2, #0
 800bb26:	701a      	strb	r2, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800bb28:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800bb2a:	46c0      	nop			; (mov r8, r8)
 800bb2c:	46bd      	mov	sp, r7
 800bb2e:	bd80      	pop	{r7, pc}
 800bb30:	20000b40 	.word	0x20000b40

0800bb34 <USART1_Configuration>:
#include "stm32eeprom.h"
#ifndef USEUSB
#include "stm32f0xx_usart.h"

void USART1_Configuration(uint32_t BaudRate)
{
 800bb34:	b580      	push	{r7, lr}
 800bb36:	b08c      	sub	sp, #48	; 0x30
 800bb38:	af00      	add	r7, sp, #0
 800bb3a:	6078      	str	r0, [r7, #4]

	RCC_OscConfig();
 800bb3c:	f000 f940 	bl	800bdc0 <RCC_OscConfig>

	GPIO_InitTypeDef GPIO_InitStructure;
	USART_InitTypeDef USART_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;
	//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); TODO - Check if priority groups avaialbe for stm32f0xx
	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
 800bb40:	230c      	movs	r3, #12
 800bb42:	18fb      	adds	r3, r7, r3
 800bb44:	221b      	movs	r2, #27
 800bb46:	701a      	strb	r2, [r3, #0]
	//NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelPriority = 0;
 800bb48:	230c      	movs	r3, #12
 800bb4a:	18fb      	adds	r3, r7, r3
 800bb4c:	2200      	movs	r2, #0
 800bb4e:	705a      	strb	r2, [r3, #1]

	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800bb50:	230c      	movs	r3, #12
 800bb52:	18fb      	adds	r3, r7, r3
 800bb54:	2201      	movs	r2, #1
 800bb56:	709a      	strb	r2, [r3, #2]
	NVIC_Init(&NVIC_InitStructure);
 800bb58:	230c      	movs	r3, #12
 800bb5a:	18fb      	adds	r3, r7, r3
 800bb5c:	0018      	movs	r0, r3
 800bb5e:	f7f6 fff7 	bl	8002b50 <NVIC_Init>
	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);

	RCC_HCLKConfig(RCC_SYSCLK_Div1);
 800bb62:	2000      	movs	r0, #0
 800bb64:	f7f7 f8be 	bl	8002ce4 <RCC_HCLKConfig>
	RCC_USARTCLKConfig(RCC_USART1CLK_PCLK);
 800bb68:	2380      	movs	r3, #128	; 0x80
 800bb6a:	055b      	lsls	r3, r3, #21
 800bb6c:	0018      	movs	r0, r3
 800bb6e:	f7f7 f8d3 	bl	8002d18 <RCC_USARTCLKConfig>

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 800bb72:	2380      	movs	r3, #128	; 0x80
 800bb74:	01db      	lsls	r3, r3, #7
 800bb76:	2101      	movs	r1, #1
 800bb78:	0018      	movs	r0, r3
 800bb7a:	f7f7 fa89 	bl	8003090 <RCC_APB2PeriphClockCmd>
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 800bb7e:	2380      	movs	r3, #128	; 0x80
 800bb80:	029b      	lsls	r3, r3, #10
 800bb82:	2101      	movs	r1, #1
 800bb84:	0018      	movs	r0, r3
 800bb86:	f7f7 fa63 	bl	8003050 <RCC_AHBPeriphClockCmd>
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC, ENABLE);
 800bb8a:	2380      	movs	r3, #128	; 0x80
 800bb8c:	031b      	lsls	r3, r3, #12
 800bb8e:	2101      	movs	r1, #1
 800bb90:	0018      	movs	r0, r3
 800bb92:	f7f7 fa5d 	bl	8003050 <RCC_AHBPeriphClockCmd>

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 800bb96:	2328      	movs	r3, #40	; 0x28
 800bb98:	18fb      	adds	r3, r7, r3
 800bb9a:	2280      	movs	r2, #128	; 0x80
 800bb9c:	0092      	lsls	r2, r2, #2
 800bb9e:	601a      	str	r2, [r3, #0]
	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800bba0:	2328      	movs	r3, #40	; 0x28
 800bba2:	18fb      	adds	r3, r7, r3
 800bba4:	2202      	movs	r2, #2
 800bba6:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800bba8:	2328      	movs	r3, #40	; 0x28
 800bbaa:	18fb      	adds	r3, r7, r3
 800bbac:	2200      	movs	r2, #0
 800bbae:	719a      	strb	r2, [r3, #6]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; //CMS***
 800bbb0:	2328      	movs	r3, #40	; 0x28
 800bbb2:	18fb      	adds	r3, r7, r3
 800bbb4:	2201      	movs	r2, #1
 800bbb6:	71da      	strb	r2, [r3, #7]

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800bbb8:	2328      	movs	r3, #40	; 0x28
 800bbba:	18fb      	adds	r3, r7, r3
 800bbbc:	2203      	movs	r2, #3
 800bbbe:	715a      	strb	r2, [r3, #5]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800bbc0:	2328      	movs	r3, #40	; 0x28
 800bbc2:	18fa      	adds	r2, r7, r3
 800bbc4:	2390      	movs	r3, #144	; 0x90
 800bbc6:	05db      	lsls	r3, r3, #23
 800bbc8:	0011      	movs	r1, r2
 800bbca:	0018      	movs	r0, r3
 800bbcc:	f7f6 fec2 	bl	8002954 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 800bbd0:	2328      	movs	r3, #40	; 0x28
 800bbd2:	18fb      	adds	r3, r7, r3
 800bbd4:	2280      	movs	r2, #128	; 0x80
 800bbd6:	00d2      	lsls	r2, r2, #3
 800bbd8:	601a      	str	r2, [r3, #0]
	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;		//CMS***
 800bbda:	2328      	movs	r3, #40	; 0x28
 800bbdc:	18fb      	adds	r3, r7, r3
 800bbde:	2202      	movs	r2, #2
 800bbe0:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	//CMS***
 800bbe2:	2328      	movs	r3, #40	; 0x28
 800bbe4:	18fb      	adds	r3, r7, r3
 800bbe6:	2203      	movs	r2, #3
 800bbe8:	715a      	strb	r2, [r3, #5]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;		//CMS***
 800bbea:	2328      	movs	r3, #40	; 0x28
 800bbec:	18fb      	adds	r3, r7, r3
 800bbee:	2201      	movs	r2, #1
 800bbf0:	71da      	strb	r2, [r3, #7]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800bbf2:	2328      	movs	r3, #40	; 0x28
 800bbf4:	18fa      	adds	r2, r7, r3
 800bbf6:	2390      	movs	r3, #144	; 0x90
 800bbf8:	05db      	lsls	r3, r3, #23
 800bbfa:	0011      	movs	r1, r2
 800bbfc:	0018      	movs	r0, r3
 800bbfe:	f7f6 fea9 	bl	8002954 <GPIO_Init>

	GPIOA->AFR[1] |= 0x110;
 800bc02:	2390      	movs	r3, #144	; 0x90
 800bc04:	05db      	lsls	r3, r3, #23
 800bc06:	2290      	movs	r2, #144	; 0x90
 800bc08:	05d2      	lsls	r2, r2, #23
 800bc0a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800bc0c:	2188      	movs	r1, #136	; 0x88
 800bc0e:	0049      	lsls	r1, r1, #1
 800bc10:	430a      	orrs	r2, r1
 800bc12:	625a      	str	r2, [r3, #36]	; 0x24

	USART_InitStructure.USART_BaudRate = BaudRate;
 800bc14:	2310      	movs	r3, #16
 800bc16:	18fb      	adds	r3, r7, r3
 800bc18:	687a      	ldr	r2, [r7, #4]
 800bc1a:	601a      	str	r2, [r3, #0]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 800bc1c:	2310      	movs	r3, #16
 800bc1e:	18fb      	adds	r3, r7, r3
 800bc20:	2200      	movs	r2, #0
 800bc22:	605a      	str	r2, [r3, #4]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 800bc24:	2310      	movs	r3, #16
 800bc26:	18fb      	adds	r3, r7, r3
 800bc28:	2200      	movs	r2, #0
 800bc2a:	609a      	str	r2, [r3, #8]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 800bc2c:	2310      	movs	r3, #16
 800bc2e:	18fb      	adds	r3, r7, r3
 800bc30:	2200      	movs	r2, #0
 800bc32:	60da      	str	r2, [r3, #12]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 800bc34:	2310      	movs	r3, #16
 800bc36:	18fb      	adds	r3, r7, r3
 800bc38:	2200      	movs	r2, #0
 800bc3a:	615a      	str	r2, [r3, #20]
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 800bc3c:	2310      	movs	r3, #16
 800bc3e:	18fb      	adds	r3, r7, r3
 800bc40:	220c      	movs	r2, #12
 800bc42:	611a      	str	r2, [r3, #16]
	USART1->CR1 |= (USART_CR1_RE | USART_CR1_TE);
 800bc44:	4b0d      	ldr	r3, [pc, #52]	; (800bc7c <USART1_Configuration+0x148>)
 800bc46:	4a0d      	ldr	r2, [pc, #52]	; (800bc7c <USART1_Configuration+0x148>)
 800bc48:	6812      	ldr	r2, [r2, #0]
 800bc4a:	210c      	movs	r1, #12
 800bc4c:	430a      	orrs	r2, r1
 800bc4e:	601a      	str	r2, [r3, #0]
	USART_Init(USART1, &USART_InitStructure);
 800bc50:	2310      	movs	r3, #16
 800bc52:	18fb      	adds	r3, r7, r3
 800bc54:	4a09      	ldr	r2, [pc, #36]	; (800bc7c <USART1_Configuration+0x148>)
 800bc56:	0019      	movs	r1, r3
 800bc58:	0010      	movs	r0, r2
 800bc5a:	f7f7 fc91 	bl	8003580 <USART_Init>
		//USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
 800bc5e:	4908      	ldr	r1, [pc, #32]	; (800bc80 <USART1_Configuration+0x14c>)
 800bc60:	4b06      	ldr	r3, [pc, #24]	; (800bc7c <USART1_Configuration+0x148>)
 800bc62:	2201      	movs	r2, #1
 800bc64:	0018      	movs	r0, r3
 800bc66:	f7f7 fd81 	bl	800376c <USART_ITConfig>
	USART_Cmd(USART1, ENABLE);
 800bc6a:	4b04      	ldr	r3, [pc, #16]	; (800bc7c <USART1_Configuration+0x148>)
 800bc6c:	2101      	movs	r1, #1
 800bc6e:	0018      	movs	r0, r3
 800bc70:	f7f7 fd4c 	bl	800370c <USART_Cmd>


}
 800bc74:	46c0      	nop			; (mov r8, r8)
 800bc76:	46bd      	mov	sp, r7
 800bc78:	b00c      	add	sp, #48	; 0x30
 800bc7a:	bd80      	pop	{r7, pc}
 800bc7c:	40013800 	.word	0x40013800
 800bc80:	00050105 	.word	0x00050105

0800bc84 <main>:
#ifdef WIN32
int main(int argc, char *argv[])
#else
int main(void)
#endif
{
 800bc84:	b580      	push	{r7, lr}
 800bc86:	b082      	sub	sp, #8
 800bc88:	af00      	add	r7, sp, #0
	GPIO_Init(GPIOC, &GPIO_InitStructure);
#endif
	//Set_System();
#ifndef USEUSB
	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	USART1_Configuration(9600);
 800bc8a:	2396      	movs	r3, #150	; 0x96
 800bc8c:	019b      	lsls	r3, r3, #6
 800bc8e:	0018      	movs	r0, r3
 800bc90:	f7ff ff50 	bl	800bb34 <USART1_Configuration>

#ifndef NOEEPROMSUPPORT
	FLASH_Unlock();
	eeprom_init();
#endif
	 SysTick->CTRL &= 0xfffffffb;
 800bc94:	4b2d      	ldr	r3, [pc, #180]	; (800bd4c <main+0xc8>)
 800bc96:	4a2d      	ldr	r2, [pc, #180]	; (800bd4c <main+0xc8>)
 800bc98:	6812      	ldr	r2, [r2, #0]
 800bc9a:	2104      	movs	r1, #4
 800bc9c:	438a      	bics	r2, r1
 800bc9e:	601a      	str	r2, [r3, #0]
#endif
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
 800bca0:	f7fd f9a8 	bl	8008ff4 <serial_init>
#ifdef WIN32
  winserial_init(argv[1]);
  eeprom_init();
#endif
  settings_init(); // Load Grbl settings from EEPROM
 800bca4:	f7fd fe8c 	bl	80099c0 <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
 800bca8:	f7fe fbe4 	bl	800a474 <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
 800bcac:	f7ff fabe 	bl	800b22c <system_init>

  memset(sys_position,0,sizeof(sys_position)); // Clear machine position.
 800bcb0:	4b27      	ldr	r3, [pc, #156]	; (800bd50 <main+0xcc>)
 800bcb2:	220c      	movs	r2, #12
 800bcb4:	2100      	movs	r1, #0
 800bcb6:	0018      	movs	r0, r3
 800bcb8:	f000 fa22 	bl	800c100 <memset>
  // Initialize system state.
  #ifdef FORCE_INITIALIZATION_ALARM
    // Force Grbl into an ALARM state upon a power-cycle or hard reset.
    sys.state = STATE_ALARM;
  #else
    sys.state = STATE_IDLE;
 800bcbc:	4b25      	ldr	r3, [pc, #148]	; (800bd54 <main+0xd0>)
 800bcbe:	2200      	movs	r2, #0
 800bcc0:	701a      	strb	r2, [r3, #0]
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
 800bcc2:	1dfb      	adds	r3, r7, #7
 800bcc4:	4a23      	ldr	r2, [pc, #140]	; (800bd54 <main+0xd0>)
 800bcc6:	7812      	ldrb	r2, [r2, #0]
 800bcc8:	701a      	strb	r2, [r3, #0]
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
 800bcca:	4b22      	ldr	r3, [pc, #136]	; (800bd54 <main+0xd0>)
 800bccc:	2214      	movs	r2, #20
 800bcce:	2100      	movs	r1, #0
 800bcd0:	0018      	movs	r0, r3
 800bcd2:	f000 fa15 	bl	800c100 <memset>
    sys.state = prior_state;
 800bcd6:	4b1f      	ldr	r3, [pc, #124]	; (800bd54 <main+0xd0>)
 800bcd8:	1dfa      	adds	r2, r7, #7
 800bcda:	7812      	ldrb	r2, [r2, #0]
 800bcdc:	701a      	strb	r2, [r3, #0]
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
 800bcde:	4b1d      	ldr	r3, [pc, #116]	; (800bd54 <main+0xd0>)
 800bce0:	2264      	movs	r2, #100	; 0x64
 800bce2:	71da      	strb	r2, [r3, #7]
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
 800bce4:	4b1b      	ldr	r3, [pc, #108]	; (800bd54 <main+0xd0>)
 800bce6:	2264      	movs	r2, #100	; 0x64
 800bce8:	721a      	strb	r2, [r3, #8]
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
 800bcea:	4b1a      	ldr	r3, [pc, #104]	; (800bd54 <main+0xd0>)
 800bcec:	2264      	movs	r2, #100	; 0x64
 800bcee:	725a      	strb	r2, [r3, #9]
		memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
 800bcf0:	4b19      	ldr	r3, [pc, #100]	; (800bd58 <main+0xd4>)
 800bcf2:	220c      	movs	r2, #12
 800bcf4:	2100      	movs	r1, #0
 800bcf6:	0018      	movs	r0, r3
 800bcf8:	f000 fa02 	bl	800c100 <memset>
    sys_probe_state = 0;
 800bcfc:	4b17      	ldr	r3, [pc, #92]	; (800bd5c <main+0xd8>)
 800bcfe:	2200      	movs	r2, #0
 800bd00:	701a      	strb	r2, [r3, #0]
    sys_rt_exec_state = 0;
 800bd02:	4b17      	ldr	r3, [pc, #92]	; (800bd60 <main+0xdc>)
 800bd04:	2200      	movs	r2, #0
 800bd06:	701a      	strb	r2, [r3, #0]
    sys_rt_exec_alarm = 0;
 800bd08:	4b16      	ldr	r3, [pc, #88]	; (800bd64 <main+0xe0>)
 800bd0a:	2200      	movs	r2, #0
 800bd0c:	701a      	strb	r2, [r3, #0]
    sys_rt_exec_motion_override = 0;
 800bd0e:	4b16      	ldr	r3, [pc, #88]	; (800bd68 <main+0xe4>)
 800bd10:	2200      	movs	r2, #0
 800bd12:	701a      	strb	r2, [r3, #0]
    sys_rt_exec_accessory_override = 0;
 800bd14:	4b15      	ldr	r3, [pc, #84]	; (800bd6c <main+0xe8>)
 800bd16:	2200      	movs	r2, #0
 800bd18:	701a      	strb	r2, [r3, #0]

    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
 800bd1a:	f7fd fa83 	bl	8009224 <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
 800bd1e:	f7f7 fe67 	bl	80039f0 <gc_init>
    spindle_init();
 800bd22:	f7fd fe5f 	bl	80099e4 <spindle_init>
    coolant_init();
 800bd26:	f7f7 fd65 	bl	80037f4 <coolant_init>
    limits_init();
 800bd2a:	f7f9 fc0d 	bl	8005548 <limits_init>
    probe_init();
 800bd2e:	f7fb fc27 	bl	8007580 <probe_init>
    plan_reset(); // Clear block buffer and planner variables
 800bd32:	f7fa febf 	bl	8006ab4 <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
 800bd36:	f7fe fb2d 	bl	800a394 <st_reset>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
 800bd3a:	f7fb fa5b 	bl	80071f4 <plan_sync_position>
    gc_sync_position();
 800bd3e:	f7f7 fe73 	bl	8003a28 <gc_sync_position>

    // Print welcome message. Indicates an initialization has occured at power-up or with a reset.
    report_init_message();
 800bd42:	f7fc fba5 	bl	8008490 <report_init_message>

    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
 800bd46:	f7fb fc9b 	bl	8007680 <protocol_main_loop>

  }
 800bd4a:	e7ba      	b.n	800bcc2 <main+0x3e>
 800bd4c:	e000e010 	.word	0xe000e010
 800bd50:	20000b50 	.word	0x20000b50
 800bd54:	20000b2c 	.word	0x20000b2c
 800bd58:	20000b44 	.word	0x20000b44
 800bd5c:	20000b42 	.word	0x20000b42
 800bd60:	20000b41 	.word	0x20000b41
 800bd64:	20000b5c 	.word	0x20000b5c
 800bd68:	20000b28 	.word	0x20000b28
 800bd6c:	20000b40 	.word	0x20000b40

0800bd70 <_delay_ms>:
	nOnFlag = (nOnFlag == Bit_SET) ? Bit_RESET : Bit_SET;
}
#endif
#if defined (STM32F0DISCOVERY)
void _delay_ms(uint32_t x)
{
 800bd70:	b580      	push	{r7, lr}
 800bd72:	b084      	sub	sp, #16
 800bd74:	af00      	add	r7, sp, #0
 800bd76:	6078      	str	r0, [r7, #4]
	uint32_t temp;
	SysTick->LOAD = (uint32_t)72000000 / 8000;                     // Loading time
 800bd78:	4b0f      	ldr	r3, [pc, #60]	; (800bdb8 <_delay_ms+0x48>)
 800bd7a:	4a10      	ldr	r2, [pc, #64]	; (800bdbc <_delay_ms+0x4c>)
 800bd7c:	605a      	str	r2, [r3, #4]
	SysTick->VAL = 0x00;                                            // Empty the counter
 800bd7e:	4b0e      	ldr	r3, [pc, #56]	; (800bdb8 <_delay_ms+0x48>)
 800bd80:	2200      	movs	r2, #0
 800bd82:	609a      	str	r2, [r3, #8]
	SysTick->CTRL = 0x01;                                           // Start from bottom
 800bd84:	4b0c      	ldr	r3, [pc, #48]	; (800bdb8 <_delay_ms+0x48>)
 800bd86:	2201      	movs	r2, #1
 800bd88:	601a      	str	r2, [r3, #0]
	do
	{
		temp = SysTick->CTRL;
 800bd8a:	4b0b      	ldr	r3, [pc, #44]	; (800bdb8 <_delay_ms+0x48>)
 800bd8c:	681b      	ldr	r3, [r3, #0]
 800bd8e:	60fb      	str	r3, [r7, #12]
	} while (temp & 0x01 && !(temp&(1 << 16)));                             // Wait time arrive
 800bd90:	68fb      	ldr	r3, [r7, #12]
 800bd92:	2201      	movs	r2, #1
 800bd94:	4013      	ands	r3, r2
 800bd96:	d004      	beq.n	800bda2 <_delay_ms+0x32>
 800bd98:	68fa      	ldr	r2, [r7, #12]
 800bd9a:	2380      	movs	r3, #128	; 0x80
 800bd9c:	025b      	lsls	r3, r3, #9
 800bd9e:	4013      	ands	r3, r2
 800bda0:	d0f3      	beq.n	800bd8a <_delay_ms+0x1a>
	SysTick->CTRL = 0x00;                                            // Close the counter
 800bda2:	4b05      	ldr	r3, [pc, #20]	; (800bdb8 <_delay_ms+0x48>)
 800bda4:	2200      	movs	r2, #0
 800bda6:	601a      	str	r2, [r3, #0]
	SysTick->VAL = 0X00;                                            // Empty the counter
 800bda8:	4b03      	ldr	r3, [pc, #12]	; (800bdb8 <_delay_ms+0x48>)
 800bdaa:	2200      	movs	r2, #0
 800bdac:	609a      	str	r2, [r3, #8]
}
 800bdae:	46c0      	nop			; (mov r8, r8)
 800bdb0:	46bd      	mov	sp, r7
 800bdb2:	b004      	add	sp, #16
 800bdb4:	bd80      	pop	{r7, pc}
 800bdb6:	46c0      	nop			; (mov r8, r8)
 800bdb8:	e000e010 	.word	0xe000e010
 800bdbc:	00002328 	.word	0x00002328

0800bdc0 <RCC_OscConfig>:
//
//#define RCC_FLAG_PLLRDY                  ((uint8_t)((CR_REG_INDEX << 5U) | RCC_CR_PLLRDY_BitNumber))
//#define CR_REG_INDEX                     ((uint8_t)1U)
//#define RCC_CR_PLLRDY_BitNumber           25U

void RCC_OscConfig(void){
 800bdc0:	b580      	push	{r7, lr}
 800bdc2:	b08c      	sub	sp, #48	; 0x30
 800bdc4:	af00      	add	r7, sp, #0


	 /*----------------------------- HSI Configuration --------------------------*/

	/* Enable the Internal High Speed oscillator (HSI). */
	RCC->CR |= RCC_CR_HSION;
 800bdc6:	4b27      	ldr	r3, [pc, #156]	; (800be64 <RCC_OscConfig+0xa4>)
 800bdc8:	4a26      	ldr	r2, [pc, #152]	; (800be64 <RCC_OscConfig+0xa4>)
 800bdca:	6812      	ldr	r2, [r2, #0]
 800bdcc:	2101      	movs	r1, #1
 800bdce:	430a      	orrs	r2, r1
 800bdd0:	601a      	str	r2, [r3, #0]

	/* Wait till HSI is ready */
	while (!(RCC->CR & 0x2)){};//while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET){};
 800bdd2:	46c0      	nop			; (mov r8, r8)
 800bdd4:	4b23      	ldr	r3, [pc, #140]	; (800be64 <RCC_OscConfig+0xa4>)
 800bdd6:	681b      	ldr	r3, [r3, #0]
 800bdd8:	2202      	movs	r2, #2
 800bdda:	4013      	ands	r3, r2
 800bddc:	d0fa      	beq.n	800bdd4 <RCC_OscConfig+0x14>

	/* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
	RCC_AdjustHSI14CalibrationValue(16);
 800bdde:	2010      	movs	r0, #16
 800bde0:	f7f6 ff0c 	bl	8002bfc <RCC_AdjustHSI14CalibrationValue>

	RCC->CFGR &= (uint32_t) (~RCC_CFGR_SW); //Select as HSI System clock
 800bde4:	4b1f      	ldr	r3, [pc, #124]	; (800be64 <RCC_OscConfig+0xa4>)
 800bde6:	4a1f      	ldr	r2, [pc, #124]	; (800be64 <RCC_OscConfig+0xa4>)
 800bde8:	6852      	ldr	r2, [r2, #4]
 800bdea:	2103      	movs	r1, #3
 800bdec:	438a      	bics	r2, r1
 800bdee:	605a      	str	r2, [r3, #4]
	while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI){}; //For for HSI to be set as system clock
 800bdf0:	46c0      	nop			; (mov r8, r8)
 800bdf2:	4b1c      	ldr	r3, [pc, #112]	; (800be64 <RCC_OscConfig+0xa4>)
 800bdf4:	685b      	ldr	r3, [r3, #4]
 800bdf6:	220c      	movs	r2, #12
 800bdf8:	4013      	ands	r3, r2
 800bdfa:	d1fa      	bne.n	800bdf2 <RCC_OscConfig+0x32>

	RCC_PLLCmd(DISABLE);
 800bdfc:	2000      	movs	r0, #0
 800bdfe:	f7f6 ff37 	bl	8002c70 <RCC_PLLCmd>
		while((RCC->CR & RCC_CR_PLLRDY) != 0){};
 800be02:	46c0      	nop			; (mov r8, r8)
 800be04:	4b17      	ldr	r3, [pc, #92]	; (800be64 <RCC_OscConfig+0xa4>)
 800be06:	681a      	ldr	r2, [r3, #0]
 800be08:	2380      	movs	r3, #128	; 0x80
 800be0a:	049b      	lsls	r3, r3, #18
 800be0c:	4013      	ands	r3, r2
 800be0e:	d1f9      	bne.n	800be04 <RCC_OscConfig+0x44>

		RCC_PLLConfig(RCC_PLLSource_HSI_Div2,RCC_PLLMul_12);
 800be10:	23a0      	movs	r3, #160	; 0xa0
 800be12:	039b      	lsls	r3, r3, #14
 800be14:	0019      	movs	r1, r3
 800be16:	2000      	movs	r0, #0
 800be18:	f7f6 ff0e 	bl	8002c38 <RCC_PLLConfig>

		RCC_PLLCmd(ENABLE);
 800be1c:	2001      	movs	r0, #1
 800be1e:	f7f6 ff27 	bl	8002c70 <RCC_PLLCmd>

		while((RCC->CR & RCC_CR_PLLRDY) == 0){};
 800be22:	46c0      	nop			; (mov r8, r8)
 800be24:	4b0f      	ldr	r3, [pc, #60]	; (800be64 <RCC_OscConfig+0xa4>)
 800be26:	681a      	ldr	r2, [r3, #0]
 800be28:	2380      	movs	r3, #128	; 0x80
 800be2a:	049b      	lsls	r3, r3, #18
 800be2c:	4013      	ands	r3, r2
 800be2e:	d0f9      	beq.n	800be24 <RCC_OscConfig+0x64>

		RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
 800be30:	2002      	movs	r0, #2
 800be32:	f7f6 ff3d 	bl	8002cb0 <RCC_SYSCLKConfig>

		while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL){};
 800be36:	46c0      	nop			; (mov r8, r8)
 800be38:	4b0a      	ldr	r3, [pc, #40]	; (800be64 <RCC_OscConfig+0xa4>)
 800be3a:	685b      	ldr	r3, [r3, #4]
 800be3c:	220c      	movs	r2, #12
 800be3e:	4013      	ands	r3, r2
 800be40:	2b08      	cmp	r3, #8
 800be42:	d1f9      	bne.n	800be38 <RCC_OscConfig+0x78>


	RCC->APB2ENR |= 0x1; //***
 800be44:	4b07      	ldr	r3, [pc, #28]	; (800be64 <RCC_OscConfig+0xa4>)
 800be46:	4a07      	ldr	r2, [pc, #28]	; (800be64 <RCC_OscConfig+0xa4>)
 800be48:	6992      	ldr	r2, [r2, #24]
 800be4a:	2101      	movs	r1, #1
 800be4c:	430a      	orrs	r2, r1
 800be4e:	619a      	str	r2, [r3, #24]

	RCC->CR &= 0xfffeffff;
 800be50:	4b04      	ldr	r3, [pc, #16]	; (800be64 <RCC_OscConfig+0xa4>)
 800be52:	4a04      	ldr	r2, [pc, #16]	; (800be64 <RCC_OscConfig+0xa4>)
 800be54:	6812      	ldr	r2, [r2, #0]
 800be56:	4904      	ldr	r1, [pc, #16]	; (800be68 <RCC_OscConfig+0xa8>)
 800be58:	400a      	ands	r2, r1
 800be5a:	601a      	str	r2, [r3, #0]
//	    }
//	  }



}
 800be5c:	46c0      	nop			; (mov r8, r8)
 800be5e:	46bd      	mov	sp, r7
 800be60:	b00c      	add	sp, #48	; 0x30
 800be62:	bd80      	pop	{r7, pc}
 800be64:	40021000 	.word	0x40021000
 800be68:	fffeffff 	.word	0xfffeffff

0800be6c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800be6c:	4813      	ldr	r0, [pc, #76]	; (800bebc <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800be6e:	4685      	mov	sp, r0

/*Check if boot space corresponds to test memory*/
 
    LDR R0,=0x00000004
 800be70:	2004      	movs	r0, #4
    LDR R1, [R0]
 800be72:	6801      	ldr	r1, [r0, #0]
    LSRS R1, R1, #24
 800be74:	0e09      	lsrs	r1, r1, #24
    LDR R2,=0x1F
 800be76:	221f      	movs	r2, #31
    CMP R1, R2
 800be78:	4291      	cmp	r1, r2
    BNE ApplicationStart
 800be7a:	d105      	bne.n	800be88 <ApplicationStart>

 /*SYSCFG clock enable*/

    LDR R0,=0x40021018
 800be7c:	4810      	ldr	r0, [pc, #64]	; (800bec0 <LoopForever+0x6>)
    LDR R1,=0x00000001
 800be7e:	2101      	movs	r1, #1
    STR R1, [R0]
 800be80:	6001      	str	r1, [r0, #0]

/*Set CFGR1 register with flash memory remap at address 0*/
    LDR R0,=0x40010000
 800be82:	4810      	ldr	r0, [pc, #64]	; (800bec4 <LoopForever+0xa>)
    LDR R1,=0x00000000
 800be84:	2100      	movs	r1, #0
    STR R1, [R0]
 800be86:	6001      	str	r1, [r0, #0]

0800be88 <ApplicationStart>:

ApplicationStart:
/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 800be88:	2100      	movs	r1, #0
  b LoopCopyDataInit
 800be8a:	e003      	b.n	800be94 <LoopCopyDataInit>

0800be8c <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 800be8c:	4b0e      	ldr	r3, [pc, #56]	; (800bec8 <LoopForever+0xe>)
  ldr r3, [r3, r1]
 800be8e:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 800be90:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 800be92:	3104      	adds	r1, #4

0800be94 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 800be94:	480d      	ldr	r0, [pc, #52]	; (800becc <LoopForever+0x12>)
  ldr r3, =_edata
 800be96:	4b0e      	ldr	r3, [pc, #56]	; (800bed0 <LoopForever+0x16>)
  adds r2, r0, r1
 800be98:	1842      	adds	r2, r0, r1
  cmp r2, r3
 800be9a:	429a      	cmp	r2, r3
  bcc CopyDataInit
 800be9c:	d3f6      	bcc.n	800be8c <CopyDataInit>
  ldr r2, =_sbss
 800be9e:	4a0d      	ldr	r2, [pc, #52]	; (800bed4 <LoopForever+0x1a>)
  b LoopFillZerobss
 800bea0:	e002      	b.n	800bea8 <LoopFillZerobss>

0800bea2 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 800bea2:	2300      	movs	r3, #0
  str  r3, [r2]
 800bea4:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800bea6:	3204      	adds	r2, #4

0800bea8 <LoopFillZerobss>:


LoopFillZerobss:
  ldr r3, = _ebss
 800bea8:	4b0b      	ldr	r3, [pc, #44]	; (800bed8 <LoopForever+0x1e>)
  cmp r2, r3
 800beaa:	429a      	cmp	r2, r3
  bcc FillZerobss
 800beac:	d3f9      	bcc.n	800bea2 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 800beae:	f000 f833 	bl	800bf18 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800beb2:	f000 f8e7 	bl	800c084 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800beb6:	f7ff fee5 	bl	800bc84 <main>

0800beba <LoopForever>:
  
LoopForever:
    b LoopForever
 800beba:	e7fe      	b.n	800beba <LoopForever>

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800bebc:	20002000 	.word	0x20002000
    CMP R1, R2
    BNE ApplicationStart

 /*SYSCFG clock enable*/

    LDR R0,=0x40021018
 800bec0:	40021018 	.word	0x40021018
    LDR R1,=0x00000001
    STR R1, [R0]

/*Set CFGR1 register with flash memory remap at address 0*/
    LDR R0,=0x40010000
 800bec4:	40010000 	.word	0x40010000
/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
  b LoopCopyDataInit

CopyDataInit:
  ldr r3, =_sidata
 800bec8:	0800df5c 	.word	0x0800df5c
  ldr r3, [r3, r1]
  str r3, [r0, r1]
  adds r1, r1, #4

LoopCopyDataInit:
  ldr r0, =_sdata
 800becc:	20000000 	.word	0x20000000
  ldr r3, =_edata
 800bed0:	2000007c 	.word	0x2000007c
  adds r2, r0, r1
  cmp r2, r3
  bcc CopyDataInit
  ldr r2, =_sbss
 800bed4:	2000007c 	.word	0x2000007c
  str  r3, [r2]
  adds r2, r2, #4


LoopFillZerobss:
  ldr r3, = _ebss
 800bed8:	20000b60 	.word	0x20000b60

0800bedc <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 800bedc:	e7fe      	b.n	800bedc <ADC1_COMP_IRQHandler>
	...

0800bee0 <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 800bee0:	b580      	push	{r7, lr}
 800bee2:	af00      	add	r7, sp, #0
}
 800bee4:	46c0      	nop			; (mov r8, r8)
 800bee6:	46bd      	mov	sp, r7
 800bee8:	bd80      	pop	{r7, pc}
 800beea:	46c0      	nop			; (mov r8, r8)

0800beec <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 800beec:	b580      	push	{r7, lr}
 800beee:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
  {
  }
 800bef0:	e7fe      	b.n	800bef0 <HardFault_Handler+0x4>
 800bef2:	46c0      	nop			; (mov r8, r8)

0800bef4 <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 800bef4:	b580      	push	{r7, lr}
 800bef6:	af00      	add	r7, sp, #0
}
 800bef8:	46c0      	nop			; (mov r8, r8)
 800befa:	46bd      	mov	sp, r7
 800befc:	bd80      	pop	{r7, pc}
 800befe:	46c0      	nop			; (mov r8, r8)

0800bf00 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 800bf00:	b580      	push	{r7, lr}
 800bf02:	af00      	add	r7, sp, #0
}
 800bf04:	46c0      	nop			; (mov r8, r8)
 800bf06:	46bd      	mov	sp, r7
 800bf08:	bd80      	pop	{r7, pc}
 800bf0a:	46c0      	nop			; (mov r8, r8)

0800bf0c <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 800bf0c:	b580      	push	{r7, lr}
 800bf0e:	af00      	add	r7, sp, #0
}
 800bf10:	46c0      	nop			; (mov r8, r8)
 800bf12:	46bd      	mov	sp, r7
 800bf14:	bd80      	pop	{r7, pc}
 800bf16:	46c0      	nop			; (mov r8, r8)

0800bf18 <SystemInit>:
  *         SystemCoreClock variable.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{    
 800bf18:	b580      	push	{r7, lr}
 800bf1a:	af00      	add	r7, sp, #0
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800bf1c:	4b1b      	ldr	r3, [pc, #108]	; (800bf8c <SystemInit+0x74>)
 800bf1e:	4a1b      	ldr	r2, [pc, #108]	; (800bf8c <SystemInit+0x74>)
 800bf20:	6812      	ldr	r2, [r2, #0]
 800bf22:	2101      	movs	r1, #1
 800bf24:	430a      	orrs	r2, r1
 800bf26:	601a      	str	r2, [r3, #0]

#if defined(STM32F051)  
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE and MCOSEL[2:0] bits */
  RCC->CFGR &= (uint32_t)0xF8FFB80C;
 800bf28:	4b18      	ldr	r3, [pc, #96]	; (800bf8c <SystemInit+0x74>)
 800bf2a:	4a18      	ldr	r2, [pc, #96]	; (800bf8c <SystemInit+0x74>)
 800bf2c:	6852      	ldr	r2, [r2, #4]
 800bf2e:	4918      	ldr	r1, [pc, #96]	; (800bf90 <SystemInit+0x78>)
 800bf30:	400a      	ands	r2, r1
 800bf32:	605a      	str	r2, [r3, #4]
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */
  RCC->CFGR &= (uint32_t)0x08FFB80C;
#endif /* STM32F051 */
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800bf34:	4b15      	ldr	r3, [pc, #84]	; (800bf8c <SystemInit+0x74>)
 800bf36:	4a15      	ldr	r2, [pc, #84]	; (800bf8c <SystemInit+0x74>)
 800bf38:	6812      	ldr	r2, [r2, #0]
 800bf3a:	4916      	ldr	r1, [pc, #88]	; (800bf94 <SystemInit+0x7c>)
 800bf3c:	400a      	ands	r2, r1
 800bf3e:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800bf40:	4b12      	ldr	r3, [pc, #72]	; (800bf8c <SystemInit+0x74>)
 800bf42:	4a12      	ldr	r2, [pc, #72]	; (800bf8c <SystemInit+0x74>)
 800bf44:	6812      	ldr	r2, [r2, #0]
 800bf46:	4914      	ldr	r1, [pc, #80]	; (800bf98 <SystemInit+0x80>)
 800bf48:	400a      	ands	r2, r1
 800bf4a:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  RCC->CFGR &= (uint32_t)0xFFC0FFFF;
 800bf4c:	4b0f      	ldr	r3, [pc, #60]	; (800bf8c <SystemInit+0x74>)
 800bf4e:	4a0f      	ldr	r2, [pc, #60]	; (800bf8c <SystemInit+0x74>)
 800bf50:	6852      	ldr	r2, [r2, #4]
 800bf52:	4912      	ldr	r1, [pc, #72]	; (800bf9c <SystemInit+0x84>)
 800bf54:	400a      	ands	r2, r1
 800bf56:	605a      	str	r2, [r3, #4]

  /* Reset PREDIV1[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
 800bf58:	4b0c      	ldr	r3, [pc, #48]	; (800bf8c <SystemInit+0x74>)
 800bf5a:	4a0c      	ldr	r2, [pc, #48]	; (800bf8c <SystemInit+0x74>)
 800bf5c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800bf5e:	210f      	movs	r1, #15
 800bf60:	438a      	bics	r2, r1
 800bf62:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset USARTSW[1:0], I2CSW, CECSW and ADCSW bits */
  RCC->CFGR3 &= (uint32_t)0xFFFFFEAC;
 800bf64:	4b09      	ldr	r3, [pc, #36]	; (800bf8c <SystemInit+0x74>)
 800bf66:	4a09      	ldr	r2, [pc, #36]	; (800bf8c <SystemInit+0x74>)
 800bf68:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800bf6a:	490d      	ldr	r1, [pc, #52]	; (800bfa0 <SystemInit+0x88>)
 800bf6c:	400a      	ands	r2, r1
 800bf6e:	631a      	str	r2, [r3, #48]	; 0x30

  /* Reset HSI14 bit */
  RCC->CR2 &= (uint32_t)0xFFFFFFFE;
 800bf70:	4b06      	ldr	r3, [pc, #24]	; (800bf8c <SystemInit+0x74>)
 800bf72:	4a06      	ldr	r2, [pc, #24]	; (800bf8c <SystemInit+0x74>)
 800bf74:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800bf76:	2101      	movs	r1, #1
 800bf78:	438a      	bics	r2, r1
 800bf7a:	635a      	str	r2, [r3, #52]	; 0x34

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800bf7c:	4b03      	ldr	r3, [pc, #12]	; (800bf8c <SystemInit+0x74>)
 800bf7e:	2200      	movs	r2, #0
 800bf80:	609a      	str	r2, [r3, #8]

  /* Configure the System clock frequency, AHB/APBx prescalers and Flash settings */
  SetSysClock();
 800bf82:	f000 f80f 	bl	800bfa4 <SetSysClock>
}
 800bf86:	46c0      	nop			; (mov r8, r8)
 800bf88:	46bd      	mov	sp, r7
 800bf8a:	bd80      	pop	{r7, pc}
 800bf8c:	40021000 	.word	0x40021000
 800bf90:	f8ffb80c 	.word	0xf8ffb80c
 800bf94:	fef6ffff 	.word	0xfef6ffff
 800bf98:	fffbffff 	.word	0xfffbffff
 800bf9c:	ffc0ffff 	.word	0xffc0ffff
 800bfa0:	fffffeac 	.word	0xfffffeac

0800bfa4 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 800bfa4:	b580      	push	{r7, lr}
 800bfa6:	b082      	sub	sp, #8
 800bfa8:	af00      	add	r7, sp, #0
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 800bfaa:	2300      	movs	r3, #0
 800bfac:	607b      	str	r3, [r7, #4]
 800bfae:	2300      	movs	r3, #0
 800bfb0:	603b      	str	r3, [r7, #0]
  
  /* SYSCLK, HCLK, PCLK configuration ----------------------------------------*/
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 800bfb2:	4b31      	ldr	r3, [pc, #196]	; (800c078 <SetSysClock+0xd4>)
 800bfb4:	4a30      	ldr	r2, [pc, #192]	; (800c078 <SetSysClock+0xd4>)
 800bfb6:	6812      	ldr	r2, [r2, #0]
 800bfb8:	2180      	movs	r1, #128	; 0x80
 800bfba:	0249      	lsls	r1, r1, #9
 800bfbc:	430a      	orrs	r2, r1
 800bfbe:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 800bfc0:	4b2d      	ldr	r3, [pc, #180]	; (800c078 <SetSysClock+0xd4>)
 800bfc2:	681a      	ldr	r2, [r3, #0]
 800bfc4:	2380      	movs	r3, #128	; 0x80
 800bfc6:	029b      	lsls	r3, r3, #10
 800bfc8:	4013      	ands	r3, r2
 800bfca:	603b      	str	r3, [r7, #0]
    StartUpCounter++;  
 800bfcc:	687b      	ldr	r3, [r7, #4]
 800bfce:	3301      	adds	r3, #1
 800bfd0:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 800bfd2:	683b      	ldr	r3, [r7, #0]
 800bfd4:	2b00      	cmp	r3, #0
 800bfd6:	d104      	bne.n	800bfe2 <SetSysClock+0x3e>
 800bfd8:	687a      	ldr	r2, [r7, #4]
 800bfda:	23a0      	movs	r3, #160	; 0xa0
 800bfdc:	01db      	lsls	r3, r3, #7
 800bfde:	429a      	cmp	r2, r3
 800bfe0:	d1ee      	bne.n	800bfc0 <SetSysClock+0x1c>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 800bfe2:	4b25      	ldr	r3, [pc, #148]	; (800c078 <SetSysClock+0xd4>)
 800bfe4:	681a      	ldr	r2, [r3, #0]
 800bfe6:	2380      	movs	r3, #128	; 0x80
 800bfe8:	029b      	lsls	r3, r3, #10
 800bfea:	4013      	ands	r3, r2
 800bfec:	d002      	beq.n	800bff4 <SetSysClock+0x50>
  {
    HSEStatus = (uint32_t)0x01;
 800bfee:	2301      	movs	r3, #1
 800bff0:	603b      	str	r3, [r7, #0]
 800bff2:	e001      	b.n	800bff8 <SetSysClock+0x54>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 800bff4:	2300      	movs	r3, #0
 800bff6:	603b      	str	r3, [r7, #0]
  }  

  if (HSEStatus == (uint32_t)0x01)
 800bff8:	683b      	ldr	r3, [r7, #0]
 800bffa:	2b01      	cmp	r3, #1
 800bffc:	d138      	bne.n	800c070 <SetSysClock+0xcc>
  {
    /* Enable Prefetch Buffer and set Flash Latency */
    FLASH->ACR = FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY;
 800bffe:	4b1f      	ldr	r3, [pc, #124]	; (800c07c <SetSysClock+0xd8>)
 800c000:	2211      	movs	r2, #17
 800c002:	601a      	str	r2, [r3, #0]
 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 800c004:	4b1c      	ldr	r3, [pc, #112]	; (800c078 <SetSysClock+0xd4>)
 800c006:	4a1c      	ldr	r2, [pc, #112]	; (800c078 <SetSysClock+0xd4>)
 800c008:	6852      	ldr	r2, [r2, #4]
 800c00a:	605a      	str	r2, [r3, #4]
      
    /* PCLK = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE_DIV1;
 800c00c:	4b1a      	ldr	r3, [pc, #104]	; (800c078 <SetSysClock+0xd4>)
 800c00e:	4a1a      	ldr	r2, [pc, #104]	; (800c078 <SetSysClock+0xd4>)
 800c010:	6852      	ldr	r2, [r2, #4]
 800c012:	605a      	str	r2, [r3, #4]

    /* PLL configuration = HSE * 6 = 48 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
 800c014:	4b18      	ldr	r3, [pc, #96]	; (800c078 <SetSysClock+0xd4>)
 800c016:	4a18      	ldr	r2, [pc, #96]	; (800c078 <SetSysClock+0xd4>)
 800c018:	6852      	ldr	r2, [r2, #4]
 800c01a:	4919      	ldr	r1, [pc, #100]	; (800c080 <SetSysClock+0xdc>)
 800c01c:	400a      	ands	r2, r1
 800c01e:	605a      	str	r2, [r3, #4]
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLMULL6);
 800c020:	4b15      	ldr	r3, [pc, #84]	; (800c078 <SetSysClock+0xd4>)
 800c022:	4a15      	ldr	r2, [pc, #84]	; (800c078 <SetSysClock+0xd4>)
 800c024:	6852      	ldr	r2, [r2, #4]
 800c026:	2188      	movs	r1, #136	; 0x88
 800c028:	0349      	lsls	r1, r1, #13
 800c02a:	430a      	orrs	r2, r1
 800c02c:	605a      	str	r2, [r3, #4]
            
    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 800c02e:	4b12      	ldr	r3, [pc, #72]	; (800c078 <SetSysClock+0xd4>)
 800c030:	4a11      	ldr	r2, [pc, #68]	; (800c078 <SetSysClock+0xd4>)
 800c032:	6812      	ldr	r2, [r2, #0]
 800c034:	2180      	movs	r1, #128	; 0x80
 800c036:	0449      	lsls	r1, r1, #17
 800c038:	430a      	orrs	r2, r1
 800c03a:	601a      	str	r2, [r3, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 800c03c:	46c0      	nop			; (mov r8, r8)
 800c03e:	4b0e      	ldr	r3, [pc, #56]	; (800c078 <SetSysClock+0xd4>)
 800c040:	681a      	ldr	r2, [r3, #0]
 800c042:	2380      	movs	r3, #128	; 0x80
 800c044:	049b      	lsls	r3, r3, #18
 800c046:	4013      	ands	r3, r2
 800c048:	d0f9      	beq.n	800c03e <SetSysClock+0x9a>
    {
    }

    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 800c04a:	4b0b      	ldr	r3, [pc, #44]	; (800c078 <SetSysClock+0xd4>)
 800c04c:	4a0a      	ldr	r2, [pc, #40]	; (800c078 <SetSysClock+0xd4>)
 800c04e:	6852      	ldr	r2, [r2, #4]
 800c050:	2103      	movs	r1, #3
 800c052:	438a      	bics	r2, r1
 800c054:	605a      	str	r2, [r3, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
 800c056:	4b08      	ldr	r3, [pc, #32]	; (800c078 <SetSysClock+0xd4>)
 800c058:	4a07      	ldr	r2, [pc, #28]	; (800c078 <SetSysClock+0xd4>)
 800c05a:	6852      	ldr	r2, [r2, #4]
 800c05c:	2102      	movs	r1, #2
 800c05e:	430a      	orrs	r2, r1
 800c060:	605a      	str	r2, [r3, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)RCC_CFGR_SWS_PLL)
 800c062:	46c0      	nop			; (mov r8, r8)
 800c064:	4b04      	ldr	r3, [pc, #16]	; (800c078 <SetSysClock+0xd4>)
 800c066:	685b      	ldr	r3, [r3, #4]
 800c068:	220c      	movs	r2, #12
 800c06a:	4013      	ands	r3, r2
 800c06c:	2b08      	cmp	r3, #8
 800c06e:	d1f9      	bne.n	800c064 <SetSysClock+0xc0>
  }
  else
  { /* If HSE fails to start-up, the application will have wrong clock 
         configuration. User can add here some code to deal with this error */
  }  
}
 800c070:	46c0      	nop			; (mov r8, r8)
 800c072:	46bd      	mov	sp, r7
 800c074:	b002      	add	sp, #8
 800c076:	bd80      	pop	{r7, pc}
 800c078:	40021000 	.word	0x40021000
 800c07c:	40022000 	.word	0x40022000
 800c080:	ffc07fff 	.word	0xffc07fff

0800c084 <__libc_init_array>:
 800c084:	4b0e      	ldr	r3, [pc, #56]	; (800c0c0 <__libc_init_array+0x3c>)
 800c086:	b570      	push	{r4, r5, r6, lr}
 800c088:	2500      	movs	r5, #0
 800c08a:	001e      	movs	r6, r3
 800c08c:	4c0d      	ldr	r4, [pc, #52]	; (800c0c4 <__libc_init_array+0x40>)
 800c08e:	1ae4      	subs	r4, r4, r3
 800c090:	10a4      	asrs	r4, r4, #2
 800c092:	42a5      	cmp	r5, r4
 800c094:	d004      	beq.n	800c0a0 <__libc_init_array+0x1c>
 800c096:	00ab      	lsls	r3, r5, #2
 800c098:	58f3      	ldr	r3, [r6, r3]
 800c09a:	4798      	blx	r3
 800c09c:	3501      	adds	r5, #1
 800c09e:	e7f8      	b.n	800c092 <__libc_init_array+0xe>
 800c0a0:	f001 f998 	bl	800d3d4 <_init>
 800c0a4:	4b08      	ldr	r3, [pc, #32]	; (800c0c8 <__libc_init_array+0x44>)
 800c0a6:	2500      	movs	r5, #0
 800c0a8:	001e      	movs	r6, r3
 800c0aa:	4c08      	ldr	r4, [pc, #32]	; (800c0cc <__libc_init_array+0x48>)
 800c0ac:	1ae4      	subs	r4, r4, r3
 800c0ae:	10a4      	asrs	r4, r4, #2
 800c0b0:	42a5      	cmp	r5, r4
 800c0b2:	d004      	beq.n	800c0be <__libc_init_array+0x3a>
 800c0b4:	00ab      	lsls	r3, r5, #2
 800c0b6:	58f3      	ldr	r3, [r6, r3]
 800c0b8:	4798      	blx	r3
 800c0ba:	3501      	adds	r5, #1
 800c0bc:	e7f8      	b.n	800c0b0 <__libc_init_array+0x2c>
 800c0be:	bd70      	pop	{r4, r5, r6, pc}
 800c0c0:	0800df54 	.word	0x0800df54
 800c0c4:	0800df54 	.word	0x0800df54
 800c0c8:	0800df54 	.word	0x0800df54
 800c0cc:	0800df58 	.word	0x0800df58

0800c0d0 <memcmp>:
 800c0d0:	b530      	push	{r4, r5, lr}
 800c0d2:	2400      	movs	r4, #0
 800c0d4:	42a2      	cmp	r2, r4
 800c0d6:	d008      	beq.n	800c0ea <memcmp+0x1a>
 800c0d8:	5d03      	ldrb	r3, [r0, r4]
 800c0da:	1c65      	adds	r5, r4, #1
 800c0dc:	5d0c      	ldrb	r4, [r1, r4]
 800c0de:	42a3      	cmp	r3, r4
 800c0e0:	d001      	beq.n	800c0e6 <memcmp+0x16>
 800c0e2:	1b18      	subs	r0, r3, r4
 800c0e4:	e002      	b.n	800c0ec <memcmp+0x1c>
 800c0e6:	002c      	movs	r4, r5
 800c0e8:	e7f4      	b.n	800c0d4 <memcmp+0x4>
 800c0ea:	2000      	movs	r0, #0
 800c0ec:	bd30      	pop	{r4, r5, pc}

0800c0ee <memcpy>:
 800c0ee:	2300      	movs	r3, #0
 800c0f0:	b510      	push	{r4, lr}
 800c0f2:	429a      	cmp	r2, r3
 800c0f4:	d003      	beq.n	800c0fe <memcpy+0x10>
 800c0f6:	5ccc      	ldrb	r4, [r1, r3]
 800c0f8:	54c4      	strb	r4, [r0, r3]
 800c0fa:	3301      	adds	r3, #1
 800c0fc:	e7f9      	b.n	800c0f2 <memcpy+0x4>
 800c0fe:	bd10      	pop	{r4, pc}

0800c100 <memset>:
 800c100:	0003      	movs	r3, r0
 800c102:	1882      	adds	r2, r0, r2
 800c104:	4293      	cmp	r3, r2
 800c106:	d002      	beq.n	800c10e <memset+0xe>
 800c108:	7019      	strb	r1, [r3, #0]
 800c10a:	3301      	adds	r3, #1
 800c10c:	e7fa      	b.n	800c104 <memset+0x4>
 800c10e:	4770      	bx	lr

0800c110 <lround>:
 800c110:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c112:	2301      	movs	r3, #1
 800c114:	2780      	movs	r7, #128	; 0x80
 800c116:	17cd      	asrs	r5, r1, #31
 800c118:	431d      	orrs	r5, r3
 800c11a:	004c      	lsls	r4, r1, #1
 800c11c:	4b1c      	ldr	r3, [pc, #112]	; (800c190 <lround+0x80>)
 800c11e:	0d64      	lsrs	r4, r4, #21
 800c120:	18e2      	adds	r2, r4, r3
 800c122:	030b      	lsls	r3, r1, #12
 800c124:	0b1b      	lsrs	r3, r3, #12
 800c126:	037f      	lsls	r7, r7, #13
 800c128:	433b      	orrs	r3, r7
 800c12a:	2a13      	cmp	r2, #19
 800c12c:	dc0e      	bgt.n	800c14c <lround+0x3c>
 800c12e:	2a00      	cmp	r2, #0
 800c130:	da04      	bge.n	800c13c <lround+0x2c>
 800c132:	2000      	movs	r0, #0
 800c134:	1c53      	adds	r3, r2, #1
 800c136:	d12a      	bne.n	800c18e <lround+0x7e>
 800c138:	0028      	movs	r0, r5
 800c13a:	e028      	b.n	800c18e <lround+0x7e>
 800c13c:	2080      	movs	r0, #128	; 0x80
 800c13e:	0300      	lsls	r0, r0, #12
 800c140:	4110      	asrs	r0, r2
 800c142:	18c0      	adds	r0, r0, r3
 800c144:	2314      	movs	r3, #20
 800c146:	1a9a      	subs	r2, r3, r2
 800c148:	40d0      	lsrs	r0, r2
 800c14a:	e01f      	b.n	800c18c <lround+0x7c>
 800c14c:	2a1e      	cmp	r2, #30
 800c14e:	d81a      	bhi.n	800c186 <lround+0x76>
 800c150:	4910      	ldr	r1, [pc, #64]	; (800c194 <lround+0x84>)
 800c152:	1867      	adds	r7, r4, r1
 800c154:	2a33      	cmp	r2, #51	; 0x33
 800c156:	dd04      	ble.n	800c162 <lround+0x52>
 800c158:	4a0f      	ldr	r2, [pc, #60]	; (800c198 <lround+0x88>)
 800c15a:	40bb      	lsls	r3, r7
 800c15c:	18a4      	adds	r4, r4, r2
 800c15e:	40a0      	lsls	r0, r4
 800c160:	e00f      	b.n	800c182 <lround+0x72>
 800c162:	2480      	movs	r4, #128	; 0x80
 800c164:	0624      	lsls	r4, r4, #24
 800c166:	40fc      	lsrs	r4, r7
 800c168:	1824      	adds	r4, r4, r0
 800c16a:	4284      	cmp	r4, r0
 800c16c:	4189      	sbcs	r1, r1
 800c16e:	4249      	negs	r1, r1
 800c170:	185b      	adds	r3, r3, r1
 800c172:	2134      	movs	r1, #52	; 0x34
 800c174:	40bb      	lsls	r3, r7
 800c176:	1a8a      	subs	r2, r1, r2
 800c178:	2000      	movs	r0, #0
 800c17a:	2a20      	cmp	r2, #32
 800c17c:	d001      	beq.n	800c182 <lround+0x72>
 800c17e:	0020      	movs	r0, r4
 800c180:	40d0      	lsrs	r0, r2
 800c182:	4318      	orrs	r0, r3
 800c184:	e002      	b.n	800c18c <lround+0x7c>
 800c186:	f7f6 fa41 	bl	800260c <__aeabi_d2iz>
 800c18a:	e000      	b.n	800c18e <lround+0x7e>
 800c18c:	4368      	muls	r0, r5
 800c18e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c190:	fffffc01 	.word	0xfffffc01
 800c194:	fffffbed 	.word	0xfffffbed
 800c198:	fffffbcd 	.word	0xfffffbcd

0800c19c <trunc>:
 800c19c:	004b      	lsls	r3, r1, #1
 800c19e:	4a14      	ldr	r2, [pc, #80]	; (800c1f0 <trunc+0x54>)
 800c1a0:	0d5b      	lsrs	r3, r3, #21
 800c1a2:	189a      	adds	r2, r3, r2
 800c1a4:	b570      	push	{r4, r5, r6, lr}
 800c1a6:	2a13      	cmp	r2, #19
 800c1a8:	dc0f      	bgt.n	800c1ca <trunc+0x2e>
 800c1aa:	0fc8      	lsrs	r0, r1, #31
 800c1ac:	07c0      	lsls	r0, r0, #31
 800c1ae:	2a00      	cmp	r2, #0
 800c1b0:	da04      	bge.n	800c1bc <trunc+0x20>
 800c1b2:	0003      	movs	r3, r0
 800c1b4:	2200      	movs	r2, #0
 800c1b6:	0019      	movs	r1, r3
 800c1b8:	0010      	movs	r0, r2
 800c1ba:	e017      	b.n	800c1ec <trunc+0x50>
 800c1bc:	4b0d      	ldr	r3, [pc, #52]	; (800c1f4 <trunc+0x58>)
 800c1be:	4113      	asrs	r3, r2
 800c1c0:	2200      	movs	r2, #0
 800c1c2:	4399      	bics	r1, r3
 800c1c4:	4301      	orrs	r1, r0
 800c1c6:	0010      	movs	r0, r2
 800c1c8:	e010      	b.n	800c1ec <trunc+0x50>
 800c1ca:	2a33      	cmp	r2, #51	; 0x33
 800c1cc:	dd08      	ble.n	800c1e0 <trunc+0x44>
 800c1ce:	2380      	movs	r3, #128	; 0x80
 800c1d0:	00db      	lsls	r3, r3, #3
 800c1d2:	429a      	cmp	r2, r3
 800c1d4:	d10a      	bne.n	800c1ec <trunc+0x50>
 800c1d6:	0002      	movs	r2, r0
 800c1d8:	000b      	movs	r3, r1
 800c1da:	f7f4 ff73 	bl	80010c4 <__aeabi_dadd>
 800c1de:	e005      	b.n	800c1ec <trunc+0x50>
 800c1e0:	4a05      	ldr	r2, [pc, #20]	; (800c1f8 <trunc+0x5c>)
 800c1e2:	189b      	adds	r3, r3, r2
 800c1e4:	2201      	movs	r2, #1
 800c1e6:	4252      	negs	r2, r2
 800c1e8:	40da      	lsrs	r2, r3
 800c1ea:	4390      	bics	r0, r2
 800c1ec:	bd70      	pop	{r4, r5, r6, pc}
 800c1ee:	46c0      	nop			; (mov r8, r8)
 800c1f0:	fffffc01 	.word	0xfffffc01
 800c1f4:	000fffff 	.word	0x000fffff
 800c1f8:	fffffbed 	.word	0xfffffbed

0800c1fc <ceilf>:
 800c1fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c1fe:	0045      	lsls	r5, r0, #1
 800c200:	086f      	lsrs	r7, r5, #1
 800c202:	0e2d      	lsrs	r5, r5, #24
 800c204:	3d7f      	subs	r5, #127	; 0x7f
 800c206:	1c06      	adds	r6, r0, #0
 800c208:	0004      	movs	r4, r0
 800c20a:	2d16      	cmp	r5, #22
 800c20c:	dc24      	bgt.n	800c258 <ceilf+0x5c>
 800c20e:	2d00      	cmp	r5, #0
 800c210:	da0e      	bge.n	800c230 <ceilf+0x34>
 800c212:	4917      	ldr	r1, [pc, #92]	; (800c270 <ceilf+0x74>)
 800c214:	f7f4 f8bc 	bl	8000390 <__aeabi_fadd>
 800c218:	2100      	movs	r1, #0
 800c21a:	f7f4 f86f 	bl	80002fc <__aeabi_fcmpgt>
 800c21e:	2800      	cmp	r0, #0
 800c220:	d023      	beq.n	800c26a <ceilf+0x6e>
 800c222:	2e00      	cmp	r6, #0
 800c224:	db1f      	blt.n	800c266 <ceilf+0x6a>
 800c226:	2f00      	cmp	r7, #0
 800c228:	d01f      	beq.n	800c26a <ceilf+0x6e>
 800c22a:	24fe      	movs	r4, #254	; 0xfe
 800c22c:	05a4      	lsls	r4, r4, #22
 800c22e:	e01c      	b.n	800c26a <ceilf+0x6e>
 800c230:	4f10      	ldr	r7, [pc, #64]	; (800c274 <ceilf+0x78>)
 800c232:	412f      	asrs	r7, r5
 800c234:	4207      	tst	r7, r0
 800c236:	d019      	beq.n	800c26c <ceilf+0x70>
 800c238:	490d      	ldr	r1, [pc, #52]	; (800c270 <ceilf+0x74>)
 800c23a:	f7f4 f8a9 	bl	8000390 <__aeabi_fadd>
 800c23e:	2100      	movs	r1, #0
 800c240:	f7f4 f85c 	bl	80002fc <__aeabi_fcmpgt>
 800c244:	2800      	cmp	r0, #0
 800c246:	d010      	beq.n	800c26a <ceilf+0x6e>
 800c248:	2e00      	cmp	r6, #0
 800c24a:	dd03      	ble.n	800c254 <ceilf+0x58>
 800c24c:	2480      	movs	r4, #128	; 0x80
 800c24e:	0424      	lsls	r4, r4, #16
 800c250:	412c      	asrs	r4, r5
 800c252:	19a4      	adds	r4, r4, r6
 800c254:	43bc      	bics	r4, r7
 800c256:	e008      	b.n	800c26a <ceilf+0x6e>
 800c258:	4b07      	ldr	r3, [pc, #28]	; (800c278 <ceilf+0x7c>)
 800c25a:	429f      	cmp	r7, r3
 800c25c:	d906      	bls.n	800c26c <ceilf+0x70>
 800c25e:	1c01      	adds	r1, r0, #0
 800c260:	f7f4 f896 	bl	8000390 <__aeabi_fadd>
 800c264:	e002      	b.n	800c26c <ceilf+0x70>
 800c266:	2480      	movs	r4, #128	; 0x80
 800c268:	0624      	lsls	r4, r4, #24
 800c26a:	1c20      	adds	r0, r4, #0
 800c26c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c26e:	46c0      	nop			; (mov r8, r8)
 800c270:	7149f2ca 	.word	0x7149f2ca
 800c274:	007fffff 	.word	0x007fffff
 800c278:	7f7fffff 	.word	0x7f7fffff

0800c27c <cosf>:
 800c27c:	b507      	push	{r0, r1, r2, lr}
 800c27e:	4a18      	ldr	r2, [pc, #96]	; (800c2e0 <cosf+0x64>)
 800c280:	0043      	lsls	r3, r0, #1
 800c282:	085b      	lsrs	r3, r3, #1
 800c284:	2100      	movs	r1, #0
 800c286:	4293      	cmp	r3, r2
 800c288:	dd14      	ble.n	800c2b4 <cosf+0x38>
 800c28a:	4a16      	ldr	r2, [pc, #88]	; (800c2e4 <cosf+0x68>)
 800c28c:	4293      	cmp	r3, r2
 800c28e:	dd03      	ble.n	800c298 <cosf+0x1c>
 800c290:	1c01      	adds	r1, r0, #0
 800c292:	f7f4 fcd1 	bl	8000c38 <__aeabi_fsub>
 800c296:	e022      	b.n	800c2de <cosf+0x62>
 800c298:	4669      	mov	r1, sp
 800c29a:	f000 f9a9 	bl	800c5f0 <__ieee754_rem_pio2f>
 800c29e:	2303      	movs	r3, #3
 800c2a0:	0002      	movs	r2, r0
 800c2a2:	401a      	ands	r2, r3
 800c2a4:	2a01      	cmp	r2, #1
 800c2a6:	d008      	beq.n	800c2ba <cosf+0x3e>
 800c2a8:	2a02      	cmp	r2, #2
 800c2aa:	d00b      	beq.n	800c2c4 <cosf+0x48>
 800c2ac:	2a00      	cmp	r2, #0
 800c2ae:	d111      	bne.n	800c2d4 <cosf+0x58>
 800c2b0:	9901      	ldr	r1, [sp, #4]
 800c2b2:	9800      	ldr	r0, [sp, #0]
 800c2b4:	f000 fb4a 	bl	800c94c <__kernel_cosf>
 800c2b8:	e011      	b.n	800c2de <cosf+0x62>
 800c2ba:	9901      	ldr	r1, [sp, #4]
 800c2bc:	9800      	ldr	r0, [sp, #0]
 800c2be:	f000 fe93 	bl	800cfe8 <__kernel_sinf>
 800c2c2:	e003      	b.n	800c2cc <cosf+0x50>
 800c2c4:	9901      	ldr	r1, [sp, #4]
 800c2c6:	9800      	ldr	r0, [sp, #0]
 800c2c8:	f000 fb40 	bl	800c94c <__kernel_cosf>
 800c2cc:	2380      	movs	r3, #128	; 0x80
 800c2ce:	061b      	lsls	r3, r3, #24
 800c2d0:	18c0      	adds	r0, r0, r3
 800c2d2:	e004      	b.n	800c2de <cosf+0x62>
 800c2d4:	2201      	movs	r2, #1
 800c2d6:	9901      	ldr	r1, [sp, #4]
 800c2d8:	9800      	ldr	r0, [sp, #0]
 800c2da:	f000 fe85 	bl	800cfe8 <__kernel_sinf>
 800c2de:	bd0e      	pop	{r1, r2, r3, pc}
 800c2e0:	3f490fd8 	.word	0x3f490fd8
 800c2e4:	7f7fffff 	.word	0x7f7fffff

0800c2e8 <floorf>:
 800c2e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c2ea:	0045      	lsls	r5, r0, #1
 800c2ec:	086f      	lsrs	r7, r5, #1
 800c2ee:	0e2d      	lsrs	r5, r5, #24
 800c2f0:	3d7f      	subs	r5, #127	; 0x7f
 800c2f2:	1c06      	adds	r6, r0, #0
 800c2f4:	0004      	movs	r4, r0
 800c2f6:	2d16      	cmp	r5, #22
 800c2f8:	dc23      	bgt.n	800c342 <floorf+0x5a>
 800c2fa:	2d00      	cmp	r5, #0
 800c2fc:	da0d      	bge.n	800c31a <floorf+0x32>
 800c2fe:	4916      	ldr	r1, [pc, #88]	; (800c358 <floorf+0x70>)
 800c300:	f7f4 f846 	bl	8000390 <__aeabi_fadd>
 800c304:	2100      	movs	r1, #0
 800c306:	f7f3 fff9 	bl	80002fc <__aeabi_fcmpgt>
 800c30a:	2800      	cmp	r0, #0
 800c30c:	d021      	beq.n	800c352 <floorf+0x6a>
 800c30e:	2e00      	cmp	r6, #0
 800c310:	da1e      	bge.n	800c350 <floorf+0x68>
 800c312:	2f00      	cmp	r7, #0
 800c314:	d01d      	beq.n	800c352 <floorf+0x6a>
 800c316:	4c11      	ldr	r4, [pc, #68]	; (800c35c <floorf+0x74>)
 800c318:	e01b      	b.n	800c352 <floorf+0x6a>
 800c31a:	4f11      	ldr	r7, [pc, #68]	; (800c360 <floorf+0x78>)
 800c31c:	412f      	asrs	r7, r5
 800c31e:	4207      	tst	r7, r0
 800c320:	d018      	beq.n	800c354 <floorf+0x6c>
 800c322:	490d      	ldr	r1, [pc, #52]	; (800c358 <floorf+0x70>)
 800c324:	f7f4 f834 	bl	8000390 <__aeabi_fadd>
 800c328:	2100      	movs	r1, #0
 800c32a:	f7f3 ffe7 	bl	80002fc <__aeabi_fcmpgt>
 800c32e:	2800      	cmp	r0, #0
 800c330:	d00f      	beq.n	800c352 <floorf+0x6a>
 800c332:	2e00      	cmp	r6, #0
 800c334:	da03      	bge.n	800c33e <floorf+0x56>
 800c336:	2480      	movs	r4, #128	; 0x80
 800c338:	0424      	lsls	r4, r4, #16
 800c33a:	412c      	asrs	r4, r5
 800c33c:	19a4      	adds	r4, r4, r6
 800c33e:	43bc      	bics	r4, r7
 800c340:	e007      	b.n	800c352 <floorf+0x6a>
 800c342:	4b08      	ldr	r3, [pc, #32]	; (800c364 <floorf+0x7c>)
 800c344:	429f      	cmp	r7, r3
 800c346:	d905      	bls.n	800c354 <floorf+0x6c>
 800c348:	1c01      	adds	r1, r0, #0
 800c34a:	f7f4 f821 	bl	8000390 <__aeabi_fadd>
 800c34e:	e001      	b.n	800c354 <floorf+0x6c>
 800c350:	2400      	movs	r4, #0
 800c352:	1c20      	adds	r0, r4, #0
 800c354:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c356:	46c0      	nop			; (mov r8, r8)
 800c358:	7149f2ca 	.word	0x7149f2ca
 800c35c:	bf800000 	.word	0xbf800000
 800c360:	007fffff 	.word	0x007fffff
 800c364:	7f7fffff 	.word	0x7f7fffff

0800c368 <roundf>:
 800c368:	0dc3      	lsrs	r3, r0, #23
 800c36a:	b2db      	uxtb	r3, r3
 800c36c:	3b7f      	subs	r3, #127	; 0x7f
 800c36e:	b510      	push	{r4, lr}
 800c370:	1c02      	adds	r2, r0, #0
 800c372:	2b16      	cmp	r3, #22
 800c374:	dc13      	bgt.n	800c39e <roundf+0x36>
 800c376:	2b00      	cmp	r3, #0
 800c378:	da07      	bge.n	800c38a <roundf+0x22>
 800c37a:	0fc0      	lsrs	r0, r0, #31
 800c37c:	07c0      	lsls	r0, r0, #31
 800c37e:	3301      	adds	r3, #1
 800c380:	d112      	bne.n	800c3a8 <roundf+0x40>
 800c382:	23fe      	movs	r3, #254	; 0xfe
 800c384:	059b      	lsls	r3, r3, #22
 800c386:	4318      	orrs	r0, r3
 800c388:	e00e      	b.n	800c3a8 <roundf+0x40>
 800c38a:	4908      	ldr	r1, [pc, #32]	; (800c3ac <roundf+0x44>)
 800c38c:	4119      	asrs	r1, r3
 800c38e:	4201      	tst	r1, r0
 800c390:	d00a      	beq.n	800c3a8 <roundf+0x40>
 800c392:	2080      	movs	r0, #128	; 0x80
 800c394:	03c0      	lsls	r0, r0, #15
 800c396:	4118      	asrs	r0, r3
 800c398:	1880      	adds	r0, r0, r2
 800c39a:	4388      	bics	r0, r1
 800c39c:	e004      	b.n	800c3a8 <roundf+0x40>
 800c39e:	2b80      	cmp	r3, #128	; 0x80
 800c3a0:	d102      	bne.n	800c3a8 <roundf+0x40>
 800c3a2:	1c01      	adds	r1, r0, #0
 800c3a4:	f7f3 fff4 	bl	8000390 <__aeabi_fadd>
 800c3a8:	bd10      	pop	{r4, pc}
 800c3aa:	46c0      	nop			; (mov r8, r8)
 800c3ac:	007fffff 	.word	0x007fffff

0800c3b0 <sinf>:
 800c3b0:	b507      	push	{r0, r1, r2, lr}
 800c3b2:	4a19      	ldr	r2, [pc, #100]	; (800c418 <sinf+0x68>)
 800c3b4:	0043      	lsls	r3, r0, #1
 800c3b6:	085b      	lsrs	r3, r3, #1
 800c3b8:	4293      	cmp	r3, r2
 800c3ba:	dc02      	bgt.n	800c3c2 <sinf+0x12>
 800c3bc:	2200      	movs	r2, #0
 800c3be:	2100      	movs	r1, #0
 800c3c0:	e014      	b.n	800c3ec <sinf+0x3c>
 800c3c2:	4a16      	ldr	r2, [pc, #88]	; (800c41c <sinf+0x6c>)
 800c3c4:	4293      	cmp	r3, r2
 800c3c6:	dd03      	ble.n	800c3d0 <sinf+0x20>
 800c3c8:	1c01      	adds	r1, r0, #0
 800c3ca:	f7f4 fc35 	bl	8000c38 <__aeabi_fsub>
 800c3ce:	e022      	b.n	800c416 <sinf+0x66>
 800c3d0:	4669      	mov	r1, sp
 800c3d2:	f000 f90d 	bl	800c5f0 <__ieee754_rem_pio2f>
 800c3d6:	2303      	movs	r3, #3
 800c3d8:	4018      	ands	r0, r3
 800c3da:	2801      	cmp	r0, #1
 800c3dc:	d009      	beq.n	800c3f2 <sinf+0x42>
 800c3de:	2802      	cmp	r0, #2
 800c3e0:	d00c      	beq.n	800c3fc <sinf+0x4c>
 800c3e2:	2800      	cmp	r0, #0
 800c3e4:	d110      	bne.n	800c408 <sinf+0x58>
 800c3e6:	2201      	movs	r2, #1
 800c3e8:	9901      	ldr	r1, [sp, #4]
 800c3ea:	9800      	ldr	r0, [sp, #0]
 800c3ec:	f000 fdfc 	bl	800cfe8 <__kernel_sinf>
 800c3f0:	e011      	b.n	800c416 <sinf+0x66>
 800c3f2:	9901      	ldr	r1, [sp, #4]
 800c3f4:	9800      	ldr	r0, [sp, #0]
 800c3f6:	f000 faa9 	bl	800c94c <__kernel_cosf>
 800c3fa:	e00c      	b.n	800c416 <sinf+0x66>
 800c3fc:	2201      	movs	r2, #1
 800c3fe:	9901      	ldr	r1, [sp, #4]
 800c400:	9800      	ldr	r0, [sp, #0]
 800c402:	f000 fdf1 	bl	800cfe8 <__kernel_sinf>
 800c406:	e003      	b.n	800c410 <sinf+0x60>
 800c408:	9901      	ldr	r1, [sp, #4]
 800c40a:	9800      	ldr	r0, [sp, #0]
 800c40c:	f000 fa9e 	bl	800c94c <__kernel_cosf>
 800c410:	2380      	movs	r3, #128	; 0x80
 800c412:	061b      	lsls	r3, r3, #24
 800c414:	18c0      	adds	r0, r0, r3
 800c416:	bd0e      	pop	{r1, r2, r3, pc}
 800c418:	3f490fd8 	.word	0x3f490fd8
 800c41c:	7f7fffff 	.word	0x7f7fffff

0800c420 <atan2f>:
 800c420:	b510      	push	{r4, lr}
 800c422:	f000 f853 	bl	800c4cc <__ieee754_atan2f>
 800c426:	bd10      	pop	{r4, pc}

0800c428 <sqrtf>:
 800c428:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c42a:	2600      	movs	r6, #0
 800c42c:	b08d      	sub	sp, #52	; 0x34
 800c42e:	1c04      	adds	r4, r0, #0
 800c430:	f000 fa3a 	bl	800c8a8 <__ieee754_sqrtf>
 800c434:	4b23      	ldr	r3, [pc, #140]	; (800c4c4 <sqrtf+0x9c>)
 800c436:	1c05      	adds	r5, r0, #0
 800c438:	579e      	ldrsb	r6, [r3, r6]
 800c43a:	1c73      	adds	r3, r6, #1
 800c43c:	d040      	beq.n	800c4c0 <sqrtf+0x98>
 800c43e:	1c21      	adds	r1, r4, #0
 800c440:	1c20      	adds	r0, r4, #0
 800c442:	f7f4 fd7f 	bl	8000f44 <__aeabi_fcmpun>
 800c446:	0007      	movs	r7, r0
 800c448:	1c28      	adds	r0, r5, #0
 800c44a:	2f00      	cmp	r7, #0
 800c44c:	d138      	bne.n	800c4c0 <sqrtf+0x98>
 800c44e:	2100      	movs	r1, #0
 800c450:	1c20      	adds	r0, r4, #0
 800c452:	f7f3 ff3f 	bl	80002d4 <__aeabi_fcmplt>
 800c456:	2800      	cmp	r0, #0
 800c458:	d031      	beq.n	800c4be <sqrtf+0x96>
 800c45a:	2301      	movs	r3, #1
 800c45c:	9302      	str	r3, [sp, #8]
 800c45e:	4b1a      	ldr	r3, [pc, #104]	; (800c4c8 <sqrtf+0xa0>)
 800c460:	1c20      	adds	r0, r4, #0
 800c462:	9303      	str	r3, [sp, #12]
 800c464:	970a      	str	r7, [sp, #40]	; 0x28
 800c466:	f7f6 f907 	bl	8002678 <__aeabi_f2d>
 800c46a:	2200      	movs	r2, #0
 800c46c:	9006      	str	r0, [sp, #24]
 800c46e:	9107      	str	r1, [sp, #28]
 800c470:	9004      	str	r0, [sp, #16]
 800c472:	9105      	str	r1, [sp, #20]
 800c474:	2300      	movs	r3, #0
 800c476:	2e00      	cmp	r6, #0
 800c478:	d102      	bne.n	800c480 <sqrtf+0x58>
 800c47a:	9208      	str	r2, [sp, #32]
 800c47c:	9309      	str	r3, [sp, #36]	; 0x24
 800c47e:	e007      	b.n	800c490 <sqrtf+0x68>
 800c480:	0010      	movs	r0, r2
 800c482:	0019      	movs	r1, r3
 800c484:	f7f5 f94a 	bl	800171c <__aeabi_ddiv>
 800c488:	9008      	str	r0, [sp, #32]
 800c48a:	9109      	str	r1, [sp, #36]	; 0x24
 800c48c:	2e02      	cmp	r6, #2
 800c48e:	d004      	beq.n	800c49a <sqrtf+0x72>
 800c490:	a802      	add	r0, sp, #8
 800c492:	f000 fe1d 	bl	800d0d0 <matherr>
 800c496:	2800      	cmp	r0, #0
 800c498:	d103      	bne.n	800c4a2 <sqrtf+0x7a>
 800c49a:	f000 ff95 	bl	800d3c8 <__errno>
 800c49e:	2321      	movs	r3, #33	; 0x21
 800c4a0:	6003      	str	r3, [r0, #0]
 800c4a2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c4a4:	9301      	str	r3, [sp, #4]
 800c4a6:	2b00      	cmp	r3, #0
 800c4a8:	d004      	beq.n	800c4b4 <sqrtf+0x8c>
 800c4aa:	f000 ff8d 	bl	800d3c8 <__errno>
 800c4ae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c4b0:	9301      	str	r3, [sp, #4]
 800c4b2:	6003      	str	r3, [r0, #0]
 800c4b4:	9808      	ldr	r0, [sp, #32]
 800c4b6:	9909      	ldr	r1, [sp, #36]	; 0x24
 800c4b8:	f7f6 f932 	bl	8002720 <__aeabi_d2f>
 800c4bc:	e000      	b.n	800c4c0 <sqrtf+0x98>
 800c4be:	1c28      	adds	r0, r5, #0
 800c4c0:	b00d      	add	sp, #52	; 0x34
 800c4c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c4c4:	20000078 	.word	0x20000078
 800c4c8:	0800db5e 	.word	0x0800db5e

0800c4cc <__ieee754_atan2f>:
 800c4cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800c4ce:	004b      	lsls	r3, r1, #1
 800c4d0:	1c0d      	adds	r5, r1, #0
 800c4d2:	9101      	str	r1, [sp, #4]
 800c4d4:	21ff      	movs	r1, #255	; 0xff
 800c4d6:	085a      	lsrs	r2, r3, #1
 800c4d8:	05c9      	lsls	r1, r1, #23
 800c4da:	428a      	cmp	r2, r1
 800c4dc:	dc04      	bgt.n	800c4e8 <__ieee754_atan2f+0x1c>
 800c4de:	0043      	lsls	r3, r0, #1
 800c4e0:	0007      	movs	r7, r0
 800c4e2:	085b      	lsrs	r3, r3, #1
 800c4e4:	428b      	cmp	r3, r1
 800c4e6:	dd04      	ble.n	800c4f2 <__ieee754_atan2f+0x26>
 800c4e8:	1c01      	adds	r1, r0, #0
 800c4ea:	1c28      	adds	r0, r5, #0
 800c4ec:	f7f3 ff50 	bl	8000390 <__aeabi_fadd>
 800c4f0:	e06a      	b.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c4f2:	24fe      	movs	r4, #254	; 0xfe
 800c4f4:	05a4      	lsls	r4, r4, #22
 800c4f6:	42a5      	cmp	r5, r4
 800c4f8:	d102      	bne.n	800c500 <__ieee754_atan2f+0x34>
 800c4fa:	f000 fdeb 	bl	800d0d4 <atanf>
 800c4fe:	e063      	b.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c500:	17ac      	asrs	r4, r5, #30
 800c502:	46a4      	mov	ip, r4
 800c504:	2402      	movs	r4, #2
 800c506:	4666      	mov	r6, ip
 800c508:	4034      	ands	r4, r6
 800c50a:	0fc6      	lsrs	r6, r0, #31
 800c50c:	4334      	orrs	r4, r6
 800c50e:	2b00      	cmp	r3, #0
 800c510:	d104      	bne.n	800c51c <__ieee754_atan2f+0x50>
 800c512:	2c02      	cmp	r4, #2
 800c514:	d053      	beq.n	800c5be <__ieee754_atan2f+0xf2>
 800c516:	2c03      	cmp	r4, #3
 800c518:	d156      	bne.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c51a:	e01b      	b.n	800c554 <__ieee754_atan2f+0x88>
 800c51c:	2a00      	cmp	r2, #0
 800c51e:	d01d      	beq.n	800c55c <__ieee754_atan2f+0x90>
 800c520:	428a      	cmp	r2, r1
 800c522:	d119      	bne.n	800c558 <__ieee754_atan2f+0x8c>
 800c524:	4293      	cmp	r3, r2
 800c526:	d10b      	bne.n	800c540 <__ieee754_atan2f+0x74>
 800c528:	2c02      	cmp	r4, #2
 800c52a:	d005      	beq.n	800c538 <__ieee754_atan2f+0x6c>
 800c52c:	2c03      	cmp	r4, #3
 800c52e:	d005      	beq.n	800c53c <__ieee754_atan2f+0x70>
 800c530:	2c01      	cmp	r4, #1
 800c532:	d146      	bne.n	800c5c2 <__ieee754_atan2f+0xf6>
 800c534:	4825      	ldr	r0, [pc, #148]	; (800c5cc <__ieee754_atan2f+0x100>)
 800c536:	e047      	b.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c538:	4825      	ldr	r0, [pc, #148]	; (800c5d0 <__ieee754_atan2f+0x104>)
 800c53a:	e045      	b.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c53c:	4825      	ldr	r0, [pc, #148]	; (800c5d4 <__ieee754_atan2f+0x108>)
 800c53e:	e043      	b.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c540:	2c02      	cmp	r4, #2
 800c542:	d03c      	beq.n	800c5be <__ieee754_atan2f+0xf2>
 800c544:	2c03      	cmp	r4, #3
 800c546:	d005      	beq.n	800c554 <__ieee754_atan2f+0x88>
 800c548:	2000      	movs	r0, #0
 800c54a:	2c01      	cmp	r4, #1
 800c54c:	d13c      	bne.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c54e:	2080      	movs	r0, #128	; 0x80
 800c550:	0600      	lsls	r0, r0, #24
 800c552:	e039      	b.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c554:	4820      	ldr	r0, [pc, #128]	; (800c5d8 <__ieee754_atan2f+0x10c>)
 800c556:	e037      	b.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c558:	428b      	cmp	r3, r1
 800c55a:	d103      	bne.n	800c564 <__ieee754_atan2f+0x98>
 800c55c:	2f00      	cmp	r7, #0
 800c55e:	da32      	bge.n	800c5c6 <__ieee754_atan2f+0xfa>
 800c560:	481e      	ldr	r0, [pc, #120]	; (800c5dc <__ieee754_atan2f+0x110>)
 800c562:	e031      	b.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c564:	1a9b      	subs	r3, r3, r2
 800c566:	15db      	asrs	r3, r3, #23
 800c568:	2b3c      	cmp	r3, #60	; 0x3c
 800c56a:	dc0c      	bgt.n	800c586 <__ieee754_atan2f+0xba>
 800c56c:	2d00      	cmp	r5, #0
 800c56e:	da01      	bge.n	800c574 <__ieee754_atan2f+0xa8>
 800c570:	333c      	adds	r3, #60	; 0x3c
 800c572:	db0a      	blt.n	800c58a <__ieee754_atan2f+0xbe>
 800c574:	1c29      	adds	r1, r5, #0
 800c576:	f7f4 f881 	bl	800067c <__aeabi_fdiv>
 800c57a:	f000 fec3 	bl	800d304 <fabsf>
 800c57e:	f000 fda9 	bl	800d0d4 <atanf>
 800c582:	1c03      	adds	r3, r0, #0
 800c584:	e002      	b.n	800c58c <__ieee754_atan2f+0xc0>
 800c586:	4b16      	ldr	r3, [pc, #88]	; (800c5e0 <__ieee754_atan2f+0x114>)
 800c588:	e000      	b.n	800c58c <__ieee754_atan2f+0xc0>
 800c58a:	2300      	movs	r3, #0
 800c58c:	2280      	movs	r2, #128	; 0x80
 800c58e:	0612      	lsls	r2, r2, #24
 800c590:	1898      	adds	r0, r3, r2
 800c592:	2c01      	cmp	r4, #1
 800c594:	d018      	beq.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c596:	2c02      	cmp	r4, #2
 800c598:	d008      	beq.n	800c5ac <__ieee754_atan2f+0xe0>
 800c59a:	1c18      	adds	r0, r3, #0
 800c59c:	2c00      	cmp	r4, #0
 800c59e:	d013      	beq.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c5a0:	4910      	ldr	r1, [pc, #64]	; (800c5e4 <__ieee754_atan2f+0x118>)
 800c5a2:	1c18      	adds	r0, r3, #0
 800c5a4:	f7f3 fef4 	bl	8000390 <__aeabi_fadd>
 800c5a8:	490f      	ldr	r1, [pc, #60]	; (800c5e8 <__ieee754_atan2f+0x11c>)
 800c5aa:	e005      	b.n	800c5b8 <__ieee754_atan2f+0xec>
 800c5ac:	490d      	ldr	r1, [pc, #52]	; (800c5e4 <__ieee754_atan2f+0x118>)
 800c5ae:	1c18      	adds	r0, r3, #0
 800c5b0:	f7f3 feee 	bl	8000390 <__aeabi_fadd>
 800c5b4:	1c01      	adds	r1, r0, #0
 800c5b6:	480c      	ldr	r0, [pc, #48]	; (800c5e8 <__ieee754_atan2f+0x11c>)
 800c5b8:	f7f4 fb3e 	bl	8000c38 <__aeabi_fsub>
 800c5bc:	e004      	b.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c5be:	480a      	ldr	r0, [pc, #40]	; (800c5e8 <__ieee754_atan2f+0x11c>)
 800c5c0:	e002      	b.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c5c2:	480a      	ldr	r0, [pc, #40]	; (800c5ec <__ieee754_atan2f+0x120>)
 800c5c4:	e000      	b.n	800c5c8 <__ieee754_atan2f+0xfc>
 800c5c6:	4806      	ldr	r0, [pc, #24]	; (800c5e0 <__ieee754_atan2f+0x114>)
 800c5c8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800c5ca:	46c0      	nop			; (mov r8, r8)
 800c5cc:	bf490fdb 	.word	0xbf490fdb
 800c5d0:	4016cbe4 	.word	0x4016cbe4
 800c5d4:	c016cbe4 	.word	0xc016cbe4
 800c5d8:	c0490fdb 	.word	0xc0490fdb
 800c5dc:	bfc90fdb 	.word	0xbfc90fdb
 800c5e0:	3fc90fdb 	.word	0x3fc90fdb
 800c5e4:	33bbbd2e 	.word	0x33bbbd2e
 800c5e8:	40490fdb 	.word	0x40490fdb
 800c5ec:	3f490fdb 	.word	0x3f490fdb

0800c5f0 <__ieee754_rem_pio2f>:
 800c5f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c5f2:	4b9f      	ldr	r3, [pc, #636]	; (800c870 <__ieee754_rem_pio2f+0x280>)
 800c5f4:	b08b      	sub	sp, #44	; 0x2c
 800c5f6:	0045      	lsls	r5, r0, #1
 800c5f8:	000c      	movs	r4, r1
 800c5fa:	9004      	str	r0, [sp, #16]
 800c5fc:	086d      	lsrs	r5, r5, #1
 800c5fe:	429d      	cmp	r5, r3
 800c600:	dc03      	bgt.n	800c60a <__ieee754_rem_pio2f+0x1a>
 800c602:	2300      	movs	r3, #0
 800c604:	6008      	str	r0, [r1, #0]
 800c606:	604b      	str	r3, [r1, #4]
 800c608:	e0e9      	b.n	800c7de <__ieee754_rem_pio2f+0x1ee>
 800c60a:	4b9a      	ldr	r3, [pc, #616]	; (800c874 <__ieee754_rem_pio2f+0x284>)
 800c60c:	429d      	cmp	r5, r3
 800c60e:	dc49      	bgt.n	800c6a4 <__ieee754_rem_pio2f+0xb4>
 800c610:	4e99      	ldr	r6, [pc, #612]	; (800c878 <__ieee754_rem_pio2f+0x288>)
 800c612:	499a      	ldr	r1, [pc, #616]	; (800c87c <__ieee754_rem_pio2f+0x28c>)
 800c614:	2800      	cmp	r0, #0
 800c616:	dd22      	ble.n	800c65e <__ieee754_rem_pio2f+0x6e>
 800c618:	f7f4 fb0e 	bl	8000c38 <__aeabi_fsub>
 800c61c:	230f      	movs	r3, #15
 800c61e:	1c07      	adds	r7, r0, #0
 800c620:	439d      	bics	r5, r3
 800c622:	42b5      	cmp	r5, r6
 800c624:	d009      	beq.n	800c63a <__ieee754_rem_pio2f+0x4a>
 800c626:	4996      	ldr	r1, [pc, #600]	; (800c880 <__ieee754_rem_pio2f+0x290>)
 800c628:	f7f4 fb06 	bl	8000c38 <__aeabi_fsub>
 800c62c:	1c01      	adds	r1, r0, #0
 800c62e:	6020      	str	r0, [r4, #0]
 800c630:	1c38      	adds	r0, r7, #0
 800c632:	f7f4 fb01 	bl	8000c38 <__aeabi_fsub>
 800c636:	4992      	ldr	r1, [pc, #584]	; (800c880 <__ieee754_rem_pio2f+0x290>)
 800c638:	e00c      	b.n	800c654 <__ieee754_rem_pio2f+0x64>
 800c63a:	4992      	ldr	r1, [pc, #584]	; (800c884 <__ieee754_rem_pio2f+0x294>)
 800c63c:	f7f4 fafc 	bl	8000c38 <__aeabi_fsub>
 800c640:	4991      	ldr	r1, [pc, #580]	; (800c888 <__ieee754_rem_pio2f+0x298>)
 800c642:	1c05      	adds	r5, r0, #0
 800c644:	f7f4 faf8 	bl	8000c38 <__aeabi_fsub>
 800c648:	1c01      	adds	r1, r0, #0
 800c64a:	6020      	str	r0, [r4, #0]
 800c64c:	1c28      	adds	r0, r5, #0
 800c64e:	f7f4 faf3 	bl	8000c38 <__aeabi_fsub>
 800c652:	498d      	ldr	r1, [pc, #564]	; (800c888 <__ieee754_rem_pio2f+0x298>)
 800c654:	f7f4 faf0 	bl	8000c38 <__aeabi_fsub>
 800c658:	6060      	str	r0, [r4, #4]
 800c65a:	2001      	movs	r0, #1
 800c65c:	e106      	b.n	800c86c <__ieee754_rem_pio2f+0x27c>
 800c65e:	f7f3 fe97 	bl	8000390 <__aeabi_fadd>
 800c662:	230f      	movs	r3, #15
 800c664:	1c07      	adds	r7, r0, #0
 800c666:	439d      	bics	r5, r3
 800c668:	42b5      	cmp	r5, r6
 800c66a:	d009      	beq.n	800c680 <__ieee754_rem_pio2f+0x90>
 800c66c:	4984      	ldr	r1, [pc, #528]	; (800c880 <__ieee754_rem_pio2f+0x290>)
 800c66e:	f7f3 fe8f 	bl	8000390 <__aeabi_fadd>
 800c672:	1c01      	adds	r1, r0, #0
 800c674:	6020      	str	r0, [r4, #0]
 800c676:	1c38      	adds	r0, r7, #0
 800c678:	f7f4 fade 	bl	8000c38 <__aeabi_fsub>
 800c67c:	4980      	ldr	r1, [pc, #512]	; (800c880 <__ieee754_rem_pio2f+0x290>)
 800c67e:	e00c      	b.n	800c69a <__ieee754_rem_pio2f+0xaa>
 800c680:	4980      	ldr	r1, [pc, #512]	; (800c884 <__ieee754_rem_pio2f+0x294>)
 800c682:	f7f3 fe85 	bl	8000390 <__aeabi_fadd>
 800c686:	4980      	ldr	r1, [pc, #512]	; (800c888 <__ieee754_rem_pio2f+0x298>)
 800c688:	1c05      	adds	r5, r0, #0
 800c68a:	f7f3 fe81 	bl	8000390 <__aeabi_fadd>
 800c68e:	1c01      	adds	r1, r0, #0
 800c690:	6020      	str	r0, [r4, #0]
 800c692:	1c28      	adds	r0, r5, #0
 800c694:	f7f4 fad0 	bl	8000c38 <__aeabi_fsub>
 800c698:	497b      	ldr	r1, [pc, #492]	; (800c888 <__ieee754_rem_pio2f+0x298>)
 800c69a:	f7f3 fe79 	bl	8000390 <__aeabi_fadd>
 800c69e:	6060      	str	r0, [r4, #4]
 800c6a0:	2001      	movs	r0, #1
 800c6a2:	e0e2      	b.n	800c86a <__ieee754_rem_pio2f+0x27a>
 800c6a4:	4b79      	ldr	r3, [pc, #484]	; (800c88c <__ieee754_rem_pio2f+0x29c>)
 800c6a6:	429d      	cmp	r5, r3
 800c6a8:	dd00      	ble.n	800c6ac <__ieee754_rem_pio2f+0xbc>
 800c6aa:	e090      	b.n	800c7ce <__ieee754_rem_pio2f+0x1de>
 800c6ac:	f000 fe2a 	bl	800d304 <fabsf>
 800c6b0:	4977      	ldr	r1, [pc, #476]	; (800c890 <__ieee754_rem_pio2f+0x2a0>)
 800c6b2:	1c06      	adds	r6, r0, #0
 800c6b4:	f7f4 f9ac 	bl	8000a10 <__aeabi_fmul>
 800c6b8:	21fc      	movs	r1, #252	; 0xfc
 800c6ba:	0589      	lsls	r1, r1, #22
 800c6bc:	f7f3 fe68 	bl	8000390 <__aeabi_fadd>
 800c6c0:	f7f4 fc58 	bl	8000f74 <__aeabi_f2iz>
 800c6c4:	9003      	str	r0, [sp, #12]
 800c6c6:	f7f4 fc77 	bl	8000fb8 <__aeabi_i2f>
 800c6ca:	496c      	ldr	r1, [pc, #432]	; (800c87c <__ieee754_rem_pio2f+0x28c>)
 800c6cc:	9002      	str	r0, [sp, #8]
 800c6ce:	f7f4 f99f 	bl	8000a10 <__aeabi_fmul>
 800c6d2:	1c01      	adds	r1, r0, #0
 800c6d4:	1c30      	adds	r0, r6, #0
 800c6d6:	f7f4 faaf 	bl	8000c38 <__aeabi_fsub>
 800c6da:	4969      	ldr	r1, [pc, #420]	; (800c880 <__ieee754_rem_pio2f+0x290>)
 800c6dc:	1c06      	adds	r6, r0, #0
 800c6de:	9802      	ldr	r0, [sp, #8]
 800c6e0:	f7f4 f996 	bl	8000a10 <__aeabi_fmul>
 800c6e4:	9b03      	ldr	r3, [sp, #12]
 800c6e6:	1c07      	adds	r7, r0, #0
 800c6e8:	2b1f      	cmp	r3, #31
 800c6ea:	dc09      	bgt.n	800c700 <__ieee754_rem_pio2f+0x110>
 800c6ec:	23ff      	movs	r3, #255	; 0xff
 800c6ee:	002a      	movs	r2, r5
 800c6f0:	439a      	bics	r2, r3
 800c6f2:	9b03      	ldr	r3, [sp, #12]
 800c6f4:	4967      	ldr	r1, [pc, #412]	; (800c894 <__ieee754_rem_pio2f+0x2a4>)
 800c6f6:	3b01      	subs	r3, #1
 800c6f8:	009b      	lsls	r3, r3, #2
 800c6fa:	585b      	ldr	r3, [r3, r1]
 800c6fc:	429a      	cmp	r2, r3
 800c6fe:	d14e      	bne.n	800c79e <__ieee754_rem_pio2f+0x1ae>
 800c700:	1c39      	adds	r1, r7, #0
 800c702:	1c30      	adds	r0, r6, #0
 800c704:	f7f4 fa98 	bl	8000c38 <__aeabi_fsub>
 800c708:	22ff      	movs	r2, #255	; 0xff
 800c70a:	15eb      	asrs	r3, r5, #23
 800c70c:	9305      	str	r3, [sp, #20]
 800c70e:	0dc3      	lsrs	r3, r0, #23
 800c710:	4013      	ands	r3, r2
 800c712:	9a05      	ldr	r2, [sp, #20]
 800c714:	1ad3      	subs	r3, r2, r3
 800c716:	2b08      	cmp	r3, #8
 800c718:	dd45      	ble.n	800c7a6 <__ieee754_rem_pio2f+0x1b6>
 800c71a:	495a      	ldr	r1, [pc, #360]	; (800c884 <__ieee754_rem_pio2f+0x294>)
 800c71c:	9802      	ldr	r0, [sp, #8]
 800c71e:	f7f4 f977 	bl	8000a10 <__aeabi_fmul>
 800c722:	1c07      	adds	r7, r0, #0
 800c724:	1c01      	adds	r1, r0, #0
 800c726:	1c30      	adds	r0, r6, #0
 800c728:	f7f4 fa86 	bl	8000c38 <__aeabi_fsub>
 800c72c:	1c01      	adds	r1, r0, #0
 800c72e:	1c05      	adds	r5, r0, #0
 800c730:	1c30      	adds	r0, r6, #0
 800c732:	f7f4 fa81 	bl	8000c38 <__aeabi_fsub>
 800c736:	1c39      	adds	r1, r7, #0
 800c738:	f7f4 fa7e 	bl	8000c38 <__aeabi_fsub>
 800c73c:	4952      	ldr	r1, [pc, #328]	; (800c888 <__ieee754_rem_pio2f+0x298>)
 800c73e:	1c06      	adds	r6, r0, #0
 800c740:	9802      	ldr	r0, [sp, #8]
 800c742:	f7f4 f965 	bl	8000a10 <__aeabi_fmul>
 800c746:	1c31      	adds	r1, r6, #0
 800c748:	f7f4 fa76 	bl	8000c38 <__aeabi_fsub>
 800c74c:	1c01      	adds	r1, r0, #0
 800c74e:	1c07      	adds	r7, r0, #0
 800c750:	1c28      	adds	r0, r5, #0
 800c752:	f7f4 fa71 	bl	8000c38 <__aeabi_fsub>
 800c756:	22ff      	movs	r2, #255	; 0xff
 800c758:	0dc3      	lsrs	r3, r0, #23
 800c75a:	4013      	ands	r3, r2
 800c75c:	9a05      	ldr	r2, [sp, #20]
 800c75e:	1ad3      	subs	r3, r2, r3
 800c760:	2b19      	cmp	r3, #25
 800c762:	dc02      	bgt.n	800c76a <__ieee754_rem_pio2f+0x17a>
 800c764:	6020      	str	r0, [r4, #0]
 800c766:	1c2e      	adds	r6, r5, #0
 800c768:	e01e      	b.n	800c7a8 <__ieee754_rem_pio2f+0x1b8>
 800c76a:	494b      	ldr	r1, [pc, #300]	; (800c898 <__ieee754_rem_pio2f+0x2a8>)
 800c76c:	9802      	ldr	r0, [sp, #8]
 800c76e:	f7f4 f94f 	bl	8000a10 <__aeabi_fmul>
 800c772:	1c07      	adds	r7, r0, #0
 800c774:	1c01      	adds	r1, r0, #0
 800c776:	1c28      	adds	r0, r5, #0
 800c778:	f7f4 fa5e 	bl	8000c38 <__aeabi_fsub>
 800c77c:	1c01      	adds	r1, r0, #0
 800c77e:	1c06      	adds	r6, r0, #0
 800c780:	1c28      	adds	r0, r5, #0
 800c782:	f7f4 fa59 	bl	8000c38 <__aeabi_fsub>
 800c786:	1c39      	adds	r1, r7, #0
 800c788:	f7f4 fa56 	bl	8000c38 <__aeabi_fsub>
 800c78c:	4943      	ldr	r1, [pc, #268]	; (800c89c <__ieee754_rem_pio2f+0x2ac>)
 800c78e:	1c05      	adds	r5, r0, #0
 800c790:	9802      	ldr	r0, [sp, #8]
 800c792:	f7f4 f93d 	bl	8000a10 <__aeabi_fmul>
 800c796:	1c29      	adds	r1, r5, #0
 800c798:	f7f4 fa4e 	bl	8000c38 <__aeabi_fsub>
 800c79c:	1c07      	adds	r7, r0, #0
 800c79e:	1c39      	adds	r1, r7, #0
 800c7a0:	1c30      	adds	r0, r6, #0
 800c7a2:	f7f4 fa49 	bl	8000c38 <__aeabi_fsub>
 800c7a6:	6020      	str	r0, [r4, #0]
 800c7a8:	6825      	ldr	r5, [r4, #0]
 800c7aa:	1c30      	adds	r0, r6, #0
 800c7ac:	1c29      	adds	r1, r5, #0
 800c7ae:	f7f4 fa43 	bl	8000c38 <__aeabi_fsub>
 800c7b2:	1c39      	adds	r1, r7, #0
 800c7b4:	f7f4 fa40 	bl	8000c38 <__aeabi_fsub>
 800c7b8:	9a04      	ldr	r2, [sp, #16]
 800c7ba:	1c03      	adds	r3, r0, #0
 800c7bc:	6060      	str	r0, [r4, #4]
 800c7be:	9803      	ldr	r0, [sp, #12]
 800c7c0:	2a00      	cmp	r2, #0
 800c7c2:	da53      	bge.n	800c86c <__ieee754_rem_pio2f+0x27c>
 800c7c4:	2280      	movs	r2, #128	; 0x80
 800c7c6:	0612      	lsls	r2, r2, #24
 800c7c8:	18ad      	adds	r5, r5, r2
 800c7ca:	6025      	str	r5, [r4, #0]
 800c7cc:	e04b      	b.n	800c866 <__ieee754_rem_pio2f+0x276>
 800c7ce:	4b34      	ldr	r3, [pc, #208]	; (800c8a0 <__ieee754_rem_pio2f+0x2b0>)
 800c7d0:	429d      	cmp	r5, r3
 800c7d2:	dd06      	ble.n	800c7e2 <__ieee754_rem_pio2f+0x1f2>
 800c7d4:	1c01      	adds	r1, r0, #0
 800c7d6:	f7f4 fa2f 	bl	8000c38 <__aeabi_fsub>
 800c7da:	6060      	str	r0, [r4, #4]
 800c7dc:	6020      	str	r0, [r4, #0]
 800c7de:	2000      	movs	r0, #0
 800c7e0:	e044      	b.n	800c86c <__ieee754_rem_pio2f+0x27c>
 800c7e2:	15ee      	asrs	r6, r5, #23
 800c7e4:	3e86      	subs	r6, #134	; 0x86
 800c7e6:	05f3      	lsls	r3, r6, #23
 800c7e8:	1aed      	subs	r5, r5, r3
 800c7ea:	1c28      	adds	r0, r5, #0
 800c7ec:	f7f4 fbc2 	bl	8000f74 <__aeabi_f2iz>
 800c7f0:	f7f4 fbe2 	bl	8000fb8 <__aeabi_i2f>
 800c7f4:	1c01      	adds	r1, r0, #0
 800c7f6:	9007      	str	r0, [sp, #28]
 800c7f8:	1c28      	adds	r0, r5, #0
 800c7fa:	f7f4 fa1d 	bl	8000c38 <__aeabi_fsub>
 800c7fe:	2187      	movs	r1, #135	; 0x87
 800c800:	05c9      	lsls	r1, r1, #23
 800c802:	f7f4 f905 	bl	8000a10 <__aeabi_fmul>
 800c806:	1c07      	adds	r7, r0, #0
 800c808:	f7f4 fbb4 	bl	8000f74 <__aeabi_f2iz>
 800c80c:	f7f4 fbd4 	bl	8000fb8 <__aeabi_i2f>
 800c810:	1c01      	adds	r1, r0, #0
 800c812:	9008      	str	r0, [sp, #32]
 800c814:	1c05      	adds	r5, r0, #0
 800c816:	1c38      	adds	r0, r7, #0
 800c818:	f7f4 fa0e 	bl	8000c38 <__aeabi_fsub>
 800c81c:	2187      	movs	r1, #135	; 0x87
 800c81e:	05c9      	lsls	r1, r1, #23
 800c820:	f7f4 f8f6 	bl	8000a10 <__aeabi_fmul>
 800c824:	2100      	movs	r1, #0
 800c826:	9009      	str	r0, [sp, #36]	; 0x24
 800c828:	f7f3 fd4e 	bl	80002c8 <__aeabi_fcmpeq>
 800c82c:	2303      	movs	r3, #3
 800c82e:	2800      	cmp	r0, #0
 800c830:	d007      	beq.n	800c842 <__ieee754_rem_pio2f+0x252>
 800c832:	2100      	movs	r1, #0
 800c834:	1c28      	adds	r0, r5, #0
 800c836:	f7f3 fd47 	bl	80002c8 <__aeabi_fcmpeq>
 800c83a:	2202      	movs	r2, #2
 800c83c:	1e43      	subs	r3, r0, #1
 800c83e:	4198      	sbcs	r0, r3
 800c840:	1a13      	subs	r3, r2, r0
 800c842:	4a18      	ldr	r2, [pc, #96]	; (800c8a4 <__ieee754_rem_pio2f+0x2b4>)
 800c844:	0021      	movs	r1, r4
 800c846:	9201      	str	r2, [sp, #4]
 800c848:	2202      	movs	r2, #2
 800c84a:	a807      	add	r0, sp, #28
 800c84c:	9200      	str	r2, [sp, #0]
 800c84e:	0032      	movs	r2, r6
 800c850:	f000 f912 	bl	800ca78 <__kernel_rem_pio2f>
 800c854:	9b04      	ldr	r3, [sp, #16]
 800c856:	2b00      	cmp	r3, #0
 800c858:	da08      	bge.n	800c86c <__ieee754_rem_pio2f+0x27c>
 800c85a:	2280      	movs	r2, #128	; 0x80
 800c85c:	6823      	ldr	r3, [r4, #0]
 800c85e:	0612      	lsls	r2, r2, #24
 800c860:	189b      	adds	r3, r3, r2
 800c862:	6023      	str	r3, [r4, #0]
 800c864:	6863      	ldr	r3, [r4, #4]
 800c866:	189b      	adds	r3, r3, r2
 800c868:	6063      	str	r3, [r4, #4]
 800c86a:	4240      	negs	r0, r0
 800c86c:	b00b      	add	sp, #44	; 0x2c
 800c86e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c870:	3f490fd8 	.word	0x3f490fd8
 800c874:	4016cbe3 	.word	0x4016cbe3
 800c878:	3fc90fd0 	.word	0x3fc90fd0
 800c87c:	3fc90f80 	.word	0x3fc90f80
 800c880:	37354443 	.word	0x37354443
 800c884:	37354400 	.word	0x37354400
 800c888:	2e85a308 	.word	0x2e85a308
 800c88c:	43490f80 	.word	0x43490f80
 800c890:	3f22f984 	.word	0x3f22f984
 800c894:	0800db64 	.word	0x0800db64
 800c898:	2e85a300 	.word	0x2e85a300
 800c89c:	248d3132 	.word	0x248d3132
 800c8a0:	7f7fffff 	.word	0x7f7fffff
 800c8a4:	0800dbe4 	.word	0x0800dbe4

0800c8a8 <__ieee754_sqrtf>:
 800c8a8:	4926      	ldr	r1, [pc, #152]	; (800c944 <__ieee754_sqrtf+0x9c>)
 800c8aa:	0042      	lsls	r2, r0, #1
 800c8ac:	b570      	push	{r4, r5, r6, lr}
 800c8ae:	0003      	movs	r3, r0
 800c8b0:	1c04      	adds	r4, r0, #0
 800c8b2:	0852      	lsrs	r2, r2, #1
 800c8b4:	428a      	cmp	r2, r1
 800c8b6:	d906      	bls.n	800c8c6 <__ieee754_sqrtf+0x1e>
 800c8b8:	1c01      	adds	r1, r0, #0
 800c8ba:	f7f4 f8a9 	bl	8000a10 <__aeabi_fmul>
 800c8be:	1c21      	adds	r1, r4, #0
 800c8c0:	f7f3 fd66 	bl	8000390 <__aeabi_fadd>
 800c8c4:	e03d      	b.n	800c942 <__ieee754_sqrtf+0x9a>
 800c8c6:	2a00      	cmp	r2, #0
 800c8c8:	d03b      	beq.n	800c942 <__ieee754_sqrtf+0x9a>
 800c8ca:	2800      	cmp	r0, #0
 800c8cc:	da06      	bge.n	800c8dc <__ieee754_sqrtf+0x34>
 800c8ce:	1c01      	adds	r1, r0, #0
 800c8d0:	f7f4 f9b2 	bl	8000c38 <__aeabi_fsub>
 800c8d4:	1c01      	adds	r1, r0, #0
 800c8d6:	f7f3 fed1 	bl	800067c <__aeabi_fdiv>
 800c8da:	e032      	b.n	800c942 <__ieee754_sqrtf+0x9a>
 800c8dc:	491a      	ldr	r1, [pc, #104]	; (800c948 <__ieee754_sqrtf+0xa0>)
 800c8de:	15c4      	asrs	r4, r0, #23
 800c8e0:	428a      	cmp	r2, r1
 800c8e2:	d808      	bhi.n	800c8f6 <__ieee754_sqrtf+0x4e>
 800c8e4:	2200      	movs	r2, #0
 800c8e6:	3101      	adds	r1, #1
 800c8e8:	420b      	tst	r3, r1
 800c8ea:	d102      	bne.n	800c8f2 <__ieee754_sqrtf+0x4a>
 800c8ec:	005b      	lsls	r3, r3, #1
 800c8ee:	3201      	adds	r2, #1
 800c8f0:	e7fa      	b.n	800c8e8 <__ieee754_sqrtf+0x40>
 800c8f2:	3a01      	subs	r2, #1
 800c8f4:	1aa4      	subs	r4, r4, r2
 800c8f6:	2280      	movs	r2, #128	; 0x80
 800c8f8:	025b      	lsls	r3, r3, #9
 800c8fa:	0a5b      	lsrs	r3, r3, #9
 800c8fc:	0412      	lsls	r2, r2, #16
 800c8fe:	3c7f      	subs	r4, #127	; 0x7f
 800c900:	4313      	orrs	r3, r2
 800c902:	07e2      	lsls	r2, r4, #31
 800c904:	d500      	bpl.n	800c908 <__ieee754_sqrtf+0x60>
 800c906:	005b      	lsls	r3, r3, #1
 800c908:	2200      	movs	r2, #0
 800c90a:	2180      	movs	r1, #128	; 0x80
 800c90c:	2019      	movs	r0, #25
 800c90e:	0016      	movs	r6, r2
 800c910:	1064      	asrs	r4, r4, #1
 800c912:	005b      	lsls	r3, r3, #1
 800c914:	0449      	lsls	r1, r1, #17
 800c916:	1875      	adds	r5, r6, r1
 800c918:	429d      	cmp	r5, r3
 800c91a:	dc02      	bgt.n	800c922 <__ieee754_sqrtf+0x7a>
 800c91c:	186e      	adds	r6, r5, r1
 800c91e:	1b5b      	subs	r3, r3, r5
 800c920:	1852      	adds	r2, r2, r1
 800c922:	3801      	subs	r0, #1
 800c924:	005b      	lsls	r3, r3, #1
 800c926:	0849      	lsrs	r1, r1, #1
 800c928:	2800      	cmp	r0, #0
 800c92a:	d1f4      	bne.n	800c916 <__ieee754_sqrtf+0x6e>
 800c92c:	2b00      	cmp	r3, #0
 800c92e:	d002      	beq.n	800c936 <__ieee754_sqrtf+0x8e>
 800c930:	2301      	movs	r3, #1
 800c932:	4013      	ands	r3, r2
 800c934:	18d2      	adds	r2, r2, r3
 800c936:	23fc      	movs	r3, #252	; 0xfc
 800c938:	1052      	asrs	r2, r2, #1
 800c93a:	059b      	lsls	r3, r3, #22
 800c93c:	18d2      	adds	r2, r2, r3
 800c93e:	05e0      	lsls	r0, r4, #23
 800c940:	1880      	adds	r0, r0, r2
 800c942:	bd70      	pop	{r4, r5, r6, pc}
 800c944:	7f7fffff 	.word	0x7f7fffff
 800c948:	007fffff 	.word	0x007fffff

0800c94c <__kernel_cosf>:
 800c94c:	4b40      	ldr	r3, [pc, #256]	; (800ca50 <__kernel_cosf+0x104>)
 800c94e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800c950:	0045      	lsls	r5, r0, #1
 800c952:	1c06      	adds	r6, r0, #0
 800c954:	1c0f      	adds	r7, r1, #0
 800c956:	086d      	lsrs	r5, r5, #1
 800c958:	429d      	cmp	r5, r3
 800c95a:	dc03      	bgt.n	800c964 <__kernel_cosf+0x18>
 800c95c:	f7f4 fb0a 	bl	8000f74 <__aeabi_f2iz>
 800c960:	2800      	cmp	r0, #0
 800c962:	d071      	beq.n	800ca48 <__kernel_cosf+0xfc>
 800c964:	1c31      	adds	r1, r6, #0
 800c966:	1c30      	adds	r0, r6, #0
 800c968:	f7f4 f852 	bl	8000a10 <__aeabi_fmul>
 800c96c:	4939      	ldr	r1, [pc, #228]	; (800ca54 <__kernel_cosf+0x108>)
 800c96e:	1c04      	adds	r4, r0, #0
 800c970:	f7f4 f84e 	bl	8000a10 <__aeabi_fmul>
 800c974:	4938      	ldr	r1, [pc, #224]	; (800ca58 <__kernel_cosf+0x10c>)
 800c976:	f7f3 fd0b 	bl	8000390 <__aeabi_fadd>
 800c97a:	1c21      	adds	r1, r4, #0
 800c97c:	f7f4 f848 	bl	8000a10 <__aeabi_fmul>
 800c980:	4936      	ldr	r1, [pc, #216]	; (800ca5c <__kernel_cosf+0x110>)
 800c982:	f7f4 f959 	bl	8000c38 <__aeabi_fsub>
 800c986:	1c21      	adds	r1, r4, #0
 800c988:	f7f4 f842 	bl	8000a10 <__aeabi_fmul>
 800c98c:	4934      	ldr	r1, [pc, #208]	; (800ca60 <__kernel_cosf+0x114>)
 800c98e:	f7f3 fcff 	bl	8000390 <__aeabi_fadd>
 800c992:	1c21      	adds	r1, r4, #0
 800c994:	f7f4 f83c 	bl	8000a10 <__aeabi_fmul>
 800c998:	4932      	ldr	r1, [pc, #200]	; (800ca64 <__kernel_cosf+0x118>)
 800c99a:	f7f4 f94d 	bl	8000c38 <__aeabi_fsub>
 800c99e:	1c21      	adds	r1, r4, #0
 800c9a0:	f7f4 f836 	bl	8000a10 <__aeabi_fmul>
 800c9a4:	4930      	ldr	r1, [pc, #192]	; (800ca68 <__kernel_cosf+0x11c>)
 800c9a6:	f7f3 fcf3 	bl	8000390 <__aeabi_fadd>
 800c9aa:	1c21      	adds	r1, r4, #0
 800c9ac:	f7f4 f830 	bl	8000a10 <__aeabi_fmul>
 800c9b0:	4b2e      	ldr	r3, [pc, #184]	; (800ca6c <__kernel_cosf+0x120>)
 800c9b2:	9000      	str	r0, [sp, #0]
 800c9b4:	429d      	cmp	r5, r3
 800c9b6:	dc1a      	bgt.n	800c9ee <__kernel_cosf+0xa2>
 800c9b8:	21fc      	movs	r1, #252	; 0xfc
 800c9ba:	1c20      	adds	r0, r4, #0
 800c9bc:	0589      	lsls	r1, r1, #22
 800c9be:	f7f4 f827 	bl	8000a10 <__aeabi_fmul>
 800c9c2:	9900      	ldr	r1, [sp, #0]
 800c9c4:	1c05      	adds	r5, r0, #0
 800c9c6:	1c20      	adds	r0, r4, #0
 800c9c8:	f7f4 f822 	bl	8000a10 <__aeabi_fmul>
 800c9cc:	1c39      	adds	r1, r7, #0
 800c9ce:	1c04      	adds	r4, r0, #0
 800c9d0:	1c30      	adds	r0, r6, #0
 800c9d2:	f7f4 f81d 	bl	8000a10 <__aeabi_fmul>
 800c9d6:	1c01      	adds	r1, r0, #0
 800c9d8:	1c20      	adds	r0, r4, #0
 800c9da:	f7f4 f92d 	bl	8000c38 <__aeabi_fsub>
 800c9de:	1c01      	adds	r1, r0, #0
 800c9e0:	1c28      	adds	r0, r5, #0
 800c9e2:	f7f4 f929 	bl	8000c38 <__aeabi_fsub>
 800c9e6:	1c01      	adds	r1, r0, #0
 800c9e8:	20fe      	movs	r0, #254	; 0xfe
 800c9ea:	0580      	lsls	r0, r0, #22
 800c9ec:	e029      	b.n	800ca42 <__kernel_cosf+0xf6>
 800c9ee:	4b20      	ldr	r3, [pc, #128]	; (800ca70 <__kernel_cosf+0x124>)
 800c9f0:	429d      	cmp	r5, r3
 800c9f2:	dc03      	bgt.n	800c9fc <__kernel_cosf+0xb0>
 800c9f4:	23ff      	movs	r3, #255	; 0xff
 800c9f6:	061b      	lsls	r3, r3, #24
 800c9f8:	18ed      	adds	r5, r5, r3
 800c9fa:	e000      	b.n	800c9fe <__kernel_cosf+0xb2>
 800c9fc:	4d1d      	ldr	r5, [pc, #116]	; (800ca74 <__kernel_cosf+0x128>)
 800c9fe:	20fe      	movs	r0, #254	; 0xfe
 800ca00:	1c29      	adds	r1, r5, #0
 800ca02:	0580      	lsls	r0, r0, #22
 800ca04:	f7f4 f918 	bl	8000c38 <__aeabi_fsub>
 800ca08:	21fc      	movs	r1, #252	; 0xfc
 800ca0a:	9001      	str	r0, [sp, #4]
 800ca0c:	0589      	lsls	r1, r1, #22
 800ca0e:	1c20      	adds	r0, r4, #0
 800ca10:	f7f3 fffe 	bl	8000a10 <__aeabi_fmul>
 800ca14:	1c29      	adds	r1, r5, #0
 800ca16:	f7f4 f90f 	bl	8000c38 <__aeabi_fsub>
 800ca1a:	9900      	ldr	r1, [sp, #0]
 800ca1c:	1c05      	adds	r5, r0, #0
 800ca1e:	1c20      	adds	r0, r4, #0
 800ca20:	f7f3 fff6 	bl	8000a10 <__aeabi_fmul>
 800ca24:	1c39      	adds	r1, r7, #0
 800ca26:	1c04      	adds	r4, r0, #0
 800ca28:	1c30      	adds	r0, r6, #0
 800ca2a:	f7f3 fff1 	bl	8000a10 <__aeabi_fmul>
 800ca2e:	1c01      	adds	r1, r0, #0
 800ca30:	1c20      	adds	r0, r4, #0
 800ca32:	f7f4 f901 	bl	8000c38 <__aeabi_fsub>
 800ca36:	1c01      	adds	r1, r0, #0
 800ca38:	1c28      	adds	r0, r5, #0
 800ca3a:	f7f4 f8fd 	bl	8000c38 <__aeabi_fsub>
 800ca3e:	1c01      	adds	r1, r0, #0
 800ca40:	9801      	ldr	r0, [sp, #4]
 800ca42:	f7f4 f8f9 	bl	8000c38 <__aeabi_fsub>
 800ca46:	e001      	b.n	800ca4c <__kernel_cosf+0x100>
 800ca48:	20fe      	movs	r0, #254	; 0xfe
 800ca4a:	0580      	lsls	r0, r0, #22
 800ca4c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800ca4e:	46c0      	nop			; (mov r8, r8)
 800ca50:	31ffffff 	.word	0x31ffffff
 800ca54:	ad47d74e 	.word	0xad47d74e
 800ca58:	310f74f6 	.word	0x310f74f6
 800ca5c:	3493f27c 	.word	0x3493f27c
 800ca60:	37d00d01 	.word	0x37d00d01
 800ca64:	3ab60b61 	.word	0x3ab60b61
 800ca68:	3d2aaaab 	.word	0x3d2aaaab
 800ca6c:	3e999999 	.word	0x3e999999
 800ca70:	3f480000 	.word	0x3f480000
 800ca74:	3e900000 	.word	0x3e900000

0800ca78 <__kernel_rem_pio2f>:
 800ca78:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ca7a:	b0e1      	sub	sp, #388	; 0x184
 800ca7c:	9308      	str	r3, [sp, #32]
 800ca7e:	9b66      	ldr	r3, [sp, #408]	; 0x198
 800ca80:	9103      	str	r1, [sp, #12]
 800ca82:	0099      	lsls	r1, r3, #2
 800ca84:	4bd9      	ldr	r3, [pc, #868]	; (800cdec <__kernel_rem_pio2f+0x374>)
 800ca86:	9009      	str	r0, [sp, #36]	; 0x24
 800ca88:	58cb      	ldr	r3, [r1, r3]
 800ca8a:	2107      	movs	r1, #7
 800ca8c:	9305      	str	r3, [sp, #20]
 800ca8e:	9b08      	ldr	r3, [sp, #32]
 800ca90:	2400      	movs	r4, #0
 800ca92:	3b01      	subs	r3, #1
 800ca94:	9307      	str	r3, [sp, #28]
 800ca96:	1ed3      	subs	r3, r2, #3
 800ca98:	17d8      	asrs	r0, r3, #31
 800ca9a:	4001      	ands	r1, r0
 800ca9c:	18cb      	adds	r3, r1, r3
 800ca9e:	10db      	asrs	r3, r3, #3
 800caa0:	9306      	str	r3, [sp, #24]
 800caa2:	43db      	mvns	r3, r3
 800caa4:	9906      	ldr	r1, [sp, #24]
 800caa6:	17db      	asrs	r3, r3, #31
 800caa8:	4019      	ands	r1, r3
 800caaa:	000b      	movs	r3, r1
 800caac:	3301      	adds	r3, #1
 800caae:	00db      	lsls	r3, r3, #3
 800cab0:	1ad3      	subs	r3, r2, r3
 800cab2:	9301      	str	r3, [sp, #4]
 800cab4:	9a07      	ldr	r2, [sp, #28]
 800cab6:	9b05      	ldr	r3, [sp, #20]
 800cab8:	1a8e      	subs	r6, r1, r2
 800caba:	189f      	adds	r7, r3, r2
 800cabc:	9b67      	ldr	r3, [sp, #412]	; 0x19c
 800cabe:	00b5      	lsls	r5, r6, #2
 800cac0:	9106      	str	r1, [sp, #24]
 800cac2:	195d      	adds	r5, r3, r5
 800cac4:	42bc      	cmp	r4, r7
 800cac6:	dc0b      	bgt.n	800cae0 <__kernel_rem_pio2f+0x68>
 800cac8:	2000      	movs	r0, #0
 800caca:	42e6      	cmn	r6, r4
 800cacc:	d403      	bmi.n	800cad6 <__kernel_rem_pio2f+0x5e>
 800cace:	00a3      	lsls	r3, r4, #2
 800cad0:	58e8      	ldr	r0, [r5, r3]
 800cad2:	f7f4 fa71 	bl	8000fb8 <__aeabi_i2f>
 800cad6:	00a2      	lsls	r2, r4, #2
 800cad8:	ab24      	add	r3, sp, #144	; 0x90
 800cada:	50d0      	str	r0, [r2, r3]
 800cadc:	3401      	adds	r4, #1
 800cade:	e7f1      	b.n	800cac4 <__kernel_rem_pio2f+0x4c>
 800cae0:	2400      	movs	r4, #0
 800cae2:	9b05      	ldr	r3, [sp, #20]
 800cae4:	429c      	cmp	r4, r3
 800cae6:	dc1e      	bgt.n	800cb26 <__kernel_rem_pio2f+0xae>
 800cae8:	2600      	movs	r6, #0
 800caea:	2500      	movs	r5, #0
 800caec:	9b08      	ldr	r3, [sp, #32]
 800caee:	191f      	adds	r7, r3, r4
 800caf0:	00bf      	lsls	r7, r7, #2
 800caf2:	9b07      	ldr	r3, [sp, #28]
 800caf4:	429d      	cmp	r5, r3
 800caf6:	dc11      	bgt.n	800cb1c <__kernel_rem_pio2f+0xa4>
 800caf8:	2050      	movs	r0, #80	; 0x50
 800cafa:	9909      	ldr	r1, [sp, #36]	; 0x24
 800cafc:	00aa      	lsls	r2, r5, #2
 800cafe:	5889      	ldr	r1, [r1, r2]
 800cb00:	1abb      	subs	r3, r7, r2
 800cb02:	aa10      	add	r2, sp, #64	; 0x40
 800cb04:	3b04      	subs	r3, #4
 800cb06:	1812      	adds	r2, r2, r0
 800cb08:	58d0      	ldr	r0, [r2, r3]
 800cb0a:	f7f3 ff81 	bl	8000a10 <__aeabi_fmul>
 800cb0e:	1c01      	adds	r1, r0, #0
 800cb10:	1c30      	adds	r0, r6, #0
 800cb12:	f7f3 fc3d 	bl	8000390 <__aeabi_fadd>
 800cb16:	3501      	adds	r5, #1
 800cb18:	1c06      	adds	r6, r0, #0
 800cb1a:	e7ea      	b.n	800caf2 <__kernel_rem_pio2f+0x7a>
 800cb1c:	00a2      	lsls	r2, r4, #2
 800cb1e:	ab4c      	add	r3, sp, #304	; 0x130
 800cb20:	50d6      	str	r6, [r2, r3]
 800cb22:	3401      	adds	r4, #1
 800cb24:	e7dd      	b.n	800cae2 <__kernel_rem_pio2f+0x6a>
 800cb26:	9b05      	ldr	r3, [sp, #20]
 800cb28:	aa10      	add	r2, sp, #64	; 0x40
 800cb2a:	009b      	lsls	r3, r3, #2
 800cb2c:	189b      	adds	r3, r3, r2
 800cb2e:	9f05      	ldr	r7, [sp, #20]
 800cb30:	930b      	str	r3, [sp, #44]	; 0x2c
 800cb32:	00bb      	lsls	r3, r7, #2
 800cb34:	00ba      	lsls	r2, r7, #2
 800cb36:	930e      	str	r3, [sp, #56]	; 0x38
 800cb38:	ab4c      	add	r3, sp, #304	; 0x130
 800cb3a:	58d5      	ldr	r5, [r2, r3]
 800cb3c:	0013      	movs	r3, r2
 800cb3e:	003c      	movs	r4, r7
 800cb40:	aa10      	add	r2, sp, #64	; 0x40
 800cb42:	189b      	adds	r3, r3, r2
 800cb44:	9304      	str	r3, [sp, #16]
 800cb46:	2c00      	cmp	r4, #0
 800cb48:	dd20      	ble.n	800cb8c <__kernel_rem_pio2f+0x114>
 800cb4a:	21ee      	movs	r1, #238	; 0xee
 800cb4c:	1c28      	adds	r0, r5, #0
 800cb4e:	0589      	lsls	r1, r1, #22
 800cb50:	f7f3 ff5e 	bl	8000a10 <__aeabi_fmul>
 800cb54:	f7f4 fa0e 	bl	8000f74 <__aeabi_f2iz>
 800cb58:	f7f4 fa2e 	bl	8000fb8 <__aeabi_i2f>
 800cb5c:	2187      	movs	r1, #135	; 0x87
 800cb5e:	05c9      	lsls	r1, r1, #23
 800cb60:	9002      	str	r0, [sp, #8]
 800cb62:	f7f3 ff55 	bl	8000a10 <__aeabi_fmul>
 800cb66:	1c01      	adds	r1, r0, #0
 800cb68:	1c28      	adds	r0, r5, #0
 800cb6a:	f7f4 f865 	bl	8000c38 <__aeabi_fsub>
 800cb6e:	f7f4 fa01 	bl	8000f74 <__aeabi_f2iz>
 800cb72:	00a6      	lsls	r6, r4, #2
 800cb74:	9b04      	ldr	r3, [sp, #16]
 800cb76:	4276      	negs	r6, r6
 800cb78:	3c01      	subs	r4, #1
 800cb7a:	5198      	str	r0, [r3, r6]
 800cb7c:	00a2      	lsls	r2, r4, #2
 800cb7e:	ab4c      	add	r3, sp, #304	; 0x130
 800cb80:	58d1      	ldr	r1, [r2, r3]
 800cb82:	9802      	ldr	r0, [sp, #8]
 800cb84:	f7f3 fc04 	bl	8000390 <__aeabi_fadd>
 800cb88:	1c05      	adds	r5, r0, #0
 800cb8a:	e7dc      	b.n	800cb46 <__kernel_rem_pio2f+0xce>
 800cb8c:	9901      	ldr	r1, [sp, #4]
 800cb8e:	1c28      	adds	r0, r5, #0
 800cb90:	f000 fbbc 	bl	800d30c <scalbnf>
 800cb94:	21f8      	movs	r1, #248	; 0xf8
 800cb96:	0589      	lsls	r1, r1, #22
 800cb98:	1c04      	adds	r4, r0, #0
 800cb9a:	f7f3 ff39 	bl	8000a10 <__aeabi_fmul>
 800cb9e:	f7ff fba3 	bl	800c2e8 <floorf>
 800cba2:	2182      	movs	r1, #130	; 0x82
 800cba4:	05c9      	lsls	r1, r1, #23
 800cba6:	f7f3 ff33 	bl	8000a10 <__aeabi_fmul>
 800cbaa:	1c01      	adds	r1, r0, #0
 800cbac:	1c20      	adds	r0, r4, #0
 800cbae:	f7f4 f843 	bl	8000c38 <__aeabi_fsub>
 800cbb2:	1c04      	adds	r4, r0, #0
 800cbb4:	f7f4 f9de 	bl	8000f74 <__aeabi_f2iz>
 800cbb8:	9004      	str	r0, [sp, #16]
 800cbba:	f7f4 f9fd 	bl	8000fb8 <__aeabi_i2f>
 800cbbe:	1c01      	adds	r1, r0, #0
 800cbc0:	1c20      	adds	r0, r4, #0
 800cbc2:	f7f4 f839 	bl	8000c38 <__aeabi_fsub>
 800cbc6:	9b01      	ldr	r3, [sp, #4]
 800cbc8:	1c04      	adds	r4, r0, #0
 800cbca:	2b00      	cmp	r3, #0
 800cbcc:	dd15      	ble.n	800cbfa <__kernel_rem_pio2f+0x182>
 800cbce:	2108      	movs	r1, #8
 800cbd0:	1e7b      	subs	r3, r7, #1
 800cbd2:	009b      	lsls	r3, r3, #2
 800cbd4:	aa10      	add	r2, sp, #64	; 0x40
 800cbd6:	589a      	ldr	r2, [r3, r2]
 800cbd8:	9801      	ldr	r0, [sp, #4]
 800cbda:	9d04      	ldr	r5, [sp, #16]
 800cbdc:	1a09      	subs	r1, r1, r0
 800cbde:	0010      	movs	r0, r2
 800cbe0:	4108      	asrs	r0, r1
 800cbe2:	182d      	adds	r5, r5, r0
 800cbe4:	4088      	lsls	r0, r1
 800cbe6:	1a10      	subs	r0, r2, r0
 800cbe8:	aa10      	add	r2, sp, #64	; 0x40
 800cbea:	5098      	str	r0, [r3, r2]
 800cbec:	2307      	movs	r3, #7
 800cbee:	9a01      	ldr	r2, [sp, #4]
 800cbf0:	9504      	str	r5, [sp, #16]
 800cbf2:	1a9b      	subs	r3, r3, r2
 800cbf4:	4118      	asrs	r0, r3
 800cbf6:	9002      	str	r0, [sp, #8]
 800cbf8:	e011      	b.n	800cc1e <__kernel_rem_pio2f+0x1a6>
 800cbfa:	9b01      	ldr	r3, [sp, #4]
 800cbfc:	2b00      	cmp	r3, #0
 800cbfe:	d106      	bne.n	800cc0e <__kernel_rem_pio2f+0x196>
 800cc00:	1e7b      	subs	r3, r7, #1
 800cc02:	009b      	lsls	r3, r3, #2
 800cc04:	aa10      	add	r2, sp, #64	; 0x40
 800cc06:	5898      	ldr	r0, [r3, r2]
 800cc08:	1203      	asrs	r3, r0, #8
 800cc0a:	9302      	str	r3, [sp, #8]
 800cc0c:	e007      	b.n	800cc1e <__kernel_rem_pio2f+0x1a6>
 800cc0e:	21fc      	movs	r1, #252	; 0xfc
 800cc10:	0589      	lsls	r1, r1, #22
 800cc12:	f7f3 fb7d 	bl	8000310 <__aeabi_fcmpge>
 800cc16:	2800      	cmp	r0, #0
 800cc18:	d105      	bne.n	800cc26 <__kernel_rem_pio2f+0x1ae>
 800cc1a:	9002      	str	r0, [sp, #8]
 800cc1c:	e04b      	b.n	800ccb6 <__kernel_rem_pio2f+0x23e>
 800cc1e:	9b02      	ldr	r3, [sp, #8]
 800cc20:	2b00      	cmp	r3, #0
 800cc22:	dc02      	bgt.n	800cc2a <__kernel_rem_pio2f+0x1b2>
 800cc24:	e047      	b.n	800ccb6 <__kernel_rem_pio2f+0x23e>
 800cc26:	2302      	movs	r3, #2
 800cc28:	9302      	str	r3, [sp, #8]
 800cc2a:	2200      	movs	r2, #0
 800cc2c:	2680      	movs	r6, #128	; 0x80
 800cc2e:	0015      	movs	r5, r2
 800cc30:	20ff      	movs	r0, #255	; 0xff
 800cc32:	9b04      	ldr	r3, [sp, #16]
 800cc34:	0076      	lsls	r6, r6, #1
 800cc36:	3301      	adds	r3, #1
 800cc38:	9304      	str	r3, [sp, #16]
 800cc3a:	4297      	cmp	r7, r2
 800cc3c:	dd0e      	ble.n	800cc5c <__kernel_rem_pio2f+0x1e4>
 800cc3e:	0091      	lsls	r1, r2, #2
 800cc40:	ab10      	add	r3, sp, #64	; 0x40
 800cc42:	58cb      	ldr	r3, [r1, r3]
 800cc44:	2d00      	cmp	r5, #0
 800cc46:	d103      	bne.n	800cc50 <__kernel_rem_pio2f+0x1d8>
 800cc48:	2b00      	cmp	r3, #0
 800cc4a:	d005      	beq.n	800cc58 <__kernel_rem_pio2f+0x1e0>
 800cc4c:	1af3      	subs	r3, r6, r3
 800cc4e:	e000      	b.n	800cc52 <__kernel_rem_pio2f+0x1da>
 800cc50:	1ac3      	subs	r3, r0, r3
 800cc52:	ad10      	add	r5, sp, #64	; 0x40
 800cc54:	514b      	str	r3, [r1, r5]
 800cc56:	2501      	movs	r5, #1
 800cc58:	3201      	adds	r2, #1
 800cc5a:	e7ee      	b.n	800cc3a <__kernel_rem_pio2f+0x1c2>
 800cc5c:	9b01      	ldr	r3, [sp, #4]
 800cc5e:	2b00      	cmp	r3, #0
 800cc60:	dd14      	ble.n	800cc8c <__kernel_rem_pio2f+0x214>
 800cc62:	2b01      	cmp	r3, #1
 800cc64:	d008      	beq.n	800cc78 <__kernel_rem_pio2f+0x200>
 800cc66:	2b02      	cmp	r3, #2
 800cc68:	d110      	bne.n	800cc8c <__kernel_rem_pio2f+0x214>
 800cc6a:	1e7b      	subs	r3, r7, #1
 800cc6c:	009b      	lsls	r3, r3, #2
 800cc6e:	aa10      	add	r2, sp, #64	; 0x40
 800cc70:	589a      	ldr	r2, [r3, r2]
 800cc72:	920a      	str	r2, [sp, #40]	; 0x28
 800cc74:	223f      	movs	r2, #63	; 0x3f
 800cc76:	e005      	b.n	800cc84 <__kernel_rem_pio2f+0x20c>
 800cc78:	1e7b      	subs	r3, r7, #1
 800cc7a:	009b      	lsls	r3, r3, #2
 800cc7c:	aa10      	add	r2, sp, #64	; 0x40
 800cc7e:	589a      	ldr	r2, [r3, r2]
 800cc80:	920a      	str	r2, [sp, #40]	; 0x28
 800cc82:	227f      	movs	r2, #127	; 0x7f
 800cc84:	990a      	ldr	r1, [sp, #40]	; 0x28
 800cc86:	400a      	ands	r2, r1
 800cc88:	a910      	add	r1, sp, #64	; 0x40
 800cc8a:	505a      	str	r2, [r3, r1]
 800cc8c:	9b02      	ldr	r3, [sp, #8]
 800cc8e:	2b02      	cmp	r3, #2
 800cc90:	d111      	bne.n	800ccb6 <__kernel_rem_pio2f+0x23e>
 800cc92:	20fe      	movs	r0, #254	; 0xfe
 800cc94:	1c21      	adds	r1, r4, #0
 800cc96:	0580      	lsls	r0, r0, #22
 800cc98:	f7f3 ffce 	bl	8000c38 <__aeabi_fsub>
 800cc9c:	1c04      	adds	r4, r0, #0
 800cc9e:	2d00      	cmp	r5, #0
 800cca0:	d009      	beq.n	800ccb6 <__kernel_rem_pio2f+0x23e>
 800cca2:	20fe      	movs	r0, #254	; 0xfe
 800cca4:	9901      	ldr	r1, [sp, #4]
 800cca6:	0580      	lsls	r0, r0, #22
 800cca8:	f000 fb30 	bl	800d30c <scalbnf>
 800ccac:	1c01      	adds	r1, r0, #0
 800ccae:	1c20      	adds	r0, r4, #0
 800ccb0:	f7f3 ffc2 	bl	8000c38 <__aeabi_fsub>
 800ccb4:	1c04      	adds	r4, r0, #0
 800ccb6:	2100      	movs	r1, #0
 800ccb8:	1c20      	adds	r0, r4, #0
 800ccba:	f7f3 fb05 	bl	80002c8 <__aeabi_fcmpeq>
 800ccbe:	2800      	cmp	r0, #0
 800ccc0:	d066      	beq.n	800cd90 <__kernel_rem_pio2f+0x318>
 800ccc2:	003b      	movs	r3, r7
 800ccc4:	2200      	movs	r2, #0
 800ccc6:	1e78      	subs	r0, r7, #1
 800ccc8:	9905      	ldr	r1, [sp, #20]
 800ccca:	3b01      	subs	r3, #1
 800cccc:	4299      	cmp	r1, r3
 800ccce:	dc04      	bgt.n	800ccda <__kernel_rem_pio2f+0x262>
 800ccd0:	0099      	lsls	r1, r3, #2
 800ccd2:	ac10      	add	r4, sp, #64	; 0x40
 800ccd4:	5909      	ldr	r1, [r1, r4]
 800ccd6:	430a      	orrs	r2, r1
 800ccd8:	e7f6      	b.n	800ccc8 <__kernel_rem_pio2f+0x250>
 800ccda:	2a00      	cmp	r2, #0
 800ccdc:	d14a      	bne.n	800cd74 <__kernel_rem_pio2f+0x2fc>
 800ccde:	2301      	movs	r3, #1
 800cce0:	009a      	lsls	r2, r3, #2
 800cce2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800cce4:	4252      	negs	r2, r2
 800cce6:	588a      	ldr	r2, [r1, r2]
 800cce8:	2a00      	cmp	r2, #0
 800ccea:	d101      	bne.n	800ccf0 <__kernel_rem_pio2f+0x278>
 800ccec:	3301      	adds	r3, #1
 800ccee:	e7f7      	b.n	800cce0 <__kernel_rem_pio2f+0x268>
 800ccf0:	2400      	movs	r4, #0
 800ccf2:	1c7a      	adds	r2, r7, #1
 800ccf4:	9202      	str	r2, [sp, #8]
 800ccf6:	9a06      	ldr	r2, [sp, #24]
 800ccf8:	18fb      	adds	r3, r7, r3
 800ccfa:	19d2      	adds	r2, r2, r7
 800ccfc:	0092      	lsls	r2, r2, #2
 800ccfe:	920c      	str	r2, [sp, #48]	; 0x30
 800cd00:	9a08      	ldr	r2, [sp, #32]
 800cd02:	930a      	str	r3, [sp, #40]	; 0x28
 800cd04:	19d2      	adds	r2, r2, r7
 800cd06:	0092      	lsls	r2, r2, #2
 800cd08:	9204      	str	r2, [sp, #16]
 800cd0a:	9904      	ldr	r1, [sp, #16]
 800cd0c:	aa24      	add	r2, sp, #144	; 0x90
 800cd0e:	1851      	adds	r1, r2, r1
 800cd10:	910d      	str	r1, [sp, #52]	; 0x34
 800cd12:	920f      	str	r2, [sp, #60]	; 0x3c
 800cd14:	9b02      	ldr	r3, [sp, #8]
 800cd16:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800cd18:	4293      	cmp	r3, r2
 800cd1a:	dc29      	bgt.n	800cd70 <__kernel_rem_pio2f+0x2f8>
 800cd1c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800cd1e:	9a67      	ldr	r2, [sp, #412]	; 0x19c
 800cd20:	18e3      	adds	r3, r4, r3
 800cd22:	18d3      	adds	r3, r2, r3
 800cd24:	6858      	ldr	r0, [r3, #4]
 800cd26:	f7f4 f947 	bl	8000fb8 <__aeabi_i2f>
 800cd2a:	2500      	movs	r5, #0
 800cd2c:	2600      	movs	r6, #0
 800cd2e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800cd30:	5118      	str	r0, [r3, r4]
 800cd32:	9b04      	ldr	r3, [sp, #16]
 800cd34:	18e7      	adds	r7, r4, r3
 800cd36:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800cd38:	19df      	adds	r7, r3, r7
 800cd3a:	9b07      	ldr	r3, [sp, #28]
 800cd3c:	429d      	cmp	r5, r3
 800cd3e:	dc0d      	bgt.n	800cd5c <__kernel_rem_pio2f+0x2e4>
 800cd40:	00ab      	lsls	r3, r5, #2
 800cd42:	425a      	negs	r2, r3
 800cd44:	58b9      	ldr	r1, [r7, r2]
 800cd46:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800cd48:	3501      	adds	r5, #1
 800cd4a:	58d0      	ldr	r0, [r2, r3]
 800cd4c:	f7f3 fe60 	bl	8000a10 <__aeabi_fmul>
 800cd50:	1c01      	adds	r1, r0, #0
 800cd52:	1c30      	adds	r0, r6, #0
 800cd54:	f7f3 fb1c 	bl	8000390 <__aeabi_fadd>
 800cd58:	1c06      	adds	r6, r0, #0
 800cd5a:	e7ee      	b.n	800cd3a <__kernel_rem_pio2f+0x2c2>
 800cd5c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800cd5e:	aa4c      	add	r2, sp, #304	; 0x130
 800cd60:	18e3      	adds	r3, r4, r3
 800cd62:	18d3      	adds	r3, r2, r3
 800cd64:	605e      	str	r6, [r3, #4]
 800cd66:	9b02      	ldr	r3, [sp, #8]
 800cd68:	3404      	adds	r4, #4
 800cd6a:	3301      	adds	r3, #1
 800cd6c:	9302      	str	r3, [sp, #8]
 800cd6e:	e7d1      	b.n	800cd14 <__kernel_rem_pio2f+0x29c>
 800cd70:	0017      	movs	r7, r2
 800cd72:	e6de      	b.n	800cb32 <__kernel_rem_pio2f+0xba>
 800cd74:	0007      	movs	r7, r0
 800cd76:	9b01      	ldr	r3, [sp, #4]
 800cd78:	3b08      	subs	r3, #8
 800cd7a:	9301      	str	r3, [sp, #4]
 800cd7c:	00bb      	lsls	r3, r7, #2
 800cd7e:	aa10      	add	r2, sp, #64	; 0x40
 800cd80:	589b      	ldr	r3, [r3, r2]
 800cd82:	2b00      	cmp	r3, #0
 800cd84:	d13a      	bne.n	800cdfc <__kernel_rem_pio2f+0x384>
 800cd86:	9b01      	ldr	r3, [sp, #4]
 800cd88:	3f01      	subs	r7, #1
 800cd8a:	3b08      	subs	r3, #8
 800cd8c:	9301      	str	r3, [sp, #4]
 800cd8e:	e7f5      	b.n	800cd7c <__kernel_rem_pio2f+0x304>
 800cd90:	9b01      	ldr	r3, [sp, #4]
 800cd92:	1c20      	adds	r0, r4, #0
 800cd94:	4259      	negs	r1, r3
 800cd96:	f000 fab9 	bl	800d30c <scalbnf>
 800cd9a:	2187      	movs	r1, #135	; 0x87
 800cd9c:	05c9      	lsls	r1, r1, #23
 800cd9e:	1c04      	adds	r4, r0, #0
 800cda0:	f7f3 fab6 	bl	8000310 <__aeabi_fcmpge>
 800cda4:	2800      	cmp	r0, #0
 800cda6:	d023      	beq.n	800cdf0 <__kernel_rem_pio2f+0x378>
 800cda8:	21ee      	movs	r1, #238	; 0xee
 800cdaa:	1c20      	adds	r0, r4, #0
 800cdac:	0589      	lsls	r1, r1, #22
 800cdae:	f7f3 fe2f 	bl	8000a10 <__aeabi_fmul>
 800cdb2:	f7f4 f8df 	bl	8000f74 <__aeabi_f2iz>
 800cdb6:	f7f4 f8ff 	bl	8000fb8 <__aeabi_i2f>
 800cdba:	2187      	movs	r1, #135	; 0x87
 800cdbc:	05c9      	lsls	r1, r1, #23
 800cdbe:	1c05      	adds	r5, r0, #0
 800cdc0:	f7f3 fe26 	bl	8000a10 <__aeabi_fmul>
 800cdc4:	1c01      	adds	r1, r0, #0
 800cdc6:	1c20      	adds	r0, r4, #0
 800cdc8:	f7f3 ff36 	bl	8000c38 <__aeabi_fsub>
 800cdcc:	f7f4 f8d2 	bl	8000f74 <__aeabi_f2iz>
 800cdd0:	00be      	lsls	r6, r7, #2
 800cdd2:	ab10      	add	r3, sp, #64	; 0x40
 800cdd4:	50f0      	str	r0, [r6, r3]
 800cdd6:	9b01      	ldr	r3, [sp, #4]
 800cdd8:	1c28      	adds	r0, r5, #0
 800cdda:	3308      	adds	r3, #8
 800cddc:	9301      	str	r3, [sp, #4]
 800cdde:	f7f4 f8c9 	bl	8000f74 <__aeabi_f2iz>
 800cde2:	3701      	adds	r7, #1
 800cde4:	00bc      	lsls	r4, r7, #2
 800cde6:	ab10      	add	r3, sp, #64	; 0x40
 800cde8:	50e0      	str	r0, [r4, r3]
 800cdea:	e007      	b.n	800cdfc <__kernel_rem_pio2f+0x384>
 800cdec:	0800defc 	.word	0x0800defc
 800cdf0:	1c20      	adds	r0, r4, #0
 800cdf2:	f7f4 f8bf 	bl	8000f74 <__aeabi_f2iz>
 800cdf6:	00bd      	lsls	r5, r7, #2
 800cdf8:	ab10      	add	r3, sp, #64	; 0x40
 800cdfa:	50e8      	str	r0, [r5, r3]
 800cdfc:	20fe      	movs	r0, #254	; 0xfe
 800cdfe:	9901      	ldr	r1, [sp, #4]
 800ce00:	0580      	lsls	r0, r0, #22
 800ce02:	f000 fa83 	bl	800d30c <scalbnf>
 800ce06:	00bb      	lsls	r3, r7, #2
 800ce08:	aa10      	add	r2, sp, #64	; 0x40
 800ce0a:	9306      	str	r3, [sp, #24]
 800ce0c:	189b      	adds	r3, r3, r2
 800ce0e:	00ba      	lsls	r2, r7, #2
 800ce10:	4694      	mov	ip, r2
 800ce12:	003d      	movs	r5, r7
 800ce14:	2400      	movs	r4, #0
 800ce16:	9301      	str	r3, [sp, #4]
 800ce18:	ab4c      	add	r3, sp, #304	; 0x130
 800ce1a:	4463      	add	r3, ip
 800ce1c:	1c06      	adds	r6, r0, #0
 800ce1e:	9307      	str	r3, [sp, #28]
 800ce20:	2d00      	cmp	r5, #0
 800ce22:	db11      	blt.n	800ce48 <__kernel_rem_pio2f+0x3d0>
 800ce24:	9b01      	ldr	r3, [sp, #4]
 800ce26:	3d01      	subs	r5, #1
 800ce28:	5918      	ldr	r0, [r3, r4]
 800ce2a:	f7f4 f8c5 	bl	8000fb8 <__aeabi_i2f>
 800ce2e:	1c31      	adds	r1, r6, #0
 800ce30:	f7f3 fdee 	bl	8000a10 <__aeabi_fmul>
 800ce34:	21ee      	movs	r1, #238	; 0xee
 800ce36:	9b07      	ldr	r3, [sp, #28]
 800ce38:	0589      	lsls	r1, r1, #22
 800ce3a:	5118      	str	r0, [r3, r4]
 800ce3c:	1c30      	adds	r0, r6, #0
 800ce3e:	f7f3 fde7 	bl	8000a10 <__aeabi_fmul>
 800ce42:	3c04      	subs	r4, #4
 800ce44:	1c06      	adds	r6, r0, #0
 800ce46:	e7eb      	b.n	800ce20 <__kernel_rem_pio2f+0x3a8>
 800ce48:	2500      	movs	r5, #0
 800ce4a:	1b7b      	subs	r3, r7, r5
 800ce4c:	d41d      	bmi.n	800ce8a <__kernel_rem_pio2f+0x412>
 800ce4e:	2600      	movs	r6, #0
 800ce50:	2400      	movs	r4, #0
 800ce52:	009b      	lsls	r3, r3, #2
 800ce54:	aa4c      	add	r2, sp, #304	; 0x130
 800ce56:	18d3      	adds	r3, r2, r3
 800ce58:	9301      	str	r3, [sp, #4]
 800ce5a:	9b05      	ldr	r3, [sp, #20]
 800ce5c:	429c      	cmp	r4, r3
 800ce5e:	dc0f      	bgt.n	800ce80 <__kernel_rem_pio2f+0x408>
 800ce60:	42ac      	cmp	r4, r5
 800ce62:	dc0d      	bgt.n	800ce80 <__kernel_rem_pio2f+0x408>
 800ce64:	9a01      	ldr	r2, [sp, #4]
 800ce66:	00a3      	lsls	r3, r4, #2
 800ce68:	58d1      	ldr	r1, [r2, r3]
 800ce6a:	4a5e      	ldr	r2, [pc, #376]	; (800cfe4 <__kernel_rem_pio2f+0x56c>)
 800ce6c:	3401      	adds	r4, #1
 800ce6e:	5898      	ldr	r0, [r3, r2]
 800ce70:	f7f3 fdce 	bl	8000a10 <__aeabi_fmul>
 800ce74:	1c01      	adds	r1, r0, #0
 800ce76:	1c30      	adds	r0, r6, #0
 800ce78:	f7f3 fa8a 	bl	8000390 <__aeabi_fadd>
 800ce7c:	1c06      	adds	r6, r0, #0
 800ce7e:	e7ec      	b.n	800ce5a <__kernel_rem_pio2f+0x3e2>
 800ce80:	00aa      	lsls	r2, r5, #2
 800ce82:	ab38      	add	r3, sp, #224	; 0xe0
 800ce84:	50d6      	str	r6, [r2, r3]
 800ce86:	3501      	adds	r5, #1
 800ce88:	e7df      	b.n	800ce4a <__kernel_rem_pio2f+0x3d2>
 800ce8a:	9b66      	ldr	r3, [sp, #408]	; 0x198
 800ce8c:	2b03      	cmp	r3, #3
 800ce8e:	d900      	bls.n	800ce92 <__kernel_rem_pio2f+0x41a>
 800ce90:	e0a2      	b.n	800cfd8 <__kernel_rem_pio2f+0x560>
 800ce92:	0018      	movs	r0, r3
 800ce94:	f7f3 f938 	bl	8000108 <__gnu_thumb1_case_uqi>
 800ce98:	07020205 	.word	0x07020205
 800ce9c:	003c      	movs	r4, r7
 800ce9e:	2000      	movs	r0, #0
 800cea0:	e01b      	b.n	800ceda <__kernel_rem_pio2f+0x462>
 800cea2:	2000      	movs	r0, #0
 800cea4:	e007      	b.n	800ceb6 <__kernel_rem_pio2f+0x43e>
 800cea6:	aa38      	add	r2, sp, #224	; 0xe0
 800cea8:	4694      	mov	ip, r2
 800ceaa:	9b06      	ldr	r3, [sp, #24]
 800ceac:	003e      	movs	r6, r7
 800ceae:	4463      	add	r3, ip
 800ceb0:	001d      	movs	r5, r3
 800ceb2:	001c      	movs	r4, r3
 800ceb4:	e03a      	b.n	800cf2c <__kernel_rem_pio2f+0x4b4>
 800ceb6:	2f00      	cmp	r7, #0
 800ceb8:	db06      	blt.n	800cec8 <__kernel_rem_pio2f+0x450>
 800ceba:	00ba      	lsls	r2, r7, #2
 800cebc:	ab38      	add	r3, sp, #224	; 0xe0
 800cebe:	58d1      	ldr	r1, [r2, r3]
 800cec0:	f7f3 fa66 	bl	8000390 <__aeabi_fadd>
 800cec4:	3f01      	subs	r7, #1
 800cec6:	e7f6      	b.n	800ceb6 <__kernel_rem_pio2f+0x43e>
 800cec8:	9b02      	ldr	r3, [sp, #8]
 800ceca:	2b00      	cmp	r3, #0
 800cecc:	d002      	beq.n	800ced4 <__kernel_rem_pio2f+0x45c>
 800cece:	2380      	movs	r3, #128	; 0x80
 800ced0:	061b      	lsls	r3, r3, #24
 800ced2:	18c0      	adds	r0, r0, r3
 800ced4:	9b03      	ldr	r3, [sp, #12]
 800ced6:	6018      	str	r0, [r3, #0]
 800ced8:	e07e      	b.n	800cfd8 <__kernel_rem_pio2f+0x560>
 800ceda:	2c00      	cmp	r4, #0
 800cedc:	db06      	blt.n	800ceec <__kernel_rem_pio2f+0x474>
 800cede:	00a2      	lsls	r2, r4, #2
 800cee0:	ab38      	add	r3, sp, #224	; 0xe0
 800cee2:	58d1      	ldr	r1, [r2, r3]
 800cee4:	f7f3 fa54 	bl	8000390 <__aeabi_fadd>
 800cee8:	3c01      	subs	r4, #1
 800ceea:	e7f6      	b.n	800ceda <__kernel_rem_pio2f+0x462>
 800ceec:	9a02      	ldr	r2, [sp, #8]
 800ceee:	1c03      	adds	r3, r0, #0
 800cef0:	2a00      	cmp	r2, #0
 800cef2:	d002      	beq.n	800cefa <__kernel_rem_pio2f+0x482>
 800cef4:	2380      	movs	r3, #128	; 0x80
 800cef6:	061b      	lsls	r3, r3, #24
 800cef8:	18c3      	adds	r3, r0, r3
 800cefa:	9a03      	ldr	r2, [sp, #12]
 800cefc:	1c01      	adds	r1, r0, #0
 800cefe:	6013      	str	r3, [r2, #0]
 800cf00:	9838      	ldr	r0, [sp, #224]	; 0xe0
 800cf02:	f7f3 fe99 	bl	8000c38 <__aeabi_fsub>
 800cf06:	2401      	movs	r4, #1
 800cf08:	42a7      	cmp	r7, r4
 800cf0a:	db06      	blt.n	800cf1a <__kernel_rem_pio2f+0x4a2>
 800cf0c:	00a2      	lsls	r2, r4, #2
 800cf0e:	ab38      	add	r3, sp, #224	; 0xe0
 800cf10:	58d1      	ldr	r1, [r2, r3]
 800cf12:	f7f3 fa3d 	bl	8000390 <__aeabi_fadd>
 800cf16:	3401      	adds	r4, #1
 800cf18:	e7f6      	b.n	800cf08 <__kernel_rem_pio2f+0x490>
 800cf1a:	9b02      	ldr	r3, [sp, #8]
 800cf1c:	2b00      	cmp	r3, #0
 800cf1e:	d002      	beq.n	800cf26 <__kernel_rem_pio2f+0x4ae>
 800cf20:	2380      	movs	r3, #128	; 0x80
 800cf22:	061b      	lsls	r3, r3, #24
 800cf24:	18c0      	adds	r0, r0, r3
 800cf26:	9b03      	ldr	r3, [sp, #12]
 800cf28:	6058      	str	r0, [r3, #4]
 800cf2a:	e055      	b.n	800cfd8 <__kernel_rem_pio2f+0x560>
 800cf2c:	3c04      	subs	r4, #4
 800cf2e:	2e00      	cmp	r6, #0
 800cf30:	dd14      	ble.n	800cf5c <__kernel_rem_pio2f+0x4e4>
 800cf32:	6823      	ldr	r3, [r4, #0]
 800cf34:	3e01      	subs	r6, #1
 800cf36:	9301      	str	r3, [sp, #4]
 800cf38:	6863      	ldr	r3, [r4, #4]
 800cf3a:	9801      	ldr	r0, [sp, #4]
 800cf3c:	1c19      	adds	r1, r3, #0
 800cf3e:	9305      	str	r3, [sp, #20]
 800cf40:	f7f3 fa26 	bl	8000390 <__aeabi_fadd>
 800cf44:	1c01      	adds	r1, r0, #0
 800cf46:	9006      	str	r0, [sp, #24]
 800cf48:	9801      	ldr	r0, [sp, #4]
 800cf4a:	f7f3 fe75 	bl	8000c38 <__aeabi_fsub>
 800cf4e:	9905      	ldr	r1, [sp, #20]
 800cf50:	f7f3 fa1e 	bl	8000390 <__aeabi_fadd>
 800cf54:	9b06      	ldr	r3, [sp, #24]
 800cf56:	6060      	str	r0, [r4, #4]
 800cf58:	6023      	str	r3, [r4, #0]
 800cf5a:	e7e7      	b.n	800cf2c <__kernel_rem_pio2f+0x4b4>
 800cf5c:	003c      	movs	r4, r7
 800cf5e:	3d04      	subs	r5, #4
 800cf60:	2c01      	cmp	r4, #1
 800cf62:	dd13      	ble.n	800cf8c <__kernel_rem_pio2f+0x514>
 800cf64:	682b      	ldr	r3, [r5, #0]
 800cf66:	686e      	ldr	r6, [r5, #4]
 800cf68:	1c18      	adds	r0, r3, #0
 800cf6a:	1c31      	adds	r1, r6, #0
 800cf6c:	9301      	str	r3, [sp, #4]
 800cf6e:	f7f3 fa0f 	bl	8000390 <__aeabi_fadd>
 800cf72:	1c01      	adds	r1, r0, #0
 800cf74:	9005      	str	r0, [sp, #20]
 800cf76:	9801      	ldr	r0, [sp, #4]
 800cf78:	f7f3 fe5e 	bl	8000c38 <__aeabi_fsub>
 800cf7c:	1c31      	adds	r1, r6, #0
 800cf7e:	f7f3 fa07 	bl	8000390 <__aeabi_fadd>
 800cf82:	9b05      	ldr	r3, [sp, #20]
 800cf84:	3c01      	subs	r4, #1
 800cf86:	6068      	str	r0, [r5, #4]
 800cf88:	602b      	str	r3, [r5, #0]
 800cf8a:	e7e8      	b.n	800cf5e <__kernel_rem_pio2f+0x4e6>
 800cf8c:	2000      	movs	r0, #0
 800cf8e:	ab38      	add	r3, sp, #224	; 0xe0
 800cf90:	2f01      	cmp	r7, #1
 800cf92:	dd05      	ble.n	800cfa0 <__kernel_rem_pio2f+0x528>
 800cf94:	00ba      	lsls	r2, r7, #2
 800cf96:	5899      	ldr	r1, [r3, r2]
 800cf98:	f7f3 f9fa 	bl	8000390 <__aeabi_fadd>
 800cf9c:	3f01      	subs	r7, #1
 800cf9e:	e7f6      	b.n	800cf8e <__kernel_rem_pio2f+0x516>
 800cfa0:	9a02      	ldr	r2, [sp, #8]
 800cfa2:	2a00      	cmp	r2, #0
 800cfa4:	d108      	bne.n	800cfb8 <__kernel_rem_pio2f+0x540>
 800cfa6:	9a03      	ldr	r2, [sp, #12]
 800cfa8:	685b      	ldr	r3, [r3, #4]
 800cfaa:	9938      	ldr	r1, [sp, #224]	; 0xe0
 800cfac:	9301      	str	r3, [sp, #4]
 800cfae:	0013      	movs	r3, r2
 800cfb0:	6011      	str	r1, [r2, #0]
 800cfb2:	9a01      	ldr	r2, [sp, #4]
 800cfb4:	605a      	str	r2, [r3, #4]
 800cfb6:	e00e      	b.n	800cfd6 <__kernel_rem_pio2f+0x55e>
 800cfb8:	2180      	movs	r1, #128	; 0x80
 800cfba:	9a38      	ldr	r2, [sp, #224]	; 0xe0
 800cfbc:	0609      	lsls	r1, r1, #24
 800cfbe:	1852      	adds	r2, r2, r1
 800cfc0:	9903      	ldr	r1, [sp, #12]
 800cfc2:	685b      	ldr	r3, [r3, #4]
 800cfc4:	600a      	str	r2, [r1, #0]
 800cfc6:	2280      	movs	r2, #128	; 0x80
 800cfc8:	0612      	lsls	r2, r2, #24
 800cfca:	189b      	adds	r3, r3, r2
 800cfcc:	604b      	str	r3, [r1, #4]
 800cfce:	2380      	movs	r3, #128	; 0x80
 800cfd0:	061b      	lsls	r3, r3, #24
 800cfd2:	18c0      	adds	r0, r0, r3
 800cfd4:	000b      	movs	r3, r1
 800cfd6:	6098      	str	r0, [r3, #8]
 800cfd8:	2007      	movs	r0, #7
 800cfda:	9b04      	ldr	r3, [sp, #16]
 800cfdc:	4003      	ands	r3, r0
 800cfde:	0018      	movs	r0, r3
 800cfe0:	b061      	add	sp, #388	; 0x184
 800cfe2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800cfe4:	0800df08 	.word	0x0800df08

0800cfe8 <__kernel_sinf>:
 800cfe8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800cfea:	9201      	str	r2, [sp, #4]
 800cfec:	4a31      	ldr	r2, [pc, #196]	; (800d0b4 <__kernel_sinf+0xcc>)
 800cfee:	0043      	lsls	r3, r0, #1
 800cff0:	1c04      	adds	r4, r0, #0
 800cff2:	9100      	str	r1, [sp, #0]
 800cff4:	085b      	lsrs	r3, r3, #1
 800cff6:	4293      	cmp	r3, r2
 800cff8:	dc05      	bgt.n	800d006 <__kernel_sinf+0x1e>
 800cffa:	f7f3 ffbb 	bl	8000f74 <__aeabi_f2iz>
 800cffe:	0003      	movs	r3, r0
 800d000:	1c20      	adds	r0, r4, #0
 800d002:	2b00      	cmp	r3, #0
 800d004:	d055      	beq.n	800d0b2 <__kernel_sinf+0xca>
 800d006:	1c21      	adds	r1, r4, #0
 800d008:	1c20      	adds	r0, r4, #0
 800d00a:	f7f3 fd01 	bl	8000a10 <__aeabi_fmul>
 800d00e:	1c05      	adds	r5, r0, #0
 800d010:	1c01      	adds	r1, r0, #0
 800d012:	1c20      	adds	r0, r4, #0
 800d014:	f7f3 fcfc 	bl	8000a10 <__aeabi_fmul>
 800d018:	4927      	ldr	r1, [pc, #156]	; (800d0b8 <__kernel_sinf+0xd0>)
 800d01a:	1c06      	adds	r6, r0, #0
 800d01c:	1c28      	adds	r0, r5, #0
 800d01e:	f7f3 fcf7 	bl	8000a10 <__aeabi_fmul>
 800d022:	4926      	ldr	r1, [pc, #152]	; (800d0bc <__kernel_sinf+0xd4>)
 800d024:	f7f3 fe08 	bl	8000c38 <__aeabi_fsub>
 800d028:	1c29      	adds	r1, r5, #0
 800d02a:	f7f3 fcf1 	bl	8000a10 <__aeabi_fmul>
 800d02e:	4924      	ldr	r1, [pc, #144]	; (800d0c0 <__kernel_sinf+0xd8>)
 800d030:	f7f3 f9ae 	bl	8000390 <__aeabi_fadd>
 800d034:	1c29      	adds	r1, r5, #0
 800d036:	f7f3 fceb 	bl	8000a10 <__aeabi_fmul>
 800d03a:	4922      	ldr	r1, [pc, #136]	; (800d0c4 <__kernel_sinf+0xdc>)
 800d03c:	f7f3 fdfc 	bl	8000c38 <__aeabi_fsub>
 800d040:	1c29      	adds	r1, r5, #0
 800d042:	f7f3 fce5 	bl	8000a10 <__aeabi_fmul>
 800d046:	4920      	ldr	r1, [pc, #128]	; (800d0c8 <__kernel_sinf+0xe0>)
 800d048:	f7f3 f9a2 	bl	8000390 <__aeabi_fadd>
 800d04c:	9b01      	ldr	r3, [sp, #4]
 800d04e:	1c07      	adds	r7, r0, #0
 800d050:	2b00      	cmp	r3, #0
 800d052:	d10d      	bne.n	800d070 <__kernel_sinf+0x88>
 800d054:	1c01      	adds	r1, r0, #0
 800d056:	1c28      	adds	r0, r5, #0
 800d058:	f7f3 fcda 	bl	8000a10 <__aeabi_fmul>
 800d05c:	491b      	ldr	r1, [pc, #108]	; (800d0cc <__kernel_sinf+0xe4>)
 800d05e:	f7f3 fdeb 	bl	8000c38 <__aeabi_fsub>
 800d062:	1c31      	adds	r1, r6, #0
 800d064:	f7f3 fcd4 	bl	8000a10 <__aeabi_fmul>
 800d068:	1c21      	adds	r1, r4, #0
 800d06a:	f7f3 f991 	bl	8000390 <__aeabi_fadd>
 800d06e:	e020      	b.n	800d0b2 <__kernel_sinf+0xca>
 800d070:	21fc      	movs	r1, #252	; 0xfc
 800d072:	9800      	ldr	r0, [sp, #0]
 800d074:	0589      	lsls	r1, r1, #22
 800d076:	f7f3 fccb 	bl	8000a10 <__aeabi_fmul>
 800d07a:	1c39      	adds	r1, r7, #0
 800d07c:	9001      	str	r0, [sp, #4]
 800d07e:	1c30      	adds	r0, r6, #0
 800d080:	f7f3 fcc6 	bl	8000a10 <__aeabi_fmul>
 800d084:	1c01      	adds	r1, r0, #0
 800d086:	9801      	ldr	r0, [sp, #4]
 800d088:	f7f3 fdd6 	bl	8000c38 <__aeabi_fsub>
 800d08c:	1c29      	adds	r1, r5, #0
 800d08e:	f7f3 fcbf 	bl	8000a10 <__aeabi_fmul>
 800d092:	9900      	ldr	r1, [sp, #0]
 800d094:	f7f3 fdd0 	bl	8000c38 <__aeabi_fsub>
 800d098:	490c      	ldr	r1, [pc, #48]	; (800d0cc <__kernel_sinf+0xe4>)
 800d09a:	1c05      	adds	r5, r0, #0
 800d09c:	1c30      	adds	r0, r6, #0
 800d09e:	f7f3 fcb7 	bl	8000a10 <__aeabi_fmul>
 800d0a2:	1c01      	adds	r1, r0, #0
 800d0a4:	1c28      	adds	r0, r5, #0
 800d0a6:	f7f3 f973 	bl	8000390 <__aeabi_fadd>
 800d0aa:	1c01      	adds	r1, r0, #0
 800d0ac:	1c20      	adds	r0, r4, #0
 800d0ae:	f7f3 fdc3 	bl	8000c38 <__aeabi_fsub>
 800d0b2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800d0b4:	31ffffff 	.word	0x31ffffff
 800d0b8:	2f2ec9d3 	.word	0x2f2ec9d3
 800d0bc:	32d72f34 	.word	0x32d72f34
 800d0c0:	3638ef1b 	.word	0x3638ef1b
 800d0c4:	39500d01 	.word	0x39500d01
 800d0c8:	3c088889 	.word	0x3c088889
 800d0cc:	3e2aaaab 	.word	0x3e2aaaab

0800d0d0 <matherr>:
 800d0d0:	2000      	movs	r0, #0
 800d0d2:	4770      	bx	lr

0800d0d4 <atanf>:
 800d0d4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800d0d6:	4b74      	ldr	r3, [pc, #464]	; (800d2a8 <atanf+0x1d4>)
 800d0d8:	0045      	lsls	r5, r0, #1
 800d0da:	1c04      	adds	r4, r0, #0
 800d0dc:	9001      	str	r0, [sp, #4]
 800d0de:	086d      	lsrs	r5, r5, #1
 800d0e0:	429d      	cmp	r5, r3
 800d0e2:	dd0d      	ble.n	800d100 <atanf+0x2c>
 800d0e4:	23ff      	movs	r3, #255	; 0xff
 800d0e6:	05db      	lsls	r3, r3, #23
 800d0e8:	429d      	cmp	r5, r3
 800d0ea:	dd03      	ble.n	800d0f4 <atanf+0x20>
 800d0ec:	1c01      	adds	r1, r0, #0
 800d0ee:	f7f3 f94f 	bl	8000390 <__aeabi_fadd>
 800d0f2:	e0d7      	b.n	800d2a4 <atanf+0x1d0>
 800d0f4:	9b01      	ldr	r3, [sp, #4]
 800d0f6:	2b00      	cmp	r3, #0
 800d0f8:	dd00      	ble.n	800d0fc <atanf+0x28>
 800d0fa:	e0d2      	b.n	800d2a2 <atanf+0x1ce>
 800d0fc:	486b      	ldr	r0, [pc, #428]	; (800d2ac <atanf+0x1d8>)
 800d0fe:	e0d1      	b.n	800d2a4 <atanf+0x1d0>
 800d100:	4b6b      	ldr	r3, [pc, #428]	; (800d2b0 <atanf+0x1dc>)
 800d102:	429d      	cmp	r5, r3
 800d104:	dc0f      	bgt.n	800d126 <atanf+0x52>
 800d106:	4b6b      	ldr	r3, [pc, #428]	; (800d2b4 <atanf+0x1e0>)
 800d108:	429d      	cmp	r5, r3
 800d10a:	dc59      	bgt.n	800d1c0 <atanf+0xec>
 800d10c:	496a      	ldr	r1, [pc, #424]	; (800d2b8 <atanf+0x1e4>)
 800d10e:	f7f3 f93f 	bl	8000390 <__aeabi_fadd>
 800d112:	21fe      	movs	r1, #254	; 0xfe
 800d114:	0589      	lsls	r1, r1, #22
 800d116:	f7f3 f8f1 	bl	80002fc <__aeabi_fcmpgt>
 800d11a:	0003      	movs	r3, r0
 800d11c:	1c20      	adds	r0, r4, #0
 800d11e:	2b00      	cmp	r3, #0
 800d120:	d000      	beq.n	800d124 <atanf+0x50>
 800d122:	e0bf      	b.n	800d2a4 <atanf+0x1d0>
 800d124:	e04c      	b.n	800d1c0 <atanf+0xec>
 800d126:	f000 f8ed 	bl	800d304 <fabsf>
 800d12a:	4b64      	ldr	r3, [pc, #400]	; (800d2bc <atanf+0x1e8>)
 800d12c:	1c04      	adds	r4, r0, #0
 800d12e:	429d      	cmp	r5, r3
 800d130:	dc27      	bgt.n	800d182 <atanf+0xae>
 800d132:	4b63      	ldr	r3, [pc, #396]	; (800d2c0 <atanf+0x1ec>)
 800d134:	429d      	cmp	r5, r3
 800d136:	dc13      	bgt.n	800d160 <atanf+0x8c>
 800d138:	1c01      	adds	r1, r0, #0
 800d13a:	f7f3 f929 	bl	8000390 <__aeabi_fadd>
 800d13e:	21fe      	movs	r1, #254	; 0xfe
 800d140:	0589      	lsls	r1, r1, #22
 800d142:	f7f3 fd79 	bl	8000c38 <__aeabi_fsub>
 800d146:	2180      	movs	r1, #128	; 0x80
 800d148:	1c05      	adds	r5, r0, #0
 800d14a:	05c9      	lsls	r1, r1, #23
 800d14c:	1c20      	adds	r0, r4, #0
 800d14e:	f7f3 f91f 	bl	8000390 <__aeabi_fadd>
 800d152:	1c01      	adds	r1, r0, #0
 800d154:	1c28      	adds	r0, r5, #0
 800d156:	f7f3 fa91 	bl	800067c <__aeabi_fdiv>
 800d15a:	2500      	movs	r5, #0
 800d15c:	1c04      	adds	r4, r0, #0
 800d15e:	e031      	b.n	800d1c4 <atanf+0xf0>
 800d160:	21fe      	movs	r1, #254	; 0xfe
 800d162:	0589      	lsls	r1, r1, #22
 800d164:	f7f3 fd68 	bl	8000c38 <__aeabi_fsub>
 800d168:	21fe      	movs	r1, #254	; 0xfe
 800d16a:	1c05      	adds	r5, r0, #0
 800d16c:	0589      	lsls	r1, r1, #22
 800d16e:	1c20      	adds	r0, r4, #0
 800d170:	f7f3 f90e 	bl	8000390 <__aeabi_fadd>
 800d174:	1c01      	adds	r1, r0, #0
 800d176:	1c28      	adds	r0, r5, #0
 800d178:	f7f3 fa80 	bl	800067c <__aeabi_fdiv>
 800d17c:	2501      	movs	r5, #1
 800d17e:	1c04      	adds	r4, r0, #0
 800d180:	e020      	b.n	800d1c4 <atanf+0xf0>
 800d182:	4b50      	ldr	r3, [pc, #320]	; (800d2c4 <atanf+0x1f0>)
 800d184:	429d      	cmp	r5, r3
 800d186:	dc14      	bgt.n	800d1b2 <atanf+0xde>
 800d188:	21ff      	movs	r1, #255	; 0xff
 800d18a:	0589      	lsls	r1, r1, #22
 800d18c:	f7f3 fd54 	bl	8000c38 <__aeabi_fsub>
 800d190:	21ff      	movs	r1, #255	; 0xff
 800d192:	1c05      	adds	r5, r0, #0
 800d194:	0589      	lsls	r1, r1, #22
 800d196:	1c20      	adds	r0, r4, #0
 800d198:	f7f3 fc3a 	bl	8000a10 <__aeabi_fmul>
 800d19c:	21fe      	movs	r1, #254	; 0xfe
 800d19e:	0589      	lsls	r1, r1, #22
 800d1a0:	f7f3 f8f6 	bl	8000390 <__aeabi_fadd>
 800d1a4:	1c01      	adds	r1, r0, #0
 800d1a6:	1c28      	adds	r0, r5, #0
 800d1a8:	f7f3 fa68 	bl	800067c <__aeabi_fdiv>
 800d1ac:	2502      	movs	r5, #2
 800d1ae:	1c04      	adds	r4, r0, #0
 800d1b0:	e008      	b.n	800d1c4 <atanf+0xf0>
 800d1b2:	1c01      	adds	r1, r0, #0
 800d1b4:	4844      	ldr	r0, [pc, #272]	; (800d2c8 <atanf+0x1f4>)
 800d1b6:	f7f3 fa61 	bl	800067c <__aeabi_fdiv>
 800d1ba:	2503      	movs	r5, #3
 800d1bc:	1c04      	adds	r4, r0, #0
 800d1be:	e001      	b.n	800d1c4 <atanf+0xf0>
 800d1c0:	2501      	movs	r5, #1
 800d1c2:	426d      	negs	r5, r5
 800d1c4:	1c21      	adds	r1, r4, #0
 800d1c6:	1c20      	adds	r0, r4, #0
 800d1c8:	f7f3 fc22 	bl	8000a10 <__aeabi_fmul>
 800d1cc:	1c01      	adds	r1, r0, #0
 800d1ce:	1c07      	adds	r7, r0, #0
 800d1d0:	f7f3 fc1e 	bl	8000a10 <__aeabi_fmul>
 800d1d4:	493d      	ldr	r1, [pc, #244]	; (800d2cc <atanf+0x1f8>)
 800d1d6:	1c06      	adds	r6, r0, #0
 800d1d8:	f7f3 fc1a 	bl	8000a10 <__aeabi_fmul>
 800d1dc:	493c      	ldr	r1, [pc, #240]	; (800d2d0 <atanf+0x1fc>)
 800d1de:	f7f3 f8d7 	bl	8000390 <__aeabi_fadd>
 800d1e2:	1c31      	adds	r1, r6, #0
 800d1e4:	f7f3 fc14 	bl	8000a10 <__aeabi_fmul>
 800d1e8:	493a      	ldr	r1, [pc, #232]	; (800d2d4 <atanf+0x200>)
 800d1ea:	f7f3 f8d1 	bl	8000390 <__aeabi_fadd>
 800d1ee:	1c31      	adds	r1, r6, #0
 800d1f0:	f7f3 fc0e 	bl	8000a10 <__aeabi_fmul>
 800d1f4:	4938      	ldr	r1, [pc, #224]	; (800d2d8 <atanf+0x204>)
 800d1f6:	f7f3 f8cb 	bl	8000390 <__aeabi_fadd>
 800d1fa:	1c31      	adds	r1, r6, #0
 800d1fc:	f7f3 fc08 	bl	8000a10 <__aeabi_fmul>
 800d200:	4936      	ldr	r1, [pc, #216]	; (800d2dc <atanf+0x208>)
 800d202:	f7f3 f8c5 	bl	8000390 <__aeabi_fadd>
 800d206:	1c31      	adds	r1, r6, #0
 800d208:	f7f3 fc02 	bl	8000a10 <__aeabi_fmul>
 800d20c:	4934      	ldr	r1, [pc, #208]	; (800d2e0 <atanf+0x20c>)
 800d20e:	f7f3 f8bf 	bl	8000390 <__aeabi_fadd>
 800d212:	1c39      	adds	r1, r7, #0
 800d214:	f7f3 fbfc 	bl	8000a10 <__aeabi_fmul>
 800d218:	4932      	ldr	r1, [pc, #200]	; (800d2e4 <atanf+0x210>)
 800d21a:	1c07      	adds	r7, r0, #0
 800d21c:	1c30      	adds	r0, r6, #0
 800d21e:	f7f3 fbf7 	bl	8000a10 <__aeabi_fmul>
 800d222:	4931      	ldr	r1, [pc, #196]	; (800d2e8 <atanf+0x214>)
 800d224:	f7f3 fd08 	bl	8000c38 <__aeabi_fsub>
 800d228:	1c31      	adds	r1, r6, #0
 800d22a:	f7f3 fbf1 	bl	8000a10 <__aeabi_fmul>
 800d22e:	492f      	ldr	r1, [pc, #188]	; (800d2ec <atanf+0x218>)
 800d230:	f7f3 fd02 	bl	8000c38 <__aeabi_fsub>
 800d234:	1c31      	adds	r1, r6, #0
 800d236:	f7f3 fbeb 	bl	8000a10 <__aeabi_fmul>
 800d23a:	492d      	ldr	r1, [pc, #180]	; (800d2f0 <atanf+0x21c>)
 800d23c:	f7f3 fcfc 	bl	8000c38 <__aeabi_fsub>
 800d240:	1c31      	adds	r1, r6, #0
 800d242:	f7f3 fbe5 	bl	8000a10 <__aeabi_fmul>
 800d246:	492b      	ldr	r1, [pc, #172]	; (800d2f4 <atanf+0x220>)
 800d248:	f7f3 fcf6 	bl	8000c38 <__aeabi_fsub>
 800d24c:	1c31      	adds	r1, r6, #0
 800d24e:	f7f3 fbdf 	bl	8000a10 <__aeabi_fmul>
 800d252:	1c01      	adds	r1, r0, #0
 800d254:	1c6b      	adds	r3, r5, #1
 800d256:	d10a      	bne.n	800d26e <atanf+0x19a>
 800d258:	1c38      	adds	r0, r7, #0
 800d25a:	f7f3 f899 	bl	8000390 <__aeabi_fadd>
 800d25e:	1c21      	adds	r1, r4, #0
 800d260:	f7f3 fbd6 	bl	8000a10 <__aeabi_fmul>
 800d264:	1c01      	adds	r1, r0, #0
 800d266:	1c20      	adds	r0, r4, #0
 800d268:	f7f3 fce6 	bl	8000c38 <__aeabi_fsub>
 800d26c:	e01a      	b.n	800d2a4 <atanf+0x1d0>
 800d26e:	1c38      	adds	r0, r7, #0
 800d270:	f7f3 f88e 	bl	8000390 <__aeabi_fadd>
 800d274:	1c21      	adds	r1, r4, #0
 800d276:	f7f3 fbcb 	bl	8000a10 <__aeabi_fmul>
 800d27a:	4b1f      	ldr	r3, [pc, #124]	; (800d2f8 <atanf+0x224>)
 800d27c:	00ad      	lsls	r5, r5, #2
 800d27e:	58e9      	ldr	r1, [r5, r3]
 800d280:	f7f3 fcda 	bl	8000c38 <__aeabi_fsub>
 800d284:	1c21      	adds	r1, r4, #0
 800d286:	f7f3 fcd7 	bl	8000c38 <__aeabi_fsub>
 800d28a:	4b1c      	ldr	r3, [pc, #112]	; (800d2fc <atanf+0x228>)
 800d28c:	1c01      	adds	r1, r0, #0
 800d28e:	58e8      	ldr	r0, [r5, r3]
 800d290:	f7f3 fcd2 	bl	8000c38 <__aeabi_fsub>
 800d294:	9b01      	ldr	r3, [sp, #4]
 800d296:	2b00      	cmp	r3, #0
 800d298:	da04      	bge.n	800d2a4 <atanf+0x1d0>
 800d29a:	2380      	movs	r3, #128	; 0x80
 800d29c:	061b      	lsls	r3, r3, #24
 800d29e:	18c0      	adds	r0, r0, r3
 800d2a0:	e000      	b.n	800d2a4 <atanf+0x1d0>
 800d2a2:	4817      	ldr	r0, [pc, #92]	; (800d300 <atanf+0x22c>)
 800d2a4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800d2a6:	46c0      	nop			; (mov r8, r8)
 800d2a8:	507fffff 	.word	0x507fffff
 800d2ac:	bfc90fdb 	.word	0xbfc90fdb
 800d2b0:	3edfffff 	.word	0x3edfffff
 800d2b4:	30ffffff 	.word	0x30ffffff
 800d2b8:	7149f2ca 	.word	0x7149f2ca
 800d2bc:	3f97ffff 	.word	0x3f97ffff
 800d2c0:	3f2fffff 	.word	0x3f2fffff
 800d2c4:	401bffff 	.word	0x401bffff
 800d2c8:	bf800000 	.word	0xbf800000
 800d2cc:	3c8569d7 	.word	0x3c8569d7
 800d2d0:	3d4bda59 	.word	0x3d4bda59
 800d2d4:	3d886b35 	.word	0x3d886b35
 800d2d8:	3dba2e6e 	.word	0x3dba2e6e
 800d2dc:	3e124925 	.word	0x3e124925
 800d2e0:	3eaaaaab 	.word	0x3eaaaaab
 800d2e4:	bd15a221 	.word	0xbd15a221
 800d2e8:	3d6ef16b 	.word	0x3d6ef16b
 800d2ec:	3d9d8795 	.word	0x3d9d8795
 800d2f0:	3de38e38 	.word	0x3de38e38
 800d2f4:	3e4ccccd 	.word	0x3e4ccccd
 800d2f8:	0800df34 	.word	0x0800df34
 800d2fc:	0800df44 	.word	0x0800df44
 800d300:	3fc90fdb 	.word	0x3fc90fdb

0800d304 <fabsf>:
 800d304:	0040      	lsls	r0, r0, #1
 800d306:	0840      	lsrs	r0, r0, #1
 800d308:	4770      	bx	lr
	...

0800d30c <scalbnf>:
 800d30c:	0043      	lsls	r3, r0, #1
 800d30e:	b570      	push	{r4, r5, r6, lr}
 800d310:	1c02      	adds	r2, r0, #0
 800d312:	000c      	movs	r4, r1
 800d314:	085d      	lsrs	r5, r3, #1
 800d316:	0001      	movs	r1, r0
 800d318:	2d00      	cmp	r5, #0
 800d31a:	d040      	beq.n	800d39e <scalbnf+0x92>
 800d31c:	4e20      	ldr	r6, [pc, #128]	; (800d3a0 <scalbnf+0x94>)
 800d31e:	42b5      	cmp	r5, r6
 800d320:	d903      	bls.n	800d32a <scalbnf+0x1e>
 800d322:	1c01      	adds	r1, r0, #0
 800d324:	f7f3 f834 	bl	8000390 <__aeabi_fadd>
 800d328:	e039      	b.n	800d39e <scalbnf+0x92>
 800d32a:	481e      	ldr	r0, [pc, #120]	; (800d3a4 <scalbnf+0x98>)
 800d32c:	4285      	cmp	r5, r0
 800d32e:	d80f      	bhi.n	800d350 <scalbnf+0x44>
 800d330:	2198      	movs	r1, #152	; 0x98
 800d332:	1c10      	adds	r0, r2, #0
 800d334:	05c9      	lsls	r1, r1, #23
 800d336:	f7f3 fb6b 	bl	8000a10 <__aeabi_fmul>
 800d33a:	4b1b      	ldr	r3, [pc, #108]	; (800d3a8 <scalbnf+0x9c>)
 800d33c:	1c02      	adds	r2, r0, #0
 800d33e:	429c      	cmp	r4, r3
 800d340:	db04      	blt.n	800d34c <scalbnf+0x40>
 800d342:	15c3      	asrs	r3, r0, #23
 800d344:	b2db      	uxtb	r3, r3
 800d346:	0001      	movs	r1, r0
 800d348:	3b19      	subs	r3, #25
 800d34a:	e002      	b.n	800d352 <scalbnf+0x46>
 800d34c:	4917      	ldr	r1, [pc, #92]	; (800d3ac <scalbnf+0xa0>)
 800d34e:	e024      	b.n	800d39a <scalbnf+0x8e>
 800d350:	0e1b      	lsrs	r3, r3, #24
 800d352:	191b      	adds	r3, r3, r4
 800d354:	2bfe      	cmp	r3, #254	; 0xfe
 800d356:	dd01      	ble.n	800d35c <scalbnf+0x50>
 800d358:	1c11      	adds	r1, r2, #0
 800d35a:	e00d      	b.n	800d378 <scalbnf+0x6c>
 800d35c:	2b00      	cmp	r3, #0
 800d35e:	dd04      	ble.n	800d36a <scalbnf+0x5e>
 800d360:	4813      	ldr	r0, [pc, #76]	; (800d3b0 <scalbnf+0xa4>)
 800d362:	05db      	lsls	r3, r3, #23
 800d364:	4008      	ands	r0, r1
 800d366:	4318      	orrs	r0, r3
 800d368:	e019      	b.n	800d39e <scalbnf+0x92>
 800d36a:	0018      	movs	r0, r3
 800d36c:	3016      	adds	r0, #22
 800d36e:	da0d      	bge.n	800d38c <scalbnf+0x80>
 800d370:	4b10      	ldr	r3, [pc, #64]	; (800d3b4 <scalbnf+0xa8>)
 800d372:	1c11      	adds	r1, r2, #0
 800d374:	429c      	cmp	r4, r3
 800d376:	dd04      	ble.n	800d382 <scalbnf+0x76>
 800d378:	480f      	ldr	r0, [pc, #60]	; (800d3b8 <scalbnf+0xac>)
 800d37a:	f000 f81f 	bl	800d3bc <copysignf>
 800d37e:	490e      	ldr	r1, [pc, #56]	; (800d3b8 <scalbnf+0xac>)
 800d380:	e00b      	b.n	800d39a <scalbnf+0x8e>
 800d382:	480a      	ldr	r0, [pc, #40]	; (800d3ac <scalbnf+0xa0>)
 800d384:	f000 f81a 	bl	800d3bc <copysignf>
 800d388:	4908      	ldr	r1, [pc, #32]	; (800d3ac <scalbnf+0xa0>)
 800d38a:	e006      	b.n	800d39a <scalbnf+0x8e>
 800d38c:	4808      	ldr	r0, [pc, #32]	; (800d3b0 <scalbnf+0xa4>)
 800d38e:	3319      	adds	r3, #25
 800d390:	4008      	ands	r0, r1
 800d392:	21cc      	movs	r1, #204	; 0xcc
 800d394:	05db      	lsls	r3, r3, #23
 800d396:	4318      	orrs	r0, r3
 800d398:	0589      	lsls	r1, r1, #22
 800d39a:	f7f3 fb39 	bl	8000a10 <__aeabi_fmul>
 800d39e:	bd70      	pop	{r4, r5, r6, pc}
 800d3a0:	7f7fffff 	.word	0x7f7fffff
 800d3a4:	007fffff 	.word	0x007fffff
 800d3a8:	ffff3cb0 	.word	0xffff3cb0
 800d3ac:	0da24260 	.word	0x0da24260
 800d3b0:	807fffff 	.word	0x807fffff
 800d3b4:	0000c350 	.word	0x0000c350
 800d3b8:	7149f2ca 	.word	0x7149f2ca

0800d3bc <copysignf>:
 800d3bc:	0040      	lsls	r0, r0, #1
 800d3be:	0fc9      	lsrs	r1, r1, #31
 800d3c0:	07c9      	lsls	r1, r1, #31
 800d3c2:	0840      	lsrs	r0, r0, #1
 800d3c4:	4308      	orrs	r0, r1
 800d3c6:	4770      	bx	lr

0800d3c8 <__errno>:
 800d3c8:	4b01      	ldr	r3, [pc, #4]	; (800d3d0 <__errno+0x8>)
 800d3ca:	6818      	ldr	r0, [r3, #0]
 800d3cc:	4770      	bx	lr
 800d3ce:	46c0      	nop			; (mov r8, r8)
 800d3d0:	20000074 	.word	0x20000074

0800d3d4 <_init>:
 800d3d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d3d6:	46c0      	nop			; (mov r8, r8)
 800d3d8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800d3da:	bc08      	pop	{r3}
 800d3dc:	469e      	mov	lr, r3
 800d3de:	4770      	bx	lr

0800d3e0 <_fini>:
 800d3e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d3e2:	46c0      	nop			; (mov r8, r8)
 800d3e4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800d3e6:	bc08      	pop	{r3}
 800d3e8:	469e      	mov	lr, r3
 800d3ea:	4770      	bx	lr
