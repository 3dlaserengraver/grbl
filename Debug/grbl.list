
C:\Attolic Projects\grbl\Debug\grbl.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000d944  080000c0  080000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000b8c  0800da04  0800da04  0001da04  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0800e590  0800e590  0001e590  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  0800e594  0800e594  0001e594  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         0000007c  20000000  0800e598  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000b74  2000007c  0800e614  0002007c  2**2
                  ALLOC
  7 ._user_heap_stack 00000080  20000bf0  0800e614  00020bf0  2**0
                  ALLOC
  8 .ARM.attributes 00000028  00000000  00000000  0002007c  2**0
                  CONTENTS, READONLY
  9 .debug_info   00017bf4  00000000  00000000  000200a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00003a77  00000000  00000000  00037c98  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000e98  00000000  00000000  0003b710  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000d48  00000000  00000000  0003c5a8  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   000077fb  00000000  00000000  0003d2f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00004479  00000000  00000000  00044aeb  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .comment      0000007c  00000000  00000000  00048f64  2**0
                  CONTENTS, READONLY
 16 .debug_frame  00003928  00000000  00000000  00048fe0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	2000007c 	.word	0x2000007c
 80000e0:	00000000 	.word	0x00000000
 80000e4:	0800d9ec 	.word	0x0800d9ec

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	20000080 	.word	0x20000080
 8000104:	0800d9ec 	.word	0x0800d9ec

08000108 <__gnu_thumb1_case_uqi>:
 8000108:	b402      	push	{r1}
 800010a:	4671      	mov	r1, lr
 800010c:	0849      	lsrs	r1, r1, #1
 800010e:	0049      	lsls	r1, r1, #1
 8000110:	5c09      	ldrb	r1, [r1, r0]
 8000112:	0049      	lsls	r1, r1, #1
 8000114:	448e      	add	lr, r1
 8000116:	bc02      	pop	{r1}
 8000118:	4770      	bx	lr
 800011a:	46c0      	nop			; (mov r8, r8)

0800011c <__udivsi3>:
 800011c:	2200      	movs	r2, #0
 800011e:	0843      	lsrs	r3, r0, #1
 8000120:	428b      	cmp	r3, r1
 8000122:	d374      	bcc.n	800020e <__udivsi3+0xf2>
 8000124:	0903      	lsrs	r3, r0, #4
 8000126:	428b      	cmp	r3, r1
 8000128:	d35f      	bcc.n	80001ea <__udivsi3+0xce>
 800012a:	0a03      	lsrs	r3, r0, #8
 800012c:	428b      	cmp	r3, r1
 800012e:	d344      	bcc.n	80001ba <__udivsi3+0x9e>
 8000130:	0b03      	lsrs	r3, r0, #12
 8000132:	428b      	cmp	r3, r1
 8000134:	d328      	bcc.n	8000188 <__udivsi3+0x6c>
 8000136:	0c03      	lsrs	r3, r0, #16
 8000138:	428b      	cmp	r3, r1
 800013a:	d30d      	bcc.n	8000158 <__udivsi3+0x3c>
 800013c:	22ff      	movs	r2, #255	; 0xff
 800013e:	0209      	lsls	r1, r1, #8
 8000140:	ba12      	rev	r2, r2
 8000142:	0c03      	lsrs	r3, r0, #16
 8000144:	428b      	cmp	r3, r1
 8000146:	d302      	bcc.n	800014e <__udivsi3+0x32>
 8000148:	1212      	asrs	r2, r2, #8
 800014a:	0209      	lsls	r1, r1, #8
 800014c:	d065      	beq.n	800021a <__udivsi3+0xfe>
 800014e:	0b03      	lsrs	r3, r0, #12
 8000150:	428b      	cmp	r3, r1
 8000152:	d319      	bcc.n	8000188 <__udivsi3+0x6c>
 8000154:	e000      	b.n	8000158 <__udivsi3+0x3c>
 8000156:	0a09      	lsrs	r1, r1, #8
 8000158:	0bc3      	lsrs	r3, r0, #15
 800015a:	428b      	cmp	r3, r1
 800015c:	d301      	bcc.n	8000162 <__udivsi3+0x46>
 800015e:	03cb      	lsls	r3, r1, #15
 8000160:	1ac0      	subs	r0, r0, r3
 8000162:	4152      	adcs	r2, r2
 8000164:	0b83      	lsrs	r3, r0, #14
 8000166:	428b      	cmp	r3, r1
 8000168:	d301      	bcc.n	800016e <__udivsi3+0x52>
 800016a:	038b      	lsls	r3, r1, #14
 800016c:	1ac0      	subs	r0, r0, r3
 800016e:	4152      	adcs	r2, r2
 8000170:	0b43      	lsrs	r3, r0, #13
 8000172:	428b      	cmp	r3, r1
 8000174:	d301      	bcc.n	800017a <__udivsi3+0x5e>
 8000176:	034b      	lsls	r3, r1, #13
 8000178:	1ac0      	subs	r0, r0, r3
 800017a:	4152      	adcs	r2, r2
 800017c:	0b03      	lsrs	r3, r0, #12
 800017e:	428b      	cmp	r3, r1
 8000180:	d301      	bcc.n	8000186 <__udivsi3+0x6a>
 8000182:	030b      	lsls	r3, r1, #12
 8000184:	1ac0      	subs	r0, r0, r3
 8000186:	4152      	adcs	r2, r2
 8000188:	0ac3      	lsrs	r3, r0, #11
 800018a:	428b      	cmp	r3, r1
 800018c:	d301      	bcc.n	8000192 <__udivsi3+0x76>
 800018e:	02cb      	lsls	r3, r1, #11
 8000190:	1ac0      	subs	r0, r0, r3
 8000192:	4152      	adcs	r2, r2
 8000194:	0a83      	lsrs	r3, r0, #10
 8000196:	428b      	cmp	r3, r1
 8000198:	d301      	bcc.n	800019e <__udivsi3+0x82>
 800019a:	028b      	lsls	r3, r1, #10
 800019c:	1ac0      	subs	r0, r0, r3
 800019e:	4152      	adcs	r2, r2
 80001a0:	0a43      	lsrs	r3, r0, #9
 80001a2:	428b      	cmp	r3, r1
 80001a4:	d301      	bcc.n	80001aa <__udivsi3+0x8e>
 80001a6:	024b      	lsls	r3, r1, #9
 80001a8:	1ac0      	subs	r0, r0, r3
 80001aa:	4152      	adcs	r2, r2
 80001ac:	0a03      	lsrs	r3, r0, #8
 80001ae:	428b      	cmp	r3, r1
 80001b0:	d301      	bcc.n	80001b6 <__udivsi3+0x9a>
 80001b2:	020b      	lsls	r3, r1, #8
 80001b4:	1ac0      	subs	r0, r0, r3
 80001b6:	4152      	adcs	r2, r2
 80001b8:	d2cd      	bcs.n	8000156 <__udivsi3+0x3a>
 80001ba:	09c3      	lsrs	r3, r0, #7
 80001bc:	428b      	cmp	r3, r1
 80001be:	d301      	bcc.n	80001c4 <__udivsi3+0xa8>
 80001c0:	01cb      	lsls	r3, r1, #7
 80001c2:	1ac0      	subs	r0, r0, r3
 80001c4:	4152      	adcs	r2, r2
 80001c6:	0983      	lsrs	r3, r0, #6
 80001c8:	428b      	cmp	r3, r1
 80001ca:	d301      	bcc.n	80001d0 <__udivsi3+0xb4>
 80001cc:	018b      	lsls	r3, r1, #6
 80001ce:	1ac0      	subs	r0, r0, r3
 80001d0:	4152      	adcs	r2, r2
 80001d2:	0943      	lsrs	r3, r0, #5
 80001d4:	428b      	cmp	r3, r1
 80001d6:	d301      	bcc.n	80001dc <__udivsi3+0xc0>
 80001d8:	014b      	lsls	r3, r1, #5
 80001da:	1ac0      	subs	r0, r0, r3
 80001dc:	4152      	adcs	r2, r2
 80001de:	0903      	lsrs	r3, r0, #4
 80001e0:	428b      	cmp	r3, r1
 80001e2:	d301      	bcc.n	80001e8 <__udivsi3+0xcc>
 80001e4:	010b      	lsls	r3, r1, #4
 80001e6:	1ac0      	subs	r0, r0, r3
 80001e8:	4152      	adcs	r2, r2
 80001ea:	08c3      	lsrs	r3, r0, #3
 80001ec:	428b      	cmp	r3, r1
 80001ee:	d301      	bcc.n	80001f4 <__udivsi3+0xd8>
 80001f0:	00cb      	lsls	r3, r1, #3
 80001f2:	1ac0      	subs	r0, r0, r3
 80001f4:	4152      	adcs	r2, r2
 80001f6:	0883      	lsrs	r3, r0, #2
 80001f8:	428b      	cmp	r3, r1
 80001fa:	d301      	bcc.n	8000200 <__udivsi3+0xe4>
 80001fc:	008b      	lsls	r3, r1, #2
 80001fe:	1ac0      	subs	r0, r0, r3
 8000200:	4152      	adcs	r2, r2
 8000202:	0843      	lsrs	r3, r0, #1
 8000204:	428b      	cmp	r3, r1
 8000206:	d301      	bcc.n	800020c <__udivsi3+0xf0>
 8000208:	004b      	lsls	r3, r1, #1
 800020a:	1ac0      	subs	r0, r0, r3
 800020c:	4152      	adcs	r2, r2
 800020e:	1a41      	subs	r1, r0, r1
 8000210:	d200      	bcs.n	8000214 <__udivsi3+0xf8>
 8000212:	4601      	mov	r1, r0
 8000214:	4152      	adcs	r2, r2
 8000216:	4610      	mov	r0, r2
 8000218:	4770      	bx	lr
 800021a:	e7ff      	b.n	800021c <__udivsi3+0x100>
 800021c:	b501      	push	{r0, lr}
 800021e:	2000      	movs	r0, #0
 8000220:	f000 f806 	bl	8000230 <__aeabi_idiv0>
 8000224:	bd02      	pop	{r1, pc}
 8000226:	46c0      	nop			; (mov r8, r8)

08000228 <__aeabi_uidivmod>:
 8000228:	2900      	cmp	r1, #0
 800022a:	d0f7      	beq.n	800021c <__udivsi3+0x100>
 800022c:	e776      	b.n	800011c <__udivsi3>
 800022e:	4770      	bx	lr

08000230 <__aeabi_idiv0>:
 8000230:	4770      	bx	lr
 8000232:	46c0      	nop			; (mov r8, r8)

08000234 <__aeabi_cdrcmple>:
 8000234:	4684      	mov	ip, r0
 8000236:	1c10      	adds	r0, r2, #0
 8000238:	4662      	mov	r2, ip
 800023a:	468c      	mov	ip, r1
 800023c:	1c19      	adds	r1, r3, #0
 800023e:	4663      	mov	r3, ip
 8000240:	e000      	b.n	8000244 <__aeabi_cdcmpeq>
 8000242:	46c0      	nop			; (mov r8, r8)

08000244 <__aeabi_cdcmpeq>:
 8000244:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8000246:	f001 fe91 	bl	8001f6c <__ledf2>
 800024a:	2800      	cmp	r0, #0
 800024c:	d401      	bmi.n	8000252 <__aeabi_cdcmpeq+0xe>
 800024e:	2100      	movs	r1, #0
 8000250:	42c8      	cmn	r0, r1
 8000252:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

08000254 <__aeabi_dcmpeq>:
 8000254:	b510      	push	{r4, lr}
 8000256:	f001 fdeb 	bl	8001e30 <__eqdf2>
 800025a:	4240      	negs	r0, r0
 800025c:	3001      	adds	r0, #1
 800025e:	bd10      	pop	{r4, pc}

08000260 <__aeabi_dcmplt>:
 8000260:	b510      	push	{r4, lr}
 8000262:	f001 fe83 	bl	8001f6c <__ledf2>
 8000266:	2800      	cmp	r0, #0
 8000268:	db01      	blt.n	800026e <__aeabi_dcmplt+0xe>
 800026a:	2000      	movs	r0, #0
 800026c:	bd10      	pop	{r4, pc}
 800026e:	2001      	movs	r0, #1
 8000270:	bd10      	pop	{r4, pc}
 8000272:	46c0      	nop			; (mov r8, r8)

08000274 <__aeabi_dcmple>:
 8000274:	b510      	push	{r4, lr}
 8000276:	f001 fe79 	bl	8001f6c <__ledf2>
 800027a:	2800      	cmp	r0, #0
 800027c:	dd01      	ble.n	8000282 <__aeabi_dcmple+0xe>
 800027e:	2000      	movs	r0, #0
 8000280:	bd10      	pop	{r4, pc}
 8000282:	2001      	movs	r0, #1
 8000284:	bd10      	pop	{r4, pc}
 8000286:	46c0      	nop			; (mov r8, r8)

08000288 <__aeabi_dcmpgt>:
 8000288:	b510      	push	{r4, lr}
 800028a:	f001 fe0b 	bl	8001ea4 <__gedf2>
 800028e:	2800      	cmp	r0, #0
 8000290:	dc01      	bgt.n	8000296 <__aeabi_dcmpgt+0xe>
 8000292:	2000      	movs	r0, #0
 8000294:	bd10      	pop	{r4, pc}
 8000296:	2001      	movs	r0, #1
 8000298:	bd10      	pop	{r4, pc}
 800029a:	46c0      	nop			; (mov r8, r8)

0800029c <__aeabi_dcmpge>:
 800029c:	b510      	push	{r4, lr}
 800029e:	f001 fe01 	bl	8001ea4 <__gedf2>
 80002a2:	2800      	cmp	r0, #0
 80002a4:	da01      	bge.n	80002aa <__aeabi_dcmpge+0xe>
 80002a6:	2000      	movs	r0, #0
 80002a8:	bd10      	pop	{r4, pc}
 80002aa:	2001      	movs	r0, #1
 80002ac:	bd10      	pop	{r4, pc}
 80002ae:	46c0      	nop			; (mov r8, r8)

080002b0 <__aeabi_cfrcmple>:
 80002b0:	4684      	mov	ip, r0
 80002b2:	1c08      	adds	r0, r1, #0
 80002b4:	4661      	mov	r1, ip
 80002b6:	e7ff      	b.n	80002b8 <__aeabi_cfcmpeq>

080002b8 <__aeabi_cfcmpeq>:
 80002b8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80002ba:	f000 fba9 	bl	8000a10 <__lesf2>
 80002be:	2800      	cmp	r0, #0
 80002c0:	d401      	bmi.n	80002c6 <__aeabi_cfcmpeq+0xe>
 80002c2:	2100      	movs	r1, #0
 80002c4:	42c8      	cmn	r0, r1
 80002c6:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

080002c8 <__aeabi_fcmpeq>:
 80002c8:	b510      	push	{r4, lr}
 80002ca:	f000 fb3b 	bl	8000944 <__eqsf2>
 80002ce:	4240      	negs	r0, r0
 80002d0:	3001      	adds	r0, #1
 80002d2:	bd10      	pop	{r4, pc}

080002d4 <__aeabi_fcmplt>:
 80002d4:	b510      	push	{r4, lr}
 80002d6:	f000 fb9b 	bl	8000a10 <__lesf2>
 80002da:	2800      	cmp	r0, #0
 80002dc:	db01      	blt.n	80002e2 <__aeabi_fcmplt+0xe>
 80002de:	2000      	movs	r0, #0
 80002e0:	bd10      	pop	{r4, pc}
 80002e2:	2001      	movs	r0, #1
 80002e4:	bd10      	pop	{r4, pc}
 80002e6:	46c0      	nop			; (mov r8, r8)

080002e8 <__aeabi_fcmple>:
 80002e8:	b510      	push	{r4, lr}
 80002ea:	f000 fb91 	bl	8000a10 <__lesf2>
 80002ee:	2800      	cmp	r0, #0
 80002f0:	dd01      	ble.n	80002f6 <__aeabi_fcmple+0xe>
 80002f2:	2000      	movs	r0, #0
 80002f4:	bd10      	pop	{r4, pc}
 80002f6:	2001      	movs	r0, #1
 80002f8:	bd10      	pop	{r4, pc}
 80002fa:	46c0      	nop			; (mov r8, r8)

080002fc <__aeabi_fcmpgt>:
 80002fc:	b510      	push	{r4, lr}
 80002fe:	f000 fb47 	bl	8000990 <__gesf2>
 8000302:	2800      	cmp	r0, #0
 8000304:	dc01      	bgt.n	800030a <__aeabi_fcmpgt+0xe>
 8000306:	2000      	movs	r0, #0
 8000308:	bd10      	pop	{r4, pc}
 800030a:	2001      	movs	r0, #1
 800030c:	bd10      	pop	{r4, pc}
 800030e:	46c0      	nop			; (mov r8, r8)

08000310 <__aeabi_fcmpge>:
 8000310:	b510      	push	{r4, lr}
 8000312:	f000 fb3d 	bl	8000990 <__gesf2>
 8000316:	2800      	cmp	r0, #0
 8000318:	da01      	bge.n	800031e <__aeabi_fcmpge+0xe>
 800031a:	2000      	movs	r0, #0
 800031c:	bd10      	pop	{r4, pc}
 800031e:	2001      	movs	r0, #1
 8000320:	bd10      	pop	{r4, pc}
 8000322:	46c0      	nop			; (mov r8, r8)

08000324 <__aeabi_f2uiz>:
 8000324:	219e      	movs	r1, #158	; 0x9e
 8000326:	b510      	push	{r4, lr}
 8000328:	05c9      	lsls	r1, r1, #23
 800032a:	1c04      	adds	r4, r0, #0
 800032c:	f7ff fff0 	bl	8000310 <__aeabi_fcmpge>
 8000330:	2800      	cmp	r0, #0
 8000332:	d103      	bne.n	800033c <__aeabi_f2uiz+0x18>
 8000334:	1c20      	adds	r0, r4, #0
 8000336:	f000 fe81 	bl	800103c <__aeabi_f2iz>
 800033a:	bd10      	pop	{r4, pc}
 800033c:	219e      	movs	r1, #158	; 0x9e
 800033e:	1c20      	adds	r0, r4, #0
 8000340:	05c9      	lsls	r1, r1, #23
 8000342:	f000 fcc7 	bl	8000cd4 <__aeabi_fsub>
 8000346:	f000 fe79 	bl	800103c <__aeabi_f2iz>
 800034a:	2380      	movs	r3, #128	; 0x80
 800034c:	061b      	lsls	r3, r3, #24
 800034e:	469c      	mov	ip, r3
 8000350:	4460      	add	r0, ip
 8000352:	e7f2      	b.n	800033a <__aeabi_f2uiz+0x16>

08000354 <__aeabi_d2uiz>:
 8000354:	b570      	push	{r4, r5, r6, lr}
 8000356:	2200      	movs	r2, #0
 8000358:	4b0c      	ldr	r3, [pc, #48]	; (800038c <__aeabi_d2uiz+0x38>)
 800035a:	0004      	movs	r4, r0
 800035c:	000d      	movs	r5, r1
 800035e:	f7ff ff9d 	bl	800029c <__aeabi_dcmpge>
 8000362:	2800      	cmp	r0, #0
 8000364:	d104      	bne.n	8000370 <__aeabi_d2uiz+0x1c>
 8000366:	0020      	movs	r0, r4
 8000368:	0029      	movs	r1, r5
 800036a:	f002 f977 	bl	800265c <__aeabi_d2iz>
 800036e:	bd70      	pop	{r4, r5, r6, pc}
 8000370:	4b06      	ldr	r3, [pc, #24]	; (800038c <__aeabi_d2uiz+0x38>)
 8000372:	2200      	movs	r2, #0
 8000374:	0020      	movs	r0, r4
 8000376:	0029      	movs	r1, r5
 8000378:	f001 fe5a 	bl	8002030 <__aeabi_dsub>
 800037c:	f002 f96e 	bl	800265c <__aeabi_d2iz>
 8000380:	2380      	movs	r3, #128	; 0x80
 8000382:	061b      	lsls	r3, r3, #24
 8000384:	469c      	mov	ip, r3
 8000386:	4460      	add	r0, ip
 8000388:	e7f1      	b.n	800036e <__aeabi_d2uiz+0x1a>
 800038a:	46c0      	nop			; (mov r8, r8)
 800038c:	41e00000 	.word	0x41e00000

08000390 <__aeabi_fadd>:
 8000390:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000392:	46c6      	mov	lr, r8
 8000394:	024e      	lsls	r6, r1, #9
 8000396:	0247      	lsls	r7, r0, #9
 8000398:	0a76      	lsrs	r6, r6, #9
 800039a:	0a7b      	lsrs	r3, r7, #9
 800039c:	0044      	lsls	r4, r0, #1
 800039e:	0fc5      	lsrs	r5, r0, #31
 80003a0:	00f7      	lsls	r7, r6, #3
 80003a2:	0048      	lsls	r0, r1, #1
 80003a4:	4698      	mov	r8, r3
 80003a6:	b500      	push	{lr}
 80003a8:	0e24      	lsrs	r4, r4, #24
 80003aa:	002a      	movs	r2, r5
 80003ac:	00db      	lsls	r3, r3, #3
 80003ae:	0e00      	lsrs	r0, r0, #24
 80003b0:	0fc9      	lsrs	r1, r1, #31
 80003b2:	46bc      	mov	ip, r7
 80003b4:	428d      	cmp	r5, r1
 80003b6:	d067      	beq.n	8000488 <__aeabi_fadd+0xf8>
 80003b8:	1a22      	subs	r2, r4, r0
 80003ba:	2a00      	cmp	r2, #0
 80003bc:	dc00      	bgt.n	80003c0 <__aeabi_fadd+0x30>
 80003be:	e0a5      	b.n	800050c <__aeabi_fadd+0x17c>
 80003c0:	2800      	cmp	r0, #0
 80003c2:	d13a      	bne.n	800043a <__aeabi_fadd+0xaa>
 80003c4:	2f00      	cmp	r7, #0
 80003c6:	d100      	bne.n	80003ca <__aeabi_fadd+0x3a>
 80003c8:	e093      	b.n	80004f2 <__aeabi_fadd+0x162>
 80003ca:	1e51      	subs	r1, r2, #1
 80003cc:	2900      	cmp	r1, #0
 80003ce:	d000      	beq.n	80003d2 <__aeabi_fadd+0x42>
 80003d0:	e0bc      	b.n	800054c <__aeabi_fadd+0x1bc>
 80003d2:	2401      	movs	r4, #1
 80003d4:	1bdb      	subs	r3, r3, r7
 80003d6:	015a      	lsls	r2, r3, #5
 80003d8:	d546      	bpl.n	8000468 <__aeabi_fadd+0xd8>
 80003da:	019b      	lsls	r3, r3, #6
 80003dc:	099e      	lsrs	r6, r3, #6
 80003de:	0030      	movs	r0, r6
 80003e0:	f002 fa4c 	bl	800287c <__clzsi2>
 80003e4:	3805      	subs	r0, #5
 80003e6:	4086      	lsls	r6, r0
 80003e8:	4284      	cmp	r4, r0
 80003ea:	dd00      	ble.n	80003ee <__aeabi_fadd+0x5e>
 80003ec:	e09d      	b.n	800052a <__aeabi_fadd+0x19a>
 80003ee:	1b04      	subs	r4, r0, r4
 80003f0:	0032      	movs	r2, r6
 80003f2:	2020      	movs	r0, #32
 80003f4:	3401      	adds	r4, #1
 80003f6:	40e2      	lsrs	r2, r4
 80003f8:	1b04      	subs	r4, r0, r4
 80003fa:	40a6      	lsls	r6, r4
 80003fc:	0033      	movs	r3, r6
 80003fe:	1e5e      	subs	r6, r3, #1
 8000400:	41b3      	sbcs	r3, r6
 8000402:	2400      	movs	r4, #0
 8000404:	4313      	orrs	r3, r2
 8000406:	075a      	lsls	r2, r3, #29
 8000408:	d004      	beq.n	8000414 <__aeabi_fadd+0x84>
 800040a:	220f      	movs	r2, #15
 800040c:	401a      	ands	r2, r3
 800040e:	2a04      	cmp	r2, #4
 8000410:	d000      	beq.n	8000414 <__aeabi_fadd+0x84>
 8000412:	3304      	adds	r3, #4
 8000414:	015a      	lsls	r2, r3, #5
 8000416:	d529      	bpl.n	800046c <__aeabi_fadd+0xdc>
 8000418:	3401      	adds	r4, #1
 800041a:	2cff      	cmp	r4, #255	; 0xff
 800041c:	d100      	bne.n	8000420 <__aeabi_fadd+0x90>
 800041e:	e081      	b.n	8000524 <__aeabi_fadd+0x194>
 8000420:	002a      	movs	r2, r5
 8000422:	019b      	lsls	r3, r3, #6
 8000424:	0a5b      	lsrs	r3, r3, #9
 8000426:	b2e4      	uxtb	r4, r4
 8000428:	025b      	lsls	r3, r3, #9
 800042a:	05e4      	lsls	r4, r4, #23
 800042c:	0a58      	lsrs	r0, r3, #9
 800042e:	07d2      	lsls	r2, r2, #31
 8000430:	4320      	orrs	r0, r4
 8000432:	4310      	orrs	r0, r2
 8000434:	bc04      	pop	{r2}
 8000436:	4690      	mov	r8, r2
 8000438:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800043a:	2cff      	cmp	r4, #255	; 0xff
 800043c:	d0e3      	beq.n	8000406 <__aeabi_fadd+0x76>
 800043e:	2180      	movs	r1, #128	; 0x80
 8000440:	0038      	movs	r0, r7
 8000442:	04c9      	lsls	r1, r1, #19
 8000444:	4308      	orrs	r0, r1
 8000446:	4684      	mov	ip, r0
 8000448:	2a1b      	cmp	r2, #27
 800044a:	dd00      	ble.n	800044e <__aeabi_fadd+0xbe>
 800044c:	e082      	b.n	8000554 <__aeabi_fadd+0x1c4>
 800044e:	2020      	movs	r0, #32
 8000450:	4661      	mov	r1, ip
 8000452:	40d1      	lsrs	r1, r2
 8000454:	1a82      	subs	r2, r0, r2
 8000456:	4660      	mov	r0, ip
 8000458:	4090      	lsls	r0, r2
 800045a:	0002      	movs	r2, r0
 800045c:	1e50      	subs	r0, r2, #1
 800045e:	4182      	sbcs	r2, r0
 8000460:	430a      	orrs	r2, r1
 8000462:	1a9b      	subs	r3, r3, r2
 8000464:	015a      	lsls	r2, r3, #5
 8000466:	d4b8      	bmi.n	80003da <__aeabi_fadd+0x4a>
 8000468:	075a      	lsls	r2, r3, #29
 800046a:	d1ce      	bne.n	800040a <__aeabi_fadd+0x7a>
 800046c:	08de      	lsrs	r6, r3, #3
 800046e:	002a      	movs	r2, r5
 8000470:	2cff      	cmp	r4, #255	; 0xff
 8000472:	d13a      	bne.n	80004ea <__aeabi_fadd+0x15a>
 8000474:	2e00      	cmp	r6, #0
 8000476:	d100      	bne.n	800047a <__aeabi_fadd+0xea>
 8000478:	e0ae      	b.n	80005d8 <__aeabi_fadd+0x248>
 800047a:	2380      	movs	r3, #128	; 0x80
 800047c:	03db      	lsls	r3, r3, #15
 800047e:	4333      	orrs	r3, r6
 8000480:	025b      	lsls	r3, r3, #9
 8000482:	0a5b      	lsrs	r3, r3, #9
 8000484:	24ff      	movs	r4, #255	; 0xff
 8000486:	e7cf      	b.n	8000428 <__aeabi_fadd+0x98>
 8000488:	1a21      	subs	r1, r4, r0
 800048a:	2900      	cmp	r1, #0
 800048c:	dd52      	ble.n	8000534 <__aeabi_fadd+0x1a4>
 800048e:	2800      	cmp	r0, #0
 8000490:	d031      	beq.n	80004f6 <__aeabi_fadd+0x166>
 8000492:	2cff      	cmp	r4, #255	; 0xff
 8000494:	d0b7      	beq.n	8000406 <__aeabi_fadd+0x76>
 8000496:	2080      	movs	r0, #128	; 0x80
 8000498:	003e      	movs	r6, r7
 800049a:	04c0      	lsls	r0, r0, #19
 800049c:	4306      	orrs	r6, r0
 800049e:	46b4      	mov	ip, r6
 80004a0:	291b      	cmp	r1, #27
 80004a2:	dd00      	ble.n	80004a6 <__aeabi_fadd+0x116>
 80004a4:	e0aa      	b.n	80005fc <__aeabi_fadd+0x26c>
 80004a6:	2620      	movs	r6, #32
 80004a8:	4660      	mov	r0, ip
 80004aa:	40c8      	lsrs	r0, r1
 80004ac:	1a71      	subs	r1, r6, r1
 80004ae:	4666      	mov	r6, ip
 80004b0:	408e      	lsls	r6, r1
 80004b2:	0031      	movs	r1, r6
 80004b4:	1e4e      	subs	r6, r1, #1
 80004b6:	41b1      	sbcs	r1, r6
 80004b8:	4301      	orrs	r1, r0
 80004ba:	185b      	adds	r3, r3, r1
 80004bc:	0159      	lsls	r1, r3, #5
 80004be:	d5d3      	bpl.n	8000468 <__aeabi_fadd+0xd8>
 80004c0:	3401      	adds	r4, #1
 80004c2:	2cff      	cmp	r4, #255	; 0xff
 80004c4:	d100      	bne.n	80004c8 <__aeabi_fadd+0x138>
 80004c6:	e087      	b.n	80005d8 <__aeabi_fadd+0x248>
 80004c8:	2201      	movs	r2, #1
 80004ca:	4978      	ldr	r1, [pc, #480]	; (80006ac <__aeabi_fadd+0x31c>)
 80004cc:	401a      	ands	r2, r3
 80004ce:	085b      	lsrs	r3, r3, #1
 80004d0:	400b      	ands	r3, r1
 80004d2:	4313      	orrs	r3, r2
 80004d4:	e797      	b.n	8000406 <__aeabi_fadd+0x76>
 80004d6:	2c00      	cmp	r4, #0
 80004d8:	d000      	beq.n	80004dc <__aeabi_fadd+0x14c>
 80004da:	e0a7      	b.n	800062c <__aeabi_fadd+0x29c>
 80004dc:	2b00      	cmp	r3, #0
 80004de:	d000      	beq.n	80004e2 <__aeabi_fadd+0x152>
 80004e0:	e0b6      	b.n	8000650 <__aeabi_fadd+0x2c0>
 80004e2:	1e3b      	subs	r3, r7, #0
 80004e4:	d162      	bne.n	80005ac <__aeabi_fadd+0x21c>
 80004e6:	2600      	movs	r6, #0
 80004e8:	2200      	movs	r2, #0
 80004ea:	0273      	lsls	r3, r6, #9
 80004ec:	0a5b      	lsrs	r3, r3, #9
 80004ee:	b2e4      	uxtb	r4, r4
 80004f0:	e79a      	b.n	8000428 <__aeabi_fadd+0x98>
 80004f2:	0014      	movs	r4, r2
 80004f4:	e787      	b.n	8000406 <__aeabi_fadd+0x76>
 80004f6:	2f00      	cmp	r7, #0
 80004f8:	d04d      	beq.n	8000596 <__aeabi_fadd+0x206>
 80004fa:	1e48      	subs	r0, r1, #1
 80004fc:	2800      	cmp	r0, #0
 80004fe:	d157      	bne.n	80005b0 <__aeabi_fadd+0x220>
 8000500:	4463      	add	r3, ip
 8000502:	2401      	movs	r4, #1
 8000504:	015a      	lsls	r2, r3, #5
 8000506:	d5af      	bpl.n	8000468 <__aeabi_fadd+0xd8>
 8000508:	2402      	movs	r4, #2
 800050a:	e7dd      	b.n	80004c8 <__aeabi_fadd+0x138>
 800050c:	2a00      	cmp	r2, #0
 800050e:	d124      	bne.n	800055a <__aeabi_fadd+0x1ca>
 8000510:	1c62      	adds	r2, r4, #1
 8000512:	b2d2      	uxtb	r2, r2
 8000514:	2a01      	cmp	r2, #1
 8000516:	ddde      	ble.n	80004d6 <__aeabi_fadd+0x146>
 8000518:	1bde      	subs	r6, r3, r7
 800051a:	0172      	lsls	r2, r6, #5
 800051c:	d535      	bpl.n	800058a <__aeabi_fadd+0x1fa>
 800051e:	1afe      	subs	r6, r7, r3
 8000520:	000d      	movs	r5, r1
 8000522:	e75c      	b.n	80003de <__aeabi_fadd+0x4e>
 8000524:	002a      	movs	r2, r5
 8000526:	2300      	movs	r3, #0
 8000528:	e77e      	b.n	8000428 <__aeabi_fadd+0x98>
 800052a:	0033      	movs	r3, r6
 800052c:	4a60      	ldr	r2, [pc, #384]	; (80006b0 <__aeabi_fadd+0x320>)
 800052e:	1a24      	subs	r4, r4, r0
 8000530:	4013      	ands	r3, r2
 8000532:	e768      	b.n	8000406 <__aeabi_fadd+0x76>
 8000534:	2900      	cmp	r1, #0
 8000536:	d163      	bne.n	8000600 <__aeabi_fadd+0x270>
 8000538:	1c61      	adds	r1, r4, #1
 800053a:	b2c8      	uxtb	r0, r1
 800053c:	2801      	cmp	r0, #1
 800053e:	dd4e      	ble.n	80005de <__aeabi_fadd+0x24e>
 8000540:	29ff      	cmp	r1, #255	; 0xff
 8000542:	d049      	beq.n	80005d8 <__aeabi_fadd+0x248>
 8000544:	4463      	add	r3, ip
 8000546:	085b      	lsrs	r3, r3, #1
 8000548:	000c      	movs	r4, r1
 800054a:	e75c      	b.n	8000406 <__aeabi_fadd+0x76>
 800054c:	2aff      	cmp	r2, #255	; 0xff
 800054e:	d041      	beq.n	80005d4 <__aeabi_fadd+0x244>
 8000550:	000a      	movs	r2, r1
 8000552:	e779      	b.n	8000448 <__aeabi_fadd+0xb8>
 8000554:	2201      	movs	r2, #1
 8000556:	1a9b      	subs	r3, r3, r2
 8000558:	e784      	b.n	8000464 <__aeabi_fadd+0xd4>
 800055a:	2c00      	cmp	r4, #0
 800055c:	d01d      	beq.n	800059a <__aeabi_fadd+0x20a>
 800055e:	28ff      	cmp	r0, #255	; 0xff
 8000560:	d022      	beq.n	80005a8 <__aeabi_fadd+0x218>
 8000562:	2480      	movs	r4, #128	; 0x80
 8000564:	04e4      	lsls	r4, r4, #19
 8000566:	4252      	negs	r2, r2
 8000568:	4323      	orrs	r3, r4
 800056a:	2a1b      	cmp	r2, #27
 800056c:	dd00      	ble.n	8000570 <__aeabi_fadd+0x1e0>
 800056e:	e08a      	b.n	8000686 <__aeabi_fadd+0x2f6>
 8000570:	001c      	movs	r4, r3
 8000572:	2520      	movs	r5, #32
 8000574:	40d4      	lsrs	r4, r2
 8000576:	1aaa      	subs	r2, r5, r2
 8000578:	4093      	lsls	r3, r2
 800057a:	1e5a      	subs	r2, r3, #1
 800057c:	4193      	sbcs	r3, r2
 800057e:	4323      	orrs	r3, r4
 8000580:	4662      	mov	r2, ip
 8000582:	0004      	movs	r4, r0
 8000584:	1ad3      	subs	r3, r2, r3
 8000586:	000d      	movs	r5, r1
 8000588:	e725      	b.n	80003d6 <__aeabi_fadd+0x46>
 800058a:	2e00      	cmp	r6, #0
 800058c:	d000      	beq.n	8000590 <__aeabi_fadd+0x200>
 800058e:	e726      	b.n	80003de <__aeabi_fadd+0x4e>
 8000590:	2200      	movs	r2, #0
 8000592:	2400      	movs	r4, #0
 8000594:	e7a9      	b.n	80004ea <__aeabi_fadd+0x15a>
 8000596:	000c      	movs	r4, r1
 8000598:	e735      	b.n	8000406 <__aeabi_fadd+0x76>
 800059a:	2b00      	cmp	r3, #0
 800059c:	d04d      	beq.n	800063a <__aeabi_fadd+0x2aa>
 800059e:	43d2      	mvns	r2, r2
 80005a0:	2a00      	cmp	r2, #0
 80005a2:	d0ed      	beq.n	8000580 <__aeabi_fadd+0x1f0>
 80005a4:	28ff      	cmp	r0, #255	; 0xff
 80005a6:	d1e0      	bne.n	800056a <__aeabi_fadd+0x1da>
 80005a8:	4663      	mov	r3, ip
 80005aa:	24ff      	movs	r4, #255	; 0xff
 80005ac:	000d      	movs	r5, r1
 80005ae:	e72a      	b.n	8000406 <__aeabi_fadd+0x76>
 80005b0:	29ff      	cmp	r1, #255	; 0xff
 80005b2:	d00f      	beq.n	80005d4 <__aeabi_fadd+0x244>
 80005b4:	0001      	movs	r1, r0
 80005b6:	e773      	b.n	80004a0 <__aeabi_fadd+0x110>
 80005b8:	2b00      	cmp	r3, #0
 80005ba:	d061      	beq.n	8000680 <__aeabi_fadd+0x2f0>
 80005bc:	24ff      	movs	r4, #255	; 0xff
 80005be:	2f00      	cmp	r7, #0
 80005c0:	d100      	bne.n	80005c4 <__aeabi_fadd+0x234>
 80005c2:	e720      	b.n	8000406 <__aeabi_fadd+0x76>
 80005c4:	2280      	movs	r2, #128	; 0x80
 80005c6:	4641      	mov	r1, r8
 80005c8:	03d2      	lsls	r2, r2, #15
 80005ca:	4211      	tst	r1, r2
 80005cc:	d002      	beq.n	80005d4 <__aeabi_fadd+0x244>
 80005ce:	4216      	tst	r6, r2
 80005d0:	d100      	bne.n	80005d4 <__aeabi_fadd+0x244>
 80005d2:	003b      	movs	r3, r7
 80005d4:	24ff      	movs	r4, #255	; 0xff
 80005d6:	e716      	b.n	8000406 <__aeabi_fadd+0x76>
 80005d8:	24ff      	movs	r4, #255	; 0xff
 80005da:	2300      	movs	r3, #0
 80005dc:	e724      	b.n	8000428 <__aeabi_fadd+0x98>
 80005de:	2c00      	cmp	r4, #0
 80005e0:	d1ea      	bne.n	80005b8 <__aeabi_fadd+0x228>
 80005e2:	2b00      	cmp	r3, #0
 80005e4:	d058      	beq.n	8000698 <__aeabi_fadd+0x308>
 80005e6:	2f00      	cmp	r7, #0
 80005e8:	d100      	bne.n	80005ec <__aeabi_fadd+0x25c>
 80005ea:	e70c      	b.n	8000406 <__aeabi_fadd+0x76>
 80005ec:	4463      	add	r3, ip
 80005ee:	015a      	lsls	r2, r3, #5
 80005f0:	d400      	bmi.n	80005f4 <__aeabi_fadd+0x264>
 80005f2:	e739      	b.n	8000468 <__aeabi_fadd+0xd8>
 80005f4:	4a2e      	ldr	r2, [pc, #184]	; (80006b0 <__aeabi_fadd+0x320>)
 80005f6:	000c      	movs	r4, r1
 80005f8:	4013      	ands	r3, r2
 80005fa:	e704      	b.n	8000406 <__aeabi_fadd+0x76>
 80005fc:	2101      	movs	r1, #1
 80005fe:	e75c      	b.n	80004ba <__aeabi_fadd+0x12a>
 8000600:	2c00      	cmp	r4, #0
 8000602:	d11e      	bne.n	8000642 <__aeabi_fadd+0x2b2>
 8000604:	2b00      	cmp	r3, #0
 8000606:	d040      	beq.n	800068a <__aeabi_fadd+0x2fa>
 8000608:	43c9      	mvns	r1, r1
 800060a:	2900      	cmp	r1, #0
 800060c:	d00b      	beq.n	8000626 <__aeabi_fadd+0x296>
 800060e:	28ff      	cmp	r0, #255	; 0xff
 8000610:	d036      	beq.n	8000680 <__aeabi_fadd+0x2f0>
 8000612:	291b      	cmp	r1, #27
 8000614:	dc47      	bgt.n	80006a6 <__aeabi_fadd+0x316>
 8000616:	001c      	movs	r4, r3
 8000618:	2620      	movs	r6, #32
 800061a:	40cc      	lsrs	r4, r1
 800061c:	1a71      	subs	r1, r6, r1
 800061e:	408b      	lsls	r3, r1
 8000620:	1e59      	subs	r1, r3, #1
 8000622:	418b      	sbcs	r3, r1
 8000624:	4323      	orrs	r3, r4
 8000626:	4463      	add	r3, ip
 8000628:	0004      	movs	r4, r0
 800062a:	e747      	b.n	80004bc <__aeabi_fadd+0x12c>
 800062c:	2b00      	cmp	r3, #0
 800062e:	d118      	bne.n	8000662 <__aeabi_fadd+0x2d2>
 8000630:	1e3b      	subs	r3, r7, #0
 8000632:	d02d      	beq.n	8000690 <__aeabi_fadd+0x300>
 8000634:	000d      	movs	r5, r1
 8000636:	24ff      	movs	r4, #255	; 0xff
 8000638:	e6e5      	b.n	8000406 <__aeabi_fadd+0x76>
 800063a:	003b      	movs	r3, r7
 800063c:	0004      	movs	r4, r0
 800063e:	000d      	movs	r5, r1
 8000640:	e6e1      	b.n	8000406 <__aeabi_fadd+0x76>
 8000642:	28ff      	cmp	r0, #255	; 0xff
 8000644:	d01c      	beq.n	8000680 <__aeabi_fadd+0x2f0>
 8000646:	2480      	movs	r4, #128	; 0x80
 8000648:	04e4      	lsls	r4, r4, #19
 800064a:	4249      	negs	r1, r1
 800064c:	4323      	orrs	r3, r4
 800064e:	e7e0      	b.n	8000612 <__aeabi_fadd+0x282>
 8000650:	2f00      	cmp	r7, #0
 8000652:	d100      	bne.n	8000656 <__aeabi_fadd+0x2c6>
 8000654:	e6d7      	b.n	8000406 <__aeabi_fadd+0x76>
 8000656:	1bde      	subs	r6, r3, r7
 8000658:	0172      	lsls	r2, r6, #5
 800065a:	d51f      	bpl.n	800069c <__aeabi_fadd+0x30c>
 800065c:	1afb      	subs	r3, r7, r3
 800065e:	000d      	movs	r5, r1
 8000660:	e6d1      	b.n	8000406 <__aeabi_fadd+0x76>
 8000662:	24ff      	movs	r4, #255	; 0xff
 8000664:	2f00      	cmp	r7, #0
 8000666:	d100      	bne.n	800066a <__aeabi_fadd+0x2da>
 8000668:	e6cd      	b.n	8000406 <__aeabi_fadd+0x76>
 800066a:	2280      	movs	r2, #128	; 0x80
 800066c:	4640      	mov	r0, r8
 800066e:	03d2      	lsls	r2, r2, #15
 8000670:	4210      	tst	r0, r2
 8000672:	d0af      	beq.n	80005d4 <__aeabi_fadd+0x244>
 8000674:	4216      	tst	r6, r2
 8000676:	d1ad      	bne.n	80005d4 <__aeabi_fadd+0x244>
 8000678:	003b      	movs	r3, r7
 800067a:	000d      	movs	r5, r1
 800067c:	24ff      	movs	r4, #255	; 0xff
 800067e:	e6c2      	b.n	8000406 <__aeabi_fadd+0x76>
 8000680:	4663      	mov	r3, ip
 8000682:	24ff      	movs	r4, #255	; 0xff
 8000684:	e6bf      	b.n	8000406 <__aeabi_fadd+0x76>
 8000686:	2301      	movs	r3, #1
 8000688:	e77a      	b.n	8000580 <__aeabi_fadd+0x1f0>
 800068a:	003b      	movs	r3, r7
 800068c:	0004      	movs	r4, r0
 800068e:	e6ba      	b.n	8000406 <__aeabi_fadd+0x76>
 8000690:	2680      	movs	r6, #128	; 0x80
 8000692:	2200      	movs	r2, #0
 8000694:	03f6      	lsls	r6, r6, #15
 8000696:	e6f0      	b.n	800047a <__aeabi_fadd+0xea>
 8000698:	003b      	movs	r3, r7
 800069a:	e6b4      	b.n	8000406 <__aeabi_fadd+0x76>
 800069c:	1e33      	subs	r3, r6, #0
 800069e:	d000      	beq.n	80006a2 <__aeabi_fadd+0x312>
 80006a0:	e6e2      	b.n	8000468 <__aeabi_fadd+0xd8>
 80006a2:	2200      	movs	r2, #0
 80006a4:	e721      	b.n	80004ea <__aeabi_fadd+0x15a>
 80006a6:	2301      	movs	r3, #1
 80006a8:	e7bd      	b.n	8000626 <__aeabi_fadd+0x296>
 80006aa:	46c0      	nop			; (mov r8, r8)
 80006ac:	7dffffff 	.word	0x7dffffff
 80006b0:	fbffffff 	.word	0xfbffffff

080006b4 <__aeabi_fdiv>:
 80006b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80006b6:	4657      	mov	r7, sl
 80006b8:	464e      	mov	r6, r9
 80006ba:	46de      	mov	lr, fp
 80006bc:	4645      	mov	r5, r8
 80006be:	b5e0      	push	{r5, r6, r7, lr}
 80006c0:	0244      	lsls	r4, r0, #9
 80006c2:	0043      	lsls	r3, r0, #1
 80006c4:	0fc6      	lsrs	r6, r0, #31
 80006c6:	b083      	sub	sp, #12
 80006c8:	1c0f      	adds	r7, r1, #0
 80006ca:	0a64      	lsrs	r4, r4, #9
 80006cc:	0e1b      	lsrs	r3, r3, #24
 80006ce:	46b2      	mov	sl, r6
 80006d0:	d053      	beq.n	800077a <__aeabi_fdiv+0xc6>
 80006d2:	2bff      	cmp	r3, #255	; 0xff
 80006d4:	d027      	beq.n	8000726 <__aeabi_fdiv+0x72>
 80006d6:	2280      	movs	r2, #128	; 0x80
 80006d8:	00e4      	lsls	r4, r4, #3
 80006da:	04d2      	lsls	r2, r2, #19
 80006dc:	4314      	orrs	r4, r2
 80006de:	227f      	movs	r2, #127	; 0x7f
 80006e0:	4252      	negs	r2, r2
 80006e2:	4690      	mov	r8, r2
 80006e4:	4498      	add	r8, r3
 80006e6:	2300      	movs	r3, #0
 80006e8:	4699      	mov	r9, r3
 80006ea:	469b      	mov	fp, r3
 80006ec:	027d      	lsls	r5, r7, #9
 80006ee:	0078      	lsls	r0, r7, #1
 80006f0:	0ffb      	lsrs	r3, r7, #31
 80006f2:	0a6d      	lsrs	r5, r5, #9
 80006f4:	0e00      	lsrs	r0, r0, #24
 80006f6:	9300      	str	r3, [sp, #0]
 80006f8:	d024      	beq.n	8000744 <__aeabi_fdiv+0x90>
 80006fa:	28ff      	cmp	r0, #255	; 0xff
 80006fc:	d046      	beq.n	800078c <__aeabi_fdiv+0xd8>
 80006fe:	2380      	movs	r3, #128	; 0x80
 8000700:	2100      	movs	r1, #0
 8000702:	00ed      	lsls	r5, r5, #3
 8000704:	04db      	lsls	r3, r3, #19
 8000706:	431d      	orrs	r5, r3
 8000708:	387f      	subs	r0, #127	; 0x7f
 800070a:	4647      	mov	r7, r8
 800070c:	1a38      	subs	r0, r7, r0
 800070e:	464f      	mov	r7, r9
 8000710:	430f      	orrs	r7, r1
 8000712:	00bf      	lsls	r7, r7, #2
 8000714:	46b9      	mov	r9, r7
 8000716:	0033      	movs	r3, r6
 8000718:	9a00      	ldr	r2, [sp, #0]
 800071a:	4f87      	ldr	r7, [pc, #540]	; (8000938 <__aeabi_fdiv+0x284>)
 800071c:	4053      	eors	r3, r2
 800071e:	464a      	mov	r2, r9
 8000720:	58ba      	ldr	r2, [r7, r2]
 8000722:	9301      	str	r3, [sp, #4]
 8000724:	4697      	mov	pc, r2
 8000726:	2c00      	cmp	r4, #0
 8000728:	d14e      	bne.n	80007c8 <__aeabi_fdiv+0x114>
 800072a:	2308      	movs	r3, #8
 800072c:	4699      	mov	r9, r3
 800072e:	33f7      	adds	r3, #247	; 0xf7
 8000730:	4698      	mov	r8, r3
 8000732:	3bfd      	subs	r3, #253	; 0xfd
 8000734:	469b      	mov	fp, r3
 8000736:	027d      	lsls	r5, r7, #9
 8000738:	0078      	lsls	r0, r7, #1
 800073a:	0ffb      	lsrs	r3, r7, #31
 800073c:	0a6d      	lsrs	r5, r5, #9
 800073e:	0e00      	lsrs	r0, r0, #24
 8000740:	9300      	str	r3, [sp, #0]
 8000742:	d1da      	bne.n	80006fa <__aeabi_fdiv+0x46>
 8000744:	2d00      	cmp	r5, #0
 8000746:	d126      	bne.n	8000796 <__aeabi_fdiv+0xe2>
 8000748:	2000      	movs	r0, #0
 800074a:	2101      	movs	r1, #1
 800074c:	0033      	movs	r3, r6
 800074e:	9a00      	ldr	r2, [sp, #0]
 8000750:	4f7a      	ldr	r7, [pc, #488]	; (800093c <__aeabi_fdiv+0x288>)
 8000752:	4053      	eors	r3, r2
 8000754:	4642      	mov	r2, r8
 8000756:	1a10      	subs	r0, r2, r0
 8000758:	464a      	mov	r2, r9
 800075a:	430a      	orrs	r2, r1
 800075c:	0092      	lsls	r2, r2, #2
 800075e:	58ba      	ldr	r2, [r7, r2]
 8000760:	001d      	movs	r5, r3
 8000762:	4697      	mov	pc, r2
 8000764:	9b00      	ldr	r3, [sp, #0]
 8000766:	002c      	movs	r4, r5
 8000768:	469a      	mov	sl, r3
 800076a:	468b      	mov	fp, r1
 800076c:	465b      	mov	r3, fp
 800076e:	2b02      	cmp	r3, #2
 8000770:	d131      	bne.n	80007d6 <__aeabi_fdiv+0x122>
 8000772:	4653      	mov	r3, sl
 8000774:	21ff      	movs	r1, #255	; 0xff
 8000776:	2400      	movs	r4, #0
 8000778:	e038      	b.n	80007ec <__aeabi_fdiv+0x138>
 800077a:	2c00      	cmp	r4, #0
 800077c:	d117      	bne.n	80007ae <__aeabi_fdiv+0xfa>
 800077e:	2304      	movs	r3, #4
 8000780:	4699      	mov	r9, r3
 8000782:	2300      	movs	r3, #0
 8000784:	4698      	mov	r8, r3
 8000786:	3301      	adds	r3, #1
 8000788:	469b      	mov	fp, r3
 800078a:	e7af      	b.n	80006ec <__aeabi_fdiv+0x38>
 800078c:	20ff      	movs	r0, #255	; 0xff
 800078e:	2d00      	cmp	r5, #0
 8000790:	d10b      	bne.n	80007aa <__aeabi_fdiv+0xf6>
 8000792:	2102      	movs	r1, #2
 8000794:	e7da      	b.n	800074c <__aeabi_fdiv+0x98>
 8000796:	0028      	movs	r0, r5
 8000798:	f002 f870 	bl	800287c <__clzsi2>
 800079c:	1f43      	subs	r3, r0, #5
 800079e:	409d      	lsls	r5, r3
 80007a0:	2376      	movs	r3, #118	; 0x76
 80007a2:	425b      	negs	r3, r3
 80007a4:	1a18      	subs	r0, r3, r0
 80007a6:	2100      	movs	r1, #0
 80007a8:	e7af      	b.n	800070a <__aeabi_fdiv+0x56>
 80007aa:	2103      	movs	r1, #3
 80007ac:	e7ad      	b.n	800070a <__aeabi_fdiv+0x56>
 80007ae:	0020      	movs	r0, r4
 80007b0:	f002 f864 	bl	800287c <__clzsi2>
 80007b4:	1f43      	subs	r3, r0, #5
 80007b6:	409c      	lsls	r4, r3
 80007b8:	2376      	movs	r3, #118	; 0x76
 80007ba:	425b      	negs	r3, r3
 80007bc:	1a1b      	subs	r3, r3, r0
 80007be:	4698      	mov	r8, r3
 80007c0:	2300      	movs	r3, #0
 80007c2:	4699      	mov	r9, r3
 80007c4:	469b      	mov	fp, r3
 80007c6:	e791      	b.n	80006ec <__aeabi_fdiv+0x38>
 80007c8:	230c      	movs	r3, #12
 80007ca:	4699      	mov	r9, r3
 80007cc:	33f3      	adds	r3, #243	; 0xf3
 80007ce:	4698      	mov	r8, r3
 80007d0:	3bfc      	subs	r3, #252	; 0xfc
 80007d2:	469b      	mov	fp, r3
 80007d4:	e78a      	b.n	80006ec <__aeabi_fdiv+0x38>
 80007d6:	2b03      	cmp	r3, #3
 80007d8:	d100      	bne.n	80007dc <__aeabi_fdiv+0x128>
 80007da:	e0a5      	b.n	8000928 <__aeabi_fdiv+0x274>
 80007dc:	4655      	mov	r5, sl
 80007de:	2b01      	cmp	r3, #1
 80007e0:	d000      	beq.n	80007e4 <__aeabi_fdiv+0x130>
 80007e2:	e081      	b.n	80008e8 <__aeabi_fdiv+0x234>
 80007e4:	2301      	movs	r3, #1
 80007e6:	2100      	movs	r1, #0
 80007e8:	2400      	movs	r4, #0
 80007ea:	402b      	ands	r3, r5
 80007ec:	0264      	lsls	r4, r4, #9
 80007ee:	05c9      	lsls	r1, r1, #23
 80007f0:	0a60      	lsrs	r0, r4, #9
 80007f2:	07db      	lsls	r3, r3, #31
 80007f4:	4308      	orrs	r0, r1
 80007f6:	4318      	orrs	r0, r3
 80007f8:	b003      	add	sp, #12
 80007fa:	bc3c      	pop	{r2, r3, r4, r5}
 80007fc:	4690      	mov	r8, r2
 80007fe:	4699      	mov	r9, r3
 8000800:	46a2      	mov	sl, r4
 8000802:	46ab      	mov	fp, r5
 8000804:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000806:	2480      	movs	r4, #128	; 0x80
 8000808:	2300      	movs	r3, #0
 800080a:	03e4      	lsls	r4, r4, #15
 800080c:	21ff      	movs	r1, #255	; 0xff
 800080e:	e7ed      	b.n	80007ec <__aeabi_fdiv+0x138>
 8000810:	21ff      	movs	r1, #255	; 0xff
 8000812:	2400      	movs	r4, #0
 8000814:	e7ea      	b.n	80007ec <__aeabi_fdiv+0x138>
 8000816:	2301      	movs	r3, #1
 8000818:	1a59      	subs	r1, r3, r1
 800081a:	291b      	cmp	r1, #27
 800081c:	dd66      	ble.n	80008ec <__aeabi_fdiv+0x238>
 800081e:	9a01      	ldr	r2, [sp, #4]
 8000820:	4013      	ands	r3, r2
 8000822:	2100      	movs	r1, #0
 8000824:	2400      	movs	r4, #0
 8000826:	e7e1      	b.n	80007ec <__aeabi_fdiv+0x138>
 8000828:	2380      	movs	r3, #128	; 0x80
 800082a:	03db      	lsls	r3, r3, #15
 800082c:	421c      	tst	r4, r3
 800082e:	d038      	beq.n	80008a2 <__aeabi_fdiv+0x1ee>
 8000830:	421d      	tst	r5, r3
 8000832:	d051      	beq.n	80008d8 <__aeabi_fdiv+0x224>
 8000834:	431c      	orrs	r4, r3
 8000836:	0264      	lsls	r4, r4, #9
 8000838:	0a64      	lsrs	r4, r4, #9
 800083a:	0033      	movs	r3, r6
 800083c:	21ff      	movs	r1, #255	; 0xff
 800083e:	e7d5      	b.n	80007ec <__aeabi_fdiv+0x138>
 8000840:	0163      	lsls	r3, r4, #5
 8000842:	016c      	lsls	r4, r5, #5
 8000844:	42a3      	cmp	r3, r4
 8000846:	d23b      	bcs.n	80008c0 <__aeabi_fdiv+0x20c>
 8000848:	261b      	movs	r6, #27
 800084a:	2100      	movs	r1, #0
 800084c:	3801      	subs	r0, #1
 800084e:	2501      	movs	r5, #1
 8000850:	001f      	movs	r7, r3
 8000852:	0049      	lsls	r1, r1, #1
 8000854:	005b      	lsls	r3, r3, #1
 8000856:	2f00      	cmp	r7, #0
 8000858:	db01      	blt.n	800085e <__aeabi_fdiv+0x1aa>
 800085a:	429c      	cmp	r4, r3
 800085c:	d801      	bhi.n	8000862 <__aeabi_fdiv+0x1ae>
 800085e:	1b1b      	subs	r3, r3, r4
 8000860:	4329      	orrs	r1, r5
 8000862:	3e01      	subs	r6, #1
 8000864:	2e00      	cmp	r6, #0
 8000866:	d1f3      	bne.n	8000850 <__aeabi_fdiv+0x19c>
 8000868:	001c      	movs	r4, r3
 800086a:	1e63      	subs	r3, r4, #1
 800086c:	419c      	sbcs	r4, r3
 800086e:	430c      	orrs	r4, r1
 8000870:	0001      	movs	r1, r0
 8000872:	317f      	adds	r1, #127	; 0x7f
 8000874:	2900      	cmp	r1, #0
 8000876:	ddce      	ble.n	8000816 <__aeabi_fdiv+0x162>
 8000878:	0763      	lsls	r3, r4, #29
 800087a:	d004      	beq.n	8000886 <__aeabi_fdiv+0x1d2>
 800087c:	230f      	movs	r3, #15
 800087e:	4023      	ands	r3, r4
 8000880:	2b04      	cmp	r3, #4
 8000882:	d000      	beq.n	8000886 <__aeabi_fdiv+0x1d2>
 8000884:	3404      	adds	r4, #4
 8000886:	0123      	lsls	r3, r4, #4
 8000888:	d503      	bpl.n	8000892 <__aeabi_fdiv+0x1de>
 800088a:	0001      	movs	r1, r0
 800088c:	4b2c      	ldr	r3, [pc, #176]	; (8000940 <__aeabi_fdiv+0x28c>)
 800088e:	3180      	adds	r1, #128	; 0x80
 8000890:	401c      	ands	r4, r3
 8000892:	29fe      	cmp	r1, #254	; 0xfe
 8000894:	dd0d      	ble.n	80008b2 <__aeabi_fdiv+0x1fe>
 8000896:	2301      	movs	r3, #1
 8000898:	9a01      	ldr	r2, [sp, #4]
 800089a:	21ff      	movs	r1, #255	; 0xff
 800089c:	4013      	ands	r3, r2
 800089e:	2400      	movs	r4, #0
 80008a0:	e7a4      	b.n	80007ec <__aeabi_fdiv+0x138>
 80008a2:	2380      	movs	r3, #128	; 0x80
 80008a4:	03db      	lsls	r3, r3, #15
 80008a6:	431c      	orrs	r4, r3
 80008a8:	0264      	lsls	r4, r4, #9
 80008aa:	0a64      	lsrs	r4, r4, #9
 80008ac:	0033      	movs	r3, r6
 80008ae:	21ff      	movs	r1, #255	; 0xff
 80008b0:	e79c      	b.n	80007ec <__aeabi_fdiv+0x138>
 80008b2:	2301      	movs	r3, #1
 80008b4:	9a01      	ldr	r2, [sp, #4]
 80008b6:	01a4      	lsls	r4, r4, #6
 80008b8:	0a64      	lsrs	r4, r4, #9
 80008ba:	b2c9      	uxtb	r1, r1
 80008bc:	4013      	ands	r3, r2
 80008be:	e795      	b.n	80007ec <__aeabi_fdiv+0x138>
 80008c0:	1b1b      	subs	r3, r3, r4
 80008c2:	261a      	movs	r6, #26
 80008c4:	2101      	movs	r1, #1
 80008c6:	e7c2      	b.n	800084e <__aeabi_fdiv+0x19a>
 80008c8:	9b00      	ldr	r3, [sp, #0]
 80008ca:	468b      	mov	fp, r1
 80008cc:	469a      	mov	sl, r3
 80008ce:	2400      	movs	r4, #0
 80008d0:	e74c      	b.n	800076c <__aeabi_fdiv+0xb8>
 80008d2:	0263      	lsls	r3, r4, #9
 80008d4:	d5e5      	bpl.n	80008a2 <__aeabi_fdiv+0x1ee>
 80008d6:	2500      	movs	r5, #0
 80008d8:	2480      	movs	r4, #128	; 0x80
 80008da:	03e4      	lsls	r4, r4, #15
 80008dc:	432c      	orrs	r4, r5
 80008de:	0264      	lsls	r4, r4, #9
 80008e0:	0a64      	lsrs	r4, r4, #9
 80008e2:	9b00      	ldr	r3, [sp, #0]
 80008e4:	21ff      	movs	r1, #255	; 0xff
 80008e6:	e781      	b.n	80007ec <__aeabi_fdiv+0x138>
 80008e8:	9501      	str	r5, [sp, #4]
 80008ea:	e7c1      	b.n	8000870 <__aeabi_fdiv+0x1bc>
 80008ec:	0023      	movs	r3, r4
 80008ee:	2020      	movs	r0, #32
 80008f0:	40cb      	lsrs	r3, r1
 80008f2:	1a41      	subs	r1, r0, r1
 80008f4:	408c      	lsls	r4, r1
 80008f6:	1e61      	subs	r1, r4, #1
 80008f8:	418c      	sbcs	r4, r1
 80008fa:	431c      	orrs	r4, r3
 80008fc:	0763      	lsls	r3, r4, #29
 80008fe:	d004      	beq.n	800090a <__aeabi_fdiv+0x256>
 8000900:	230f      	movs	r3, #15
 8000902:	4023      	ands	r3, r4
 8000904:	2b04      	cmp	r3, #4
 8000906:	d000      	beq.n	800090a <__aeabi_fdiv+0x256>
 8000908:	3404      	adds	r4, #4
 800090a:	0163      	lsls	r3, r4, #5
 800090c:	d505      	bpl.n	800091a <__aeabi_fdiv+0x266>
 800090e:	2301      	movs	r3, #1
 8000910:	9a01      	ldr	r2, [sp, #4]
 8000912:	2101      	movs	r1, #1
 8000914:	4013      	ands	r3, r2
 8000916:	2400      	movs	r4, #0
 8000918:	e768      	b.n	80007ec <__aeabi_fdiv+0x138>
 800091a:	2301      	movs	r3, #1
 800091c:	9a01      	ldr	r2, [sp, #4]
 800091e:	01a4      	lsls	r4, r4, #6
 8000920:	0a64      	lsrs	r4, r4, #9
 8000922:	4013      	ands	r3, r2
 8000924:	2100      	movs	r1, #0
 8000926:	e761      	b.n	80007ec <__aeabi_fdiv+0x138>
 8000928:	2380      	movs	r3, #128	; 0x80
 800092a:	03db      	lsls	r3, r3, #15
 800092c:	431c      	orrs	r4, r3
 800092e:	0264      	lsls	r4, r4, #9
 8000930:	0a64      	lsrs	r4, r4, #9
 8000932:	4653      	mov	r3, sl
 8000934:	21ff      	movs	r1, #255	; 0xff
 8000936:	e759      	b.n	80007ec <__aeabi_fdiv+0x138>
 8000938:	0800dc24 	.word	0x0800dc24
 800093c:	0800dc64 	.word	0x0800dc64
 8000940:	f7ffffff 	.word	0xf7ffffff

08000944 <__eqsf2>:
 8000944:	b570      	push	{r4, r5, r6, lr}
 8000946:	0042      	lsls	r2, r0, #1
 8000948:	0245      	lsls	r5, r0, #9
 800094a:	024e      	lsls	r6, r1, #9
 800094c:	004c      	lsls	r4, r1, #1
 800094e:	0fc3      	lsrs	r3, r0, #31
 8000950:	0a6d      	lsrs	r5, r5, #9
 8000952:	0e12      	lsrs	r2, r2, #24
 8000954:	0a76      	lsrs	r6, r6, #9
 8000956:	0e24      	lsrs	r4, r4, #24
 8000958:	0fc9      	lsrs	r1, r1, #31
 800095a:	2001      	movs	r0, #1
 800095c:	2aff      	cmp	r2, #255	; 0xff
 800095e:	d006      	beq.n	800096e <__eqsf2+0x2a>
 8000960:	2cff      	cmp	r4, #255	; 0xff
 8000962:	d003      	beq.n	800096c <__eqsf2+0x28>
 8000964:	42a2      	cmp	r2, r4
 8000966:	d101      	bne.n	800096c <__eqsf2+0x28>
 8000968:	42b5      	cmp	r5, r6
 800096a:	d006      	beq.n	800097a <__eqsf2+0x36>
 800096c:	bd70      	pop	{r4, r5, r6, pc}
 800096e:	2d00      	cmp	r5, #0
 8000970:	d1fc      	bne.n	800096c <__eqsf2+0x28>
 8000972:	2cff      	cmp	r4, #255	; 0xff
 8000974:	d1fa      	bne.n	800096c <__eqsf2+0x28>
 8000976:	2e00      	cmp	r6, #0
 8000978:	d1f8      	bne.n	800096c <__eqsf2+0x28>
 800097a:	428b      	cmp	r3, r1
 800097c:	d006      	beq.n	800098c <__eqsf2+0x48>
 800097e:	2001      	movs	r0, #1
 8000980:	2a00      	cmp	r2, #0
 8000982:	d1f3      	bne.n	800096c <__eqsf2+0x28>
 8000984:	0028      	movs	r0, r5
 8000986:	1e45      	subs	r5, r0, #1
 8000988:	41a8      	sbcs	r0, r5
 800098a:	e7ef      	b.n	800096c <__eqsf2+0x28>
 800098c:	2000      	movs	r0, #0
 800098e:	e7ed      	b.n	800096c <__eqsf2+0x28>

08000990 <__gesf2>:
 8000990:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000992:	0042      	lsls	r2, r0, #1
 8000994:	0245      	lsls	r5, r0, #9
 8000996:	024c      	lsls	r4, r1, #9
 8000998:	0fc3      	lsrs	r3, r0, #31
 800099a:	0048      	lsls	r0, r1, #1
 800099c:	0a6d      	lsrs	r5, r5, #9
 800099e:	0e12      	lsrs	r2, r2, #24
 80009a0:	0a64      	lsrs	r4, r4, #9
 80009a2:	0e00      	lsrs	r0, r0, #24
 80009a4:	0fc9      	lsrs	r1, r1, #31
 80009a6:	2aff      	cmp	r2, #255	; 0xff
 80009a8:	d01e      	beq.n	80009e8 <__gesf2+0x58>
 80009aa:	28ff      	cmp	r0, #255	; 0xff
 80009ac:	d021      	beq.n	80009f2 <__gesf2+0x62>
 80009ae:	2a00      	cmp	r2, #0
 80009b0:	d10a      	bne.n	80009c8 <__gesf2+0x38>
 80009b2:	426e      	negs	r6, r5
 80009b4:	416e      	adcs	r6, r5
 80009b6:	b2f6      	uxtb	r6, r6
 80009b8:	2800      	cmp	r0, #0
 80009ba:	d10f      	bne.n	80009dc <__gesf2+0x4c>
 80009bc:	2c00      	cmp	r4, #0
 80009be:	d10d      	bne.n	80009dc <__gesf2+0x4c>
 80009c0:	2000      	movs	r0, #0
 80009c2:	2d00      	cmp	r5, #0
 80009c4:	d009      	beq.n	80009da <__gesf2+0x4a>
 80009c6:	e005      	b.n	80009d4 <__gesf2+0x44>
 80009c8:	2800      	cmp	r0, #0
 80009ca:	d101      	bne.n	80009d0 <__gesf2+0x40>
 80009cc:	2c00      	cmp	r4, #0
 80009ce:	d001      	beq.n	80009d4 <__gesf2+0x44>
 80009d0:	428b      	cmp	r3, r1
 80009d2:	d011      	beq.n	80009f8 <__gesf2+0x68>
 80009d4:	2101      	movs	r1, #1
 80009d6:	4258      	negs	r0, r3
 80009d8:	4308      	orrs	r0, r1
 80009da:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80009dc:	2e00      	cmp	r6, #0
 80009de:	d0f7      	beq.n	80009d0 <__gesf2+0x40>
 80009e0:	2001      	movs	r0, #1
 80009e2:	3901      	subs	r1, #1
 80009e4:	4308      	orrs	r0, r1
 80009e6:	e7f8      	b.n	80009da <__gesf2+0x4a>
 80009e8:	2d00      	cmp	r5, #0
 80009ea:	d0de      	beq.n	80009aa <__gesf2+0x1a>
 80009ec:	2002      	movs	r0, #2
 80009ee:	4240      	negs	r0, r0
 80009f0:	e7f3      	b.n	80009da <__gesf2+0x4a>
 80009f2:	2c00      	cmp	r4, #0
 80009f4:	d0db      	beq.n	80009ae <__gesf2+0x1e>
 80009f6:	e7f9      	b.n	80009ec <__gesf2+0x5c>
 80009f8:	4282      	cmp	r2, r0
 80009fa:	dceb      	bgt.n	80009d4 <__gesf2+0x44>
 80009fc:	db04      	blt.n	8000a08 <__gesf2+0x78>
 80009fe:	42a5      	cmp	r5, r4
 8000a00:	d8e8      	bhi.n	80009d4 <__gesf2+0x44>
 8000a02:	2000      	movs	r0, #0
 8000a04:	42a5      	cmp	r5, r4
 8000a06:	d2e8      	bcs.n	80009da <__gesf2+0x4a>
 8000a08:	2101      	movs	r1, #1
 8000a0a:	1e58      	subs	r0, r3, #1
 8000a0c:	4308      	orrs	r0, r1
 8000a0e:	e7e4      	b.n	80009da <__gesf2+0x4a>

08000a10 <__lesf2>:
 8000a10:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a12:	0042      	lsls	r2, r0, #1
 8000a14:	024d      	lsls	r5, r1, #9
 8000a16:	004c      	lsls	r4, r1, #1
 8000a18:	0246      	lsls	r6, r0, #9
 8000a1a:	0a76      	lsrs	r6, r6, #9
 8000a1c:	0e12      	lsrs	r2, r2, #24
 8000a1e:	0fc3      	lsrs	r3, r0, #31
 8000a20:	0a6d      	lsrs	r5, r5, #9
 8000a22:	0e24      	lsrs	r4, r4, #24
 8000a24:	0fc9      	lsrs	r1, r1, #31
 8000a26:	2aff      	cmp	r2, #255	; 0xff
 8000a28:	d016      	beq.n	8000a58 <__lesf2+0x48>
 8000a2a:	2cff      	cmp	r4, #255	; 0xff
 8000a2c:	d018      	beq.n	8000a60 <__lesf2+0x50>
 8000a2e:	2a00      	cmp	r2, #0
 8000a30:	d10a      	bne.n	8000a48 <__lesf2+0x38>
 8000a32:	4270      	negs	r0, r6
 8000a34:	4170      	adcs	r0, r6
 8000a36:	b2c0      	uxtb	r0, r0
 8000a38:	2c00      	cmp	r4, #0
 8000a3a:	d015      	beq.n	8000a68 <__lesf2+0x58>
 8000a3c:	2800      	cmp	r0, #0
 8000a3e:	d005      	beq.n	8000a4c <__lesf2+0x3c>
 8000a40:	2001      	movs	r0, #1
 8000a42:	3901      	subs	r1, #1
 8000a44:	4308      	orrs	r0, r1
 8000a46:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000a48:	2c00      	cmp	r4, #0
 8000a4a:	d013      	beq.n	8000a74 <__lesf2+0x64>
 8000a4c:	4299      	cmp	r1, r3
 8000a4e:	d014      	beq.n	8000a7a <__lesf2+0x6a>
 8000a50:	2001      	movs	r0, #1
 8000a52:	425b      	negs	r3, r3
 8000a54:	4318      	orrs	r0, r3
 8000a56:	e7f6      	b.n	8000a46 <__lesf2+0x36>
 8000a58:	2002      	movs	r0, #2
 8000a5a:	2e00      	cmp	r6, #0
 8000a5c:	d1f3      	bne.n	8000a46 <__lesf2+0x36>
 8000a5e:	e7e4      	b.n	8000a2a <__lesf2+0x1a>
 8000a60:	2002      	movs	r0, #2
 8000a62:	2d00      	cmp	r5, #0
 8000a64:	d1ef      	bne.n	8000a46 <__lesf2+0x36>
 8000a66:	e7e2      	b.n	8000a2e <__lesf2+0x1e>
 8000a68:	2d00      	cmp	r5, #0
 8000a6a:	d1e7      	bne.n	8000a3c <__lesf2+0x2c>
 8000a6c:	2000      	movs	r0, #0
 8000a6e:	2e00      	cmp	r6, #0
 8000a70:	d0e9      	beq.n	8000a46 <__lesf2+0x36>
 8000a72:	e7ed      	b.n	8000a50 <__lesf2+0x40>
 8000a74:	2d00      	cmp	r5, #0
 8000a76:	d1e9      	bne.n	8000a4c <__lesf2+0x3c>
 8000a78:	e7ea      	b.n	8000a50 <__lesf2+0x40>
 8000a7a:	42a2      	cmp	r2, r4
 8000a7c:	dc06      	bgt.n	8000a8c <__lesf2+0x7c>
 8000a7e:	dbdf      	blt.n	8000a40 <__lesf2+0x30>
 8000a80:	42ae      	cmp	r6, r5
 8000a82:	d803      	bhi.n	8000a8c <__lesf2+0x7c>
 8000a84:	2000      	movs	r0, #0
 8000a86:	42ae      	cmp	r6, r5
 8000a88:	d3da      	bcc.n	8000a40 <__lesf2+0x30>
 8000a8a:	e7dc      	b.n	8000a46 <__lesf2+0x36>
 8000a8c:	2001      	movs	r0, #1
 8000a8e:	4249      	negs	r1, r1
 8000a90:	4308      	orrs	r0, r1
 8000a92:	e7d8      	b.n	8000a46 <__lesf2+0x36>

08000a94 <__aeabi_fmul>:
 8000a94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000a96:	4657      	mov	r7, sl
 8000a98:	464e      	mov	r6, r9
 8000a9a:	4645      	mov	r5, r8
 8000a9c:	46de      	mov	lr, fp
 8000a9e:	b5e0      	push	{r5, r6, r7, lr}
 8000aa0:	0247      	lsls	r7, r0, #9
 8000aa2:	0046      	lsls	r6, r0, #1
 8000aa4:	4688      	mov	r8, r1
 8000aa6:	0a7f      	lsrs	r7, r7, #9
 8000aa8:	0e36      	lsrs	r6, r6, #24
 8000aaa:	0fc4      	lsrs	r4, r0, #31
 8000aac:	2e00      	cmp	r6, #0
 8000aae:	d047      	beq.n	8000b40 <__aeabi_fmul+0xac>
 8000ab0:	2eff      	cmp	r6, #255	; 0xff
 8000ab2:	d024      	beq.n	8000afe <__aeabi_fmul+0x6a>
 8000ab4:	00fb      	lsls	r3, r7, #3
 8000ab6:	2780      	movs	r7, #128	; 0x80
 8000ab8:	04ff      	lsls	r7, r7, #19
 8000aba:	431f      	orrs	r7, r3
 8000abc:	2300      	movs	r3, #0
 8000abe:	4699      	mov	r9, r3
 8000ac0:	469a      	mov	sl, r3
 8000ac2:	3e7f      	subs	r6, #127	; 0x7f
 8000ac4:	4643      	mov	r3, r8
 8000ac6:	025d      	lsls	r5, r3, #9
 8000ac8:	0058      	lsls	r0, r3, #1
 8000aca:	0fdb      	lsrs	r3, r3, #31
 8000acc:	0a6d      	lsrs	r5, r5, #9
 8000ace:	0e00      	lsrs	r0, r0, #24
 8000ad0:	4698      	mov	r8, r3
 8000ad2:	d043      	beq.n	8000b5c <__aeabi_fmul+0xc8>
 8000ad4:	28ff      	cmp	r0, #255	; 0xff
 8000ad6:	d03b      	beq.n	8000b50 <__aeabi_fmul+0xbc>
 8000ad8:	00eb      	lsls	r3, r5, #3
 8000ada:	2580      	movs	r5, #128	; 0x80
 8000adc:	2200      	movs	r2, #0
 8000ade:	04ed      	lsls	r5, r5, #19
 8000ae0:	431d      	orrs	r5, r3
 8000ae2:	387f      	subs	r0, #127	; 0x7f
 8000ae4:	1836      	adds	r6, r6, r0
 8000ae6:	1c73      	adds	r3, r6, #1
 8000ae8:	4641      	mov	r1, r8
 8000aea:	469b      	mov	fp, r3
 8000aec:	464b      	mov	r3, r9
 8000aee:	4061      	eors	r1, r4
 8000af0:	4313      	orrs	r3, r2
 8000af2:	2b0f      	cmp	r3, #15
 8000af4:	d864      	bhi.n	8000bc0 <__aeabi_fmul+0x12c>
 8000af6:	4875      	ldr	r0, [pc, #468]	; (8000ccc <__aeabi_fmul+0x238>)
 8000af8:	009b      	lsls	r3, r3, #2
 8000afa:	58c3      	ldr	r3, [r0, r3]
 8000afc:	469f      	mov	pc, r3
 8000afe:	2f00      	cmp	r7, #0
 8000b00:	d142      	bne.n	8000b88 <__aeabi_fmul+0xf4>
 8000b02:	2308      	movs	r3, #8
 8000b04:	4699      	mov	r9, r3
 8000b06:	3b06      	subs	r3, #6
 8000b08:	26ff      	movs	r6, #255	; 0xff
 8000b0a:	469a      	mov	sl, r3
 8000b0c:	e7da      	b.n	8000ac4 <__aeabi_fmul+0x30>
 8000b0e:	4641      	mov	r1, r8
 8000b10:	2a02      	cmp	r2, #2
 8000b12:	d028      	beq.n	8000b66 <__aeabi_fmul+0xd2>
 8000b14:	2a03      	cmp	r2, #3
 8000b16:	d100      	bne.n	8000b1a <__aeabi_fmul+0x86>
 8000b18:	e0ce      	b.n	8000cb8 <__aeabi_fmul+0x224>
 8000b1a:	2a01      	cmp	r2, #1
 8000b1c:	d000      	beq.n	8000b20 <__aeabi_fmul+0x8c>
 8000b1e:	e0ac      	b.n	8000c7a <__aeabi_fmul+0x1e6>
 8000b20:	4011      	ands	r1, r2
 8000b22:	2000      	movs	r0, #0
 8000b24:	2200      	movs	r2, #0
 8000b26:	b2cc      	uxtb	r4, r1
 8000b28:	0240      	lsls	r0, r0, #9
 8000b2a:	05d2      	lsls	r2, r2, #23
 8000b2c:	0a40      	lsrs	r0, r0, #9
 8000b2e:	07e4      	lsls	r4, r4, #31
 8000b30:	4310      	orrs	r0, r2
 8000b32:	4320      	orrs	r0, r4
 8000b34:	bc3c      	pop	{r2, r3, r4, r5}
 8000b36:	4690      	mov	r8, r2
 8000b38:	4699      	mov	r9, r3
 8000b3a:	46a2      	mov	sl, r4
 8000b3c:	46ab      	mov	fp, r5
 8000b3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000b40:	2f00      	cmp	r7, #0
 8000b42:	d115      	bne.n	8000b70 <__aeabi_fmul+0xdc>
 8000b44:	2304      	movs	r3, #4
 8000b46:	4699      	mov	r9, r3
 8000b48:	3b03      	subs	r3, #3
 8000b4a:	2600      	movs	r6, #0
 8000b4c:	469a      	mov	sl, r3
 8000b4e:	e7b9      	b.n	8000ac4 <__aeabi_fmul+0x30>
 8000b50:	20ff      	movs	r0, #255	; 0xff
 8000b52:	2202      	movs	r2, #2
 8000b54:	2d00      	cmp	r5, #0
 8000b56:	d0c5      	beq.n	8000ae4 <__aeabi_fmul+0x50>
 8000b58:	2203      	movs	r2, #3
 8000b5a:	e7c3      	b.n	8000ae4 <__aeabi_fmul+0x50>
 8000b5c:	2d00      	cmp	r5, #0
 8000b5e:	d119      	bne.n	8000b94 <__aeabi_fmul+0x100>
 8000b60:	2000      	movs	r0, #0
 8000b62:	2201      	movs	r2, #1
 8000b64:	e7be      	b.n	8000ae4 <__aeabi_fmul+0x50>
 8000b66:	2401      	movs	r4, #1
 8000b68:	22ff      	movs	r2, #255	; 0xff
 8000b6a:	400c      	ands	r4, r1
 8000b6c:	2000      	movs	r0, #0
 8000b6e:	e7db      	b.n	8000b28 <__aeabi_fmul+0x94>
 8000b70:	0038      	movs	r0, r7
 8000b72:	f001 fe83 	bl	800287c <__clzsi2>
 8000b76:	2676      	movs	r6, #118	; 0x76
 8000b78:	1f43      	subs	r3, r0, #5
 8000b7a:	409f      	lsls	r7, r3
 8000b7c:	2300      	movs	r3, #0
 8000b7e:	4276      	negs	r6, r6
 8000b80:	1a36      	subs	r6, r6, r0
 8000b82:	4699      	mov	r9, r3
 8000b84:	469a      	mov	sl, r3
 8000b86:	e79d      	b.n	8000ac4 <__aeabi_fmul+0x30>
 8000b88:	230c      	movs	r3, #12
 8000b8a:	4699      	mov	r9, r3
 8000b8c:	3b09      	subs	r3, #9
 8000b8e:	26ff      	movs	r6, #255	; 0xff
 8000b90:	469a      	mov	sl, r3
 8000b92:	e797      	b.n	8000ac4 <__aeabi_fmul+0x30>
 8000b94:	0028      	movs	r0, r5
 8000b96:	f001 fe71 	bl	800287c <__clzsi2>
 8000b9a:	1f43      	subs	r3, r0, #5
 8000b9c:	409d      	lsls	r5, r3
 8000b9e:	2376      	movs	r3, #118	; 0x76
 8000ba0:	425b      	negs	r3, r3
 8000ba2:	1a18      	subs	r0, r3, r0
 8000ba4:	2200      	movs	r2, #0
 8000ba6:	e79d      	b.n	8000ae4 <__aeabi_fmul+0x50>
 8000ba8:	2080      	movs	r0, #128	; 0x80
 8000baa:	2400      	movs	r4, #0
 8000bac:	03c0      	lsls	r0, r0, #15
 8000bae:	22ff      	movs	r2, #255	; 0xff
 8000bb0:	e7ba      	b.n	8000b28 <__aeabi_fmul+0x94>
 8000bb2:	003d      	movs	r5, r7
 8000bb4:	4652      	mov	r2, sl
 8000bb6:	e7ab      	b.n	8000b10 <__aeabi_fmul+0x7c>
 8000bb8:	003d      	movs	r5, r7
 8000bba:	0021      	movs	r1, r4
 8000bbc:	4652      	mov	r2, sl
 8000bbe:	e7a7      	b.n	8000b10 <__aeabi_fmul+0x7c>
 8000bc0:	0c3b      	lsrs	r3, r7, #16
 8000bc2:	469c      	mov	ip, r3
 8000bc4:	042a      	lsls	r2, r5, #16
 8000bc6:	0c12      	lsrs	r2, r2, #16
 8000bc8:	0c2b      	lsrs	r3, r5, #16
 8000bca:	0014      	movs	r4, r2
 8000bcc:	4660      	mov	r0, ip
 8000bce:	4665      	mov	r5, ip
 8000bd0:	043f      	lsls	r7, r7, #16
 8000bd2:	0c3f      	lsrs	r7, r7, #16
 8000bd4:	437c      	muls	r4, r7
 8000bd6:	4342      	muls	r2, r0
 8000bd8:	435d      	muls	r5, r3
 8000bda:	437b      	muls	r3, r7
 8000bdc:	0c27      	lsrs	r7, r4, #16
 8000bde:	189b      	adds	r3, r3, r2
 8000be0:	18ff      	adds	r7, r7, r3
 8000be2:	42ba      	cmp	r2, r7
 8000be4:	d903      	bls.n	8000bee <__aeabi_fmul+0x15a>
 8000be6:	2380      	movs	r3, #128	; 0x80
 8000be8:	025b      	lsls	r3, r3, #9
 8000bea:	469c      	mov	ip, r3
 8000bec:	4465      	add	r5, ip
 8000bee:	0424      	lsls	r4, r4, #16
 8000bf0:	043a      	lsls	r2, r7, #16
 8000bf2:	0c24      	lsrs	r4, r4, #16
 8000bf4:	1912      	adds	r2, r2, r4
 8000bf6:	0193      	lsls	r3, r2, #6
 8000bf8:	1e5c      	subs	r4, r3, #1
 8000bfa:	41a3      	sbcs	r3, r4
 8000bfc:	0c3f      	lsrs	r7, r7, #16
 8000bfe:	0e92      	lsrs	r2, r2, #26
 8000c00:	197d      	adds	r5, r7, r5
 8000c02:	431a      	orrs	r2, r3
 8000c04:	01ad      	lsls	r5, r5, #6
 8000c06:	4315      	orrs	r5, r2
 8000c08:	012b      	lsls	r3, r5, #4
 8000c0a:	d504      	bpl.n	8000c16 <__aeabi_fmul+0x182>
 8000c0c:	2301      	movs	r3, #1
 8000c0e:	465e      	mov	r6, fp
 8000c10:	086a      	lsrs	r2, r5, #1
 8000c12:	401d      	ands	r5, r3
 8000c14:	4315      	orrs	r5, r2
 8000c16:	0032      	movs	r2, r6
 8000c18:	327f      	adds	r2, #127	; 0x7f
 8000c1a:	2a00      	cmp	r2, #0
 8000c1c:	dd25      	ble.n	8000c6a <__aeabi_fmul+0x1d6>
 8000c1e:	076b      	lsls	r3, r5, #29
 8000c20:	d004      	beq.n	8000c2c <__aeabi_fmul+0x198>
 8000c22:	230f      	movs	r3, #15
 8000c24:	402b      	ands	r3, r5
 8000c26:	2b04      	cmp	r3, #4
 8000c28:	d000      	beq.n	8000c2c <__aeabi_fmul+0x198>
 8000c2a:	3504      	adds	r5, #4
 8000c2c:	012b      	lsls	r3, r5, #4
 8000c2e:	d503      	bpl.n	8000c38 <__aeabi_fmul+0x1a4>
 8000c30:	0032      	movs	r2, r6
 8000c32:	4b27      	ldr	r3, [pc, #156]	; (8000cd0 <__aeabi_fmul+0x23c>)
 8000c34:	3280      	adds	r2, #128	; 0x80
 8000c36:	401d      	ands	r5, r3
 8000c38:	2afe      	cmp	r2, #254	; 0xfe
 8000c3a:	dc94      	bgt.n	8000b66 <__aeabi_fmul+0xd2>
 8000c3c:	2401      	movs	r4, #1
 8000c3e:	01a8      	lsls	r0, r5, #6
 8000c40:	0a40      	lsrs	r0, r0, #9
 8000c42:	b2d2      	uxtb	r2, r2
 8000c44:	400c      	ands	r4, r1
 8000c46:	e76f      	b.n	8000b28 <__aeabi_fmul+0x94>
 8000c48:	2080      	movs	r0, #128	; 0x80
 8000c4a:	03c0      	lsls	r0, r0, #15
 8000c4c:	4207      	tst	r7, r0
 8000c4e:	d007      	beq.n	8000c60 <__aeabi_fmul+0x1cc>
 8000c50:	4205      	tst	r5, r0
 8000c52:	d105      	bne.n	8000c60 <__aeabi_fmul+0x1cc>
 8000c54:	4328      	orrs	r0, r5
 8000c56:	0240      	lsls	r0, r0, #9
 8000c58:	0a40      	lsrs	r0, r0, #9
 8000c5a:	4644      	mov	r4, r8
 8000c5c:	22ff      	movs	r2, #255	; 0xff
 8000c5e:	e763      	b.n	8000b28 <__aeabi_fmul+0x94>
 8000c60:	4338      	orrs	r0, r7
 8000c62:	0240      	lsls	r0, r0, #9
 8000c64:	0a40      	lsrs	r0, r0, #9
 8000c66:	22ff      	movs	r2, #255	; 0xff
 8000c68:	e75e      	b.n	8000b28 <__aeabi_fmul+0x94>
 8000c6a:	2401      	movs	r4, #1
 8000c6c:	1aa3      	subs	r3, r4, r2
 8000c6e:	2b1b      	cmp	r3, #27
 8000c70:	dd05      	ble.n	8000c7e <__aeabi_fmul+0x1ea>
 8000c72:	400c      	ands	r4, r1
 8000c74:	2200      	movs	r2, #0
 8000c76:	2000      	movs	r0, #0
 8000c78:	e756      	b.n	8000b28 <__aeabi_fmul+0x94>
 8000c7a:	465e      	mov	r6, fp
 8000c7c:	e7cb      	b.n	8000c16 <__aeabi_fmul+0x182>
 8000c7e:	002a      	movs	r2, r5
 8000c80:	2020      	movs	r0, #32
 8000c82:	40da      	lsrs	r2, r3
 8000c84:	1ac3      	subs	r3, r0, r3
 8000c86:	409d      	lsls	r5, r3
 8000c88:	002b      	movs	r3, r5
 8000c8a:	1e5d      	subs	r5, r3, #1
 8000c8c:	41ab      	sbcs	r3, r5
 8000c8e:	4313      	orrs	r3, r2
 8000c90:	075a      	lsls	r2, r3, #29
 8000c92:	d004      	beq.n	8000c9e <__aeabi_fmul+0x20a>
 8000c94:	220f      	movs	r2, #15
 8000c96:	401a      	ands	r2, r3
 8000c98:	2a04      	cmp	r2, #4
 8000c9a:	d000      	beq.n	8000c9e <__aeabi_fmul+0x20a>
 8000c9c:	3304      	adds	r3, #4
 8000c9e:	015a      	lsls	r2, r3, #5
 8000ca0:	d504      	bpl.n	8000cac <__aeabi_fmul+0x218>
 8000ca2:	2401      	movs	r4, #1
 8000ca4:	2201      	movs	r2, #1
 8000ca6:	400c      	ands	r4, r1
 8000ca8:	2000      	movs	r0, #0
 8000caa:	e73d      	b.n	8000b28 <__aeabi_fmul+0x94>
 8000cac:	2401      	movs	r4, #1
 8000cae:	019b      	lsls	r3, r3, #6
 8000cb0:	0a58      	lsrs	r0, r3, #9
 8000cb2:	400c      	ands	r4, r1
 8000cb4:	2200      	movs	r2, #0
 8000cb6:	e737      	b.n	8000b28 <__aeabi_fmul+0x94>
 8000cb8:	2080      	movs	r0, #128	; 0x80
 8000cba:	2401      	movs	r4, #1
 8000cbc:	03c0      	lsls	r0, r0, #15
 8000cbe:	4328      	orrs	r0, r5
 8000cc0:	0240      	lsls	r0, r0, #9
 8000cc2:	0a40      	lsrs	r0, r0, #9
 8000cc4:	400c      	ands	r4, r1
 8000cc6:	22ff      	movs	r2, #255	; 0xff
 8000cc8:	e72e      	b.n	8000b28 <__aeabi_fmul+0x94>
 8000cca:	46c0      	nop			; (mov r8, r8)
 8000ccc:	0800dca4 	.word	0x0800dca4
 8000cd0:	f7ffffff 	.word	0xf7ffffff

08000cd4 <__aeabi_fsub>:
 8000cd4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000cd6:	464f      	mov	r7, r9
 8000cd8:	46d6      	mov	lr, sl
 8000cda:	4646      	mov	r6, r8
 8000cdc:	0044      	lsls	r4, r0, #1
 8000cde:	b5c0      	push	{r6, r7, lr}
 8000ce0:	0fc2      	lsrs	r2, r0, #31
 8000ce2:	0247      	lsls	r7, r0, #9
 8000ce4:	0248      	lsls	r0, r1, #9
 8000ce6:	0a40      	lsrs	r0, r0, #9
 8000ce8:	4684      	mov	ip, r0
 8000cea:	4666      	mov	r6, ip
 8000cec:	0a7b      	lsrs	r3, r7, #9
 8000cee:	0048      	lsls	r0, r1, #1
 8000cf0:	0fc9      	lsrs	r1, r1, #31
 8000cf2:	469a      	mov	sl, r3
 8000cf4:	0e24      	lsrs	r4, r4, #24
 8000cf6:	0015      	movs	r5, r2
 8000cf8:	00db      	lsls	r3, r3, #3
 8000cfa:	0e00      	lsrs	r0, r0, #24
 8000cfc:	4689      	mov	r9, r1
 8000cfe:	00f6      	lsls	r6, r6, #3
 8000d00:	28ff      	cmp	r0, #255	; 0xff
 8000d02:	d100      	bne.n	8000d06 <__aeabi_fsub+0x32>
 8000d04:	e08f      	b.n	8000e26 <__aeabi_fsub+0x152>
 8000d06:	2101      	movs	r1, #1
 8000d08:	464f      	mov	r7, r9
 8000d0a:	404f      	eors	r7, r1
 8000d0c:	0039      	movs	r1, r7
 8000d0e:	4291      	cmp	r1, r2
 8000d10:	d066      	beq.n	8000de0 <__aeabi_fsub+0x10c>
 8000d12:	1a22      	subs	r2, r4, r0
 8000d14:	2a00      	cmp	r2, #0
 8000d16:	dc00      	bgt.n	8000d1a <__aeabi_fsub+0x46>
 8000d18:	e09d      	b.n	8000e56 <__aeabi_fsub+0x182>
 8000d1a:	2800      	cmp	r0, #0
 8000d1c:	d13d      	bne.n	8000d9a <__aeabi_fsub+0xc6>
 8000d1e:	2e00      	cmp	r6, #0
 8000d20:	d100      	bne.n	8000d24 <__aeabi_fsub+0x50>
 8000d22:	e08b      	b.n	8000e3c <__aeabi_fsub+0x168>
 8000d24:	1e51      	subs	r1, r2, #1
 8000d26:	2900      	cmp	r1, #0
 8000d28:	d000      	beq.n	8000d2c <__aeabi_fsub+0x58>
 8000d2a:	e0b5      	b.n	8000e98 <__aeabi_fsub+0x1c4>
 8000d2c:	2401      	movs	r4, #1
 8000d2e:	1b9b      	subs	r3, r3, r6
 8000d30:	015a      	lsls	r2, r3, #5
 8000d32:	d544      	bpl.n	8000dbe <__aeabi_fsub+0xea>
 8000d34:	019b      	lsls	r3, r3, #6
 8000d36:	099f      	lsrs	r7, r3, #6
 8000d38:	0038      	movs	r0, r7
 8000d3a:	f001 fd9f 	bl	800287c <__clzsi2>
 8000d3e:	3805      	subs	r0, #5
 8000d40:	4087      	lsls	r7, r0
 8000d42:	4284      	cmp	r4, r0
 8000d44:	dd00      	ble.n	8000d48 <__aeabi_fsub+0x74>
 8000d46:	e096      	b.n	8000e76 <__aeabi_fsub+0x1a2>
 8000d48:	1b04      	subs	r4, r0, r4
 8000d4a:	003a      	movs	r2, r7
 8000d4c:	2020      	movs	r0, #32
 8000d4e:	3401      	adds	r4, #1
 8000d50:	40e2      	lsrs	r2, r4
 8000d52:	1b04      	subs	r4, r0, r4
 8000d54:	40a7      	lsls	r7, r4
 8000d56:	003b      	movs	r3, r7
 8000d58:	1e5f      	subs	r7, r3, #1
 8000d5a:	41bb      	sbcs	r3, r7
 8000d5c:	2400      	movs	r4, #0
 8000d5e:	4313      	orrs	r3, r2
 8000d60:	075a      	lsls	r2, r3, #29
 8000d62:	d004      	beq.n	8000d6e <__aeabi_fsub+0x9a>
 8000d64:	220f      	movs	r2, #15
 8000d66:	401a      	ands	r2, r3
 8000d68:	2a04      	cmp	r2, #4
 8000d6a:	d000      	beq.n	8000d6e <__aeabi_fsub+0x9a>
 8000d6c:	3304      	adds	r3, #4
 8000d6e:	015a      	lsls	r2, r3, #5
 8000d70:	d527      	bpl.n	8000dc2 <__aeabi_fsub+0xee>
 8000d72:	3401      	adds	r4, #1
 8000d74:	2cff      	cmp	r4, #255	; 0xff
 8000d76:	d100      	bne.n	8000d7a <__aeabi_fsub+0xa6>
 8000d78:	e079      	b.n	8000e6e <__aeabi_fsub+0x19a>
 8000d7a:	2201      	movs	r2, #1
 8000d7c:	019b      	lsls	r3, r3, #6
 8000d7e:	0a5b      	lsrs	r3, r3, #9
 8000d80:	b2e4      	uxtb	r4, r4
 8000d82:	402a      	ands	r2, r5
 8000d84:	025b      	lsls	r3, r3, #9
 8000d86:	05e4      	lsls	r4, r4, #23
 8000d88:	0a58      	lsrs	r0, r3, #9
 8000d8a:	07d2      	lsls	r2, r2, #31
 8000d8c:	4320      	orrs	r0, r4
 8000d8e:	4310      	orrs	r0, r2
 8000d90:	bc1c      	pop	{r2, r3, r4}
 8000d92:	4690      	mov	r8, r2
 8000d94:	4699      	mov	r9, r3
 8000d96:	46a2      	mov	sl, r4
 8000d98:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000d9a:	2cff      	cmp	r4, #255	; 0xff
 8000d9c:	d0e0      	beq.n	8000d60 <__aeabi_fsub+0x8c>
 8000d9e:	2180      	movs	r1, #128	; 0x80
 8000da0:	04c9      	lsls	r1, r1, #19
 8000da2:	430e      	orrs	r6, r1
 8000da4:	2a1b      	cmp	r2, #27
 8000da6:	dc7b      	bgt.n	8000ea0 <__aeabi_fsub+0x1cc>
 8000da8:	0031      	movs	r1, r6
 8000daa:	2020      	movs	r0, #32
 8000dac:	40d1      	lsrs	r1, r2
 8000dae:	1a82      	subs	r2, r0, r2
 8000db0:	4096      	lsls	r6, r2
 8000db2:	1e72      	subs	r2, r6, #1
 8000db4:	4196      	sbcs	r6, r2
 8000db6:	430e      	orrs	r6, r1
 8000db8:	1b9b      	subs	r3, r3, r6
 8000dba:	015a      	lsls	r2, r3, #5
 8000dbc:	d4ba      	bmi.n	8000d34 <__aeabi_fsub+0x60>
 8000dbe:	075a      	lsls	r2, r3, #29
 8000dc0:	d1d0      	bne.n	8000d64 <__aeabi_fsub+0x90>
 8000dc2:	2201      	movs	r2, #1
 8000dc4:	08df      	lsrs	r7, r3, #3
 8000dc6:	402a      	ands	r2, r5
 8000dc8:	2cff      	cmp	r4, #255	; 0xff
 8000dca:	d133      	bne.n	8000e34 <__aeabi_fsub+0x160>
 8000dcc:	2f00      	cmp	r7, #0
 8000dce:	d100      	bne.n	8000dd2 <__aeabi_fsub+0xfe>
 8000dd0:	e0a8      	b.n	8000f24 <__aeabi_fsub+0x250>
 8000dd2:	2380      	movs	r3, #128	; 0x80
 8000dd4:	03db      	lsls	r3, r3, #15
 8000dd6:	433b      	orrs	r3, r7
 8000dd8:	025b      	lsls	r3, r3, #9
 8000dda:	0a5b      	lsrs	r3, r3, #9
 8000ddc:	24ff      	movs	r4, #255	; 0xff
 8000dde:	e7d1      	b.n	8000d84 <__aeabi_fsub+0xb0>
 8000de0:	1a21      	subs	r1, r4, r0
 8000de2:	2900      	cmp	r1, #0
 8000de4:	dd4c      	ble.n	8000e80 <__aeabi_fsub+0x1ac>
 8000de6:	2800      	cmp	r0, #0
 8000de8:	d02a      	beq.n	8000e40 <__aeabi_fsub+0x16c>
 8000dea:	2cff      	cmp	r4, #255	; 0xff
 8000dec:	d0b8      	beq.n	8000d60 <__aeabi_fsub+0x8c>
 8000dee:	2080      	movs	r0, #128	; 0x80
 8000df0:	04c0      	lsls	r0, r0, #19
 8000df2:	4306      	orrs	r6, r0
 8000df4:	291b      	cmp	r1, #27
 8000df6:	dd00      	ble.n	8000dfa <__aeabi_fsub+0x126>
 8000df8:	e0af      	b.n	8000f5a <__aeabi_fsub+0x286>
 8000dfa:	0030      	movs	r0, r6
 8000dfc:	2720      	movs	r7, #32
 8000dfe:	40c8      	lsrs	r0, r1
 8000e00:	1a79      	subs	r1, r7, r1
 8000e02:	408e      	lsls	r6, r1
 8000e04:	1e71      	subs	r1, r6, #1
 8000e06:	418e      	sbcs	r6, r1
 8000e08:	4306      	orrs	r6, r0
 8000e0a:	199b      	adds	r3, r3, r6
 8000e0c:	0159      	lsls	r1, r3, #5
 8000e0e:	d5d6      	bpl.n	8000dbe <__aeabi_fsub+0xea>
 8000e10:	3401      	adds	r4, #1
 8000e12:	2cff      	cmp	r4, #255	; 0xff
 8000e14:	d100      	bne.n	8000e18 <__aeabi_fsub+0x144>
 8000e16:	e085      	b.n	8000f24 <__aeabi_fsub+0x250>
 8000e18:	2201      	movs	r2, #1
 8000e1a:	497a      	ldr	r1, [pc, #488]	; (8001004 <__aeabi_fsub+0x330>)
 8000e1c:	401a      	ands	r2, r3
 8000e1e:	085b      	lsrs	r3, r3, #1
 8000e20:	400b      	ands	r3, r1
 8000e22:	4313      	orrs	r3, r2
 8000e24:	e79c      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000e26:	2e00      	cmp	r6, #0
 8000e28:	d000      	beq.n	8000e2c <__aeabi_fsub+0x158>
 8000e2a:	e770      	b.n	8000d0e <__aeabi_fsub+0x3a>
 8000e2c:	e76b      	b.n	8000d06 <__aeabi_fsub+0x32>
 8000e2e:	1e3b      	subs	r3, r7, #0
 8000e30:	d1c5      	bne.n	8000dbe <__aeabi_fsub+0xea>
 8000e32:	2200      	movs	r2, #0
 8000e34:	027b      	lsls	r3, r7, #9
 8000e36:	0a5b      	lsrs	r3, r3, #9
 8000e38:	b2e4      	uxtb	r4, r4
 8000e3a:	e7a3      	b.n	8000d84 <__aeabi_fsub+0xb0>
 8000e3c:	0014      	movs	r4, r2
 8000e3e:	e78f      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000e40:	2e00      	cmp	r6, #0
 8000e42:	d04d      	beq.n	8000ee0 <__aeabi_fsub+0x20c>
 8000e44:	1e48      	subs	r0, r1, #1
 8000e46:	2800      	cmp	r0, #0
 8000e48:	d157      	bne.n	8000efa <__aeabi_fsub+0x226>
 8000e4a:	199b      	adds	r3, r3, r6
 8000e4c:	2401      	movs	r4, #1
 8000e4e:	015a      	lsls	r2, r3, #5
 8000e50:	d5b5      	bpl.n	8000dbe <__aeabi_fsub+0xea>
 8000e52:	2402      	movs	r4, #2
 8000e54:	e7e0      	b.n	8000e18 <__aeabi_fsub+0x144>
 8000e56:	2a00      	cmp	r2, #0
 8000e58:	d125      	bne.n	8000ea6 <__aeabi_fsub+0x1d2>
 8000e5a:	1c62      	adds	r2, r4, #1
 8000e5c:	b2d2      	uxtb	r2, r2
 8000e5e:	2a01      	cmp	r2, #1
 8000e60:	dd72      	ble.n	8000f48 <__aeabi_fsub+0x274>
 8000e62:	1b9f      	subs	r7, r3, r6
 8000e64:	017a      	lsls	r2, r7, #5
 8000e66:	d535      	bpl.n	8000ed4 <__aeabi_fsub+0x200>
 8000e68:	1af7      	subs	r7, r6, r3
 8000e6a:	000d      	movs	r5, r1
 8000e6c:	e764      	b.n	8000d38 <__aeabi_fsub+0x64>
 8000e6e:	2201      	movs	r2, #1
 8000e70:	2300      	movs	r3, #0
 8000e72:	402a      	ands	r2, r5
 8000e74:	e786      	b.n	8000d84 <__aeabi_fsub+0xb0>
 8000e76:	003b      	movs	r3, r7
 8000e78:	4a63      	ldr	r2, [pc, #396]	; (8001008 <__aeabi_fsub+0x334>)
 8000e7a:	1a24      	subs	r4, r4, r0
 8000e7c:	4013      	ands	r3, r2
 8000e7e:	e76f      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000e80:	2900      	cmp	r1, #0
 8000e82:	d16c      	bne.n	8000f5e <__aeabi_fsub+0x28a>
 8000e84:	1c61      	adds	r1, r4, #1
 8000e86:	b2c8      	uxtb	r0, r1
 8000e88:	2801      	cmp	r0, #1
 8000e8a:	dd4e      	ble.n	8000f2a <__aeabi_fsub+0x256>
 8000e8c:	29ff      	cmp	r1, #255	; 0xff
 8000e8e:	d049      	beq.n	8000f24 <__aeabi_fsub+0x250>
 8000e90:	199b      	adds	r3, r3, r6
 8000e92:	085b      	lsrs	r3, r3, #1
 8000e94:	000c      	movs	r4, r1
 8000e96:	e763      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000e98:	2aff      	cmp	r2, #255	; 0xff
 8000e9a:	d041      	beq.n	8000f20 <__aeabi_fsub+0x24c>
 8000e9c:	000a      	movs	r2, r1
 8000e9e:	e781      	b.n	8000da4 <__aeabi_fsub+0xd0>
 8000ea0:	2601      	movs	r6, #1
 8000ea2:	1b9b      	subs	r3, r3, r6
 8000ea4:	e789      	b.n	8000dba <__aeabi_fsub+0xe6>
 8000ea6:	2c00      	cmp	r4, #0
 8000ea8:	d01c      	beq.n	8000ee4 <__aeabi_fsub+0x210>
 8000eaa:	28ff      	cmp	r0, #255	; 0xff
 8000eac:	d021      	beq.n	8000ef2 <__aeabi_fsub+0x21e>
 8000eae:	2480      	movs	r4, #128	; 0x80
 8000eb0:	04e4      	lsls	r4, r4, #19
 8000eb2:	4252      	negs	r2, r2
 8000eb4:	4323      	orrs	r3, r4
 8000eb6:	2a1b      	cmp	r2, #27
 8000eb8:	dd00      	ble.n	8000ebc <__aeabi_fsub+0x1e8>
 8000eba:	e096      	b.n	8000fea <__aeabi_fsub+0x316>
 8000ebc:	001c      	movs	r4, r3
 8000ebe:	2520      	movs	r5, #32
 8000ec0:	40d4      	lsrs	r4, r2
 8000ec2:	1aaa      	subs	r2, r5, r2
 8000ec4:	4093      	lsls	r3, r2
 8000ec6:	1e5a      	subs	r2, r3, #1
 8000ec8:	4193      	sbcs	r3, r2
 8000eca:	4323      	orrs	r3, r4
 8000ecc:	1af3      	subs	r3, r6, r3
 8000ece:	0004      	movs	r4, r0
 8000ed0:	000d      	movs	r5, r1
 8000ed2:	e72d      	b.n	8000d30 <__aeabi_fsub+0x5c>
 8000ed4:	2f00      	cmp	r7, #0
 8000ed6:	d000      	beq.n	8000eda <__aeabi_fsub+0x206>
 8000ed8:	e72e      	b.n	8000d38 <__aeabi_fsub+0x64>
 8000eda:	2200      	movs	r2, #0
 8000edc:	2400      	movs	r4, #0
 8000ede:	e7a9      	b.n	8000e34 <__aeabi_fsub+0x160>
 8000ee0:	000c      	movs	r4, r1
 8000ee2:	e73d      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000ee4:	2b00      	cmp	r3, #0
 8000ee6:	d058      	beq.n	8000f9a <__aeabi_fsub+0x2c6>
 8000ee8:	43d2      	mvns	r2, r2
 8000eea:	2a00      	cmp	r2, #0
 8000eec:	d0ee      	beq.n	8000ecc <__aeabi_fsub+0x1f8>
 8000eee:	28ff      	cmp	r0, #255	; 0xff
 8000ef0:	d1e1      	bne.n	8000eb6 <__aeabi_fsub+0x1e2>
 8000ef2:	0033      	movs	r3, r6
 8000ef4:	24ff      	movs	r4, #255	; 0xff
 8000ef6:	000d      	movs	r5, r1
 8000ef8:	e732      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000efa:	29ff      	cmp	r1, #255	; 0xff
 8000efc:	d010      	beq.n	8000f20 <__aeabi_fsub+0x24c>
 8000efe:	0001      	movs	r1, r0
 8000f00:	e778      	b.n	8000df4 <__aeabi_fsub+0x120>
 8000f02:	2b00      	cmp	r3, #0
 8000f04:	d06e      	beq.n	8000fe4 <__aeabi_fsub+0x310>
 8000f06:	24ff      	movs	r4, #255	; 0xff
 8000f08:	2e00      	cmp	r6, #0
 8000f0a:	d100      	bne.n	8000f0e <__aeabi_fsub+0x23a>
 8000f0c:	e728      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000f0e:	2280      	movs	r2, #128	; 0x80
 8000f10:	4651      	mov	r1, sl
 8000f12:	03d2      	lsls	r2, r2, #15
 8000f14:	4211      	tst	r1, r2
 8000f16:	d003      	beq.n	8000f20 <__aeabi_fsub+0x24c>
 8000f18:	4661      	mov	r1, ip
 8000f1a:	4211      	tst	r1, r2
 8000f1c:	d100      	bne.n	8000f20 <__aeabi_fsub+0x24c>
 8000f1e:	0033      	movs	r3, r6
 8000f20:	24ff      	movs	r4, #255	; 0xff
 8000f22:	e71d      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000f24:	24ff      	movs	r4, #255	; 0xff
 8000f26:	2300      	movs	r3, #0
 8000f28:	e72c      	b.n	8000d84 <__aeabi_fsub+0xb0>
 8000f2a:	2c00      	cmp	r4, #0
 8000f2c:	d1e9      	bne.n	8000f02 <__aeabi_fsub+0x22e>
 8000f2e:	2b00      	cmp	r3, #0
 8000f30:	d063      	beq.n	8000ffa <__aeabi_fsub+0x326>
 8000f32:	2e00      	cmp	r6, #0
 8000f34:	d100      	bne.n	8000f38 <__aeabi_fsub+0x264>
 8000f36:	e713      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000f38:	199b      	adds	r3, r3, r6
 8000f3a:	015a      	lsls	r2, r3, #5
 8000f3c:	d400      	bmi.n	8000f40 <__aeabi_fsub+0x26c>
 8000f3e:	e73e      	b.n	8000dbe <__aeabi_fsub+0xea>
 8000f40:	4a31      	ldr	r2, [pc, #196]	; (8001008 <__aeabi_fsub+0x334>)
 8000f42:	000c      	movs	r4, r1
 8000f44:	4013      	ands	r3, r2
 8000f46:	e70b      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000f48:	2c00      	cmp	r4, #0
 8000f4a:	d11e      	bne.n	8000f8a <__aeabi_fsub+0x2b6>
 8000f4c:	2b00      	cmp	r3, #0
 8000f4e:	d12f      	bne.n	8000fb0 <__aeabi_fsub+0x2dc>
 8000f50:	2e00      	cmp	r6, #0
 8000f52:	d04f      	beq.n	8000ff4 <__aeabi_fsub+0x320>
 8000f54:	0033      	movs	r3, r6
 8000f56:	000d      	movs	r5, r1
 8000f58:	e702      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000f5a:	2601      	movs	r6, #1
 8000f5c:	e755      	b.n	8000e0a <__aeabi_fsub+0x136>
 8000f5e:	2c00      	cmp	r4, #0
 8000f60:	d11f      	bne.n	8000fa2 <__aeabi_fsub+0x2ce>
 8000f62:	2b00      	cmp	r3, #0
 8000f64:	d043      	beq.n	8000fee <__aeabi_fsub+0x31a>
 8000f66:	43c9      	mvns	r1, r1
 8000f68:	2900      	cmp	r1, #0
 8000f6a:	d00b      	beq.n	8000f84 <__aeabi_fsub+0x2b0>
 8000f6c:	28ff      	cmp	r0, #255	; 0xff
 8000f6e:	d039      	beq.n	8000fe4 <__aeabi_fsub+0x310>
 8000f70:	291b      	cmp	r1, #27
 8000f72:	dc44      	bgt.n	8000ffe <__aeabi_fsub+0x32a>
 8000f74:	001c      	movs	r4, r3
 8000f76:	2720      	movs	r7, #32
 8000f78:	40cc      	lsrs	r4, r1
 8000f7a:	1a79      	subs	r1, r7, r1
 8000f7c:	408b      	lsls	r3, r1
 8000f7e:	1e59      	subs	r1, r3, #1
 8000f80:	418b      	sbcs	r3, r1
 8000f82:	4323      	orrs	r3, r4
 8000f84:	199b      	adds	r3, r3, r6
 8000f86:	0004      	movs	r4, r0
 8000f88:	e740      	b.n	8000e0c <__aeabi_fsub+0x138>
 8000f8a:	2b00      	cmp	r3, #0
 8000f8c:	d11a      	bne.n	8000fc4 <__aeabi_fsub+0x2f0>
 8000f8e:	2e00      	cmp	r6, #0
 8000f90:	d124      	bne.n	8000fdc <__aeabi_fsub+0x308>
 8000f92:	2780      	movs	r7, #128	; 0x80
 8000f94:	2200      	movs	r2, #0
 8000f96:	03ff      	lsls	r7, r7, #15
 8000f98:	e71b      	b.n	8000dd2 <__aeabi_fsub+0xfe>
 8000f9a:	0033      	movs	r3, r6
 8000f9c:	0004      	movs	r4, r0
 8000f9e:	000d      	movs	r5, r1
 8000fa0:	e6de      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000fa2:	28ff      	cmp	r0, #255	; 0xff
 8000fa4:	d01e      	beq.n	8000fe4 <__aeabi_fsub+0x310>
 8000fa6:	2480      	movs	r4, #128	; 0x80
 8000fa8:	04e4      	lsls	r4, r4, #19
 8000faa:	4249      	negs	r1, r1
 8000fac:	4323      	orrs	r3, r4
 8000fae:	e7df      	b.n	8000f70 <__aeabi_fsub+0x29c>
 8000fb0:	2e00      	cmp	r6, #0
 8000fb2:	d100      	bne.n	8000fb6 <__aeabi_fsub+0x2e2>
 8000fb4:	e6d4      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000fb6:	1b9f      	subs	r7, r3, r6
 8000fb8:	017a      	lsls	r2, r7, #5
 8000fba:	d400      	bmi.n	8000fbe <__aeabi_fsub+0x2ea>
 8000fbc:	e737      	b.n	8000e2e <__aeabi_fsub+0x15a>
 8000fbe:	1af3      	subs	r3, r6, r3
 8000fc0:	000d      	movs	r5, r1
 8000fc2:	e6cd      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000fc4:	24ff      	movs	r4, #255	; 0xff
 8000fc6:	2e00      	cmp	r6, #0
 8000fc8:	d100      	bne.n	8000fcc <__aeabi_fsub+0x2f8>
 8000fca:	e6c9      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000fcc:	2280      	movs	r2, #128	; 0x80
 8000fce:	4650      	mov	r0, sl
 8000fd0:	03d2      	lsls	r2, r2, #15
 8000fd2:	4210      	tst	r0, r2
 8000fd4:	d0a4      	beq.n	8000f20 <__aeabi_fsub+0x24c>
 8000fd6:	4660      	mov	r0, ip
 8000fd8:	4210      	tst	r0, r2
 8000fda:	d1a1      	bne.n	8000f20 <__aeabi_fsub+0x24c>
 8000fdc:	0033      	movs	r3, r6
 8000fde:	000d      	movs	r5, r1
 8000fe0:	24ff      	movs	r4, #255	; 0xff
 8000fe2:	e6bd      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000fe4:	0033      	movs	r3, r6
 8000fe6:	24ff      	movs	r4, #255	; 0xff
 8000fe8:	e6ba      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000fea:	2301      	movs	r3, #1
 8000fec:	e76e      	b.n	8000ecc <__aeabi_fsub+0x1f8>
 8000fee:	0033      	movs	r3, r6
 8000ff0:	0004      	movs	r4, r0
 8000ff2:	e6b5      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000ff4:	2700      	movs	r7, #0
 8000ff6:	2200      	movs	r2, #0
 8000ff8:	e71c      	b.n	8000e34 <__aeabi_fsub+0x160>
 8000ffa:	0033      	movs	r3, r6
 8000ffc:	e6b0      	b.n	8000d60 <__aeabi_fsub+0x8c>
 8000ffe:	2301      	movs	r3, #1
 8001000:	e7c0      	b.n	8000f84 <__aeabi_fsub+0x2b0>
 8001002:	46c0      	nop			; (mov r8, r8)
 8001004:	7dffffff 	.word	0x7dffffff
 8001008:	fbffffff 	.word	0xfbffffff

0800100c <__aeabi_fcmpun>:
 800100c:	0242      	lsls	r2, r0, #9
 800100e:	024b      	lsls	r3, r1, #9
 8001010:	0040      	lsls	r0, r0, #1
 8001012:	0049      	lsls	r1, r1, #1
 8001014:	0a52      	lsrs	r2, r2, #9
 8001016:	0e00      	lsrs	r0, r0, #24
 8001018:	0a5b      	lsrs	r3, r3, #9
 800101a:	0e09      	lsrs	r1, r1, #24
 800101c:	28ff      	cmp	r0, #255	; 0xff
 800101e:	d003      	beq.n	8001028 <__aeabi_fcmpun+0x1c>
 8001020:	2000      	movs	r0, #0
 8001022:	29ff      	cmp	r1, #255	; 0xff
 8001024:	d006      	beq.n	8001034 <__aeabi_fcmpun+0x28>
 8001026:	4770      	bx	lr
 8001028:	38fe      	subs	r0, #254	; 0xfe
 800102a:	2a00      	cmp	r2, #0
 800102c:	d1fb      	bne.n	8001026 <__aeabi_fcmpun+0x1a>
 800102e:	2000      	movs	r0, #0
 8001030:	29ff      	cmp	r1, #255	; 0xff
 8001032:	d1f8      	bne.n	8001026 <__aeabi_fcmpun+0x1a>
 8001034:	0018      	movs	r0, r3
 8001036:	1e43      	subs	r3, r0, #1
 8001038:	4198      	sbcs	r0, r3
 800103a:	e7f4      	b.n	8001026 <__aeabi_fcmpun+0x1a>

0800103c <__aeabi_f2iz>:
 800103c:	0241      	lsls	r1, r0, #9
 800103e:	0043      	lsls	r3, r0, #1
 8001040:	0fc2      	lsrs	r2, r0, #31
 8001042:	0a49      	lsrs	r1, r1, #9
 8001044:	0e1b      	lsrs	r3, r3, #24
 8001046:	2000      	movs	r0, #0
 8001048:	2b7e      	cmp	r3, #126	; 0x7e
 800104a:	dd0d      	ble.n	8001068 <__aeabi_f2iz+0x2c>
 800104c:	2b9d      	cmp	r3, #157	; 0x9d
 800104e:	dc0c      	bgt.n	800106a <__aeabi_f2iz+0x2e>
 8001050:	2080      	movs	r0, #128	; 0x80
 8001052:	0400      	lsls	r0, r0, #16
 8001054:	4301      	orrs	r1, r0
 8001056:	2b95      	cmp	r3, #149	; 0x95
 8001058:	dc0a      	bgt.n	8001070 <__aeabi_f2iz+0x34>
 800105a:	2096      	movs	r0, #150	; 0x96
 800105c:	1ac3      	subs	r3, r0, r3
 800105e:	40d9      	lsrs	r1, r3
 8001060:	4248      	negs	r0, r1
 8001062:	2a00      	cmp	r2, #0
 8001064:	d100      	bne.n	8001068 <__aeabi_f2iz+0x2c>
 8001066:	0008      	movs	r0, r1
 8001068:	4770      	bx	lr
 800106a:	4b03      	ldr	r3, [pc, #12]	; (8001078 <__aeabi_f2iz+0x3c>)
 800106c:	18d0      	adds	r0, r2, r3
 800106e:	e7fb      	b.n	8001068 <__aeabi_f2iz+0x2c>
 8001070:	3b96      	subs	r3, #150	; 0x96
 8001072:	4099      	lsls	r1, r3
 8001074:	e7f4      	b.n	8001060 <__aeabi_f2iz+0x24>
 8001076:	46c0      	nop			; (mov r8, r8)
 8001078:	7fffffff 	.word	0x7fffffff

0800107c <__aeabi_i2f>:
 800107c:	b570      	push	{r4, r5, r6, lr}
 800107e:	2800      	cmp	r0, #0
 8001080:	d030      	beq.n	80010e4 <__aeabi_i2f+0x68>
 8001082:	17c3      	asrs	r3, r0, #31
 8001084:	18c4      	adds	r4, r0, r3
 8001086:	405c      	eors	r4, r3
 8001088:	0fc5      	lsrs	r5, r0, #31
 800108a:	0020      	movs	r0, r4
 800108c:	f001 fbf6 	bl	800287c <__clzsi2>
 8001090:	239e      	movs	r3, #158	; 0x9e
 8001092:	1a1b      	subs	r3, r3, r0
 8001094:	2b96      	cmp	r3, #150	; 0x96
 8001096:	dc0d      	bgt.n	80010b4 <__aeabi_i2f+0x38>
 8001098:	2296      	movs	r2, #150	; 0x96
 800109a:	1ad2      	subs	r2, r2, r3
 800109c:	4094      	lsls	r4, r2
 800109e:	002a      	movs	r2, r5
 80010a0:	0264      	lsls	r4, r4, #9
 80010a2:	0a64      	lsrs	r4, r4, #9
 80010a4:	b2db      	uxtb	r3, r3
 80010a6:	0264      	lsls	r4, r4, #9
 80010a8:	05db      	lsls	r3, r3, #23
 80010aa:	0a60      	lsrs	r0, r4, #9
 80010ac:	07d2      	lsls	r2, r2, #31
 80010ae:	4318      	orrs	r0, r3
 80010b0:	4310      	orrs	r0, r2
 80010b2:	bd70      	pop	{r4, r5, r6, pc}
 80010b4:	2b99      	cmp	r3, #153	; 0x99
 80010b6:	dc19      	bgt.n	80010ec <__aeabi_i2f+0x70>
 80010b8:	2299      	movs	r2, #153	; 0x99
 80010ba:	1ad2      	subs	r2, r2, r3
 80010bc:	2a00      	cmp	r2, #0
 80010be:	dd29      	ble.n	8001114 <__aeabi_i2f+0x98>
 80010c0:	4094      	lsls	r4, r2
 80010c2:	0022      	movs	r2, r4
 80010c4:	4c14      	ldr	r4, [pc, #80]	; (8001118 <__aeabi_i2f+0x9c>)
 80010c6:	4014      	ands	r4, r2
 80010c8:	0751      	lsls	r1, r2, #29
 80010ca:	d004      	beq.n	80010d6 <__aeabi_i2f+0x5a>
 80010cc:	210f      	movs	r1, #15
 80010ce:	400a      	ands	r2, r1
 80010d0:	2a04      	cmp	r2, #4
 80010d2:	d000      	beq.n	80010d6 <__aeabi_i2f+0x5a>
 80010d4:	3404      	adds	r4, #4
 80010d6:	0162      	lsls	r2, r4, #5
 80010d8:	d413      	bmi.n	8001102 <__aeabi_i2f+0x86>
 80010da:	01a4      	lsls	r4, r4, #6
 80010dc:	0a64      	lsrs	r4, r4, #9
 80010de:	b2db      	uxtb	r3, r3
 80010e0:	002a      	movs	r2, r5
 80010e2:	e7e0      	b.n	80010a6 <__aeabi_i2f+0x2a>
 80010e4:	2200      	movs	r2, #0
 80010e6:	2300      	movs	r3, #0
 80010e8:	2400      	movs	r4, #0
 80010ea:	e7dc      	b.n	80010a6 <__aeabi_i2f+0x2a>
 80010ec:	2205      	movs	r2, #5
 80010ee:	0021      	movs	r1, r4
 80010f0:	1a12      	subs	r2, r2, r0
 80010f2:	40d1      	lsrs	r1, r2
 80010f4:	22b9      	movs	r2, #185	; 0xb9
 80010f6:	1ad2      	subs	r2, r2, r3
 80010f8:	4094      	lsls	r4, r2
 80010fa:	1e62      	subs	r2, r4, #1
 80010fc:	4194      	sbcs	r4, r2
 80010fe:	430c      	orrs	r4, r1
 8001100:	e7da      	b.n	80010b8 <__aeabi_i2f+0x3c>
 8001102:	4b05      	ldr	r3, [pc, #20]	; (8001118 <__aeabi_i2f+0x9c>)
 8001104:	002a      	movs	r2, r5
 8001106:	401c      	ands	r4, r3
 8001108:	239f      	movs	r3, #159	; 0x9f
 800110a:	01a4      	lsls	r4, r4, #6
 800110c:	1a1b      	subs	r3, r3, r0
 800110e:	0a64      	lsrs	r4, r4, #9
 8001110:	b2db      	uxtb	r3, r3
 8001112:	e7c8      	b.n	80010a6 <__aeabi_i2f+0x2a>
 8001114:	0022      	movs	r2, r4
 8001116:	e7d5      	b.n	80010c4 <__aeabi_i2f+0x48>
 8001118:	fbffffff 	.word	0xfbffffff

0800111c <__aeabi_ui2f>:
 800111c:	b510      	push	{r4, lr}
 800111e:	1e04      	subs	r4, r0, #0
 8001120:	d027      	beq.n	8001172 <__aeabi_ui2f+0x56>
 8001122:	f001 fbab 	bl	800287c <__clzsi2>
 8001126:	239e      	movs	r3, #158	; 0x9e
 8001128:	1a1b      	subs	r3, r3, r0
 800112a:	2b96      	cmp	r3, #150	; 0x96
 800112c:	dc0a      	bgt.n	8001144 <__aeabi_ui2f+0x28>
 800112e:	2296      	movs	r2, #150	; 0x96
 8001130:	1ad2      	subs	r2, r2, r3
 8001132:	4094      	lsls	r4, r2
 8001134:	0264      	lsls	r4, r4, #9
 8001136:	0a64      	lsrs	r4, r4, #9
 8001138:	b2db      	uxtb	r3, r3
 800113a:	0264      	lsls	r4, r4, #9
 800113c:	05db      	lsls	r3, r3, #23
 800113e:	0a60      	lsrs	r0, r4, #9
 8001140:	4318      	orrs	r0, r3
 8001142:	bd10      	pop	{r4, pc}
 8001144:	2b99      	cmp	r3, #153	; 0x99
 8001146:	dc17      	bgt.n	8001178 <__aeabi_ui2f+0x5c>
 8001148:	2299      	movs	r2, #153	; 0x99
 800114a:	1ad2      	subs	r2, r2, r3
 800114c:	2a00      	cmp	r2, #0
 800114e:	dd27      	ble.n	80011a0 <__aeabi_ui2f+0x84>
 8001150:	4094      	lsls	r4, r2
 8001152:	0022      	movs	r2, r4
 8001154:	4c13      	ldr	r4, [pc, #76]	; (80011a4 <__aeabi_ui2f+0x88>)
 8001156:	4014      	ands	r4, r2
 8001158:	0751      	lsls	r1, r2, #29
 800115a:	d004      	beq.n	8001166 <__aeabi_ui2f+0x4a>
 800115c:	210f      	movs	r1, #15
 800115e:	400a      	ands	r2, r1
 8001160:	2a04      	cmp	r2, #4
 8001162:	d000      	beq.n	8001166 <__aeabi_ui2f+0x4a>
 8001164:	3404      	adds	r4, #4
 8001166:	0162      	lsls	r2, r4, #5
 8001168:	d412      	bmi.n	8001190 <__aeabi_ui2f+0x74>
 800116a:	01a4      	lsls	r4, r4, #6
 800116c:	0a64      	lsrs	r4, r4, #9
 800116e:	b2db      	uxtb	r3, r3
 8001170:	e7e3      	b.n	800113a <__aeabi_ui2f+0x1e>
 8001172:	2300      	movs	r3, #0
 8001174:	2400      	movs	r4, #0
 8001176:	e7e0      	b.n	800113a <__aeabi_ui2f+0x1e>
 8001178:	22b9      	movs	r2, #185	; 0xb9
 800117a:	0021      	movs	r1, r4
 800117c:	1ad2      	subs	r2, r2, r3
 800117e:	4091      	lsls	r1, r2
 8001180:	000a      	movs	r2, r1
 8001182:	1e51      	subs	r1, r2, #1
 8001184:	418a      	sbcs	r2, r1
 8001186:	2105      	movs	r1, #5
 8001188:	1a09      	subs	r1, r1, r0
 800118a:	40cc      	lsrs	r4, r1
 800118c:	4314      	orrs	r4, r2
 800118e:	e7db      	b.n	8001148 <__aeabi_ui2f+0x2c>
 8001190:	4b04      	ldr	r3, [pc, #16]	; (80011a4 <__aeabi_ui2f+0x88>)
 8001192:	401c      	ands	r4, r3
 8001194:	239f      	movs	r3, #159	; 0x9f
 8001196:	01a4      	lsls	r4, r4, #6
 8001198:	1a1b      	subs	r3, r3, r0
 800119a:	0a64      	lsrs	r4, r4, #9
 800119c:	b2db      	uxtb	r3, r3
 800119e:	e7cc      	b.n	800113a <__aeabi_ui2f+0x1e>
 80011a0:	0022      	movs	r2, r4
 80011a2:	e7d7      	b.n	8001154 <__aeabi_ui2f+0x38>
 80011a4:	fbffffff 	.word	0xfbffffff

080011a8 <__aeabi_dadd>:
 80011a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80011aa:	4645      	mov	r5, r8
 80011ac:	46de      	mov	lr, fp
 80011ae:	4657      	mov	r7, sl
 80011b0:	464e      	mov	r6, r9
 80011b2:	030c      	lsls	r4, r1, #12
 80011b4:	b5e0      	push	{r5, r6, r7, lr}
 80011b6:	004e      	lsls	r6, r1, #1
 80011b8:	0fc9      	lsrs	r1, r1, #31
 80011ba:	4688      	mov	r8, r1
 80011bc:	000d      	movs	r5, r1
 80011be:	0a61      	lsrs	r1, r4, #9
 80011c0:	0f44      	lsrs	r4, r0, #29
 80011c2:	430c      	orrs	r4, r1
 80011c4:	00c7      	lsls	r7, r0, #3
 80011c6:	0319      	lsls	r1, r3, #12
 80011c8:	0058      	lsls	r0, r3, #1
 80011ca:	0fdb      	lsrs	r3, r3, #31
 80011cc:	469b      	mov	fp, r3
 80011ce:	0a4b      	lsrs	r3, r1, #9
 80011d0:	0f51      	lsrs	r1, r2, #29
 80011d2:	430b      	orrs	r3, r1
 80011d4:	0d76      	lsrs	r6, r6, #21
 80011d6:	0d40      	lsrs	r0, r0, #21
 80011d8:	0019      	movs	r1, r3
 80011da:	00d2      	lsls	r2, r2, #3
 80011dc:	45d8      	cmp	r8, fp
 80011de:	d100      	bne.n	80011e2 <__aeabi_dadd+0x3a>
 80011e0:	e0ae      	b.n	8001340 <__aeabi_dadd+0x198>
 80011e2:	1a35      	subs	r5, r6, r0
 80011e4:	2d00      	cmp	r5, #0
 80011e6:	dc00      	bgt.n	80011ea <__aeabi_dadd+0x42>
 80011e8:	e0f6      	b.n	80013d8 <__aeabi_dadd+0x230>
 80011ea:	2800      	cmp	r0, #0
 80011ec:	d10f      	bne.n	800120e <__aeabi_dadd+0x66>
 80011ee:	4313      	orrs	r3, r2
 80011f0:	d100      	bne.n	80011f4 <__aeabi_dadd+0x4c>
 80011f2:	e0db      	b.n	80013ac <__aeabi_dadd+0x204>
 80011f4:	1e6b      	subs	r3, r5, #1
 80011f6:	2b00      	cmp	r3, #0
 80011f8:	d000      	beq.n	80011fc <__aeabi_dadd+0x54>
 80011fa:	e137      	b.n	800146c <__aeabi_dadd+0x2c4>
 80011fc:	1aba      	subs	r2, r7, r2
 80011fe:	4297      	cmp	r7, r2
 8001200:	41bf      	sbcs	r7, r7
 8001202:	1a64      	subs	r4, r4, r1
 8001204:	427f      	negs	r7, r7
 8001206:	1be4      	subs	r4, r4, r7
 8001208:	2601      	movs	r6, #1
 800120a:	0017      	movs	r7, r2
 800120c:	e024      	b.n	8001258 <__aeabi_dadd+0xb0>
 800120e:	4bc6      	ldr	r3, [pc, #792]	; (8001528 <__aeabi_dadd+0x380>)
 8001210:	429e      	cmp	r6, r3
 8001212:	d04d      	beq.n	80012b0 <__aeabi_dadd+0x108>
 8001214:	2380      	movs	r3, #128	; 0x80
 8001216:	041b      	lsls	r3, r3, #16
 8001218:	4319      	orrs	r1, r3
 800121a:	2d38      	cmp	r5, #56	; 0x38
 800121c:	dd00      	ble.n	8001220 <__aeabi_dadd+0x78>
 800121e:	e107      	b.n	8001430 <__aeabi_dadd+0x288>
 8001220:	2d1f      	cmp	r5, #31
 8001222:	dd00      	ble.n	8001226 <__aeabi_dadd+0x7e>
 8001224:	e138      	b.n	8001498 <__aeabi_dadd+0x2f0>
 8001226:	2020      	movs	r0, #32
 8001228:	1b43      	subs	r3, r0, r5
 800122a:	469a      	mov	sl, r3
 800122c:	000b      	movs	r3, r1
 800122e:	4650      	mov	r0, sl
 8001230:	4083      	lsls	r3, r0
 8001232:	4699      	mov	r9, r3
 8001234:	0013      	movs	r3, r2
 8001236:	4648      	mov	r0, r9
 8001238:	40eb      	lsrs	r3, r5
 800123a:	4318      	orrs	r0, r3
 800123c:	0003      	movs	r3, r0
 800123e:	4650      	mov	r0, sl
 8001240:	4082      	lsls	r2, r0
 8001242:	1e50      	subs	r0, r2, #1
 8001244:	4182      	sbcs	r2, r0
 8001246:	40e9      	lsrs	r1, r5
 8001248:	431a      	orrs	r2, r3
 800124a:	1aba      	subs	r2, r7, r2
 800124c:	1a61      	subs	r1, r4, r1
 800124e:	4297      	cmp	r7, r2
 8001250:	41a4      	sbcs	r4, r4
 8001252:	0017      	movs	r7, r2
 8001254:	4264      	negs	r4, r4
 8001256:	1b0c      	subs	r4, r1, r4
 8001258:	0223      	lsls	r3, r4, #8
 800125a:	d562      	bpl.n	8001322 <__aeabi_dadd+0x17a>
 800125c:	0264      	lsls	r4, r4, #9
 800125e:	0a65      	lsrs	r5, r4, #9
 8001260:	2d00      	cmp	r5, #0
 8001262:	d100      	bne.n	8001266 <__aeabi_dadd+0xbe>
 8001264:	e0df      	b.n	8001426 <__aeabi_dadd+0x27e>
 8001266:	0028      	movs	r0, r5
 8001268:	f001 fb08 	bl	800287c <__clzsi2>
 800126c:	0003      	movs	r3, r0
 800126e:	3b08      	subs	r3, #8
 8001270:	2b1f      	cmp	r3, #31
 8001272:	dd00      	ble.n	8001276 <__aeabi_dadd+0xce>
 8001274:	e0d2      	b.n	800141c <__aeabi_dadd+0x274>
 8001276:	2220      	movs	r2, #32
 8001278:	003c      	movs	r4, r7
 800127a:	1ad2      	subs	r2, r2, r3
 800127c:	409d      	lsls	r5, r3
 800127e:	40d4      	lsrs	r4, r2
 8001280:	409f      	lsls	r7, r3
 8001282:	4325      	orrs	r5, r4
 8001284:	429e      	cmp	r6, r3
 8001286:	dd00      	ble.n	800128a <__aeabi_dadd+0xe2>
 8001288:	e0c4      	b.n	8001414 <__aeabi_dadd+0x26c>
 800128a:	1b9e      	subs	r6, r3, r6
 800128c:	1c73      	adds	r3, r6, #1
 800128e:	2b1f      	cmp	r3, #31
 8001290:	dd00      	ble.n	8001294 <__aeabi_dadd+0xec>
 8001292:	e0f1      	b.n	8001478 <__aeabi_dadd+0x2d0>
 8001294:	2220      	movs	r2, #32
 8001296:	0038      	movs	r0, r7
 8001298:	0029      	movs	r1, r5
 800129a:	1ad2      	subs	r2, r2, r3
 800129c:	40d8      	lsrs	r0, r3
 800129e:	4091      	lsls	r1, r2
 80012a0:	4097      	lsls	r7, r2
 80012a2:	002c      	movs	r4, r5
 80012a4:	4301      	orrs	r1, r0
 80012a6:	1e78      	subs	r0, r7, #1
 80012a8:	4187      	sbcs	r7, r0
 80012aa:	40dc      	lsrs	r4, r3
 80012ac:	2600      	movs	r6, #0
 80012ae:	430f      	orrs	r7, r1
 80012b0:	077b      	lsls	r3, r7, #29
 80012b2:	d009      	beq.n	80012c8 <__aeabi_dadd+0x120>
 80012b4:	230f      	movs	r3, #15
 80012b6:	403b      	ands	r3, r7
 80012b8:	2b04      	cmp	r3, #4
 80012ba:	d005      	beq.n	80012c8 <__aeabi_dadd+0x120>
 80012bc:	1d3b      	adds	r3, r7, #4
 80012be:	42bb      	cmp	r3, r7
 80012c0:	41bf      	sbcs	r7, r7
 80012c2:	427f      	negs	r7, r7
 80012c4:	19e4      	adds	r4, r4, r7
 80012c6:	001f      	movs	r7, r3
 80012c8:	0223      	lsls	r3, r4, #8
 80012ca:	d52c      	bpl.n	8001326 <__aeabi_dadd+0x17e>
 80012cc:	4b96      	ldr	r3, [pc, #600]	; (8001528 <__aeabi_dadd+0x380>)
 80012ce:	3601      	adds	r6, #1
 80012d0:	429e      	cmp	r6, r3
 80012d2:	d100      	bne.n	80012d6 <__aeabi_dadd+0x12e>
 80012d4:	e09a      	b.n	800140c <__aeabi_dadd+0x264>
 80012d6:	4645      	mov	r5, r8
 80012d8:	4b94      	ldr	r3, [pc, #592]	; (800152c <__aeabi_dadd+0x384>)
 80012da:	08ff      	lsrs	r7, r7, #3
 80012dc:	401c      	ands	r4, r3
 80012de:	0760      	lsls	r0, r4, #29
 80012e0:	0576      	lsls	r6, r6, #21
 80012e2:	0264      	lsls	r4, r4, #9
 80012e4:	4307      	orrs	r7, r0
 80012e6:	0b24      	lsrs	r4, r4, #12
 80012e8:	0d76      	lsrs	r6, r6, #21
 80012ea:	2100      	movs	r1, #0
 80012ec:	0324      	lsls	r4, r4, #12
 80012ee:	0b23      	lsrs	r3, r4, #12
 80012f0:	0d0c      	lsrs	r4, r1, #20
 80012f2:	4a8f      	ldr	r2, [pc, #572]	; (8001530 <__aeabi_dadd+0x388>)
 80012f4:	0524      	lsls	r4, r4, #20
 80012f6:	431c      	orrs	r4, r3
 80012f8:	4014      	ands	r4, r2
 80012fa:	0533      	lsls	r3, r6, #20
 80012fc:	4323      	orrs	r3, r4
 80012fe:	005b      	lsls	r3, r3, #1
 8001300:	07ed      	lsls	r5, r5, #31
 8001302:	085b      	lsrs	r3, r3, #1
 8001304:	432b      	orrs	r3, r5
 8001306:	0038      	movs	r0, r7
 8001308:	0019      	movs	r1, r3
 800130a:	bc3c      	pop	{r2, r3, r4, r5}
 800130c:	4690      	mov	r8, r2
 800130e:	4699      	mov	r9, r3
 8001310:	46a2      	mov	sl, r4
 8001312:	46ab      	mov	fp, r5
 8001314:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001316:	4664      	mov	r4, ip
 8001318:	4304      	orrs	r4, r0
 800131a:	d100      	bne.n	800131e <__aeabi_dadd+0x176>
 800131c:	e211      	b.n	8001742 <__aeabi_dadd+0x59a>
 800131e:	0004      	movs	r4, r0
 8001320:	4667      	mov	r7, ip
 8001322:	077b      	lsls	r3, r7, #29
 8001324:	d1c6      	bne.n	80012b4 <__aeabi_dadd+0x10c>
 8001326:	4645      	mov	r5, r8
 8001328:	0760      	lsls	r0, r4, #29
 800132a:	08ff      	lsrs	r7, r7, #3
 800132c:	4307      	orrs	r7, r0
 800132e:	08e4      	lsrs	r4, r4, #3
 8001330:	4b7d      	ldr	r3, [pc, #500]	; (8001528 <__aeabi_dadd+0x380>)
 8001332:	429e      	cmp	r6, r3
 8001334:	d030      	beq.n	8001398 <__aeabi_dadd+0x1f0>
 8001336:	0324      	lsls	r4, r4, #12
 8001338:	0576      	lsls	r6, r6, #21
 800133a:	0b24      	lsrs	r4, r4, #12
 800133c:	0d76      	lsrs	r6, r6, #21
 800133e:	e7d4      	b.n	80012ea <__aeabi_dadd+0x142>
 8001340:	1a33      	subs	r3, r6, r0
 8001342:	469a      	mov	sl, r3
 8001344:	2b00      	cmp	r3, #0
 8001346:	dd78      	ble.n	800143a <__aeabi_dadd+0x292>
 8001348:	2800      	cmp	r0, #0
 800134a:	d031      	beq.n	80013b0 <__aeabi_dadd+0x208>
 800134c:	4876      	ldr	r0, [pc, #472]	; (8001528 <__aeabi_dadd+0x380>)
 800134e:	4286      	cmp	r6, r0
 8001350:	d0ae      	beq.n	80012b0 <__aeabi_dadd+0x108>
 8001352:	2080      	movs	r0, #128	; 0x80
 8001354:	0400      	lsls	r0, r0, #16
 8001356:	4301      	orrs	r1, r0
 8001358:	4653      	mov	r3, sl
 800135a:	2b38      	cmp	r3, #56	; 0x38
 800135c:	dc00      	bgt.n	8001360 <__aeabi_dadd+0x1b8>
 800135e:	e0e9      	b.n	8001534 <__aeabi_dadd+0x38c>
 8001360:	430a      	orrs	r2, r1
 8001362:	1e51      	subs	r1, r2, #1
 8001364:	418a      	sbcs	r2, r1
 8001366:	2100      	movs	r1, #0
 8001368:	19d2      	adds	r2, r2, r7
 800136a:	42ba      	cmp	r2, r7
 800136c:	41bf      	sbcs	r7, r7
 800136e:	1909      	adds	r1, r1, r4
 8001370:	427c      	negs	r4, r7
 8001372:	0017      	movs	r7, r2
 8001374:	190c      	adds	r4, r1, r4
 8001376:	0223      	lsls	r3, r4, #8
 8001378:	d5d3      	bpl.n	8001322 <__aeabi_dadd+0x17a>
 800137a:	4b6b      	ldr	r3, [pc, #428]	; (8001528 <__aeabi_dadd+0x380>)
 800137c:	3601      	adds	r6, #1
 800137e:	429e      	cmp	r6, r3
 8001380:	d100      	bne.n	8001384 <__aeabi_dadd+0x1dc>
 8001382:	e13a      	b.n	80015fa <__aeabi_dadd+0x452>
 8001384:	2001      	movs	r0, #1
 8001386:	4b69      	ldr	r3, [pc, #420]	; (800152c <__aeabi_dadd+0x384>)
 8001388:	401c      	ands	r4, r3
 800138a:	087b      	lsrs	r3, r7, #1
 800138c:	4007      	ands	r7, r0
 800138e:	431f      	orrs	r7, r3
 8001390:	07e0      	lsls	r0, r4, #31
 8001392:	4307      	orrs	r7, r0
 8001394:	0864      	lsrs	r4, r4, #1
 8001396:	e78b      	b.n	80012b0 <__aeabi_dadd+0x108>
 8001398:	0023      	movs	r3, r4
 800139a:	433b      	orrs	r3, r7
 800139c:	d100      	bne.n	80013a0 <__aeabi_dadd+0x1f8>
 800139e:	e1cb      	b.n	8001738 <__aeabi_dadd+0x590>
 80013a0:	2280      	movs	r2, #128	; 0x80
 80013a2:	0312      	lsls	r2, r2, #12
 80013a4:	4314      	orrs	r4, r2
 80013a6:	0324      	lsls	r4, r4, #12
 80013a8:	0b24      	lsrs	r4, r4, #12
 80013aa:	e79e      	b.n	80012ea <__aeabi_dadd+0x142>
 80013ac:	002e      	movs	r6, r5
 80013ae:	e77f      	b.n	80012b0 <__aeabi_dadd+0x108>
 80013b0:	0008      	movs	r0, r1
 80013b2:	4310      	orrs	r0, r2
 80013b4:	d100      	bne.n	80013b8 <__aeabi_dadd+0x210>
 80013b6:	e0b4      	b.n	8001522 <__aeabi_dadd+0x37a>
 80013b8:	1e58      	subs	r0, r3, #1
 80013ba:	2800      	cmp	r0, #0
 80013bc:	d000      	beq.n	80013c0 <__aeabi_dadd+0x218>
 80013be:	e0de      	b.n	800157e <__aeabi_dadd+0x3d6>
 80013c0:	18ba      	adds	r2, r7, r2
 80013c2:	42ba      	cmp	r2, r7
 80013c4:	419b      	sbcs	r3, r3
 80013c6:	1864      	adds	r4, r4, r1
 80013c8:	425b      	negs	r3, r3
 80013ca:	18e4      	adds	r4, r4, r3
 80013cc:	0017      	movs	r7, r2
 80013ce:	2601      	movs	r6, #1
 80013d0:	0223      	lsls	r3, r4, #8
 80013d2:	d5a6      	bpl.n	8001322 <__aeabi_dadd+0x17a>
 80013d4:	2602      	movs	r6, #2
 80013d6:	e7d5      	b.n	8001384 <__aeabi_dadd+0x1dc>
 80013d8:	2d00      	cmp	r5, #0
 80013da:	d16e      	bne.n	80014ba <__aeabi_dadd+0x312>
 80013dc:	1c70      	adds	r0, r6, #1
 80013de:	0540      	lsls	r0, r0, #21
 80013e0:	0d40      	lsrs	r0, r0, #21
 80013e2:	2801      	cmp	r0, #1
 80013e4:	dc00      	bgt.n	80013e8 <__aeabi_dadd+0x240>
 80013e6:	e0f9      	b.n	80015dc <__aeabi_dadd+0x434>
 80013e8:	1ab8      	subs	r0, r7, r2
 80013ea:	4684      	mov	ip, r0
 80013ec:	4287      	cmp	r7, r0
 80013ee:	4180      	sbcs	r0, r0
 80013f0:	1ae5      	subs	r5, r4, r3
 80013f2:	4240      	negs	r0, r0
 80013f4:	1a2d      	subs	r5, r5, r0
 80013f6:	0228      	lsls	r0, r5, #8
 80013f8:	d400      	bmi.n	80013fc <__aeabi_dadd+0x254>
 80013fa:	e089      	b.n	8001510 <__aeabi_dadd+0x368>
 80013fc:	1bd7      	subs	r7, r2, r7
 80013fe:	42ba      	cmp	r2, r7
 8001400:	4192      	sbcs	r2, r2
 8001402:	1b1c      	subs	r4, r3, r4
 8001404:	4252      	negs	r2, r2
 8001406:	1aa5      	subs	r5, r4, r2
 8001408:	46d8      	mov	r8, fp
 800140a:	e729      	b.n	8001260 <__aeabi_dadd+0xb8>
 800140c:	4645      	mov	r5, r8
 800140e:	2400      	movs	r4, #0
 8001410:	2700      	movs	r7, #0
 8001412:	e76a      	b.n	80012ea <__aeabi_dadd+0x142>
 8001414:	4c45      	ldr	r4, [pc, #276]	; (800152c <__aeabi_dadd+0x384>)
 8001416:	1af6      	subs	r6, r6, r3
 8001418:	402c      	ands	r4, r5
 800141a:	e749      	b.n	80012b0 <__aeabi_dadd+0x108>
 800141c:	003d      	movs	r5, r7
 800141e:	3828      	subs	r0, #40	; 0x28
 8001420:	4085      	lsls	r5, r0
 8001422:	2700      	movs	r7, #0
 8001424:	e72e      	b.n	8001284 <__aeabi_dadd+0xdc>
 8001426:	0038      	movs	r0, r7
 8001428:	f001 fa28 	bl	800287c <__clzsi2>
 800142c:	3020      	adds	r0, #32
 800142e:	e71d      	b.n	800126c <__aeabi_dadd+0xc4>
 8001430:	430a      	orrs	r2, r1
 8001432:	1e51      	subs	r1, r2, #1
 8001434:	418a      	sbcs	r2, r1
 8001436:	2100      	movs	r1, #0
 8001438:	e707      	b.n	800124a <__aeabi_dadd+0xa2>
 800143a:	2b00      	cmp	r3, #0
 800143c:	d000      	beq.n	8001440 <__aeabi_dadd+0x298>
 800143e:	e0f3      	b.n	8001628 <__aeabi_dadd+0x480>
 8001440:	1c70      	adds	r0, r6, #1
 8001442:	0543      	lsls	r3, r0, #21
 8001444:	0d5b      	lsrs	r3, r3, #21
 8001446:	2b01      	cmp	r3, #1
 8001448:	dc00      	bgt.n	800144c <__aeabi_dadd+0x2a4>
 800144a:	e0ad      	b.n	80015a8 <__aeabi_dadd+0x400>
 800144c:	4b36      	ldr	r3, [pc, #216]	; (8001528 <__aeabi_dadd+0x380>)
 800144e:	4298      	cmp	r0, r3
 8001450:	d100      	bne.n	8001454 <__aeabi_dadd+0x2ac>
 8001452:	e0d1      	b.n	80015f8 <__aeabi_dadd+0x450>
 8001454:	18ba      	adds	r2, r7, r2
 8001456:	42ba      	cmp	r2, r7
 8001458:	41bf      	sbcs	r7, r7
 800145a:	1864      	adds	r4, r4, r1
 800145c:	427f      	negs	r7, r7
 800145e:	19e4      	adds	r4, r4, r7
 8001460:	07e7      	lsls	r7, r4, #31
 8001462:	0852      	lsrs	r2, r2, #1
 8001464:	4317      	orrs	r7, r2
 8001466:	0864      	lsrs	r4, r4, #1
 8001468:	0006      	movs	r6, r0
 800146a:	e721      	b.n	80012b0 <__aeabi_dadd+0x108>
 800146c:	482e      	ldr	r0, [pc, #184]	; (8001528 <__aeabi_dadd+0x380>)
 800146e:	4285      	cmp	r5, r0
 8001470:	d100      	bne.n	8001474 <__aeabi_dadd+0x2cc>
 8001472:	e093      	b.n	800159c <__aeabi_dadd+0x3f4>
 8001474:	001d      	movs	r5, r3
 8001476:	e6d0      	b.n	800121a <__aeabi_dadd+0x72>
 8001478:	0029      	movs	r1, r5
 800147a:	3e1f      	subs	r6, #31
 800147c:	40f1      	lsrs	r1, r6
 800147e:	2b20      	cmp	r3, #32
 8001480:	d100      	bne.n	8001484 <__aeabi_dadd+0x2dc>
 8001482:	e08d      	b.n	80015a0 <__aeabi_dadd+0x3f8>
 8001484:	2240      	movs	r2, #64	; 0x40
 8001486:	1ad3      	subs	r3, r2, r3
 8001488:	409d      	lsls	r5, r3
 800148a:	432f      	orrs	r7, r5
 800148c:	1e7d      	subs	r5, r7, #1
 800148e:	41af      	sbcs	r7, r5
 8001490:	2400      	movs	r4, #0
 8001492:	430f      	orrs	r7, r1
 8001494:	2600      	movs	r6, #0
 8001496:	e744      	b.n	8001322 <__aeabi_dadd+0x17a>
 8001498:	002b      	movs	r3, r5
 800149a:	0008      	movs	r0, r1
 800149c:	3b20      	subs	r3, #32
 800149e:	40d8      	lsrs	r0, r3
 80014a0:	0003      	movs	r3, r0
 80014a2:	2d20      	cmp	r5, #32
 80014a4:	d100      	bne.n	80014a8 <__aeabi_dadd+0x300>
 80014a6:	e07d      	b.n	80015a4 <__aeabi_dadd+0x3fc>
 80014a8:	2040      	movs	r0, #64	; 0x40
 80014aa:	1b45      	subs	r5, r0, r5
 80014ac:	40a9      	lsls	r1, r5
 80014ae:	430a      	orrs	r2, r1
 80014b0:	1e51      	subs	r1, r2, #1
 80014b2:	418a      	sbcs	r2, r1
 80014b4:	2100      	movs	r1, #0
 80014b6:	431a      	orrs	r2, r3
 80014b8:	e6c7      	b.n	800124a <__aeabi_dadd+0xa2>
 80014ba:	2e00      	cmp	r6, #0
 80014bc:	d050      	beq.n	8001560 <__aeabi_dadd+0x3b8>
 80014be:	4e1a      	ldr	r6, [pc, #104]	; (8001528 <__aeabi_dadd+0x380>)
 80014c0:	42b0      	cmp	r0, r6
 80014c2:	d057      	beq.n	8001574 <__aeabi_dadd+0x3cc>
 80014c4:	2680      	movs	r6, #128	; 0x80
 80014c6:	426b      	negs	r3, r5
 80014c8:	4699      	mov	r9, r3
 80014ca:	0436      	lsls	r6, r6, #16
 80014cc:	4334      	orrs	r4, r6
 80014ce:	464b      	mov	r3, r9
 80014d0:	2b38      	cmp	r3, #56	; 0x38
 80014d2:	dd00      	ble.n	80014d6 <__aeabi_dadd+0x32e>
 80014d4:	e0d6      	b.n	8001684 <__aeabi_dadd+0x4dc>
 80014d6:	2b1f      	cmp	r3, #31
 80014d8:	dd00      	ble.n	80014dc <__aeabi_dadd+0x334>
 80014da:	e135      	b.n	8001748 <__aeabi_dadd+0x5a0>
 80014dc:	2620      	movs	r6, #32
 80014de:	1af5      	subs	r5, r6, r3
 80014e0:	0026      	movs	r6, r4
 80014e2:	40ae      	lsls	r6, r5
 80014e4:	46b2      	mov	sl, r6
 80014e6:	003e      	movs	r6, r7
 80014e8:	40de      	lsrs	r6, r3
 80014ea:	46ac      	mov	ip, r5
 80014ec:	0035      	movs	r5, r6
 80014ee:	4656      	mov	r6, sl
 80014f0:	432e      	orrs	r6, r5
 80014f2:	4665      	mov	r5, ip
 80014f4:	40af      	lsls	r7, r5
 80014f6:	1e7d      	subs	r5, r7, #1
 80014f8:	41af      	sbcs	r7, r5
 80014fa:	40dc      	lsrs	r4, r3
 80014fc:	4337      	orrs	r7, r6
 80014fe:	1bd7      	subs	r7, r2, r7
 8001500:	42ba      	cmp	r2, r7
 8001502:	4192      	sbcs	r2, r2
 8001504:	1b0c      	subs	r4, r1, r4
 8001506:	4252      	negs	r2, r2
 8001508:	1aa4      	subs	r4, r4, r2
 800150a:	0006      	movs	r6, r0
 800150c:	46d8      	mov	r8, fp
 800150e:	e6a3      	b.n	8001258 <__aeabi_dadd+0xb0>
 8001510:	4664      	mov	r4, ip
 8001512:	4667      	mov	r7, ip
 8001514:	432c      	orrs	r4, r5
 8001516:	d000      	beq.n	800151a <__aeabi_dadd+0x372>
 8001518:	e6a2      	b.n	8001260 <__aeabi_dadd+0xb8>
 800151a:	2500      	movs	r5, #0
 800151c:	2600      	movs	r6, #0
 800151e:	2700      	movs	r7, #0
 8001520:	e706      	b.n	8001330 <__aeabi_dadd+0x188>
 8001522:	001e      	movs	r6, r3
 8001524:	e6c4      	b.n	80012b0 <__aeabi_dadd+0x108>
 8001526:	46c0      	nop			; (mov r8, r8)
 8001528:	000007ff 	.word	0x000007ff
 800152c:	ff7fffff 	.word	0xff7fffff
 8001530:	800fffff 	.word	0x800fffff
 8001534:	2b1f      	cmp	r3, #31
 8001536:	dc63      	bgt.n	8001600 <__aeabi_dadd+0x458>
 8001538:	2020      	movs	r0, #32
 800153a:	1ac3      	subs	r3, r0, r3
 800153c:	0008      	movs	r0, r1
 800153e:	4098      	lsls	r0, r3
 8001540:	469c      	mov	ip, r3
 8001542:	4683      	mov	fp, r0
 8001544:	4653      	mov	r3, sl
 8001546:	0010      	movs	r0, r2
 8001548:	40d8      	lsrs	r0, r3
 800154a:	0003      	movs	r3, r0
 800154c:	4658      	mov	r0, fp
 800154e:	4318      	orrs	r0, r3
 8001550:	4663      	mov	r3, ip
 8001552:	409a      	lsls	r2, r3
 8001554:	1e53      	subs	r3, r2, #1
 8001556:	419a      	sbcs	r2, r3
 8001558:	4653      	mov	r3, sl
 800155a:	4302      	orrs	r2, r0
 800155c:	40d9      	lsrs	r1, r3
 800155e:	e703      	b.n	8001368 <__aeabi_dadd+0x1c0>
 8001560:	0026      	movs	r6, r4
 8001562:	433e      	orrs	r6, r7
 8001564:	d006      	beq.n	8001574 <__aeabi_dadd+0x3cc>
 8001566:	43eb      	mvns	r3, r5
 8001568:	4699      	mov	r9, r3
 800156a:	2b00      	cmp	r3, #0
 800156c:	d0c7      	beq.n	80014fe <__aeabi_dadd+0x356>
 800156e:	4e94      	ldr	r6, [pc, #592]	; (80017c0 <__aeabi_dadd+0x618>)
 8001570:	42b0      	cmp	r0, r6
 8001572:	d1ac      	bne.n	80014ce <__aeabi_dadd+0x326>
 8001574:	000c      	movs	r4, r1
 8001576:	0017      	movs	r7, r2
 8001578:	0006      	movs	r6, r0
 800157a:	46d8      	mov	r8, fp
 800157c:	e698      	b.n	80012b0 <__aeabi_dadd+0x108>
 800157e:	4b90      	ldr	r3, [pc, #576]	; (80017c0 <__aeabi_dadd+0x618>)
 8001580:	459a      	cmp	sl, r3
 8001582:	d00b      	beq.n	800159c <__aeabi_dadd+0x3f4>
 8001584:	4682      	mov	sl, r0
 8001586:	e6e7      	b.n	8001358 <__aeabi_dadd+0x1b0>
 8001588:	2800      	cmp	r0, #0
 800158a:	d000      	beq.n	800158e <__aeabi_dadd+0x3e6>
 800158c:	e09e      	b.n	80016cc <__aeabi_dadd+0x524>
 800158e:	0018      	movs	r0, r3
 8001590:	4310      	orrs	r0, r2
 8001592:	d100      	bne.n	8001596 <__aeabi_dadd+0x3ee>
 8001594:	e0e9      	b.n	800176a <__aeabi_dadd+0x5c2>
 8001596:	001c      	movs	r4, r3
 8001598:	0017      	movs	r7, r2
 800159a:	46d8      	mov	r8, fp
 800159c:	4e88      	ldr	r6, [pc, #544]	; (80017c0 <__aeabi_dadd+0x618>)
 800159e:	e687      	b.n	80012b0 <__aeabi_dadd+0x108>
 80015a0:	2500      	movs	r5, #0
 80015a2:	e772      	b.n	800148a <__aeabi_dadd+0x2e2>
 80015a4:	2100      	movs	r1, #0
 80015a6:	e782      	b.n	80014ae <__aeabi_dadd+0x306>
 80015a8:	0023      	movs	r3, r4
 80015aa:	433b      	orrs	r3, r7
 80015ac:	2e00      	cmp	r6, #0
 80015ae:	d000      	beq.n	80015b2 <__aeabi_dadd+0x40a>
 80015b0:	e0ab      	b.n	800170a <__aeabi_dadd+0x562>
 80015b2:	2b00      	cmp	r3, #0
 80015b4:	d100      	bne.n	80015b8 <__aeabi_dadd+0x410>
 80015b6:	e0e7      	b.n	8001788 <__aeabi_dadd+0x5e0>
 80015b8:	000b      	movs	r3, r1
 80015ba:	4313      	orrs	r3, r2
 80015bc:	d100      	bne.n	80015c0 <__aeabi_dadd+0x418>
 80015be:	e677      	b.n	80012b0 <__aeabi_dadd+0x108>
 80015c0:	18ba      	adds	r2, r7, r2
 80015c2:	42ba      	cmp	r2, r7
 80015c4:	41bf      	sbcs	r7, r7
 80015c6:	1864      	adds	r4, r4, r1
 80015c8:	427f      	negs	r7, r7
 80015ca:	19e4      	adds	r4, r4, r7
 80015cc:	0223      	lsls	r3, r4, #8
 80015ce:	d400      	bmi.n	80015d2 <__aeabi_dadd+0x42a>
 80015d0:	e0f2      	b.n	80017b8 <__aeabi_dadd+0x610>
 80015d2:	4b7c      	ldr	r3, [pc, #496]	; (80017c4 <__aeabi_dadd+0x61c>)
 80015d4:	0017      	movs	r7, r2
 80015d6:	401c      	ands	r4, r3
 80015d8:	0006      	movs	r6, r0
 80015da:	e669      	b.n	80012b0 <__aeabi_dadd+0x108>
 80015dc:	0020      	movs	r0, r4
 80015de:	4338      	orrs	r0, r7
 80015e0:	2e00      	cmp	r6, #0
 80015e2:	d1d1      	bne.n	8001588 <__aeabi_dadd+0x3e0>
 80015e4:	2800      	cmp	r0, #0
 80015e6:	d15b      	bne.n	80016a0 <__aeabi_dadd+0x4f8>
 80015e8:	001c      	movs	r4, r3
 80015ea:	4314      	orrs	r4, r2
 80015ec:	d100      	bne.n	80015f0 <__aeabi_dadd+0x448>
 80015ee:	e0a8      	b.n	8001742 <__aeabi_dadd+0x59a>
 80015f0:	001c      	movs	r4, r3
 80015f2:	0017      	movs	r7, r2
 80015f4:	46d8      	mov	r8, fp
 80015f6:	e65b      	b.n	80012b0 <__aeabi_dadd+0x108>
 80015f8:	0006      	movs	r6, r0
 80015fa:	2400      	movs	r4, #0
 80015fc:	2700      	movs	r7, #0
 80015fe:	e697      	b.n	8001330 <__aeabi_dadd+0x188>
 8001600:	4650      	mov	r0, sl
 8001602:	000b      	movs	r3, r1
 8001604:	3820      	subs	r0, #32
 8001606:	40c3      	lsrs	r3, r0
 8001608:	4699      	mov	r9, r3
 800160a:	4653      	mov	r3, sl
 800160c:	2b20      	cmp	r3, #32
 800160e:	d100      	bne.n	8001612 <__aeabi_dadd+0x46a>
 8001610:	e095      	b.n	800173e <__aeabi_dadd+0x596>
 8001612:	2340      	movs	r3, #64	; 0x40
 8001614:	4650      	mov	r0, sl
 8001616:	1a1b      	subs	r3, r3, r0
 8001618:	4099      	lsls	r1, r3
 800161a:	430a      	orrs	r2, r1
 800161c:	1e51      	subs	r1, r2, #1
 800161e:	418a      	sbcs	r2, r1
 8001620:	464b      	mov	r3, r9
 8001622:	2100      	movs	r1, #0
 8001624:	431a      	orrs	r2, r3
 8001626:	e69f      	b.n	8001368 <__aeabi_dadd+0x1c0>
 8001628:	2e00      	cmp	r6, #0
 800162a:	d130      	bne.n	800168e <__aeabi_dadd+0x4e6>
 800162c:	0026      	movs	r6, r4
 800162e:	433e      	orrs	r6, r7
 8001630:	d067      	beq.n	8001702 <__aeabi_dadd+0x55a>
 8001632:	43db      	mvns	r3, r3
 8001634:	469a      	mov	sl, r3
 8001636:	2b00      	cmp	r3, #0
 8001638:	d01c      	beq.n	8001674 <__aeabi_dadd+0x4cc>
 800163a:	4e61      	ldr	r6, [pc, #388]	; (80017c0 <__aeabi_dadd+0x618>)
 800163c:	42b0      	cmp	r0, r6
 800163e:	d060      	beq.n	8001702 <__aeabi_dadd+0x55a>
 8001640:	4653      	mov	r3, sl
 8001642:	2b38      	cmp	r3, #56	; 0x38
 8001644:	dd00      	ble.n	8001648 <__aeabi_dadd+0x4a0>
 8001646:	e096      	b.n	8001776 <__aeabi_dadd+0x5ce>
 8001648:	2b1f      	cmp	r3, #31
 800164a:	dd00      	ble.n	800164e <__aeabi_dadd+0x4a6>
 800164c:	e09f      	b.n	800178e <__aeabi_dadd+0x5e6>
 800164e:	2620      	movs	r6, #32
 8001650:	1af3      	subs	r3, r6, r3
 8001652:	0026      	movs	r6, r4
 8001654:	409e      	lsls	r6, r3
 8001656:	469c      	mov	ip, r3
 8001658:	46b3      	mov	fp, r6
 800165a:	4653      	mov	r3, sl
 800165c:	003e      	movs	r6, r7
 800165e:	40de      	lsrs	r6, r3
 8001660:	0033      	movs	r3, r6
 8001662:	465e      	mov	r6, fp
 8001664:	431e      	orrs	r6, r3
 8001666:	4663      	mov	r3, ip
 8001668:	409f      	lsls	r7, r3
 800166a:	1e7b      	subs	r3, r7, #1
 800166c:	419f      	sbcs	r7, r3
 800166e:	4653      	mov	r3, sl
 8001670:	40dc      	lsrs	r4, r3
 8001672:	4337      	orrs	r7, r6
 8001674:	18bf      	adds	r7, r7, r2
 8001676:	4297      	cmp	r7, r2
 8001678:	4192      	sbcs	r2, r2
 800167a:	1864      	adds	r4, r4, r1
 800167c:	4252      	negs	r2, r2
 800167e:	18a4      	adds	r4, r4, r2
 8001680:	0006      	movs	r6, r0
 8001682:	e678      	b.n	8001376 <__aeabi_dadd+0x1ce>
 8001684:	4327      	orrs	r7, r4
 8001686:	1e7c      	subs	r4, r7, #1
 8001688:	41a7      	sbcs	r7, r4
 800168a:	2400      	movs	r4, #0
 800168c:	e737      	b.n	80014fe <__aeabi_dadd+0x356>
 800168e:	4e4c      	ldr	r6, [pc, #304]	; (80017c0 <__aeabi_dadd+0x618>)
 8001690:	42b0      	cmp	r0, r6
 8001692:	d036      	beq.n	8001702 <__aeabi_dadd+0x55a>
 8001694:	2680      	movs	r6, #128	; 0x80
 8001696:	425b      	negs	r3, r3
 8001698:	0436      	lsls	r6, r6, #16
 800169a:	469a      	mov	sl, r3
 800169c:	4334      	orrs	r4, r6
 800169e:	e7cf      	b.n	8001640 <__aeabi_dadd+0x498>
 80016a0:	0018      	movs	r0, r3
 80016a2:	4310      	orrs	r0, r2
 80016a4:	d100      	bne.n	80016a8 <__aeabi_dadd+0x500>
 80016a6:	e603      	b.n	80012b0 <__aeabi_dadd+0x108>
 80016a8:	1ab8      	subs	r0, r7, r2
 80016aa:	4684      	mov	ip, r0
 80016ac:	4567      	cmp	r7, ip
 80016ae:	41ad      	sbcs	r5, r5
 80016b0:	1ae0      	subs	r0, r4, r3
 80016b2:	426d      	negs	r5, r5
 80016b4:	1b40      	subs	r0, r0, r5
 80016b6:	0205      	lsls	r5, r0, #8
 80016b8:	d400      	bmi.n	80016bc <__aeabi_dadd+0x514>
 80016ba:	e62c      	b.n	8001316 <__aeabi_dadd+0x16e>
 80016bc:	1bd7      	subs	r7, r2, r7
 80016be:	42ba      	cmp	r2, r7
 80016c0:	4192      	sbcs	r2, r2
 80016c2:	1b1c      	subs	r4, r3, r4
 80016c4:	4252      	negs	r2, r2
 80016c6:	1aa4      	subs	r4, r4, r2
 80016c8:	46d8      	mov	r8, fp
 80016ca:	e5f1      	b.n	80012b0 <__aeabi_dadd+0x108>
 80016cc:	0018      	movs	r0, r3
 80016ce:	4310      	orrs	r0, r2
 80016d0:	d100      	bne.n	80016d4 <__aeabi_dadd+0x52c>
 80016d2:	e763      	b.n	800159c <__aeabi_dadd+0x3f4>
 80016d4:	08f8      	lsrs	r0, r7, #3
 80016d6:	0767      	lsls	r7, r4, #29
 80016d8:	4307      	orrs	r7, r0
 80016da:	2080      	movs	r0, #128	; 0x80
 80016dc:	08e4      	lsrs	r4, r4, #3
 80016de:	0300      	lsls	r0, r0, #12
 80016e0:	4204      	tst	r4, r0
 80016e2:	d008      	beq.n	80016f6 <__aeabi_dadd+0x54e>
 80016e4:	08dd      	lsrs	r5, r3, #3
 80016e6:	4205      	tst	r5, r0
 80016e8:	d105      	bne.n	80016f6 <__aeabi_dadd+0x54e>
 80016ea:	08d2      	lsrs	r2, r2, #3
 80016ec:	0759      	lsls	r1, r3, #29
 80016ee:	4311      	orrs	r1, r2
 80016f0:	000f      	movs	r7, r1
 80016f2:	002c      	movs	r4, r5
 80016f4:	46d8      	mov	r8, fp
 80016f6:	0f7b      	lsrs	r3, r7, #29
 80016f8:	00e4      	lsls	r4, r4, #3
 80016fa:	431c      	orrs	r4, r3
 80016fc:	00ff      	lsls	r7, r7, #3
 80016fe:	4e30      	ldr	r6, [pc, #192]	; (80017c0 <__aeabi_dadd+0x618>)
 8001700:	e5d6      	b.n	80012b0 <__aeabi_dadd+0x108>
 8001702:	000c      	movs	r4, r1
 8001704:	0017      	movs	r7, r2
 8001706:	0006      	movs	r6, r0
 8001708:	e5d2      	b.n	80012b0 <__aeabi_dadd+0x108>
 800170a:	2b00      	cmp	r3, #0
 800170c:	d038      	beq.n	8001780 <__aeabi_dadd+0x5d8>
 800170e:	000b      	movs	r3, r1
 8001710:	4313      	orrs	r3, r2
 8001712:	d100      	bne.n	8001716 <__aeabi_dadd+0x56e>
 8001714:	e742      	b.n	800159c <__aeabi_dadd+0x3f4>
 8001716:	08f8      	lsrs	r0, r7, #3
 8001718:	0767      	lsls	r7, r4, #29
 800171a:	4307      	orrs	r7, r0
 800171c:	2080      	movs	r0, #128	; 0x80
 800171e:	08e4      	lsrs	r4, r4, #3
 8001720:	0300      	lsls	r0, r0, #12
 8001722:	4204      	tst	r4, r0
 8001724:	d0e7      	beq.n	80016f6 <__aeabi_dadd+0x54e>
 8001726:	08cb      	lsrs	r3, r1, #3
 8001728:	4203      	tst	r3, r0
 800172a:	d1e4      	bne.n	80016f6 <__aeabi_dadd+0x54e>
 800172c:	08d2      	lsrs	r2, r2, #3
 800172e:	0749      	lsls	r1, r1, #29
 8001730:	4311      	orrs	r1, r2
 8001732:	000f      	movs	r7, r1
 8001734:	001c      	movs	r4, r3
 8001736:	e7de      	b.n	80016f6 <__aeabi_dadd+0x54e>
 8001738:	2700      	movs	r7, #0
 800173a:	2400      	movs	r4, #0
 800173c:	e5d5      	b.n	80012ea <__aeabi_dadd+0x142>
 800173e:	2100      	movs	r1, #0
 8001740:	e76b      	b.n	800161a <__aeabi_dadd+0x472>
 8001742:	2500      	movs	r5, #0
 8001744:	2700      	movs	r7, #0
 8001746:	e5f3      	b.n	8001330 <__aeabi_dadd+0x188>
 8001748:	464e      	mov	r6, r9
 800174a:	0025      	movs	r5, r4
 800174c:	3e20      	subs	r6, #32
 800174e:	40f5      	lsrs	r5, r6
 8001750:	464b      	mov	r3, r9
 8001752:	002e      	movs	r6, r5
 8001754:	2b20      	cmp	r3, #32
 8001756:	d02d      	beq.n	80017b4 <__aeabi_dadd+0x60c>
 8001758:	2540      	movs	r5, #64	; 0x40
 800175a:	1aed      	subs	r5, r5, r3
 800175c:	40ac      	lsls	r4, r5
 800175e:	4327      	orrs	r7, r4
 8001760:	1e7c      	subs	r4, r7, #1
 8001762:	41a7      	sbcs	r7, r4
 8001764:	2400      	movs	r4, #0
 8001766:	4337      	orrs	r7, r6
 8001768:	e6c9      	b.n	80014fe <__aeabi_dadd+0x356>
 800176a:	2480      	movs	r4, #128	; 0x80
 800176c:	2500      	movs	r5, #0
 800176e:	0324      	lsls	r4, r4, #12
 8001770:	4e13      	ldr	r6, [pc, #76]	; (80017c0 <__aeabi_dadd+0x618>)
 8001772:	2700      	movs	r7, #0
 8001774:	e5dc      	b.n	8001330 <__aeabi_dadd+0x188>
 8001776:	4327      	orrs	r7, r4
 8001778:	1e7c      	subs	r4, r7, #1
 800177a:	41a7      	sbcs	r7, r4
 800177c:	2400      	movs	r4, #0
 800177e:	e779      	b.n	8001674 <__aeabi_dadd+0x4cc>
 8001780:	000c      	movs	r4, r1
 8001782:	0017      	movs	r7, r2
 8001784:	4e0e      	ldr	r6, [pc, #56]	; (80017c0 <__aeabi_dadd+0x618>)
 8001786:	e593      	b.n	80012b0 <__aeabi_dadd+0x108>
 8001788:	000c      	movs	r4, r1
 800178a:	0017      	movs	r7, r2
 800178c:	e590      	b.n	80012b0 <__aeabi_dadd+0x108>
 800178e:	4656      	mov	r6, sl
 8001790:	0023      	movs	r3, r4
 8001792:	3e20      	subs	r6, #32
 8001794:	40f3      	lsrs	r3, r6
 8001796:	4699      	mov	r9, r3
 8001798:	4653      	mov	r3, sl
 800179a:	2b20      	cmp	r3, #32
 800179c:	d00e      	beq.n	80017bc <__aeabi_dadd+0x614>
 800179e:	2340      	movs	r3, #64	; 0x40
 80017a0:	4656      	mov	r6, sl
 80017a2:	1b9b      	subs	r3, r3, r6
 80017a4:	409c      	lsls	r4, r3
 80017a6:	4327      	orrs	r7, r4
 80017a8:	1e7c      	subs	r4, r7, #1
 80017aa:	41a7      	sbcs	r7, r4
 80017ac:	464b      	mov	r3, r9
 80017ae:	2400      	movs	r4, #0
 80017b0:	431f      	orrs	r7, r3
 80017b2:	e75f      	b.n	8001674 <__aeabi_dadd+0x4cc>
 80017b4:	2400      	movs	r4, #0
 80017b6:	e7d2      	b.n	800175e <__aeabi_dadd+0x5b6>
 80017b8:	0017      	movs	r7, r2
 80017ba:	e5b2      	b.n	8001322 <__aeabi_dadd+0x17a>
 80017bc:	2400      	movs	r4, #0
 80017be:	e7f2      	b.n	80017a6 <__aeabi_dadd+0x5fe>
 80017c0:	000007ff 	.word	0x000007ff
 80017c4:	ff7fffff 	.word	0xff7fffff

080017c8 <__aeabi_ddiv>:
 80017c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80017ca:	4657      	mov	r7, sl
 80017cc:	4645      	mov	r5, r8
 80017ce:	46de      	mov	lr, fp
 80017d0:	464e      	mov	r6, r9
 80017d2:	b5e0      	push	{r5, r6, r7, lr}
 80017d4:	004c      	lsls	r4, r1, #1
 80017d6:	030e      	lsls	r6, r1, #12
 80017d8:	b087      	sub	sp, #28
 80017da:	4683      	mov	fp, r0
 80017dc:	4692      	mov	sl, r2
 80017de:	001d      	movs	r5, r3
 80017e0:	4680      	mov	r8, r0
 80017e2:	0b36      	lsrs	r6, r6, #12
 80017e4:	0d64      	lsrs	r4, r4, #21
 80017e6:	0fcf      	lsrs	r7, r1, #31
 80017e8:	2c00      	cmp	r4, #0
 80017ea:	d04f      	beq.n	800188c <__aeabi_ddiv+0xc4>
 80017ec:	4b6f      	ldr	r3, [pc, #444]	; (80019ac <__aeabi_ddiv+0x1e4>)
 80017ee:	429c      	cmp	r4, r3
 80017f0:	d035      	beq.n	800185e <__aeabi_ddiv+0x96>
 80017f2:	2380      	movs	r3, #128	; 0x80
 80017f4:	0f42      	lsrs	r2, r0, #29
 80017f6:	041b      	lsls	r3, r3, #16
 80017f8:	00f6      	lsls	r6, r6, #3
 80017fa:	4313      	orrs	r3, r2
 80017fc:	4333      	orrs	r3, r6
 80017fe:	4699      	mov	r9, r3
 8001800:	00c3      	lsls	r3, r0, #3
 8001802:	4698      	mov	r8, r3
 8001804:	4b6a      	ldr	r3, [pc, #424]	; (80019b0 <__aeabi_ddiv+0x1e8>)
 8001806:	2600      	movs	r6, #0
 8001808:	469c      	mov	ip, r3
 800180a:	2300      	movs	r3, #0
 800180c:	4464      	add	r4, ip
 800180e:	9303      	str	r3, [sp, #12]
 8001810:	032b      	lsls	r3, r5, #12
 8001812:	0b1b      	lsrs	r3, r3, #12
 8001814:	469b      	mov	fp, r3
 8001816:	006b      	lsls	r3, r5, #1
 8001818:	0fed      	lsrs	r5, r5, #31
 800181a:	4650      	mov	r0, sl
 800181c:	0d5b      	lsrs	r3, r3, #21
 800181e:	9501      	str	r5, [sp, #4]
 8001820:	d05e      	beq.n	80018e0 <__aeabi_ddiv+0x118>
 8001822:	4a62      	ldr	r2, [pc, #392]	; (80019ac <__aeabi_ddiv+0x1e4>)
 8001824:	4293      	cmp	r3, r2
 8001826:	d053      	beq.n	80018d0 <__aeabi_ddiv+0x108>
 8001828:	465a      	mov	r2, fp
 800182a:	00d1      	lsls	r1, r2, #3
 800182c:	2280      	movs	r2, #128	; 0x80
 800182e:	0f40      	lsrs	r0, r0, #29
 8001830:	0412      	lsls	r2, r2, #16
 8001832:	4302      	orrs	r2, r0
 8001834:	430a      	orrs	r2, r1
 8001836:	4693      	mov	fp, r2
 8001838:	4652      	mov	r2, sl
 800183a:	00d1      	lsls	r1, r2, #3
 800183c:	4a5c      	ldr	r2, [pc, #368]	; (80019b0 <__aeabi_ddiv+0x1e8>)
 800183e:	4694      	mov	ip, r2
 8001840:	2200      	movs	r2, #0
 8001842:	4463      	add	r3, ip
 8001844:	0038      	movs	r0, r7
 8001846:	4068      	eors	r0, r5
 8001848:	4684      	mov	ip, r0
 800184a:	9002      	str	r0, [sp, #8]
 800184c:	1ae4      	subs	r4, r4, r3
 800184e:	4316      	orrs	r6, r2
 8001850:	2e0f      	cmp	r6, #15
 8001852:	d900      	bls.n	8001856 <__aeabi_ddiv+0x8e>
 8001854:	e0b4      	b.n	80019c0 <__aeabi_ddiv+0x1f8>
 8001856:	4b57      	ldr	r3, [pc, #348]	; (80019b4 <__aeabi_ddiv+0x1ec>)
 8001858:	00b6      	lsls	r6, r6, #2
 800185a:	599b      	ldr	r3, [r3, r6]
 800185c:	469f      	mov	pc, r3
 800185e:	0003      	movs	r3, r0
 8001860:	4333      	orrs	r3, r6
 8001862:	4699      	mov	r9, r3
 8001864:	d16c      	bne.n	8001940 <__aeabi_ddiv+0x178>
 8001866:	2300      	movs	r3, #0
 8001868:	4698      	mov	r8, r3
 800186a:	3302      	adds	r3, #2
 800186c:	2608      	movs	r6, #8
 800186e:	9303      	str	r3, [sp, #12]
 8001870:	e7ce      	b.n	8001810 <__aeabi_ddiv+0x48>
 8001872:	46cb      	mov	fp, r9
 8001874:	4641      	mov	r1, r8
 8001876:	9a03      	ldr	r2, [sp, #12]
 8001878:	9701      	str	r7, [sp, #4]
 800187a:	2a02      	cmp	r2, #2
 800187c:	d165      	bne.n	800194a <__aeabi_ddiv+0x182>
 800187e:	9b01      	ldr	r3, [sp, #4]
 8001880:	4c4a      	ldr	r4, [pc, #296]	; (80019ac <__aeabi_ddiv+0x1e4>)
 8001882:	469c      	mov	ip, r3
 8001884:	2300      	movs	r3, #0
 8001886:	2200      	movs	r2, #0
 8001888:	4698      	mov	r8, r3
 800188a:	e06b      	b.n	8001964 <__aeabi_ddiv+0x19c>
 800188c:	0003      	movs	r3, r0
 800188e:	4333      	orrs	r3, r6
 8001890:	4699      	mov	r9, r3
 8001892:	d04e      	beq.n	8001932 <__aeabi_ddiv+0x16a>
 8001894:	2e00      	cmp	r6, #0
 8001896:	d100      	bne.n	800189a <__aeabi_ddiv+0xd2>
 8001898:	e1bc      	b.n	8001c14 <__aeabi_ddiv+0x44c>
 800189a:	0030      	movs	r0, r6
 800189c:	f000 ffee 	bl	800287c <__clzsi2>
 80018a0:	0003      	movs	r3, r0
 80018a2:	3b0b      	subs	r3, #11
 80018a4:	2b1c      	cmp	r3, #28
 80018a6:	dd00      	ble.n	80018aa <__aeabi_ddiv+0xe2>
 80018a8:	e1ac      	b.n	8001c04 <__aeabi_ddiv+0x43c>
 80018aa:	221d      	movs	r2, #29
 80018ac:	1ad3      	subs	r3, r2, r3
 80018ae:	465a      	mov	r2, fp
 80018b0:	0001      	movs	r1, r0
 80018b2:	40da      	lsrs	r2, r3
 80018b4:	3908      	subs	r1, #8
 80018b6:	408e      	lsls	r6, r1
 80018b8:	0013      	movs	r3, r2
 80018ba:	4333      	orrs	r3, r6
 80018bc:	4699      	mov	r9, r3
 80018be:	465b      	mov	r3, fp
 80018c0:	408b      	lsls	r3, r1
 80018c2:	4698      	mov	r8, r3
 80018c4:	2300      	movs	r3, #0
 80018c6:	4c3c      	ldr	r4, [pc, #240]	; (80019b8 <__aeabi_ddiv+0x1f0>)
 80018c8:	2600      	movs	r6, #0
 80018ca:	1a24      	subs	r4, r4, r0
 80018cc:	9303      	str	r3, [sp, #12]
 80018ce:	e79f      	b.n	8001810 <__aeabi_ddiv+0x48>
 80018d0:	4651      	mov	r1, sl
 80018d2:	465a      	mov	r2, fp
 80018d4:	4311      	orrs	r1, r2
 80018d6:	d129      	bne.n	800192c <__aeabi_ddiv+0x164>
 80018d8:	2200      	movs	r2, #0
 80018da:	4693      	mov	fp, r2
 80018dc:	3202      	adds	r2, #2
 80018de:	e7b1      	b.n	8001844 <__aeabi_ddiv+0x7c>
 80018e0:	4659      	mov	r1, fp
 80018e2:	4301      	orrs	r1, r0
 80018e4:	d01e      	beq.n	8001924 <__aeabi_ddiv+0x15c>
 80018e6:	465b      	mov	r3, fp
 80018e8:	2b00      	cmp	r3, #0
 80018ea:	d100      	bne.n	80018ee <__aeabi_ddiv+0x126>
 80018ec:	e19e      	b.n	8001c2c <__aeabi_ddiv+0x464>
 80018ee:	4658      	mov	r0, fp
 80018f0:	f000 ffc4 	bl	800287c <__clzsi2>
 80018f4:	0003      	movs	r3, r0
 80018f6:	3b0b      	subs	r3, #11
 80018f8:	2b1c      	cmp	r3, #28
 80018fa:	dd00      	ble.n	80018fe <__aeabi_ddiv+0x136>
 80018fc:	e18f      	b.n	8001c1e <__aeabi_ddiv+0x456>
 80018fe:	0002      	movs	r2, r0
 8001900:	4659      	mov	r1, fp
 8001902:	3a08      	subs	r2, #8
 8001904:	4091      	lsls	r1, r2
 8001906:	468b      	mov	fp, r1
 8001908:	211d      	movs	r1, #29
 800190a:	1acb      	subs	r3, r1, r3
 800190c:	4651      	mov	r1, sl
 800190e:	40d9      	lsrs	r1, r3
 8001910:	000b      	movs	r3, r1
 8001912:	4659      	mov	r1, fp
 8001914:	430b      	orrs	r3, r1
 8001916:	4651      	mov	r1, sl
 8001918:	469b      	mov	fp, r3
 800191a:	4091      	lsls	r1, r2
 800191c:	4b26      	ldr	r3, [pc, #152]	; (80019b8 <__aeabi_ddiv+0x1f0>)
 800191e:	2200      	movs	r2, #0
 8001920:	1a1b      	subs	r3, r3, r0
 8001922:	e78f      	b.n	8001844 <__aeabi_ddiv+0x7c>
 8001924:	2300      	movs	r3, #0
 8001926:	2201      	movs	r2, #1
 8001928:	469b      	mov	fp, r3
 800192a:	e78b      	b.n	8001844 <__aeabi_ddiv+0x7c>
 800192c:	4651      	mov	r1, sl
 800192e:	2203      	movs	r2, #3
 8001930:	e788      	b.n	8001844 <__aeabi_ddiv+0x7c>
 8001932:	2300      	movs	r3, #0
 8001934:	4698      	mov	r8, r3
 8001936:	3301      	adds	r3, #1
 8001938:	2604      	movs	r6, #4
 800193a:	2400      	movs	r4, #0
 800193c:	9303      	str	r3, [sp, #12]
 800193e:	e767      	b.n	8001810 <__aeabi_ddiv+0x48>
 8001940:	2303      	movs	r3, #3
 8001942:	46b1      	mov	r9, r6
 8001944:	9303      	str	r3, [sp, #12]
 8001946:	260c      	movs	r6, #12
 8001948:	e762      	b.n	8001810 <__aeabi_ddiv+0x48>
 800194a:	2a03      	cmp	r2, #3
 800194c:	d100      	bne.n	8001950 <__aeabi_ddiv+0x188>
 800194e:	e25c      	b.n	8001e0a <__aeabi_ddiv+0x642>
 8001950:	9b01      	ldr	r3, [sp, #4]
 8001952:	2a01      	cmp	r2, #1
 8001954:	d000      	beq.n	8001958 <__aeabi_ddiv+0x190>
 8001956:	e1e4      	b.n	8001d22 <__aeabi_ddiv+0x55a>
 8001958:	4013      	ands	r3, r2
 800195a:	469c      	mov	ip, r3
 800195c:	2300      	movs	r3, #0
 800195e:	2400      	movs	r4, #0
 8001960:	2200      	movs	r2, #0
 8001962:	4698      	mov	r8, r3
 8001964:	2100      	movs	r1, #0
 8001966:	0312      	lsls	r2, r2, #12
 8001968:	0b13      	lsrs	r3, r2, #12
 800196a:	0d0a      	lsrs	r2, r1, #20
 800196c:	0512      	lsls	r2, r2, #20
 800196e:	431a      	orrs	r2, r3
 8001970:	0523      	lsls	r3, r4, #20
 8001972:	4c12      	ldr	r4, [pc, #72]	; (80019bc <__aeabi_ddiv+0x1f4>)
 8001974:	4640      	mov	r0, r8
 8001976:	4022      	ands	r2, r4
 8001978:	4313      	orrs	r3, r2
 800197a:	4662      	mov	r2, ip
 800197c:	005b      	lsls	r3, r3, #1
 800197e:	07d2      	lsls	r2, r2, #31
 8001980:	085b      	lsrs	r3, r3, #1
 8001982:	4313      	orrs	r3, r2
 8001984:	0019      	movs	r1, r3
 8001986:	b007      	add	sp, #28
 8001988:	bc3c      	pop	{r2, r3, r4, r5}
 800198a:	4690      	mov	r8, r2
 800198c:	4699      	mov	r9, r3
 800198e:	46a2      	mov	sl, r4
 8001990:	46ab      	mov	fp, r5
 8001992:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001994:	2300      	movs	r3, #0
 8001996:	2280      	movs	r2, #128	; 0x80
 8001998:	469c      	mov	ip, r3
 800199a:	0312      	lsls	r2, r2, #12
 800199c:	4698      	mov	r8, r3
 800199e:	4c03      	ldr	r4, [pc, #12]	; (80019ac <__aeabi_ddiv+0x1e4>)
 80019a0:	e7e0      	b.n	8001964 <__aeabi_ddiv+0x19c>
 80019a2:	2300      	movs	r3, #0
 80019a4:	4c01      	ldr	r4, [pc, #4]	; (80019ac <__aeabi_ddiv+0x1e4>)
 80019a6:	2200      	movs	r2, #0
 80019a8:	4698      	mov	r8, r3
 80019aa:	e7db      	b.n	8001964 <__aeabi_ddiv+0x19c>
 80019ac:	000007ff 	.word	0x000007ff
 80019b0:	fffffc01 	.word	0xfffffc01
 80019b4:	0800dce4 	.word	0x0800dce4
 80019b8:	fffffc0d 	.word	0xfffffc0d
 80019bc:	800fffff 	.word	0x800fffff
 80019c0:	45d9      	cmp	r9, fp
 80019c2:	d900      	bls.n	80019c6 <__aeabi_ddiv+0x1fe>
 80019c4:	e139      	b.n	8001c3a <__aeabi_ddiv+0x472>
 80019c6:	d100      	bne.n	80019ca <__aeabi_ddiv+0x202>
 80019c8:	e134      	b.n	8001c34 <__aeabi_ddiv+0x46c>
 80019ca:	2300      	movs	r3, #0
 80019cc:	4646      	mov	r6, r8
 80019ce:	464d      	mov	r5, r9
 80019d0:	469a      	mov	sl, r3
 80019d2:	3c01      	subs	r4, #1
 80019d4:	465b      	mov	r3, fp
 80019d6:	0e0a      	lsrs	r2, r1, #24
 80019d8:	021b      	lsls	r3, r3, #8
 80019da:	431a      	orrs	r2, r3
 80019dc:	020b      	lsls	r3, r1, #8
 80019de:	0c17      	lsrs	r7, r2, #16
 80019e0:	9303      	str	r3, [sp, #12]
 80019e2:	0413      	lsls	r3, r2, #16
 80019e4:	0c1b      	lsrs	r3, r3, #16
 80019e6:	0039      	movs	r1, r7
 80019e8:	0028      	movs	r0, r5
 80019ea:	4690      	mov	r8, r2
 80019ec:	9301      	str	r3, [sp, #4]
 80019ee:	f7fe fb95 	bl	800011c <__udivsi3>
 80019f2:	0002      	movs	r2, r0
 80019f4:	9b01      	ldr	r3, [sp, #4]
 80019f6:	4683      	mov	fp, r0
 80019f8:	435a      	muls	r2, r3
 80019fa:	0028      	movs	r0, r5
 80019fc:	0039      	movs	r1, r7
 80019fe:	4691      	mov	r9, r2
 8001a00:	f7fe fc12 	bl	8000228 <__aeabi_uidivmod>
 8001a04:	0c35      	lsrs	r5, r6, #16
 8001a06:	0409      	lsls	r1, r1, #16
 8001a08:	430d      	orrs	r5, r1
 8001a0a:	45a9      	cmp	r9, r5
 8001a0c:	d90d      	bls.n	8001a2a <__aeabi_ddiv+0x262>
 8001a0e:	465b      	mov	r3, fp
 8001a10:	4445      	add	r5, r8
 8001a12:	3b01      	subs	r3, #1
 8001a14:	45a8      	cmp	r8, r5
 8001a16:	d900      	bls.n	8001a1a <__aeabi_ddiv+0x252>
 8001a18:	e13a      	b.n	8001c90 <__aeabi_ddiv+0x4c8>
 8001a1a:	45a9      	cmp	r9, r5
 8001a1c:	d800      	bhi.n	8001a20 <__aeabi_ddiv+0x258>
 8001a1e:	e137      	b.n	8001c90 <__aeabi_ddiv+0x4c8>
 8001a20:	2302      	movs	r3, #2
 8001a22:	425b      	negs	r3, r3
 8001a24:	469c      	mov	ip, r3
 8001a26:	4445      	add	r5, r8
 8001a28:	44e3      	add	fp, ip
 8001a2a:	464b      	mov	r3, r9
 8001a2c:	1aeb      	subs	r3, r5, r3
 8001a2e:	0039      	movs	r1, r7
 8001a30:	0018      	movs	r0, r3
 8001a32:	9304      	str	r3, [sp, #16]
 8001a34:	f7fe fb72 	bl	800011c <__udivsi3>
 8001a38:	9b01      	ldr	r3, [sp, #4]
 8001a3a:	0005      	movs	r5, r0
 8001a3c:	4343      	muls	r3, r0
 8001a3e:	0039      	movs	r1, r7
 8001a40:	9804      	ldr	r0, [sp, #16]
 8001a42:	4699      	mov	r9, r3
 8001a44:	f7fe fbf0 	bl	8000228 <__aeabi_uidivmod>
 8001a48:	0433      	lsls	r3, r6, #16
 8001a4a:	0409      	lsls	r1, r1, #16
 8001a4c:	0c1b      	lsrs	r3, r3, #16
 8001a4e:	430b      	orrs	r3, r1
 8001a50:	4599      	cmp	r9, r3
 8001a52:	d909      	bls.n	8001a68 <__aeabi_ddiv+0x2a0>
 8001a54:	4443      	add	r3, r8
 8001a56:	1e6a      	subs	r2, r5, #1
 8001a58:	4598      	cmp	r8, r3
 8001a5a:	d900      	bls.n	8001a5e <__aeabi_ddiv+0x296>
 8001a5c:	e11a      	b.n	8001c94 <__aeabi_ddiv+0x4cc>
 8001a5e:	4599      	cmp	r9, r3
 8001a60:	d800      	bhi.n	8001a64 <__aeabi_ddiv+0x29c>
 8001a62:	e117      	b.n	8001c94 <__aeabi_ddiv+0x4cc>
 8001a64:	3d02      	subs	r5, #2
 8001a66:	4443      	add	r3, r8
 8001a68:	464a      	mov	r2, r9
 8001a6a:	1a9b      	subs	r3, r3, r2
 8001a6c:	465a      	mov	r2, fp
 8001a6e:	0412      	lsls	r2, r2, #16
 8001a70:	432a      	orrs	r2, r5
 8001a72:	9903      	ldr	r1, [sp, #12]
 8001a74:	4693      	mov	fp, r2
 8001a76:	0c10      	lsrs	r0, r2, #16
 8001a78:	0c0a      	lsrs	r2, r1, #16
 8001a7a:	4691      	mov	r9, r2
 8001a7c:	0409      	lsls	r1, r1, #16
 8001a7e:	465a      	mov	r2, fp
 8001a80:	0c09      	lsrs	r1, r1, #16
 8001a82:	464e      	mov	r6, r9
 8001a84:	000d      	movs	r5, r1
 8001a86:	0412      	lsls	r2, r2, #16
 8001a88:	0c12      	lsrs	r2, r2, #16
 8001a8a:	4345      	muls	r5, r0
 8001a8c:	9105      	str	r1, [sp, #20]
 8001a8e:	4351      	muls	r1, r2
 8001a90:	4372      	muls	r2, r6
 8001a92:	4370      	muls	r0, r6
 8001a94:	1952      	adds	r2, r2, r5
 8001a96:	0c0e      	lsrs	r6, r1, #16
 8001a98:	18b2      	adds	r2, r6, r2
 8001a9a:	4295      	cmp	r5, r2
 8001a9c:	d903      	bls.n	8001aa6 <__aeabi_ddiv+0x2de>
 8001a9e:	2580      	movs	r5, #128	; 0x80
 8001aa0:	026d      	lsls	r5, r5, #9
 8001aa2:	46ac      	mov	ip, r5
 8001aa4:	4460      	add	r0, ip
 8001aa6:	0c15      	lsrs	r5, r2, #16
 8001aa8:	0409      	lsls	r1, r1, #16
 8001aaa:	0412      	lsls	r2, r2, #16
 8001aac:	0c09      	lsrs	r1, r1, #16
 8001aae:	1828      	adds	r0, r5, r0
 8001ab0:	1852      	adds	r2, r2, r1
 8001ab2:	4283      	cmp	r3, r0
 8001ab4:	d200      	bcs.n	8001ab8 <__aeabi_ddiv+0x2f0>
 8001ab6:	e0ce      	b.n	8001c56 <__aeabi_ddiv+0x48e>
 8001ab8:	d100      	bne.n	8001abc <__aeabi_ddiv+0x2f4>
 8001aba:	e0c8      	b.n	8001c4e <__aeabi_ddiv+0x486>
 8001abc:	1a1d      	subs	r5, r3, r0
 8001abe:	4653      	mov	r3, sl
 8001ac0:	1a9e      	subs	r6, r3, r2
 8001ac2:	45b2      	cmp	sl, r6
 8001ac4:	4192      	sbcs	r2, r2
 8001ac6:	4252      	negs	r2, r2
 8001ac8:	1aab      	subs	r3, r5, r2
 8001aca:	469a      	mov	sl, r3
 8001acc:	4598      	cmp	r8, r3
 8001ace:	d100      	bne.n	8001ad2 <__aeabi_ddiv+0x30a>
 8001ad0:	e117      	b.n	8001d02 <__aeabi_ddiv+0x53a>
 8001ad2:	0039      	movs	r1, r7
 8001ad4:	0018      	movs	r0, r3
 8001ad6:	f7fe fb21 	bl	800011c <__udivsi3>
 8001ada:	9b01      	ldr	r3, [sp, #4]
 8001adc:	0005      	movs	r5, r0
 8001ade:	4343      	muls	r3, r0
 8001ae0:	0039      	movs	r1, r7
 8001ae2:	4650      	mov	r0, sl
 8001ae4:	9304      	str	r3, [sp, #16]
 8001ae6:	f7fe fb9f 	bl	8000228 <__aeabi_uidivmod>
 8001aea:	9804      	ldr	r0, [sp, #16]
 8001aec:	040b      	lsls	r3, r1, #16
 8001aee:	0c31      	lsrs	r1, r6, #16
 8001af0:	4319      	orrs	r1, r3
 8001af2:	4288      	cmp	r0, r1
 8001af4:	d909      	bls.n	8001b0a <__aeabi_ddiv+0x342>
 8001af6:	4441      	add	r1, r8
 8001af8:	1e6b      	subs	r3, r5, #1
 8001afa:	4588      	cmp	r8, r1
 8001afc:	d900      	bls.n	8001b00 <__aeabi_ddiv+0x338>
 8001afe:	e107      	b.n	8001d10 <__aeabi_ddiv+0x548>
 8001b00:	4288      	cmp	r0, r1
 8001b02:	d800      	bhi.n	8001b06 <__aeabi_ddiv+0x33e>
 8001b04:	e104      	b.n	8001d10 <__aeabi_ddiv+0x548>
 8001b06:	3d02      	subs	r5, #2
 8001b08:	4441      	add	r1, r8
 8001b0a:	9b04      	ldr	r3, [sp, #16]
 8001b0c:	1acb      	subs	r3, r1, r3
 8001b0e:	0018      	movs	r0, r3
 8001b10:	0039      	movs	r1, r7
 8001b12:	9304      	str	r3, [sp, #16]
 8001b14:	f7fe fb02 	bl	800011c <__udivsi3>
 8001b18:	9b01      	ldr	r3, [sp, #4]
 8001b1a:	4682      	mov	sl, r0
 8001b1c:	4343      	muls	r3, r0
 8001b1e:	0039      	movs	r1, r7
 8001b20:	9804      	ldr	r0, [sp, #16]
 8001b22:	9301      	str	r3, [sp, #4]
 8001b24:	f7fe fb80 	bl	8000228 <__aeabi_uidivmod>
 8001b28:	9801      	ldr	r0, [sp, #4]
 8001b2a:	040b      	lsls	r3, r1, #16
 8001b2c:	0431      	lsls	r1, r6, #16
 8001b2e:	0c09      	lsrs	r1, r1, #16
 8001b30:	4319      	orrs	r1, r3
 8001b32:	4288      	cmp	r0, r1
 8001b34:	d90d      	bls.n	8001b52 <__aeabi_ddiv+0x38a>
 8001b36:	4653      	mov	r3, sl
 8001b38:	4441      	add	r1, r8
 8001b3a:	3b01      	subs	r3, #1
 8001b3c:	4588      	cmp	r8, r1
 8001b3e:	d900      	bls.n	8001b42 <__aeabi_ddiv+0x37a>
 8001b40:	e0e8      	b.n	8001d14 <__aeabi_ddiv+0x54c>
 8001b42:	4288      	cmp	r0, r1
 8001b44:	d800      	bhi.n	8001b48 <__aeabi_ddiv+0x380>
 8001b46:	e0e5      	b.n	8001d14 <__aeabi_ddiv+0x54c>
 8001b48:	2302      	movs	r3, #2
 8001b4a:	425b      	negs	r3, r3
 8001b4c:	469c      	mov	ip, r3
 8001b4e:	4441      	add	r1, r8
 8001b50:	44e2      	add	sl, ip
 8001b52:	9b01      	ldr	r3, [sp, #4]
 8001b54:	042d      	lsls	r5, r5, #16
 8001b56:	1ace      	subs	r6, r1, r3
 8001b58:	4651      	mov	r1, sl
 8001b5a:	4329      	orrs	r1, r5
 8001b5c:	9d05      	ldr	r5, [sp, #20]
 8001b5e:	464f      	mov	r7, r9
 8001b60:	002a      	movs	r2, r5
 8001b62:	040b      	lsls	r3, r1, #16
 8001b64:	0c08      	lsrs	r0, r1, #16
 8001b66:	0c1b      	lsrs	r3, r3, #16
 8001b68:	435a      	muls	r2, r3
 8001b6a:	4345      	muls	r5, r0
 8001b6c:	437b      	muls	r3, r7
 8001b6e:	4378      	muls	r0, r7
 8001b70:	195b      	adds	r3, r3, r5
 8001b72:	0c17      	lsrs	r7, r2, #16
 8001b74:	18fb      	adds	r3, r7, r3
 8001b76:	429d      	cmp	r5, r3
 8001b78:	d903      	bls.n	8001b82 <__aeabi_ddiv+0x3ba>
 8001b7a:	2580      	movs	r5, #128	; 0x80
 8001b7c:	026d      	lsls	r5, r5, #9
 8001b7e:	46ac      	mov	ip, r5
 8001b80:	4460      	add	r0, ip
 8001b82:	0c1d      	lsrs	r5, r3, #16
 8001b84:	0412      	lsls	r2, r2, #16
 8001b86:	041b      	lsls	r3, r3, #16
 8001b88:	0c12      	lsrs	r2, r2, #16
 8001b8a:	1828      	adds	r0, r5, r0
 8001b8c:	189b      	adds	r3, r3, r2
 8001b8e:	4286      	cmp	r6, r0
 8001b90:	d200      	bcs.n	8001b94 <__aeabi_ddiv+0x3cc>
 8001b92:	e093      	b.n	8001cbc <__aeabi_ddiv+0x4f4>
 8001b94:	d100      	bne.n	8001b98 <__aeabi_ddiv+0x3d0>
 8001b96:	e08e      	b.n	8001cb6 <__aeabi_ddiv+0x4ee>
 8001b98:	2301      	movs	r3, #1
 8001b9a:	4319      	orrs	r1, r3
 8001b9c:	4ba0      	ldr	r3, [pc, #640]	; (8001e20 <__aeabi_ddiv+0x658>)
 8001b9e:	18e3      	adds	r3, r4, r3
 8001ba0:	2b00      	cmp	r3, #0
 8001ba2:	dc00      	bgt.n	8001ba6 <__aeabi_ddiv+0x3de>
 8001ba4:	e099      	b.n	8001cda <__aeabi_ddiv+0x512>
 8001ba6:	074a      	lsls	r2, r1, #29
 8001ba8:	d000      	beq.n	8001bac <__aeabi_ddiv+0x3e4>
 8001baa:	e09e      	b.n	8001cea <__aeabi_ddiv+0x522>
 8001bac:	465a      	mov	r2, fp
 8001bae:	01d2      	lsls	r2, r2, #7
 8001bb0:	d506      	bpl.n	8001bc0 <__aeabi_ddiv+0x3f8>
 8001bb2:	465a      	mov	r2, fp
 8001bb4:	4b9b      	ldr	r3, [pc, #620]	; (8001e24 <__aeabi_ddiv+0x65c>)
 8001bb6:	401a      	ands	r2, r3
 8001bb8:	2380      	movs	r3, #128	; 0x80
 8001bba:	4693      	mov	fp, r2
 8001bbc:	00db      	lsls	r3, r3, #3
 8001bbe:	18e3      	adds	r3, r4, r3
 8001bc0:	4a99      	ldr	r2, [pc, #612]	; (8001e28 <__aeabi_ddiv+0x660>)
 8001bc2:	4293      	cmp	r3, r2
 8001bc4:	dd68      	ble.n	8001c98 <__aeabi_ddiv+0x4d0>
 8001bc6:	2301      	movs	r3, #1
 8001bc8:	9a02      	ldr	r2, [sp, #8]
 8001bca:	4c98      	ldr	r4, [pc, #608]	; (8001e2c <__aeabi_ddiv+0x664>)
 8001bcc:	401a      	ands	r2, r3
 8001bce:	2300      	movs	r3, #0
 8001bd0:	4694      	mov	ip, r2
 8001bd2:	4698      	mov	r8, r3
 8001bd4:	2200      	movs	r2, #0
 8001bd6:	e6c5      	b.n	8001964 <__aeabi_ddiv+0x19c>
 8001bd8:	2280      	movs	r2, #128	; 0x80
 8001bda:	464b      	mov	r3, r9
 8001bdc:	0312      	lsls	r2, r2, #12
 8001bde:	4213      	tst	r3, r2
 8001be0:	d00a      	beq.n	8001bf8 <__aeabi_ddiv+0x430>
 8001be2:	465b      	mov	r3, fp
 8001be4:	4213      	tst	r3, r2
 8001be6:	d106      	bne.n	8001bf6 <__aeabi_ddiv+0x42e>
 8001be8:	431a      	orrs	r2, r3
 8001bea:	0312      	lsls	r2, r2, #12
 8001bec:	0b12      	lsrs	r2, r2, #12
 8001bee:	46ac      	mov	ip, r5
 8001bf0:	4688      	mov	r8, r1
 8001bf2:	4c8e      	ldr	r4, [pc, #568]	; (8001e2c <__aeabi_ddiv+0x664>)
 8001bf4:	e6b6      	b.n	8001964 <__aeabi_ddiv+0x19c>
 8001bf6:	464b      	mov	r3, r9
 8001bf8:	431a      	orrs	r2, r3
 8001bfa:	0312      	lsls	r2, r2, #12
 8001bfc:	0b12      	lsrs	r2, r2, #12
 8001bfe:	46bc      	mov	ip, r7
 8001c00:	4c8a      	ldr	r4, [pc, #552]	; (8001e2c <__aeabi_ddiv+0x664>)
 8001c02:	e6af      	b.n	8001964 <__aeabi_ddiv+0x19c>
 8001c04:	0003      	movs	r3, r0
 8001c06:	465a      	mov	r2, fp
 8001c08:	3b28      	subs	r3, #40	; 0x28
 8001c0a:	409a      	lsls	r2, r3
 8001c0c:	2300      	movs	r3, #0
 8001c0e:	4691      	mov	r9, r2
 8001c10:	4698      	mov	r8, r3
 8001c12:	e657      	b.n	80018c4 <__aeabi_ddiv+0xfc>
 8001c14:	4658      	mov	r0, fp
 8001c16:	f000 fe31 	bl	800287c <__clzsi2>
 8001c1a:	3020      	adds	r0, #32
 8001c1c:	e640      	b.n	80018a0 <__aeabi_ddiv+0xd8>
 8001c1e:	0003      	movs	r3, r0
 8001c20:	4652      	mov	r2, sl
 8001c22:	3b28      	subs	r3, #40	; 0x28
 8001c24:	409a      	lsls	r2, r3
 8001c26:	2100      	movs	r1, #0
 8001c28:	4693      	mov	fp, r2
 8001c2a:	e677      	b.n	800191c <__aeabi_ddiv+0x154>
 8001c2c:	f000 fe26 	bl	800287c <__clzsi2>
 8001c30:	3020      	adds	r0, #32
 8001c32:	e65f      	b.n	80018f4 <__aeabi_ddiv+0x12c>
 8001c34:	4588      	cmp	r8, r1
 8001c36:	d200      	bcs.n	8001c3a <__aeabi_ddiv+0x472>
 8001c38:	e6c7      	b.n	80019ca <__aeabi_ddiv+0x202>
 8001c3a:	464b      	mov	r3, r9
 8001c3c:	07de      	lsls	r6, r3, #31
 8001c3e:	085d      	lsrs	r5, r3, #1
 8001c40:	4643      	mov	r3, r8
 8001c42:	085b      	lsrs	r3, r3, #1
 8001c44:	431e      	orrs	r6, r3
 8001c46:	4643      	mov	r3, r8
 8001c48:	07db      	lsls	r3, r3, #31
 8001c4a:	469a      	mov	sl, r3
 8001c4c:	e6c2      	b.n	80019d4 <__aeabi_ddiv+0x20c>
 8001c4e:	2500      	movs	r5, #0
 8001c50:	4592      	cmp	sl, r2
 8001c52:	d300      	bcc.n	8001c56 <__aeabi_ddiv+0x48e>
 8001c54:	e733      	b.n	8001abe <__aeabi_ddiv+0x2f6>
 8001c56:	9e03      	ldr	r6, [sp, #12]
 8001c58:	4659      	mov	r1, fp
 8001c5a:	46b4      	mov	ip, r6
 8001c5c:	44e2      	add	sl, ip
 8001c5e:	45b2      	cmp	sl, r6
 8001c60:	41ad      	sbcs	r5, r5
 8001c62:	426d      	negs	r5, r5
 8001c64:	4445      	add	r5, r8
 8001c66:	18eb      	adds	r3, r5, r3
 8001c68:	3901      	subs	r1, #1
 8001c6a:	4598      	cmp	r8, r3
 8001c6c:	d207      	bcs.n	8001c7e <__aeabi_ddiv+0x4b6>
 8001c6e:	4298      	cmp	r0, r3
 8001c70:	d900      	bls.n	8001c74 <__aeabi_ddiv+0x4ac>
 8001c72:	e07f      	b.n	8001d74 <__aeabi_ddiv+0x5ac>
 8001c74:	d100      	bne.n	8001c78 <__aeabi_ddiv+0x4b0>
 8001c76:	e0bc      	b.n	8001df2 <__aeabi_ddiv+0x62a>
 8001c78:	1a1d      	subs	r5, r3, r0
 8001c7a:	468b      	mov	fp, r1
 8001c7c:	e71f      	b.n	8001abe <__aeabi_ddiv+0x2f6>
 8001c7e:	4598      	cmp	r8, r3
 8001c80:	d1fa      	bne.n	8001c78 <__aeabi_ddiv+0x4b0>
 8001c82:	9d03      	ldr	r5, [sp, #12]
 8001c84:	4555      	cmp	r5, sl
 8001c86:	d9f2      	bls.n	8001c6e <__aeabi_ddiv+0x4a6>
 8001c88:	4643      	mov	r3, r8
 8001c8a:	468b      	mov	fp, r1
 8001c8c:	1a1d      	subs	r5, r3, r0
 8001c8e:	e716      	b.n	8001abe <__aeabi_ddiv+0x2f6>
 8001c90:	469b      	mov	fp, r3
 8001c92:	e6ca      	b.n	8001a2a <__aeabi_ddiv+0x262>
 8001c94:	0015      	movs	r5, r2
 8001c96:	e6e7      	b.n	8001a68 <__aeabi_ddiv+0x2a0>
 8001c98:	465a      	mov	r2, fp
 8001c9a:	08c9      	lsrs	r1, r1, #3
 8001c9c:	0752      	lsls	r2, r2, #29
 8001c9e:	430a      	orrs	r2, r1
 8001ca0:	055b      	lsls	r3, r3, #21
 8001ca2:	4690      	mov	r8, r2
 8001ca4:	0d5c      	lsrs	r4, r3, #21
 8001ca6:	465a      	mov	r2, fp
 8001ca8:	2301      	movs	r3, #1
 8001caa:	9902      	ldr	r1, [sp, #8]
 8001cac:	0252      	lsls	r2, r2, #9
 8001cae:	4019      	ands	r1, r3
 8001cb0:	0b12      	lsrs	r2, r2, #12
 8001cb2:	468c      	mov	ip, r1
 8001cb4:	e656      	b.n	8001964 <__aeabi_ddiv+0x19c>
 8001cb6:	2b00      	cmp	r3, #0
 8001cb8:	d100      	bne.n	8001cbc <__aeabi_ddiv+0x4f4>
 8001cba:	e76f      	b.n	8001b9c <__aeabi_ddiv+0x3d4>
 8001cbc:	4446      	add	r6, r8
 8001cbe:	1e4a      	subs	r2, r1, #1
 8001cc0:	45b0      	cmp	r8, r6
 8001cc2:	d929      	bls.n	8001d18 <__aeabi_ddiv+0x550>
 8001cc4:	0011      	movs	r1, r2
 8001cc6:	4286      	cmp	r6, r0
 8001cc8:	d000      	beq.n	8001ccc <__aeabi_ddiv+0x504>
 8001cca:	e765      	b.n	8001b98 <__aeabi_ddiv+0x3d0>
 8001ccc:	9a03      	ldr	r2, [sp, #12]
 8001cce:	4293      	cmp	r3, r2
 8001cd0:	d000      	beq.n	8001cd4 <__aeabi_ddiv+0x50c>
 8001cd2:	e761      	b.n	8001b98 <__aeabi_ddiv+0x3d0>
 8001cd4:	e762      	b.n	8001b9c <__aeabi_ddiv+0x3d4>
 8001cd6:	2101      	movs	r1, #1
 8001cd8:	4249      	negs	r1, r1
 8001cda:	2001      	movs	r0, #1
 8001cdc:	1ac2      	subs	r2, r0, r3
 8001cde:	2a38      	cmp	r2, #56	; 0x38
 8001ce0:	dd21      	ble.n	8001d26 <__aeabi_ddiv+0x55e>
 8001ce2:	9b02      	ldr	r3, [sp, #8]
 8001ce4:	4003      	ands	r3, r0
 8001ce6:	469c      	mov	ip, r3
 8001ce8:	e638      	b.n	800195c <__aeabi_ddiv+0x194>
 8001cea:	220f      	movs	r2, #15
 8001cec:	400a      	ands	r2, r1
 8001cee:	2a04      	cmp	r2, #4
 8001cf0:	d100      	bne.n	8001cf4 <__aeabi_ddiv+0x52c>
 8001cf2:	e75b      	b.n	8001bac <__aeabi_ddiv+0x3e4>
 8001cf4:	000a      	movs	r2, r1
 8001cf6:	1d11      	adds	r1, r2, #4
 8001cf8:	4291      	cmp	r1, r2
 8001cfa:	4192      	sbcs	r2, r2
 8001cfc:	4252      	negs	r2, r2
 8001cfe:	4493      	add	fp, r2
 8001d00:	e754      	b.n	8001bac <__aeabi_ddiv+0x3e4>
 8001d02:	4b47      	ldr	r3, [pc, #284]	; (8001e20 <__aeabi_ddiv+0x658>)
 8001d04:	18e3      	adds	r3, r4, r3
 8001d06:	2b00      	cmp	r3, #0
 8001d08:	dde5      	ble.n	8001cd6 <__aeabi_ddiv+0x50e>
 8001d0a:	2201      	movs	r2, #1
 8001d0c:	4252      	negs	r2, r2
 8001d0e:	e7f2      	b.n	8001cf6 <__aeabi_ddiv+0x52e>
 8001d10:	001d      	movs	r5, r3
 8001d12:	e6fa      	b.n	8001b0a <__aeabi_ddiv+0x342>
 8001d14:	469a      	mov	sl, r3
 8001d16:	e71c      	b.n	8001b52 <__aeabi_ddiv+0x38a>
 8001d18:	42b0      	cmp	r0, r6
 8001d1a:	d839      	bhi.n	8001d90 <__aeabi_ddiv+0x5c8>
 8001d1c:	d06e      	beq.n	8001dfc <__aeabi_ddiv+0x634>
 8001d1e:	0011      	movs	r1, r2
 8001d20:	e73a      	b.n	8001b98 <__aeabi_ddiv+0x3d0>
 8001d22:	9302      	str	r3, [sp, #8]
 8001d24:	e73a      	b.n	8001b9c <__aeabi_ddiv+0x3d4>
 8001d26:	2a1f      	cmp	r2, #31
 8001d28:	dc3c      	bgt.n	8001da4 <__aeabi_ddiv+0x5dc>
 8001d2a:	2320      	movs	r3, #32
 8001d2c:	1a9b      	subs	r3, r3, r2
 8001d2e:	000c      	movs	r4, r1
 8001d30:	4658      	mov	r0, fp
 8001d32:	4099      	lsls	r1, r3
 8001d34:	4098      	lsls	r0, r3
 8001d36:	1e4b      	subs	r3, r1, #1
 8001d38:	4199      	sbcs	r1, r3
 8001d3a:	465b      	mov	r3, fp
 8001d3c:	40d4      	lsrs	r4, r2
 8001d3e:	40d3      	lsrs	r3, r2
 8001d40:	4320      	orrs	r0, r4
 8001d42:	4308      	orrs	r0, r1
 8001d44:	001a      	movs	r2, r3
 8001d46:	0743      	lsls	r3, r0, #29
 8001d48:	d009      	beq.n	8001d5e <__aeabi_ddiv+0x596>
 8001d4a:	230f      	movs	r3, #15
 8001d4c:	4003      	ands	r3, r0
 8001d4e:	2b04      	cmp	r3, #4
 8001d50:	d005      	beq.n	8001d5e <__aeabi_ddiv+0x596>
 8001d52:	0001      	movs	r1, r0
 8001d54:	1d08      	adds	r0, r1, #4
 8001d56:	4288      	cmp	r0, r1
 8001d58:	419b      	sbcs	r3, r3
 8001d5a:	425b      	negs	r3, r3
 8001d5c:	18d2      	adds	r2, r2, r3
 8001d5e:	0213      	lsls	r3, r2, #8
 8001d60:	d53a      	bpl.n	8001dd8 <__aeabi_ddiv+0x610>
 8001d62:	2301      	movs	r3, #1
 8001d64:	9a02      	ldr	r2, [sp, #8]
 8001d66:	2401      	movs	r4, #1
 8001d68:	401a      	ands	r2, r3
 8001d6a:	2300      	movs	r3, #0
 8001d6c:	4694      	mov	ip, r2
 8001d6e:	4698      	mov	r8, r3
 8001d70:	2200      	movs	r2, #0
 8001d72:	e5f7      	b.n	8001964 <__aeabi_ddiv+0x19c>
 8001d74:	2102      	movs	r1, #2
 8001d76:	4249      	negs	r1, r1
 8001d78:	468c      	mov	ip, r1
 8001d7a:	9d03      	ldr	r5, [sp, #12]
 8001d7c:	44e3      	add	fp, ip
 8001d7e:	46ac      	mov	ip, r5
 8001d80:	44e2      	add	sl, ip
 8001d82:	45aa      	cmp	sl, r5
 8001d84:	41ad      	sbcs	r5, r5
 8001d86:	426d      	negs	r5, r5
 8001d88:	4445      	add	r5, r8
 8001d8a:	18ed      	adds	r5, r5, r3
 8001d8c:	1a2d      	subs	r5, r5, r0
 8001d8e:	e696      	b.n	8001abe <__aeabi_ddiv+0x2f6>
 8001d90:	1e8a      	subs	r2, r1, #2
 8001d92:	9903      	ldr	r1, [sp, #12]
 8001d94:	004d      	lsls	r5, r1, #1
 8001d96:	428d      	cmp	r5, r1
 8001d98:	4189      	sbcs	r1, r1
 8001d9a:	4249      	negs	r1, r1
 8001d9c:	4441      	add	r1, r8
 8001d9e:	1876      	adds	r6, r6, r1
 8001da0:	9503      	str	r5, [sp, #12]
 8001da2:	e78f      	b.n	8001cc4 <__aeabi_ddiv+0x4fc>
 8001da4:	201f      	movs	r0, #31
 8001da6:	4240      	negs	r0, r0
 8001da8:	1ac3      	subs	r3, r0, r3
 8001daa:	4658      	mov	r0, fp
 8001dac:	40d8      	lsrs	r0, r3
 8001dae:	0003      	movs	r3, r0
 8001db0:	2a20      	cmp	r2, #32
 8001db2:	d028      	beq.n	8001e06 <__aeabi_ddiv+0x63e>
 8001db4:	2040      	movs	r0, #64	; 0x40
 8001db6:	465d      	mov	r5, fp
 8001db8:	1a82      	subs	r2, r0, r2
 8001dba:	4095      	lsls	r5, r2
 8001dbc:	4329      	orrs	r1, r5
 8001dbe:	1e4a      	subs	r2, r1, #1
 8001dc0:	4191      	sbcs	r1, r2
 8001dc2:	4319      	orrs	r1, r3
 8001dc4:	2307      	movs	r3, #7
 8001dc6:	2200      	movs	r2, #0
 8001dc8:	400b      	ands	r3, r1
 8001dca:	d009      	beq.n	8001de0 <__aeabi_ddiv+0x618>
 8001dcc:	230f      	movs	r3, #15
 8001dce:	2200      	movs	r2, #0
 8001dd0:	400b      	ands	r3, r1
 8001dd2:	0008      	movs	r0, r1
 8001dd4:	2b04      	cmp	r3, #4
 8001dd6:	d1bd      	bne.n	8001d54 <__aeabi_ddiv+0x58c>
 8001dd8:	0001      	movs	r1, r0
 8001dda:	0753      	lsls	r3, r2, #29
 8001ddc:	0252      	lsls	r2, r2, #9
 8001dde:	0b12      	lsrs	r2, r2, #12
 8001de0:	08c9      	lsrs	r1, r1, #3
 8001de2:	4319      	orrs	r1, r3
 8001de4:	2301      	movs	r3, #1
 8001de6:	4688      	mov	r8, r1
 8001de8:	9902      	ldr	r1, [sp, #8]
 8001dea:	2400      	movs	r4, #0
 8001dec:	4019      	ands	r1, r3
 8001dee:	468c      	mov	ip, r1
 8001df0:	e5b8      	b.n	8001964 <__aeabi_ddiv+0x19c>
 8001df2:	4552      	cmp	r2, sl
 8001df4:	d8be      	bhi.n	8001d74 <__aeabi_ddiv+0x5ac>
 8001df6:	468b      	mov	fp, r1
 8001df8:	2500      	movs	r5, #0
 8001dfa:	e660      	b.n	8001abe <__aeabi_ddiv+0x2f6>
 8001dfc:	9d03      	ldr	r5, [sp, #12]
 8001dfe:	429d      	cmp	r5, r3
 8001e00:	d3c6      	bcc.n	8001d90 <__aeabi_ddiv+0x5c8>
 8001e02:	0011      	movs	r1, r2
 8001e04:	e762      	b.n	8001ccc <__aeabi_ddiv+0x504>
 8001e06:	2500      	movs	r5, #0
 8001e08:	e7d8      	b.n	8001dbc <__aeabi_ddiv+0x5f4>
 8001e0a:	2280      	movs	r2, #128	; 0x80
 8001e0c:	465b      	mov	r3, fp
 8001e0e:	0312      	lsls	r2, r2, #12
 8001e10:	431a      	orrs	r2, r3
 8001e12:	9b01      	ldr	r3, [sp, #4]
 8001e14:	0312      	lsls	r2, r2, #12
 8001e16:	0b12      	lsrs	r2, r2, #12
 8001e18:	469c      	mov	ip, r3
 8001e1a:	4688      	mov	r8, r1
 8001e1c:	4c03      	ldr	r4, [pc, #12]	; (8001e2c <__aeabi_ddiv+0x664>)
 8001e1e:	e5a1      	b.n	8001964 <__aeabi_ddiv+0x19c>
 8001e20:	000003ff 	.word	0x000003ff
 8001e24:	feffffff 	.word	0xfeffffff
 8001e28:	000007fe 	.word	0x000007fe
 8001e2c:	000007ff 	.word	0x000007ff

08001e30 <__eqdf2>:
 8001e30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001e32:	464f      	mov	r7, r9
 8001e34:	4646      	mov	r6, r8
 8001e36:	46d6      	mov	lr, sl
 8001e38:	005c      	lsls	r4, r3, #1
 8001e3a:	b5c0      	push	{r6, r7, lr}
 8001e3c:	031f      	lsls	r7, r3, #12
 8001e3e:	0fdb      	lsrs	r3, r3, #31
 8001e40:	469a      	mov	sl, r3
 8001e42:	4b17      	ldr	r3, [pc, #92]	; (8001ea0 <__eqdf2+0x70>)
 8001e44:	030e      	lsls	r6, r1, #12
 8001e46:	004d      	lsls	r5, r1, #1
 8001e48:	4684      	mov	ip, r0
 8001e4a:	4680      	mov	r8, r0
 8001e4c:	0b36      	lsrs	r6, r6, #12
 8001e4e:	0d6d      	lsrs	r5, r5, #21
 8001e50:	0fc9      	lsrs	r1, r1, #31
 8001e52:	4691      	mov	r9, r2
 8001e54:	0b3f      	lsrs	r7, r7, #12
 8001e56:	0d64      	lsrs	r4, r4, #21
 8001e58:	2001      	movs	r0, #1
 8001e5a:	429d      	cmp	r5, r3
 8001e5c:	d008      	beq.n	8001e70 <__eqdf2+0x40>
 8001e5e:	429c      	cmp	r4, r3
 8001e60:	d001      	beq.n	8001e66 <__eqdf2+0x36>
 8001e62:	42a5      	cmp	r5, r4
 8001e64:	d00b      	beq.n	8001e7e <__eqdf2+0x4e>
 8001e66:	bc1c      	pop	{r2, r3, r4}
 8001e68:	4690      	mov	r8, r2
 8001e6a:	4699      	mov	r9, r3
 8001e6c:	46a2      	mov	sl, r4
 8001e6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001e70:	4663      	mov	r3, ip
 8001e72:	4333      	orrs	r3, r6
 8001e74:	d1f7      	bne.n	8001e66 <__eqdf2+0x36>
 8001e76:	42ac      	cmp	r4, r5
 8001e78:	d1f5      	bne.n	8001e66 <__eqdf2+0x36>
 8001e7a:	433a      	orrs	r2, r7
 8001e7c:	d1f3      	bne.n	8001e66 <__eqdf2+0x36>
 8001e7e:	2001      	movs	r0, #1
 8001e80:	42be      	cmp	r6, r7
 8001e82:	d1f0      	bne.n	8001e66 <__eqdf2+0x36>
 8001e84:	45c8      	cmp	r8, r9
 8001e86:	d1ee      	bne.n	8001e66 <__eqdf2+0x36>
 8001e88:	4551      	cmp	r1, sl
 8001e8a:	d007      	beq.n	8001e9c <__eqdf2+0x6c>
 8001e8c:	2d00      	cmp	r5, #0
 8001e8e:	d1ea      	bne.n	8001e66 <__eqdf2+0x36>
 8001e90:	4663      	mov	r3, ip
 8001e92:	431e      	orrs	r6, r3
 8001e94:	0030      	movs	r0, r6
 8001e96:	1e46      	subs	r6, r0, #1
 8001e98:	41b0      	sbcs	r0, r6
 8001e9a:	e7e4      	b.n	8001e66 <__eqdf2+0x36>
 8001e9c:	2000      	movs	r0, #0
 8001e9e:	e7e2      	b.n	8001e66 <__eqdf2+0x36>
 8001ea0:	000007ff 	.word	0x000007ff

08001ea4 <__gedf2>:
 8001ea4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001ea6:	4645      	mov	r5, r8
 8001ea8:	46de      	mov	lr, fp
 8001eaa:	4657      	mov	r7, sl
 8001eac:	464e      	mov	r6, r9
 8001eae:	b5e0      	push	{r5, r6, r7, lr}
 8001eb0:	031f      	lsls	r7, r3, #12
 8001eb2:	0b3d      	lsrs	r5, r7, #12
 8001eb4:	4f2c      	ldr	r7, [pc, #176]	; (8001f68 <__gedf2+0xc4>)
 8001eb6:	030e      	lsls	r6, r1, #12
 8001eb8:	004c      	lsls	r4, r1, #1
 8001eba:	46ab      	mov	fp, r5
 8001ebc:	005d      	lsls	r5, r3, #1
 8001ebe:	4684      	mov	ip, r0
 8001ec0:	0b36      	lsrs	r6, r6, #12
 8001ec2:	0d64      	lsrs	r4, r4, #21
 8001ec4:	0fc9      	lsrs	r1, r1, #31
 8001ec6:	4690      	mov	r8, r2
 8001ec8:	0d6d      	lsrs	r5, r5, #21
 8001eca:	0fdb      	lsrs	r3, r3, #31
 8001ecc:	42bc      	cmp	r4, r7
 8001ece:	d02a      	beq.n	8001f26 <__gedf2+0x82>
 8001ed0:	4f25      	ldr	r7, [pc, #148]	; (8001f68 <__gedf2+0xc4>)
 8001ed2:	42bd      	cmp	r5, r7
 8001ed4:	d02d      	beq.n	8001f32 <__gedf2+0x8e>
 8001ed6:	2c00      	cmp	r4, #0
 8001ed8:	d10f      	bne.n	8001efa <__gedf2+0x56>
 8001eda:	4330      	orrs	r0, r6
 8001edc:	0007      	movs	r7, r0
 8001ede:	4681      	mov	r9, r0
 8001ee0:	4278      	negs	r0, r7
 8001ee2:	4178      	adcs	r0, r7
 8001ee4:	b2c0      	uxtb	r0, r0
 8001ee6:	2d00      	cmp	r5, #0
 8001ee8:	d117      	bne.n	8001f1a <__gedf2+0x76>
 8001eea:	465f      	mov	r7, fp
 8001eec:	433a      	orrs	r2, r7
 8001eee:	d114      	bne.n	8001f1a <__gedf2+0x76>
 8001ef0:	464b      	mov	r3, r9
 8001ef2:	2000      	movs	r0, #0
 8001ef4:	2b00      	cmp	r3, #0
 8001ef6:	d00a      	beq.n	8001f0e <__gedf2+0x6a>
 8001ef8:	e006      	b.n	8001f08 <__gedf2+0x64>
 8001efa:	2d00      	cmp	r5, #0
 8001efc:	d102      	bne.n	8001f04 <__gedf2+0x60>
 8001efe:	4658      	mov	r0, fp
 8001f00:	4302      	orrs	r2, r0
 8001f02:	d001      	beq.n	8001f08 <__gedf2+0x64>
 8001f04:	4299      	cmp	r1, r3
 8001f06:	d018      	beq.n	8001f3a <__gedf2+0x96>
 8001f08:	4248      	negs	r0, r1
 8001f0a:	2101      	movs	r1, #1
 8001f0c:	4308      	orrs	r0, r1
 8001f0e:	bc3c      	pop	{r2, r3, r4, r5}
 8001f10:	4690      	mov	r8, r2
 8001f12:	4699      	mov	r9, r3
 8001f14:	46a2      	mov	sl, r4
 8001f16:	46ab      	mov	fp, r5
 8001f18:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001f1a:	2800      	cmp	r0, #0
 8001f1c:	d0f2      	beq.n	8001f04 <__gedf2+0x60>
 8001f1e:	2001      	movs	r0, #1
 8001f20:	3b01      	subs	r3, #1
 8001f22:	4318      	orrs	r0, r3
 8001f24:	e7f3      	b.n	8001f0e <__gedf2+0x6a>
 8001f26:	0037      	movs	r7, r6
 8001f28:	4307      	orrs	r7, r0
 8001f2a:	d0d1      	beq.n	8001ed0 <__gedf2+0x2c>
 8001f2c:	2002      	movs	r0, #2
 8001f2e:	4240      	negs	r0, r0
 8001f30:	e7ed      	b.n	8001f0e <__gedf2+0x6a>
 8001f32:	465f      	mov	r7, fp
 8001f34:	4317      	orrs	r7, r2
 8001f36:	d0ce      	beq.n	8001ed6 <__gedf2+0x32>
 8001f38:	e7f8      	b.n	8001f2c <__gedf2+0x88>
 8001f3a:	42ac      	cmp	r4, r5
 8001f3c:	dce4      	bgt.n	8001f08 <__gedf2+0x64>
 8001f3e:	da03      	bge.n	8001f48 <__gedf2+0xa4>
 8001f40:	1e48      	subs	r0, r1, #1
 8001f42:	2101      	movs	r1, #1
 8001f44:	4308      	orrs	r0, r1
 8001f46:	e7e2      	b.n	8001f0e <__gedf2+0x6a>
 8001f48:	455e      	cmp	r6, fp
 8001f4a:	d8dd      	bhi.n	8001f08 <__gedf2+0x64>
 8001f4c:	d006      	beq.n	8001f5c <__gedf2+0xb8>
 8001f4e:	2000      	movs	r0, #0
 8001f50:	455e      	cmp	r6, fp
 8001f52:	d2dc      	bcs.n	8001f0e <__gedf2+0x6a>
 8001f54:	2301      	movs	r3, #1
 8001f56:	1e48      	subs	r0, r1, #1
 8001f58:	4318      	orrs	r0, r3
 8001f5a:	e7d8      	b.n	8001f0e <__gedf2+0x6a>
 8001f5c:	45c4      	cmp	ip, r8
 8001f5e:	d8d3      	bhi.n	8001f08 <__gedf2+0x64>
 8001f60:	2000      	movs	r0, #0
 8001f62:	45c4      	cmp	ip, r8
 8001f64:	d3f6      	bcc.n	8001f54 <__gedf2+0xb0>
 8001f66:	e7d2      	b.n	8001f0e <__gedf2+0x6a>
 8001f68:	000007ff 	.word	0x000007ff

08001f6c <__ledf2>:
 8001f6c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001f6e:	464e      	mov	r6, r9
 8001f70:	4645      	mov	r5, r8
 8001f72:	46de      	mov	lr, fp
 8001f74:	4657      	mov	r7, sl
 8001f76:	005c      	lsls	r4, r3, #1
 8001f78:	b5e0      	push	{r5, r6, r7, lr}
 8001f7a:	031f      	lsls	r7, r3, #12
 8001f7c:	0fdb      	lsrs	r3, r3, #31
 8001f7e:	4699      	mov	r9, r3
 8001f80:	4b2a      	ldr	r3, [pc, #168]	; (800202c <__ledf2+0xc0>)
 8001f82:	030e      	lsls	r6, r1, #12
 8001f84:	004d      	lsls	r5, r1, #1
 8001f86:	0fc9      	lsrs	r1, r1, #31
 8001f88:	4684      	mov	ip, r0
 8001f8a:	0b36      	lsrs	r6, r6, #12
 8001f8c:	0d6d      	lsrs	r5, r5, #21
 8001f8e:	468b      	mov	fp, r1
 8001f90:	4690      	mov	r8, r2
 8001f92:	0b3f      	lsrs	r7, r7, #12
 8001f94:	0d64      	lsrs	r4, r4, #21
 8001f96:	429d      	cmp	r5, r3
 8001f98:	d020      	beq.n	8001fdc <__ledf2+0x70>
 8001f9a:	4b24      	ldr	r3, [pc, #144]	; (800202c <__ledf2+0xc0>)
 8001f9c:	429c      	cmp	r4, r3
 8001f9e:	d022      	beq.n	8001fe6 <__ledf2+0x7a>
 8001fa0:	2d00      	cmp	r5, #0
 8001fa2:	d112      	bne.n	8001fca <__ledf2+0x5e>
 8001fa4:	4330      	orrs	r0, r6
 8001fa6:	4243      	negs	r3, r0
 8001fa8:	4143      	adcs	r3, r0
 8001faa:	b2db      	uxtb	r3, r3
 8001fac:	2c00      	cmp	r4, #0
 8001fae:	d01f      	beq.n	8001ff0 <__ledf2+0x84>
 8001fb0:	2b00      	cmp	r3, #0
 8001fb2:	d00c      	beq.n	8001fce <__ledf2+0x62>
 8001fb4:	464b      	mov	r3, r9
 8001fb6:	2001      	movs	r0, #1
 8001fb8:	3b01      	subs	r3, #1
 8001fba:	4303      	orrs	r3, r0
 8001fbc:	0018      	movs	r0, r3
 8001fbe:	bc3c      	pop	{r2, r3, r4, r5}
 8001fc0:	4690      	mov	r8, r2
 8001fc2:	4699      	mov	r9, r3
 8001fc4:	46a2      	mov	sl, r4
 8001fc6:	46ab      	mov	fp, r5
 8001fc8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001fca:	2c00      	cmp	r4, #0
 8001fcc:	d016      	beq.n	8001ffc <__ledf2+0x90>
 8001fce:	45cb      	cmp	fp, r9
 8001fd0:	d017      	beq.n	8002002 <__ledf2+0x96>
 8001fd2:	465b      	mov	r3, fp
 8001fd4:	4259      	negs	r1, r3
 8001fd6:	2301      	movs	r3, #1
 8001fd8:	430b      	orrs	r3, r1
 8001fda:	e7ef      	b.n	8001fbc <__ledf2+0x50>
 8001fdc:	0031      	movs	r1, r6
 8001fde:	2302      	movs	r3, #2
 8001fe0:	4301      	orrs	r1, r0
 8001fe2:	d1eb      	bne.n	8001fbc <__ledf2+0x50>
 8001fe4:	e7d9      	b.n	8001f9a <__ledf2+0x2e>
 8001fe6:	0039      	movs	r1, r7
 8001fe8:	2302      	movs	r3, #2
 8001fea:	4311      	orrs	r1, r2
 8001fec:	d1e6      	bne.n	8001fbc <__ledf2+0x50>
 8001fee:	e7d7      	b.n	8001fa0 <__ledf2+0x34>
 8001ff0:	433a      	orrs	r2, r7
 8001ff2:	d1dd      	bne.n	8001fb0 <__ledf2+0x44>
 8001ff4:	2300      	movs	r3, #0
 8001ff6:	2800      	cmp	r0, #0
 8001ff8:	d0e0      	beq.n	8001fbc <__ledf2+0x50>
 8001ffa:	e7ea      	b.n	8001fd2 <__ledf2+0x66>
 8001ffc:	433a      	orrs	r2, r7
 8001ffe:	d1e6      	bne.n	8001fce <__ledf2+0x62>
 8002000:	e7e7      	b.n	8001fd2 <__ledf2+0x66>
 8002002:	42a5      	cmp	r5, r4
 8002004:	dce5      	bgt.n	8001fd2 <__ledf2+0x66>
 8002006:	db05      	blt.n	8002014 <__ledf2+0xa8>
 8002008:	42be      	cmp	r6, r7
 800200a:	d8e2      	bhi.n	8001fd2 <__ledf2+0x66>
 800200c:	d007      	beq.n	800201e <__ledf2+0xb2>
 800200e:	2300      	movs	r3, #0
 8002010:	42be      	cmp	r6, r7
 8002012:	d2d3      	bcs.n	8001fbc <__ledf2+0x50>
 8002014:	4659      	mov	r1, fp
 8002016:	2301      	movs	r3, #1
 8002018:	3901      	subs	r1, #1
 800201a:	430b      	orrs	r3, r1
 800201c:	e7ce      	b.n	8001fbc <__ledf2+0x50>
 800201e:	45c4      	cmp	ip, r8
 8002020:	d8d7      	bhi.n	8001fd2 <__ledf2+0x66>
 8002022:	2300      	movs	r3, #0
 8002024:	45c4      	cmp	ip, r8
 8002026:	d3f5      	bcc.n	8002014 <__ledf2+0xa8>
 8002028:	e7c8      	b.n	8001fbc <__ledf2+0x50>
 800202a:	46c0      	nop			; (mov r8, r8)
 800202c:	000007ff 	.word	0x000007ff

08002030 <__aeabi_dsub>:
 8002030:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002032:	4646      	mov	r6, r8
 8002034:	46d6      	mov	lr, sl
 8002036:	464f      	mov	r7, r9
 8002038:	030c      	lsls	r4, r1, #12
 800203a:	b5c0      	push	{r6, r7, lr}
 800203c:	0fcd      	lsrs	r5, r1, #31
 800203e:	004e      	lsls	r6, r1, #1
 8002040:	0a61      	lsrs	r1, r4, #9
 8002042:	0f44      	lsrs	r4, r0, #29
 8002044:	430c      	orrs	r4, r1
 8002046:	00c1      	lsls	r1, r0, #3
 8002048:	0058      	lsls	r0, r3, #1
 800204a:	0d40      	lsrs	r0, r0, #21
 800204c:	4684      	mov	ip, r0
 800204e:	468a      	mov	sl, r1
 8002050:	000f      	movs	r7, r1
 8002052:	0319      	lsls	r1, r3, #12
 8002054:	0f50      	lsrs	r0, r2, #29
 8002056:	0a49      	lsrs	r1, r1, #9
 8002058:	4301      	orrs	r1, r0
 800205a:	48c6      	ldr	r0, [pc, #792]	; (8002374 <__aeabi_dsub+0x344>)
 800205c:	0d76      	lsrs	r6, r6, #21
 800205e:	46a8      	mov	r8, r5
 8002060:	0fdb      	lsrs	r3, r3, #31
 8002062:	00d2      	lsls	r2, r2, #3
 8002064:	4584      	cmp	ip, r0
 8002066:	d100      	bne.n	800206a <__aeabi_dsub+0x3a>
 8002068:	e0d8      	b.n	800221c <__aeabi_dsub+0x1ec>
 800206a:	2001      	movs	r0, #1
 800206c:	4043      	eors	r3, r0
 800206e:	42ab      	cmp	r3, r5
 8002070:	d100      	bne.n	8002074 <__aeabi_dsub+0x44>
 8002072:	e0a6      	b.n	80021c2 <__aeabi_dsub+0x192>
 8002074:	4660      	mov	r0, ip
 8002076:	1a35      	subs	r5, r6, r0
 8002078:	2d00      	cmp	r5, #0
 800207a:	dc00      	bgt.n	800207e <__aeabi_dsub+0x4e>
 800207c:	e105      	b.n	800228a <__aeabi_dsub+0x25a>
 800207e:	2800      	cmp	r0, #0
 8002080:	d110      	bne.n	80020a4 <__aeabi_dsub+0x74>
 8002082:	000b      	movs	r3, r1
 8002084:	4313      	orrs	r3, r2
 8002086:	d100      	bne.n	800208a <__aeabi_dsub+0x5a>
 8002088:	e0d7      	b.n	800223a <__aeabi_dsub+0x20a>
 800208a:	1e6b      	subs	r3, r5, #1
 800208c:	2b00      	cmp	r3, #0
 800208e:	d000      	beq.n	8002092 <__aeabi_dsub+0x62>
 8002090:	e14b      	b.n	800232a <__aeabi_dsub+0x2fa>
 8002092:	4653      	mov	r3, sl
 8002094:	1a9f      	subs	r7, r3, r2
 8002096:	45ba      	cmp	sl, r7
 8002098:	4180      	sbcs	r0, r0
 800209a:	1a64      	subs	r4, r4, r1
 800209c:	4240      	negs	r0, r0
 800209e:	1a24      	subs	r4, r4, r0
 80020a0:	2601      	movs	r6, #1
 80020a2:	e01e      	b.n	80020e2 <__aeabi_dsub+0xb2>
 80020a4:	4bb3      	ldr	r3, [pc, #716]	; (8002374 <__aeabi_dsub+0x344>)
 80020a6:	429e      	cmp	r6, r3
 80020a8:	d048      	beq.n	800213c <__aeabi_dsub+0x10c>
 80020aa:	2380      	movs	r3, #128	; 0x80
 80020ac:	041b      	lsls	r3, r3, #16
 80020ae:	4319      	orrs	r1, r3
 80020b0:	2d38      	cmp	r5, #56	; 0x38
 80020b2:	dd00      	ble.n	80020b6 <__aeabi_dsub+0x86>
 80020b4:	e119      	b.n	80022ea <__aeabi_dsub+0x2ba>
 80020b6:	2d1f      	cmp	r5, #31
 80020b8:	dd00      	ble.n	80020bc <__aeabi_dsub+0x8c>
 80020ba:	e14c      	b.n	8002356 <__aeabi_dsub+0x326>
 80020bc:	2320      	movs	r3, #32
 80020be:	000f      	movs	r7, r1
 80020c0:	1b5b      	subs	r3, r3, r5
 80020c2:	0010      	movs	r0, r2
 80020c4:	409a      	lsls	r2, r3
 80020c6:	409f      	lsls	r7, r3
 80020c8:	40e8      	lsrs	r0, r5
 80020ca:	1e53      	subs	r3, r2, #1
 80020cc:	419a      	sbcs	r2, r3
 80020ce:	40e9      	lsrs	r1, r5
 80020d0:	4307      	orrs	r7, r0
 80020d2:	4317      	orrs	r7, r2
 80020d4:	4653      	mov	r3, sl
 80020d6:	1bdf      	subs	r7, r3, r7
 80020d8:	1a61      	subs	r1, r4, r1
 80020da:	45ba      	cmp	sl, r7
 80020dc:	41a4      	sbcs	r4, r4
 80020de:	4264      	negs	r4, r4
 80020e0:	1b0c      	subs	r4, r1, r4
 80020e2:	0223      	lsls	r3, r4, #8
 80020e4:	d400      	bmi.n	80020e8 <__aeabi_dsub+0xb8>
 80020e6:	e0c5      	b.n	8002274 <__aeabi_dsub+0x244>
 80020e8:	0264      	lsls	r4, r4, #9
 80020ea:	0a65      	lsrs	r5, r4, #9
 80020ec:	2d00      	cmp	r5, #0
 80020ee:	d100      	bne.n	80020f2 <__aeabi_dsub+0xc2>
 80020f0:	e0f6      	b.n	80022e0 <__aeabi_dsub+0x2b0>
 80020f2:	0028      	movs	r0, r5
 80020f4:	f000 fbc2 	bl	800287c <__clzsi2>
 80020f8:	0003      	movs	r3, r0
 80020fa:	3b08      	subs	r3, #8
 80020fc:	2b1f      	cmp	r3, #31
 80020fe:	dd00      	ble.n	8002102 <__aeabi_dsub+0xd2>
 8002100:	e0e9      	b.n	80022d6 <__aeabi_dsub+0x2a6>
 8002102:	2220      	movs	r2, #32
 8002104:	003c      	movs	r4, r7
 8002106:	1ad2      	subs	r2, r2, r3
 8002108:	409d      	lsls	r5, r3
 800210a:	40d4      	lsrs	r4, r2
 800210c:	409f      	lsls	r7, r3
 800210e:	4325      	orrs	r5, r4
 8002110:	429e      	cmp	r6, r3
 8002112:	dd00      	ble.n	8002116 <__aeabi_dsub+0xe6>
 8002114:	e0db      	b.n	80022ce <__aeabi_dsub+0x29e>
 8002116:	1b9e      	subs	r6, r3, r6
 8002118:	1c73      	adds	r3, r6, #1
 800211a:	2b1f      	cmp	r3, #31
 800211c:	dd00      	ble.n	8002120 <__aeabi_dsub+0xf0>
 800211e:	e10a      	b.n	8002336 <__aeabi_dsub+0x306>
 8002120:	2220      	movs	r2, #32
 8002122:	0038      	movs	r0, r7
 8002124:	1ad2      	subs	r2, r2, r3
 8002126:	0029      	movs	r1, r5
 8002128:	4097      	lsls	r7, r2
 800212a:	002c      	movs	r4, r5
 800212c:	4091      	lsls	r1, r2
 800212e:	40d8      	lsrs	r0, r3
 8002130:	1e7a      	subs	r2, r7, #1
 8002132:	4197      	sbcs	r7, r2
 8002134:	40dc      	lsrs	r4, r3
 8002136:	2600      	movs	r6, #0
 8002138:	4301      	orrs	r1, r0
 800213a:	430f      	orrs	r7, r1
 800213c:	077b      	lsls	r3, r7, #29
 800213e:	d009      	beq.n	8002154 <__aeabi_dsub+0x124>
 8002140:	230f      	movs	r3, #15
 8002142:	403b      	ands	r3, r7
 8002144:	2b04      	cmp	r3, #4
 8002146:	d005      	beq.n	8002154 <__aeabi_dsub+0x124>
 8002148:	1d3b      	adds	r3, r7, #4
 800214a:	42bb      	cmp	r3, r7
 800214c:	41bf      	sbcs	r7, r7
 800214e:	427f      	negs	r7, r7
 8002150:	19e4      	adds	r4, r4, r7
 8002152:	001f      	movs	r7, r3
 8002154:	0223      	lsls	r3, r4, #8
 8002156:	d525      	bpl.n	80021a4 <__aeabi_dsub+0x174>
 8002158:	4b86      	ldr	r3, [pc, #536]	; (8002374 <__aeabi_dsub+0x344>)
 800215a:	3601      	adds	r6, #1
 800215c:	429e      	cmp	r6, r3
 800215e:	d100      	bne.n	8002162 <__aeabi_dsub+0x132>
 8002160:	e0af      	b.n	80022c2 <__aeabi_dsub+0x292>
 8002162:	4b85      	ldr	r3, [pc, #532]	; (8002378 <__aeabi_dsub+0x348>)
 8002164:	2501      	movs	r5, #1
 8002166:	401c      	ands	r4, r3
 8002168:	4643      	mov	r3, r8
 800216a:	0762      	lsls	r2, r4, #29
 800216c:	08ff      	lsrs	r7, r7, #3
 800216e:	0264      	lsls	r4, r4, #9
 8002170:	0576      	lsls	r6, r6, #21
 8002172:	4317      	orrs	r7, r2
 8002174:	0b24      	lsrs	r4, r4, #12
 8002176:	0d76      	lsrs	r6, r6, #21
 8002178:	401d      	ands	r5, r3
 800217a:	2100      	movs	r1, #0
 800217c:	0324      	lsls	r4, r4, #12
 800217e:	0b23      	lsrs	r3, r4, #12
 8002180:	0d0c      	lsrs	r4, r1, #20
 8002182:	4a7e      	ldr	r2, [pc, #504]	; (800237c <__aeabi_dsub+0x34c>)
 8002184:	0524      	lsls	r4, r4, #20
 8002186:	431c      	orrs	r4, r3
 8002188:	4014      	ands	r4, r2
 800218a:	0533      	lsls	r3, r6, #20
 800218c:	4323      	orrs	r3, r4
 800218e:	005b      	lsls	r3, r3, #1
 8002190:	07ed      	lsls	r5, r5, #31
 8002192:	085b      	lsrs	r3, r3, #1
 8002194:	432b      	orrs	r3, r5
 8002196:	0038      	movs	r0, r7
 8002198:	0019      	movs	r1, r3
 800219a:	bc1c      	pop	{r2, r3, r4}
 800219c:	4690      	mov	r8, r2
 800219e:	4699      	mov	r9, r3
 80021a0:	46a2      	mov	sl, r4
 80021a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80021a4:	2501      	movs	r5, #1
 80021a6:	4643      	mov	r3, r8
 80021a8:	0762      	lsls	r2, r4, #29
 80021aa:	08ff      	lsrs	r7, r7, #3
 80021ac:	4317      	orrs	r7, r2
 80021ae:	08e4      	lsrs	r4, r4, #3
 80021b0:	401d      	ands	r5, r3
 80021b2:	4b70      	ldr	r3, [pc, #448]	; (8002374 <__aeabi_dsub+0x344>)
 80021b4:	429e      	cmp	r6, r3
 80021b6:	d036      	beq.n	8002226 <__aeabi_dsub+0x1f6>
 80021b8:	0324      	lsls	r4, r4, #12
 80021ba:	0576      	lsls	r6, r6, #21
 80021bc:	0b24      	lsrs	r4, r4, #12
 80021be:	0d76      	lsrs	r6, r6, #21
 80021c0:	e7db      	b.n	800217a <__aeabi_dsub+0x14a>
 80021c2:	4663      	mov	r3, ip
 80021c4:	1af3      	subs	r3, r6, r3
 80021c6:	2b00      	cmp	r3, #0
 80021c8:	dc00      	bgt.n	80021cc <__aeabi_dsub+0x19c>
 80021ca:	e094      	b.n	80022f6 <__aeabi_dsub+0x2c6>
 80021cc:	4660      	mov	r0, ip
 80021ce:	2800      	cmp	r0, #0
 80021d0:	d035      	beq.n	800223e <__aeabi_dsub+0x20e>
 80021d2:	4868      	ldr	r0, [pc, #416]	; (8002374 <__aeabi_dsub+0x344>)
 80021d4:	4286      	cmp	r6, r0
 80021d6:	d0b1      	beq.n	800213c <__aeabi_dsub+0x10c>
 80021d8:	2780      	movs	r7, #128	; 0x80
 80021da:	043f      	lsls	r7, r7, #16
 80021dc:	4339      	orrs	r1, r7
 80021de:	2b38      	cmp	r3, #56	; 0x38
 80021e0:	dc00      	bgt.n	80021e4 <__aeabi_dsub+0x1b4>
 80021e2:	e0fd      	b.n	80023e0 <__aeabi_dsub+0x3b0>
 80021e4:	430a      	orrs	r2, r1
 80021e6:	0017      	movs	r7, r2
 80021e8:	2100      	movs	r1, #0
 80021ea:	1e7a      	subs	r2, r7, #1
 80021ec:	4197      	sbcs	r7, r2
 80021ee:	4457      	add	r7, sl
 80021f0:	4557      	cmp	r7, sl
 80021f2:	4180      	sbcs	r0, r0
 80021f4:	1909      	adds	r1, r1, r4
 80021f6:	4244      	negs	r4, r0
 80021f8:	190c      	adds	r4, r1, r4
 80021fa:	0223      	lsls	r3, r4, #8
 80021fc:	d53a      	bpl.n	8002274 <__aeabi_dsub+0x244>
 80021fe:	4b5d      	ldr	r3, [pc, #372]	; (8002374 <__aeabi_dsub+0x344>)
 8002200:	3601      	adds	r6, #1
 8002202:	429e      	cmp	r6, r3
 8002204:	d100      	bne.n	8002208 <__aeabi_dsub+0x1d8>
 8002206:	e14b      	b.n	80024a0 <__aeabi_dsub+0x470>
 8002208:	2201      	movs	r2, #1
 800220a:	4b5b      	ldr	r3, [pc, #364]	; (8002378 <__aeabi_dsub+0x348>)
 800220c:	401c      	ands	r4, r3
 800220e:	087b      	lsrs	r3, r7, #1
 8002210:	4017      	ands	r7, r2
 8002212:	431f      	orrs	r7, r3
 8002214:	07e2      	lsls	r2, r4, #31
 8002216:	4317      	orrs	r7, r2
 8002218:	0864      	lsrs	r4, r4, #1
 800221a:	e78f      	b.n	800213c <__aeabi_dsub+0x10c>
 800221c:	0008      	movs	r0, r1
 800221e:	4310      	orrs	r0, r2
 8002220:	d000      	beq.n	8002224 <__aeabi_dsub+0x1f4>
 8002222:	e724      	b.n	800206e <__aeabi_dsub+0x3e>
 8002224:	e721      	b.n	800206a <__aeabi_dsub+0x3a>
 8002226:	0023      	movs	r3, r4
 8002228:	433b      	orrs	r3, r7
 800222a:	d100      	bne.n	800222e <__aeabi_dsub+0x1fe>
 800222c:	e1b9      	b.n	80025a2 <__aeabi_dsub+0x572>
 800222e:	2280      	movs	r2, #128	; 0x80
 8002230:	0312      	lsls	r2, r2, #12
 8002232:	4314      	orrs	r4, r2
 8002234:	0324      	lsls	r4, r4, #12
 8002236:	0b24      	lsrs	r4, r4, #12
 8002238:	e79f      	b.n	800217a <__aeabi_dsub+0x14a>
 800223a:	002e      	movs	r6, r5
 800223c:	e77e      	b.n	800213c <__aeabi_dsub+0x10c>
 800223e:	0008      	movs	r0, r1
 8002240:	4310      	orrs	r0, r2
 8002242:	d100      	bne.n	8002246 <__aeabi_dsub+0x216>
 8002244:	e0ca      	b.n	80023dc <__aeabi_dsub+0x3ac>
 8002246:	1e58      	subs	r0, r3, #1
 8002248:	4684      	mov	ip, r0
 800224a:	2800      	cmp	r0, #0
 800224c:	d000      	beq.n	8002250 <__aeabi_dsub+0x220>
 800224e:	e0e7      	b.n	8002420 <__aeabi_dsub+0x3f0>
 8002250:	4452      	add	r2, sl
 8002252:	4552      	cmp	r2, sl
 8002254:	4180      	sbcs	r0, r0
 8002256:	1864      	adds	r4, r4, r1
 8002258:	4240      	negs	r0, r0
 800225a:	1824      	adds	r4, r4, r0
 800225c:	0017      	movs	r7, r2
 800225e:	2601      	movs	r6, #1
 8002260:	0223      	lsls	r3, r4, #8
 8002262:	d507      	bpl.n	8002274 <__aeabi_dsub+0x244>
 8002264:	2602      	movs	r6, #2
 8002266:	e7cf      	b.n	8002208 <__aeabi_dsub+0x1d8>
 8002268:	4664      	mov	r4, ip
 800226a:	432c      	orrs	r4, r5
 800226c:	d100      	bne.n	8002270 <__aeabi_dsub+0x240>
 800226e:	e1b3      	b.n	80025d8 <__aeabi_dsub+0x5a8>
 8002270:	002c      	movs	r4, r5
 8002272:	4667      	mov	r7, ip
 8002274:	077b      	lsls	r3, r7, #29
 8002276:	d000      	beq.n	800227a <__aeabi_dsub+0x24a>
 8002278:	e762      	b.n	8002140 <__aeabi_dsub+0x110>
 800227a:	0763      	lsls	r3, r4, #29
 800227c:	08ff      	lsrs	r7, r7, #3
 800227e:	431f      	orrs	r7, r3
 8002280:	2501      	movs	r5, #1
 8002282:	4643      	mov	r3, r8
 8002284:	08e4      	lsrs	r4, r4, #3
 8002286:	401d      	ands	r5, r3
 8002288:	e793      	b.n	80021b2 <__aeabi_dsub+0x182>
 800228a:	2d00      	cmp	r5, #0
 800228c:	d178      	bne.n	8002380 <__aeabi_dsub+0x350>
 800228e:	1c75      	adds	r5, r6, #1
 8002290:	056d      	lsls	r5, r5, #21
 8002292:	0d6d      	lsrs	r5, r5, #21
 8002294:	2d01      	cmp	r5, #1
 8002296:	dc00      	bgt.n	800229a <__aeabi_dsub+0x26a>
 8002298:	e0f2      	b.n	8002480 <__aeabi_dsub+0x450>
 800229a:	4650      	mov	r0, sl
 800229c:	1a80      	subs	r0, r0, r2
 800229e:	4582      	cmp	sl, r0
 80022a0:	41bf      	sbcs	r7, r7
 80022a2:	1a65      	subs	r5, r4, r1
 80022a4:	427f      	negs	r7, r7
 80022a6:	1bed      	subs	r5, r5, r7
 80022a8:	4684      	mov	ip, r0
 80022aa:	0228      	lsls	r0, r5, #8
 80022ac:	d400      	bmi.n	80022b0 <__aeabi_dsub+0x280>
 80022ae:	e08c      	b.n	80023ca <__aeabi_dsub+0x39a>
 80022b0:	4650      	mov	r0, sl
 80022b2:	1a17      	subs	r7, r2, r0
 80022b4:	42ba      	cmp	r2, r7
 80022b6:	4192      	sbcs	r2, r2
 80022b8:	1b0c      	subs	r4, r1, r4
 80022ba:	4255      	negs	r5, r2
 80022bc:	1b65      	subs	r5, r4, r5
 80022be:	4698      	mov	r8, r3
 80022c0:	e714      	b.n	80020ec <__aeabi_dsub+0xbc>
 80022c2:	2501      	movs	r5, #1
 80022c4:	4643      	mov	r3, r8
 80022c6:	2400      	movs	r4, #0
 80022c8:	401d      	ands	r5, r3
 80022ca:	2700      	movs	r7, #0
 80022cc:	e755      	b.n	800217a <__aeabi_dsub+0x14a>
 80022ce:	4c2a      	ldr	r4, [pc, #168]	; (8002378 <__aeabi_dsub+0x348>)
 80022d0:	1af6      	subs	r6, r6, r3
 80022d2:	402c      	ands	r4, r5
 80022d4:	e732      	b.n	800213c <__aeabi_dsub+0x10c>
 80022d6:	003d      	movs	r5, r7
 80022d8:	3828      	subs	r0, #40	; 0x28
 80022da:	4085      	lsls	r5, r0
 80022dc:	2700      	movs	r7, #0
 80022de:	e717      	b.n	8002110 <__aeabi_dsub+0xe0>
 80022e0:	0038      	movs	r0, r7
 80022e2:	f000 facb 	bl	800287c <__clzsi2>
 80022e6:	3020      	adds	r0, #32
 80022e8:	e706      	b.n	80020f8 <__aeabi_dsub+0xc8>
 80022ea:	430a      	orrs	r2, r1
 80022ec:	0017      	movs	r7, r2
 80022ee:	2100      	movs	r1, #0
 80022f0:	1e7a      	subs	r2, r7, #1
 80022f2:	4197      	sbcs	r7, r2
 80022f4:	e6ee      	b.n	80020d4 <__aeabi_dsub+0xa4>
 80022f6:	2b00      	cmp	r3, #0
 80022f8:	d000      	beq.n	80022fc <__aeabi_dsub+0x2cc>
 80022fa:	e0e5      	b.n	80024c8 <__aeabi_dsub+0x498>
 80022fc:	1c73      	adds	r3, r6, #1
 80022fe:	469c      	mov	ip, r3
 8002300:	055b      	lsls	r3, r3, #21
 8002302:	0d5b      	lsrs	r3, r3, #21
 8002304:	2b01      	cmp	r3, #1
 8002306:	dc00      	bgt.n	800230a <__aeabi_dsub+0x2da>
 8002308:	e09f      	b.n	800244a <__aeabi_dsub+0x41a>
 800230a:	4b1a      	ldr	r3, [pc, #104]	; (8002374 <__aeabi_dsub+0x344>)
 800230c:	459c      	cmp	ip, r3
 800230e:	d100      	bne.n	8002312 <__aeabi_dsub+0x2e2>
 8002310:	e0c5      	b.n	800249e <__aeabi_dsub+0x46e>
 8002312:	4452      	add	r2, sl
 8002314:	4552      	cmp	r2, sl
 8002316:	4180      	sbcs	r0, r0
 8002318:	1864      	adds	r4, r4, r1
 800231a:	4240      	negs	r0, r0
 800231c:	1824      	adds	r4, r4, r0
 800231e:	07e7      	lsls	r7, r4, #31
 8002320:	0852      	lsrs	r2, r2, #1
 8002322:	4317      	orrs	r7, r2
 8002324:	0864      	lsrs	r4, r4, #1
 8002326:	4666      	mov	r6, ip
 8002328:	e708      	b.n	800213c <__aeabi_dsub+0x10c>
 800232a:	4812      	ldr	r0, [pc, #72]	; (8002374 <__aeabi_dsub+0x344>)
 800232c:	4285      	cmp	r5, r0
 800232e:	d100      	bne.n	8002332 <__aeabi_dsub+0x302>
 8002330:	e085      	b.n	800243e <__aeabi_dsub+0x40e>
 8002332:	001d      	movs	r5, r3
 8002334:	e6bc      	b.n	80020b0 <__aeabi_dsub+0x80>
 8002336:	0029      	movs	r1, r5
 8002338:	3e1f      	subs	r6, #31
 800233a:	40f1      	lsrs	r1, r6
 800233c:	2b20      	cmp	r3, #32
 800233e:	d100      	bne.n	8002342 <__aeabi_dsub+0x312>
 8002340:	e07f      	b.n	8002442 <__aeabi_dsub+0x412>
 8002342:	2240      	movs	r2, #64	; 0x40
 8002344:	1ad3      	subs	r3, r2, r3
 8002346:	409d      	lsls	r5, r3
 8002348:	432f      	orrs	r7, r5
 800234a:	1e7d      	subs	r5, r7, #1
 800234c:	41af      	sbcs	r7, r5
 800234e:	2400      	movs	r4, #0
 8002350:	430f      	orrs	r7, r1
 8002352:	2600      	movs	r6, #0
 8002354:	e78e      	b.n	8002274 <__aeabi_dsub+0x244>
 8002356:	002b      	movs	r3, r5
 8002358:	000f      	movs	r7, r1
 800235a:	3b20      	subs	r3, #32
 800235c:	40df      	lsrs	r7, r3
 800235e:	2d20      	cmp	r5, #32
 8002360:	d071      	beq.n	8002446 <__aeabi_dsub+0x416>
 8002362:	2340      	movs	r3, #64	; 0x40
 8002364:	1b5d      	subs	r5, r3, r5
 8002366:	40a9      	lsls	r1, r5
 8002368:	430a      	orrs	r2, r1
 800236a:	1e51      	subs	r1, r2, #1
 800236c:	418a      	sbcs	r2, r1
 800236e:	2100      	movs	r1, #0
 8002370:	4317      	orrs	r7, r2
 8002372:	e6af      	b.n	80020d4 <__aeabi_dsub+0xa4>
 8002374:	000007ff 	.word	0x000007ff
 8002378:	ff7fffff 	.word	0xff7fffff
 800237c:	800fffff 	.word	0x800fffff
 8002380:	2e00      	cmp	r6, #0
 8002382:	d03e      	beq.n	8002402 <__aeabi_dsub+0x3d2>
 8002384:	4eb3      	ldr	r6, [pc, #716]	; (8002654 <__aeabi_dsub+0x624>)
 8002386:	45b4      	cmp	ip, r6
 8002388:	d045      	beq.n	8002416 <__aeabi_dsub+0x3e6>
 800238a:	2680      	movs	r6, #128	; 0x80
 800238c:	0436      	lsls	r6, r6, #16
 800238e:	426d      	negs	r5, r5
 8002390:	4334      	orrs	r4, r6
 8002392:	2d38      	cmp	r5, #56	; 0x38
 8002394:	dd00      	ble.n	8002398 <__aeabi_dsub+0x368>
 8002396:	e0a8      	b.n	80024ea <__aeabi_dsub+0x4ba>
 8002398:	2d1f      	cmp	r5, #31
 800239a:	dd00      	ble.n	800239e <__aeabi_dsub+0x36e>
 800239c:	e11f      	b.n	80025de <__aeabi_dsub+0x5ae>
 800239e:	2620      	movs	r6, #32
 80023a0:	0027      	movs	r7, r4
 80023a2:	4650      	mov	r0, sl
 80023a4:	1b76      	subs	r6, r6, r5
 80023a6:	40b7      	lsls	r7, r6
 80023a8:	40e8      	lsrs	r0, r5
 80023aa:	4307      	orrs	r7, r0
 80023ac:	4650      	mov	r0, sl
 80023ae:	40b0      	lsls	r0, r6
 80023b0:	1e46      	subs	r6, r0, #1
 80023b2:	41b0      	sbcs	r0, r6
 80023b4:	40ec      	lsrs	r4, r5
 80023b6:	4338      	orrs	r0, r7
 80023b8:	1a17      	subs	r7, r2, r0
 80023ba:	42ba      	cmp	r2, r7
 80023bc:	4192      	sbcs	r2, r2
 80023be:	1b0c      	subs	r4, r1, r4
 80023c0:	4252      	negs	r2, r2
 80023c2:	1aa4      	subs	r4, r4, r2
 80023c4:	4666      	mov	r6, ip
 80023c6:	4698      	mov	r8, r3
 80023c8:	e68b      	b.n	80020e2 <__aeabi_dsub+0xb2>
 80023ca:	4664      	mov	r4, ip
 80023cc:	4667      	mov	r7, ip
 80023ce:	432c      	orrs	r4, r5
 80023d0:	d000      	beq.n	80023d4 <__aeabi_dsub+0x3a4>
 80023d2:	e68b      	b.n	80020ec <__aeabi_dsub+0xbc>
 80023d4:	2500      	movs	r5, #0
 80023d6:	2600      	movs	r6, #0
 80023d8:	2700      	movs	r7, #0
 80023da:	e6ea      	b.n	80021b2 <__aeabi_dsub+0x182>
 80023dc:	001e      	movs	r6, r3
 80023de:	e6ad      	b.n	800213c <__aeabi_dsub+0x10c>
 80023e0:	2b1f      	cmp	r3, #31
 80023e2:	dc60      	bgt.n	80024a6 <__aeabi_dsub+0x476>
 80023e4:	2720      	movs	r7, #32
 80023e6:	1af8      	subs	r0, r7, r3
 80023e8:	000f      	movs	r7, r1
 80023ea:	4684      	mov	ip, r0
 80023ec:	4087      	lsls	r7, r0
 80023ee:	0010      	movs	r0, r2
 80023f0:	40d8      	lsrs	r0, r3
 80023f2:	4307      	orrs	r7, r0
 80023f4:	4660      	mov	r0, ip
 80023f6:	4082      	lsls	r2, r0
 80023f8:	1e50      	subs	r0, r2, #1
 80023fa:	4182      	sbcs	r2, r0
 80023fc:	40d9      	lsrs	r1, r3
 80023fe:	4317      	orrs	r7, r2
 8002400:	e6f5      	b.n	80021ee <__aeabi_dsub+0x1be>
 8002402:	0026      	movs	r6, r4
 8002404:	4650      	mov	r0, sl
 8002406:	4306      	orrs	r6, r0
 8002408:	d005      	beq.n	8002416 <__aeabi_dsub+0x3e6>
 800240a:	43ed      	mvns	r5, r5
 800240c:	2d00      	cmp	r5, #0
 800240e:	d0d3      	beq.n	80023b8 <__aeabi_dsub+0x388>
 8002410:	4e90      	ldr	r6, [pc, #576]	; (8002654 <__aeabi_dsub+0x624>)
 8002412:	45b4      	cmp	ip, r6
 8002414:	d1bd      	bne.n	8002392 <__aeabi_dsub+0x362>
 8002416:	000c      	movs	r4, r1
 8002418:	0017      	movs	r7, r2
 800241a:	4666      	mov	r6, ip
 800241c:	4698      	mov	r8, r3
 800241e:	e68d      	b.n	800213c <__aeabi_dsub+0x10c>
 8002420:	488c      	ldr	r0, [pc, #560]	; (8002654 <__aeabi_dsub+0x624>)
 8002422:	4283      	cmp	r3, r0
 8002424:	d00b      	beq.n	800243e <__aeabi_dsub+0x40e>
 8002426:	4663      	mov	r3, ip
 8002428:	e6d9      	b.n	80021de <__aeabi_dsub+0x1ae>
 800242a:	2d00      	cmp	r5, #0
 800242c:	d000      	beq.n	8002430 <__aeabi_dsub+0x400>
 800242e:	e096      	b.n	800255e <__aeabi_dsub+0x52e>
 8002430:	0008      	movs	r0, r1
 8002432:	4310      	orrs	r0, r2
 8002434:	d100      	bne.n	8002438 <__aeabi_dsub+0x408>
 8002436:	e0e2      	b.n	80025fe <__aeabi_dsub+0x5ce>
 8002438:	000c      	movs	r4, r1
 800243a:	0017      	movs	r7, r2
 800243c:	4698      	mov	r8, r3
 800243e:	4e85      	ldr	r6, [pc, #532]	; (8002654 <__aeabi_dsub+0x624>)
 8002440:	e67c      	b.n	800213c <__aeabi_dsub+0x10c>
 8002442:	2500      	movs	r5, #0
 8002444:	e780      	b.n	8002348 <__aeabi_dsub+0x318>
 8002446:	2100      	movs	r1, #0
 8002448:	e78e      	b.n	8002368 <__aeabi_dsub+0x338>
 800244a:	0023      	movs	r3, r4
 800244c:	4650      	mov	r0, sl
 800244e:	4303      	orrs	r3, r0
 8002450:	2e00      	cmp	r6, #0
 8002452:	d000      	beq.n	8002456 <__aeabi_dsub+0x426>
 8002454:	e0a8      	b.n	80025a8 <__aeabi_dsub+0x578>
 8002456:	2b00      	cmp	r3, #0
 8002458:	d100      	bne.n	800245c <__aeabi_dsub+0x42c>
 800245a:	e0de      	b.n	800261a <__aeabi_dsub+0x5ea>
 800245c:	000b      	movs	r3, r1
 800245e:	4313      	orrs	r3, r2
 8002460:	d100      	bne.n	8002464 <__aeabi_dsub+0x434>
 8002462:	e66b      	b.n	800213c <__aeabi_dsub+0x10c>
 8002464:	4452      	add	r2, sl
 8002466:	4552      	cmp	r2, sl
 8002468:	4180      	sbcs	r0, r0
 800246a:	1864      	adds	r4, r4, r1
 800246c:	4240      	negs	r0, r0
 800246e:	1824      	adds	r4, r4, r0
 8002470:	0017      	movs	r7, r2
 8002472:	0223      	lsls	r3, r4, #8
 8002474:	d400      	bmi.n	8002478 <__aeabi_dsub+0x448>
 8002476:	e6fd      	b.n	8002274 <__aeabi_dsub+0x244>
 8002478:	4b77      	ldr	r3, [pc, #476]	; (8002658 <__aeabi_dsub+0x628>)
 800247a:	4666      	mov	r6, ip
 800247c:	401c      	ands	r4, r3
 800247e:	e65d      	b.n	800213c <__aeabi_dsub+0x10c>
 8002480:	0025      	movs	r5, r4
 8002482:	4650      	mov	r0, sl
 8002484:	4305      	orrs	r5, r0
 8002486:	2e00      	cmp	r6, #0
 8002488:	d1cf      	bne.n	800242a <__aeabi_dsub+0x3fa>
 800248a:	2d00      	cmp	r5, #0
 800248c:	d14f      	bne.n	800252e <__aeabi_dsub+0x4fe>
 800248e:	000c      	movs	r4, r1
 8002490:	4314      	orrs	r4, r2
 8002492:	d100      	bne.n	8002496 <__aeabi_dsub+0x466>
 8002494:	e0a0      	b.n	80025d8 <__aeabi_dsub+0x5a8>
 8002496:	000c      	movs	r4, r1
 8002498:	0017      	movs	r7, r2
 800249a:	4698      	mov	r8, r3
 800249c:	e64e      	b.n	800213c <__aeabi_dsub+0x10c>
 800249e:	4666      	mov	r6, ip
 80024a0:	2400      	movs	r4, #0
 80024a2:	2700      	movs	r7, #0
 80024a4:	e685      	b.n	80021b2 <__aeabi_dsub+0x182>
 80024a6:	001f      	movs	r7, r3
 80024a8:	0008      	movs	r0, r1
 80024aa:	3f20      	subs	r7, #32
 80024ac:	40f8      	lsrs	r0, r7
 80024ae:	0007      	movs	r7, r0
 80024b0:	2b20      	cmp	r3, #32
 80024b2:	d100      	bne.n	80024b6 <__aeabi_dsub+0x486>
 80024b4:	e08e      	b.n	80025d4 <__aeabi_dsub+0x5a4>
 80024b6:	2040      	movs	r0, #64	; 0x40
 80024b8:	1ac3      	subs	r3, r0, r3
 80024ba:	4099      	lsls	r1, r3
 80024bc:	430a      	orrs	r2, r1
 80024be:	1e51      	subs	r1, r2, #1
 80024c0:	418a      	sbcs	r2, r1
 80024c2:	2100      	movs	r1, #0
 80024c4:	4317      	orrs	r7, r2
 80024c6:	e692      	b.n	80021ee <__aeabi_dsub+0x1be>
 80024c8:	2e00      	cmp	r6, #0
 80024ca:	d114      	bne.n	80024f6 <__aeabi_dsub+0x4c6>
 80024cc:	0026      	movs	r6, r4
 80024ce:	4650      	mov	r0, sl
 80024d0:	4306      	orrs	r6, r0
 80024d2:	d062      	beq.n	800259a <__aeabi_dsub+0x56a>
 80024d4:	43db      	mvns	r3, r3
 80024d6:	2b00      	cmp	r3, #0
 80024d8:	d15c      	bne.n	8002594 <__aeabi_dsub+0x564>
 80024da:	1887      	adds	r7, r0, r2
 80024dc:	4297      	cmp	r7, r2
 80024de:	4192      	sbcs	r2, r2
 80024e0:	1864      	adds	r4, r4, r1
 80024e2:	4252      	negs	r2, r2
 80024e4:	18a4      	adds	r4, r4, r2
 80024e6:	4666      	mov	r6, ip
 80024e8:	e687      	b.n	80021fa <__aeabi_dsub+0x1ca>
 80024ea:	4650      	mov	r0, sl
 80024ec:	4320      	orrs	r0, r4
 80024ee:	1e44      	subs	r4, r0, #1
 80024f0:	41a0      	sbcs	r0, r4
 80024f2:	2400      	movs	r4, #0
 80024f4:	e760      	b.n	80023b8 <__aeabi_dsub+0x388>
 80024f6:	4e57      	ldr	r6, [pc, #348]	; (8002654 <__aeabi_dsub+0x624>)
 80024f8:	45b4      	cmp	ip, r6
 80024fa:	d04e      	beq.n	800259a <__aeabi_dsub+0x56a>
 80024fc:	2680      	movs	r6, #128	; 0x80
 80024fe:	0436      	lsls	r6, r6, #16
 8002500:	425b      	negs	r3, r3
 8002502:	4334      	orrs	r4, r6
 8002504:	2b38      	cmp	r3, #56	; 0x38
 8002506:	dd00      	ble.n	800250a <__aeabi_dsub+0x4da>
 8002508:	e07f      	b.n	800260a <__aeabi_dsub+0x5da>
 800250a:	2b1f      	cmp	r3, #31
 800250c:	dd00      	ble.n	8002510 <__aeabi_dsub+0x4e0>
 800250e:	e08b      	b.n	8002628 <__aeabi_dsub+0x5f8>
 8002510:	2620      	movs	r6, #32
 8002512:	0027      	movs	r7, r4
 8002514:	4650      	mov	r0, sl
 8002516:	1af6      	subs	r6, r6, r3
 8002518:	40b7      	lsls	r7, r6
 800251a:	40d8      	lsrs	r0, r3
 800251c:	4307      	orrs	r7, r0
 800251e:	4650      	mov	r0, sl
 8002520:	40b0      	lsls	r0, r6
 8002522:	1e46      	subs	r6, r0, #1
 8002524:	41b0      	sbcs	r0, r6
 8002526:	4307      	orrs	r7, r0
 8002528:	40dc      	lsrs	r4, r3
 800252a:	18bf      	adds	r7, r7, r2
 800252c:	e7d6      	b.n	80024dc <__aeabi_dsub+0x4ac>
 800252e:	000d      	movs	r5, r1
 8002530:	4315      	orrs	r5, r2
 8002532:	d100      	bne.n	8002536 <__aeabi_dsub+0x506>
 8002534:	e602      	b.n	800213c <__aeabi_dsub+0x10c>
 8002536:	4650      	mov	r0, sl
 8002538:	1a80      	subs	r0, r0, r2
 800253a:	4582      	cmp	sl, r0
 800253c:	41bf      	sbcs	r7, r7
 800253e:	1a65      	subs	r5, r4, r1
 8002540:	427f      	negs	r7, r7
 8002542:	1bed      	subs	r5, r5, r7
 8002544:	4684      	mov	ip, r0
 8002546:	0228      	lsls	r0, r5, #8
 8002548:	d400      	bmi.n	800254c <__aeabi_dsub+0x51c>
 800254a:	e68d      	b.n	8002268 <__aeabi_dsub+0x238>
 800254c:	4650      	mov	r0, sl
 800254e:	1a17      	subs	r7, r2, r0
 8002550:	42ba      	cmp	r2, r7
 8002552:	4192      	sbcs	r2, r2
 8002554:	1b0c      	subs	r4, r1, r4
 8002556:	4252      	negs	r2, r2
 8002558:	1aa4      	subs	r4, r4, r2
 800255a:	4698      	mov	r8, r3
 800255c:	e5ee      	b.n	800213c <__aeabi_dsub+0x10c>
 800255e:	000d      	movs	r5, r1
 8002560:	4315      	orrs	r5, r2
 8002562:	d100      	bne.n	8002566 <__aeabi_dsub+0x536>
 8002564:	e76b      	b.n	800243e <__aeabi_dsub+0x40e>
 8002566:	4650      	mov	r0, sl
 8002568:	0767      	lsls	r7, r4, #29
 800256a:	08c0      	lsrs	r0, r0, #3
 800256c:	4307      	orrs	r7, r0
 800256e:	2080      	movs	r0, #128	; 0x80
 8002570:	08e4      	lsrs	r4, r4, #3
 8002572:	0300      	lsls	r0, r0, #12
 8002574:	4204      	tst	r4, r0
 8002576:	d007      	beq.n	8002588 <__aeabi_dsub+0x558>
 8002578:	08cd      	lsrs	r5, r1, #3
 800257a:	4205      	tst	r5, r0
 800257c:	d104      	bne.n	8002588 <__aeabi_dsub+0x558>
 800257e:	002c      	movs	r4, r5
 8002580:	4698      	mov	r8, r3
 8002582:	08d7      	lsrs	r7, r2, #3
 8002584:	0749      	lsls	r1, r1, #29
 8002586:	430f      	orrs	r7, r1
 8002588:	0f7b      	lsrs	r3, r7, #29
 800258a:	00e4      	lsls	r4, r4, #3
 800258c:	431c      	orrs	r4, r3
 800258e:	00ff      	lsls	r7, r7, #3
 8002590:	4e30      	ldr	r6, [pc, #192]	; (8002654 <__aeabi_dsub+0x624>)
 8002592:	e5d3      	b.n	800213c <__aeabi_dsub+0x10c>
 8002594:	4e2f      	ldr	r6, [pc, #188]	; (8002654 <__aeabi_dsub+0x624>)
 8002596:	45b4      	cmp	ip, r6
 8002598:	d1b4      	bne.n	8002504 <__aeabi_dsub+0x4d4>
 800259a:	000c      	movs	r4, r1
 800259c:	0017      	movs	r7, r2
 800259e:	4666      	mov	r6, ip
 80025a0:	e5cc      	b.n	800213c <__aeabi_dsub+0x10c>
 80025a2:	2700      	movs	r7, #0
 80025a4:	2400      	movs	r4, #0
 80025a6:	e5e8      	b.n	800217a <__aeabi_dsub+0x14a>
 80025a8:	2b00      	cmp	r3, #0
 80025aa:	d039      	beq.n	8002620 <__aeabi_dsub+0x5f0>
 80025ac:	000b      	movs	r3, r1
 80025ae:	4313      	orrs	r3, r2
 80025b0:	d100      	bne.n	80025b4 <__aeabi_dsub+0x584>
 80025b2:	e744      	b.n	800243e <__aeabi_dsub+0x40e>
 80025b4:	08c0      	lsrs	r0, r0, #3
 80025b6:	0767      	lsls	r7, r4, #29
 80025b8:	4307      	orrs	r7, r0
 80025ba:	2080      	movs	r0, #128	; 0x80
 80025bc:	08e4      	lsrs	r4, r4, #3
 80025be:	0300      	lsls	r0, r0, #12
 80025c0:	4204      	tst	r4, r0
 80025c2:	d0e1      	beq.n	8002588 <__aeabi_dsub+0x558>
 80025c4:	08cb      	lsrs	r3, r1, #3
 80025c6:	4203      	tst	r3, r0
 80025c8:	d1de      	bne.n	8002588 <__aeabi_dsub+0x558>
 80025ca:	08d7      	lsrs	r7, r2, #3
 80025cc:	0749      	lsls	r1, r1, #29
 80025ce:	430f      	orrs	r7, r1
 80025d0:	001c      	movs	r4, r3
 80025d2:	e7d9      	b.n	8002588 <__aeabi_dsub+0x558>
 80025d4:	2100      	movs	r1, #0
 80025d6:	e771      	b.n	80024bc <__aeabi_dsub+0x48c>
 80025d8:	2500      	movs	r5, #0
 80025da:	2700      	movs	r7, #0
 80025dc:	e5e9      	b.n	80021b2 <__aeabi_dsub+0x182>
 80025de:	002e      	movs	r6, r5
 80025e0:	0027      	movs	r7, r4
 80025e2:	3e20      	subs	r6, #32
 80025e4:	40f7      	lsrs	r7, r6
 80025e6:	2d20      	cmp	r5, #32
 80025e8:	d02f      	beq.n	800264a <__aeabi_dsub+0x61a>
 80025ea:	2640      	movs	r6, #64	; 0x40
 80025ec:	1b75      	subs	r5, r6, r5
 80025ee:	40ac      	lsls	r4, r5
 80025f0:	4650      	mov	r0, sl
 80025f2:	4320      	orrs	r0, r4
 80025f4:	1e44      	subs	r4, r0, #1
 80025f6:	41a0      	sbcs	r0, r4
 80025f8:	2400      	movs	r4, #0
 80025fa:	4338      	orrs	r0, r7
 80025fc:	e6dc      	b.n	80023b8 <__aeabi_dsub+0x388>
 80025fe:	2480      	movs	r4, #128	; 0x80
 8002600:	2500      	movs	r5, #0
 8002602:	0324      	lsls	r4, r4, #12
 8002604:	4e13      	ldr	r6, [pc, #76]	; (8002654 <__aeabi_dsub+0x624>)
 8002606:	2700      	movs	r7, #0
 8002608:	e5d3      	b.n	80021b2 <__aeabi_dsub+0x182>
 800260a:	4650      	mov	r0, sl
 800260c:	4320      	orrs	r0, r4
 800260e:	0007      	movs	r7, r0
 8002610:	1e78      	subs	r0, r7, #1
 8002612:	4187      	sbcs	r7, r0
 8002614:	2400      	movs	r4, #0
 8002616:	18bf      	adds	r7, r7, r2
 8002618:	e760      	b.n	80024dc <__aeabi_dsub+0x4ac>
 800261a:	000c      	movs	r4, r1
 800261c:	0017      	movs	r7, r2
 800261e:	e58d      	b.n	800213c <__aeabi_dsub+0x10c>
 8002620:	000c      	movs	r4, r1
 8002622:	0017      	movs	r7, r2
 8002624:	4e0b      	ldr	r6, [pc, #44]	; (8002654 <__aeabi_dsub+0x624>)
 8002626:	e589      	b.n	800213c <__aeabi_dsub+0x10c>
 8002628:	001e      	movs	r6, r3
 800262a:	0027      	movs	r7, r4
 800262c:	3e20      	subs	r6, #32
 800262e:	40f7      	lsrs	r7, r6
 8002630:	2b20      	cmp	r3, #32
 8002632:	d00c      	beq.n	800264e <__aeabi_dsub+0x61e>
 8002634:	2640      	movs	r6, #64	; 0x40
 8002636:	1af3      	subs	r3, r6, r3
 8002638:	409c      	lsls	r4, r3
 800263a:	4650      	mov	r0, sl
 800263c:	4320      	orrs	r0, r4
 800263e:	1e44      	subs	r4, r0, #1
 8002640:	41a0      	sbcs	r0, r4
 8002642:	4307      	orrs	r7, r0
 8002644:	2400      	movs	r4, #0
 8002646:	18bf      	adds	r7, r7, r2
 8002648:	e748      	b.n	80024dc <__aeabi_dsub+0x4ac>
 800264a:	2400      	movs	r4, #0
 800264c:	e7d0      	b.n	80025f0 <__aeabi_dsub+0x5c0>
 800264e:	2400      	movs	r4, #0
 8002650:	e7f3      	b.n	800263a <__aeabi_dsub+0x60a>
 8002652:	46c0      	nop			; (mov r8, r8)
 8002654:	000007ff 	.word	0x000007ff
 8002658:	ff7fffff 	.word	0xff7fffff

0800265c <__aeabi_d2iz>:
 800265c:	b530      	push	{r4, r5, lr}
 800265e:	4d13      	ldr	r5, [pc, #76]	; (80026ac <__aeabi_d2iz+0x50>)
 8002660:	030a      	lsls	r2, r1, #12
 8002662:	004b      	lsls	r3, r1, #1
 8002664:	0b12      	lsrs	r2, r2, #12
 8002666:	0d5b      	lsrs	r3, r3, #21
 8002668:	0fc9      	lsrs	r1, r1, #31
 800266a:	2400      	movs	r4, #0
 800266c:	42ab      	cmp	r3, r5
 800266e:	dd10      	ble.n	8002692 <__aeabi_d2iz+0x36>
 8002670:	4c0f      	ldr	r4, [pc, #60]	; (80026b0 <__aeabi_d2iz+0x54>)
 8002672:	42a3      	cmp	r3, r4
 8002674:	dc0f      	bgt.n	8002696 <__aeabi_d2iz+0x3a>
 8002676:	2480      	movs	r4, #128	; 0x80
 8002678:	4d0e      	ldr	r5, [pc, #56]	; (80026b4 <__aeabi_d2iz+0x58>)
 800267a:	0364      	lsls	r4, r4, #13
 800267c:	4322      	orrs	r2, r4
 800267e:	1aed      	subs	r5, r5, r3
 8002680:	2d1f      	cmp	r5, #31
 8002682:	dd0b      	ble.n	800269c <__aeabi_d2iz+0x40>
 8002684:	480c      	ldr	r0, [pc, #48]	; (80026b8 <__aeabi_d2iz+0x5c>)
 8002686:	1ac3      	subs	r3, r0, r3
 8002688:	40da      	lsrs	r2, r3
 800268a:	4254      	negs	r4, r2
 800268c:	2900      	cmp	r1, #0
 800268e:	d100      	bne.n	8002692 <__aeabi_d2iz+0x36>
 8002690:	0014      	movs	r4, r2
 8002692:	0020      	movs	r0, r4
 8002694:	bd30      	pop	{r4, r5, pc}
 8002696:	4b09      	ldr	r3, [pc, #36]	; (80026bc <__aeabi_d2iz+0x60>)
 8002698:	18cc      	adds	r4, r1, r3
 800269a:	e7fa      	b.n	8002692 <__aeabi_d2iz+0x36>
 800269c:	4c08      	ldr	r4, [pc, #32]	; (80026c0 <__aeabi_d2iz+0x64>)
 800269e:	40e8      	lsrs	r0, r5
 80026a0:	46a4      	mov	ip, r4
 80026a2:	4463      	add	r3, ip
 80026a4:	409a      	lsls	r2, r3
 80026a6:	4302      	orrs	r2, r0
 80026a8:	e7ef      	b.n	800268a <__aeabi_d2iz+0x2e>
 80026aa:	46c0      	nop			; (mov r8, r8)
 80026ac:	000003fe 	.word	0x000003fe
 80026b0:	0000041d 	.word	0x0000041d
 80026b4:	00000433 	.word	0x00000433
 80026b8:	00000413 	.word	0x00000413
 80026bc:	7fffffff 	.word	0x7fffffff
 80026c0:	fffffbed 	.word	0xfffffbed

080026c4 <__aeabi_f2d>:
 80026c4:	0041      	lsls	r1, r0, #1
 80026c6:	0e09      	lsrs	r1, r1, #24
 80026c8:	1c4b      	adds	r3, r1, #1
 80026ca:	b570      	push	{r4, r5, r6, lr}
 80026cc:	b2db      	uxtb	r3, r3
 80026ce:	0246      	lsls	r6, r0, #9
 80026d0:	0a75      	lsrs	r5, r6, #9
 80026d2:	0fc4      	lsrs	r4, r0, #31
 80026d4:	2b01      	cmp	r3, #1
 80026d6:	dd14      	ble.n	8002702 <__aeabi_f2d+0x3e>
 80026d8:	23e0      	movs	r3, #224	; 0xe0
 80026da:	009b      	lsls	r3, r3, #2
 80026dc:	076d      	lsls	r5, r5, #29
 80026de:	0b36      	lsrs	r6, r6, #12
 80026e0:	18cb      	adds	r3, r1, r3
 80026e2:	2100      	movs	r1, #0
 80026e4:	0d0a      	lsrs	r2, r1, #20
 80026e6:	0028      	movs	r0, r5
 80026e8:	0512      	lsls	r2, r2, #20
 80026ea:	4d1c      	ldr	r5, [pc, #112]	; (800275c <__aeabi_f2d+0x98>)
 80026ec:	4332      	orrs	r2, r6
 80026ee:	055b      	lsls	r3, r3, #21
 80026f0:	402a      	ands	r2, r5
 80026f2:	085b      	lsrs	r3, r3, #1
 80026f4:	4313      	orrs	r3, r2
 80026f6:	005b      	lsls	r3, r3, #1
 80026f8:	07e4      	lsls	r4, r4, #31
 80026fa:	085b      	lsrs	r3, r3, #1
 80026fc:	4323      	orrs	r3, r4
 80026fe:	0019      	movs	r1, r3
 8002700:	bd70      	pop	{r4, r5, r6, pc}
 8002702:	2900      	cmp	r1, #0
 8002704:	d114      	bne.n	8002730 <__aeabi_f2d+0x6c>
 8002706:	2d00      	cmp	r5, #0
 8002708:	d01e      	beq.n	8002748 <__aeabi_f2d+0x84>
 800270a:	0028      	movs	r0, r5
 800270c:	f000 f8b6 	bl	800287c <__clzsi2>
 8002710:	280a      	cmp	r0, #10
 8002712:	dc1c      	bgt.n	800274e <__aeabi_f2d+0x8a>
 8002714:	230b      	movs	r3, #11
 8002716:	002a      	movs	r2, r5
 8002718:	1a1b      	subs	r3, r3, r0
 800271a:	40da      	lsrs	r2, r3
 800271c:	0003      	movs	r3, r0
 800271e:	3315      	adds	r3, #21
 8002720:	409d      	lsls	r5, r3
 8002722:	4b0f      	ldr	r3, [pc, #60]	; (8002760 <__aeabi_f2d+0x9c>)
 8002724:	0312      	lsls	r2, r2, #12
 8002726:	1a1b      	subs	r3, r3, r0
 8002728:	055b      	lsls	r3, r3, #21
 800272a:	0b16      	lsrs	r6, r2, #12
 800272c:	0d5b      	lsrs	r3, r3, #21
 800272e:	e7d8      	b.n	80026e2 <__aeabi_f2d+0x1e>
 8002730:	2d00      	cmp	r5, #0
 8002732:	d006      	beq.n	8002742 <__aeabi_f2d+0x7e>
 8002734:	0b32      	lsrs	r2, r6, #12
 8002736:	2680      	movs	r6, #128	; 0x80
 8002738:	0336      	lsls	r6, r6, #12
 800273a:	076d      	lsls	r5, r5, #29
 800273c:	4316      	orrs	r6, r2
 800273e:	4b09      	ldr	r3, [pc, #36]	; (8002764 <__aeabi_f2d+0xa0>)
 8002740:	e7cf      	b.n	80026e2 <__aeabi_f2d+0x1e>
 8002742:	4b08      	ldr	r3, [pc, #32]	; (8002764 <__aeabi_f2d+0xa0>)
 8002744:	2600      	movs	r6, #0
 8002746:	e7cc      	b.n	80026e2 <__aeabi_f2d+0x1e>
 8002748:	2300      	movs	r3, #0
 800274a:	2600      	movs	r6, #0
 800274c:	e7c9      	b.n	80026e2 <__aeabi_f2d+0x1e>
 800274e:	0003      	movs	r3, r0
 8002750:	002a      	movs	r2, r5
 8002752:	3b0b      	subs	r3, #11
 8002754:	409a      	lsls	r2, r3
 8002756:	2500      	movs	r5, #0
 8002758:	e7e3      	b.n	8002722 <__aeabi_f2d+0x5e>
 800275a:	46c0      	nop			; (mov r8, r8)
 800275c:	800fffff 	.word	0x800fffff
 8002760:	00000389 	.word	0x00000389
 8002764:	000007ff 	.word	0x000007ff

08002768 <__aeabi_d2f>:
 8002768:	b5f0      	push	{r4, r5, r6, r7, lr}
 800276a:	004c      	lsls	r4, r1, #1
 800276c:	0d64      	lsrs	r4, r4, #21
 800276e:	030b      	lsls	r3, r1, #12
 8002770:	1c62      	adds	r2, r4, #1
 8002772:	0f45      	lsrs	r5, r0, #29
 8002774:	0a5b      	lsrs	r3, r3, #9
 8002776:	0552      	lsls	r2, r2, #21
 8002778:	432b      	orrs	r3, r5
 800277a:	0fc9      	lsrs	r1, r1, #31
 800277c:	00c5      	lsls	r5, r0, #3
 800277e:	0d52      	lsrs	r2, r2, #21
 8002780:	2a01      	cmp	r2, #1
 8002782:	dd28      	ble.n	80027d6 <__aeabi_d2f+0x6e>
 8002784:	4a3a      	ldr	r2, [pc, #232]	; (8002870 <__aeabi_d2f+0x108>)
 8002786:	18a6      	adds	r6, r4, r2
 8002788:	2efe      	cmp	r6, #254	; 0xfe
 800278a:	dc1b      	bgt.n	80027c4 <__aeabi_d2f+0x5c>
 800278c:	2e00      	cmp	r6, #0
 800278e:	dd3e      	ble.n	800280e <__aeabi_d2f+0xa6>
 8002790:	0180      	lsls	r0, r0, #6
 8002792:	0002      	movs	r2, r0
 8002794:	1e50      	subs	r0, r2, #1
 8002796:	4182      	sbcs	r2, r0
 8002798:	0f6d      	lsrs	r5, r5, #29
 800279a:	432a      	orrs	r2, r5
 800279c:	00db      	lsls	r3, r3, #3
 800279e:	4313      	orrs	r3, r2
 80027a0:	075a      	lsls	r2, r3, #29
 80027a2:	d004      	beq.n	80027ae <__aeabi_d2f+0x46>
 80027a4:	220f      	movs	r2, #15
 80027a6:	401a      	ands	r2, r3
 80027a8:	2a04      	cmp	r2, #4
 80027aa:	d000      	beq.n	80027ae <__aeabi_d2f+0x46>
 80027ac:	3304      	adds	r3, #4
 80027ae:	2280      	movs	r2, #128	; 0x80
 80027b0:	04d2      	lsls	r2, r2, #19
 80027b2:	401a      	ands	r2, r3
 80027b4:	d05a      	beq.n	800286c <__aeabi_d2f+0x104>
 80027b6:	3601      	adds	r6, #1
 80027b8:	2eff      	cmp	r6, #255	; 0xff
 80027ba:	d003      	beq.n	80027c4 <__aeabi_d2f+0x5c>
 80027bc:	019b      	lsls	r3, r3, #6
 80027be:	0a5b      	lsrs	r3, r3, #9
 80027c0:	b2f4      	uxtb	r4, r6
 80027c2:	e001      	b.n	80027c8 <__aeabi_d2f+0x60>
 80027c4:	24ff      	movs	r4, #255	; 0xff
 80027c6:	2300      	movs	r3, #0
 80027c8:	0258      	lsls	r0, r3, #9
 80027ca:	05e4      	lsls	r4, r4, #23
 80027cc:	0a40      	lsrs	r0, r0, #9
 80027ce:	07c9      	lsls	r1, r1, #31
 80027d0:	4320      	orrs	r0, r4
 80027d2:	4308      	orrs	r0, r1
 80027d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80027d6:	2c00      	cmp	r4, #0
 80027d8:	d007      	beq.n	80027ea <__aeabi_d2f+0x82>
 80027da:	431d      	orrs	r5, r3
 80027dc:	d0f2      	beq.n	80027c4 <__aeabi_d2f+0x5c>
 80027de:	2080      	movs	r0, #128	; 0x80
 80027e0:	00db      	lsls	r3, r3, #3
 80027e2:	0480      	lsls	r0, r0, #18
 80027e4:	4303      	orrs	r3, r0
 80027e6:	26ff      	movs	r6, #255	; 0xff
 80027e8:	e7da      	b.n	80027a0 <__aeabi_d2f+0x38>
 80027ea:	432b      	orrs	r3, r5
 80027ec:	d003      	beq.n	80027f6 <__aeabi_d2f+0x8e>
 80027ee:	2305      	movs	r3, #5
 80027f0:	08db      	lsrs	r3, r3, #3
 80027f2:	2cff      	cmp	r4, #255	; 0xff
 80027f4:	d003      	beq.n	80027fe <__aeabi_d2f+0x96>
 80027f6:	025b      	lsls	r3, r3, #9
 80027f8:	0a5b      	lsrs	r3, r3, #9
 80027fa:	b2e4      	uxtb	r4, r4
 80027fc:	e7e4      	b.n	80027c8 <__aeabi_d2f+0x60>
 80027fe:	2b00      	cmp	r3, #0
 8002800:	d032      	beq.n	8002868 <__aeabi_d2f+0x100>
 8002802:	2080      	movs	r0, #128	; 0x80
 8002804:	03c0      	lsls	r0, r0, #15
 8002806:	4303      	orrs	r3, r0
 8002808:	025b      	lsls	r3, r3, #9
 800280a:	0a5b      	lsrs	r3, r3, #9
 800280c:	e7dc      	b.n	80027c8 <__aeabi_d2f+0x60>
 800280e:	0032      	movs	r2, r6
 8002810:	3217      	adds	r2, #23
 8002812:	db14      	blt.n	800283e <__aeabi_d2f+0xd6>
 8002814:	2280      	movs	r2, #128	; 0x80
 8002816:	271e      	movs	r7, #30
 8002818:	0412      	lsls	r2, r2, #16
 800281a:	4313      	orrs	r3, r2
 800281c:	1bbf      	subs	r7, r7, r6
 800281e:	2f1f      	cmp	r7, #31
 8002820:	dc0f      	bgt.n	8002842 <__aeabi_d2f+0xda>
 8002822:	4a14      	ldr	r2, [pc, #80]	; (8002874 <__aeabi_d2f+0x10c>)
 8002824:	4694      	mov	ip, r2
 8002826:	4464      	add	r4, ip
 8002828:	002a      	movs	r2, r5
 800282a:	40a5      	lsls	r5, r4
 800282c:	002e      	movs	r6, r5
 800282e:	40a3      	lsls	r3, r4
 8002830:	1e75      	subs	r5, r6, #1
 8002832:	41ae      	sbcs	r6, r5
 8002834:	40fa      	lsrs	r2, r7
 8002836:	4333      	orrs	r3, r6
 8002838:	4313      	orrs	r3, r2
 800283a:	2600      	movs	r6, #0
 800283c:	e7b0      	b.n	80027a0 <__aeabi_d2f+0x38>
 800283e:	2400      	movs	r4, #0
 8002840:	e7d5      	b.n	80027ee <__aeabi_d2f+0x86>
 8002842:	2202      	movs	r2, #2
 8002844:	4252      	negs	r2, r2
 8002846:	1b96      	subs	r6, r2, r6
 8002848:	001a      	movs	r2, r3
 800284a:	40f2      	lsrs	r2, r6
 800284c:	2f20      	cmp	r7, #32
 800284e:	d009      	beq.n	8002864 <__aeabi_d2f+0xfc>
 8002850:	4809      	ldr	r0, [pc, #36]	; (8002878 <__aeabi_d2f+0x110>)
 8002852:	4684      	mov	ip, r0
 8002854:	4464      	add	r4, ip
 8002856:	40a3      	lsls	r3, r4
 8002858:	432b      	orrs	r3, r5
 800285a:	1e5d      	subs	r5, r3, #1
 800285c:	41ab      	sbcs	r3, r5
 800285e:	2600      	movs	r6, #0
 8002860:	4313      	orrs	r3, r2
 8002862:	e79d      	b.n	80027a0 <__aeabi_d2f+0x38>
 8002864:	2300      	movs	r3, #0
 8002866:	e7f7      	b.n	8002858 <__aeabi_d2f+0xf0>
 8002868:	2300      	movs	r3, #0
 800286a:	e7ad      	b.n	80027c8 <__aeabi_d2f+0x60>
 800286c:	0034      	movs	r4, r6
 800286e:	e7bf      	b.n	80027f0 <__aeabi_d2f+0x88>
 8002870:	fffffc80 	.word	0xfffffc80
 8002874:	fffffc82 	.word	0xfffffc82
 8002878:	fffffca2 	.word	0xfffffca2

0800287c <__clzsi2>:
 800287c:	211c      	movs	r1, #28
 800287e:	2301      	movs	r3, #1
 8002880:	041b      	lsls	r3, r3, #16
 8002882:	4298      	cmp	r0, r3
 8002884:	d301      	bcc.n	800288a <__clzsi2+0xe>
 8002886:	0c00      	lsrs	r0, r0, #16
 8002888:	3910      	subs	r1, #16
 800288a:	0a1b      	lsrs	r3, r3, #8
 800288c:	4298      	cmp	r0, r3
 800288e:	d301      	bcc.n	8002894 <__clzsi2+0x18>
 8002890:	0a00      	lsrs	r0, r0, #8
 8002892:	3908      	subs	r1, #8
 8002894:	091b      	lsrs	r3, r3, #4
 8002896:	4298      	cmp	r0, r3
 8002898:	d301      	bcc.n	800289e <__clzsi2+0x22>
 800289a:	0900      	lsrs	r0, r0, #4
 800289c:	3904      	subs	r1, #4
 800289e:	a202      	add	r2, pc, #8	; (adr r2, 80028a8 <__clzsi2+0x2c>)
 80028a0:	5c10      	ldrb	r0, [r2, r0]
 80028a2:	1840      	adds	r0, r0, r1
 80028a4:	4770      	bx	lr
 80028a6:	46c0      	nop			; (mov r8, r8)
 80028a8:	02020304 	.word	0x02020304
 80028ac:	01010101 	.word	0x01010101
	...

080028b8 <EXTI_Init>:
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure that 
  *         contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 80028b8:	b580      	push	{r7, lr}
 80028ba:	b084      	sub	sp, #16
 80028bc:	af00      	add	r7, sp, #0
 80028be:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 80028c0:	2300      	movs	r3, #0
 80028c2:	60fb      	str	r3, [r7, #12]
  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));
  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
 80028c4:	4b33      	ldr	r3, [pc, #204]	; (8002994 <EXTI_Init+0xdc>)
 80028c6:	60fb      	str	r3, [r7, #12]

  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 80028c8:	687b      	ldr	r3, [r7, #4]
 80028ca:	799b      	ldrb	r3, [r3, #6]
 80028cc:	2b00      	cmp	r3, #0
 80028ce:	d04f      	beq.n	8002970 <EXTI_Init+0xb8>
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 80028d0:	4a30      	ldr	r2, [pc, #192]	; (8002994 <EXTI_Init+0xdc>)
 80028d2:	4b30      	ldr	r3, [pc, #192]	; (8002994 <EXTI_Init+0xdc>)
 80028d4:	6819      	ldr	r1, [r3, #0]
 80028d6:	687b      	ldr	r3, [r7, #4]
 80028d8:	681b      	ldr	r3, [r3, #0]
 80028da:	43db      	mvns	r3, r3
 80028dc:	400b      	ands	r3, r1
 80028de:	6013      	str	r3, [r2, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 80028e0:	4a2c      	ldr	r2, [pc, #176]	; (8002994 <EXTI_Init+0xdc>)
 80028e2:	4b2c      	ldr	r3, [pc, #176]	; (8002994 <EXTI_Init+0xdc>)
 80028e4:	6859      	ldr	r1, [r3, #4]
 80028e6:	687b      	ldr	r3, [r7, #4]
 80028e8:	681b      	ldr	r3, [r3, #0]
 80028ea:	43db      	mvns	r3, r3
 80028ec:	400b      	ands	r3, r1
 80028ee:	6053      	str	r3, [r2, #4]

    tmp += EXTI_InitStruct->EXTI_Mode;
 80028f0:	687b      	ldr	r3, [r7, #4]
 80028f2:	791b      	ldrb	r3, [r3, #4]
 80028f4:	001a      	movs	r2, r3
 80028f6:	68fb      	ldr	r3, [r7, #12]
 80028f8:	189b      	adds	r3, r3, r2
 80028fa:	60fb      	str	r3, [r7, #12]

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80028fc:	68fb      	ldr	r3, [r7, #12]
 80028fe:	68fa      	ldr	r2, [r7, #12]
 8002900:	6811      	ldr	r1, [r2, #0]
 8002902:	687a      	ldr	r2, [r7, #4]
 8002904:	6812      	ldr	r2, [r2, #0]
 8002906:	430a      	orrs	r2, r1
 8002908:	601a      	str	r2, [r3, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 800290a:	4a22      	ldr	r2, [pc, #136]	; (8002994 <EXTI_Init+0xdc>)
 800290c:	4b21      	ldr	r3, [pc, #132]	; (8002994 <EXTI_Init+0xdc>)
 800290e:	6899      	ldr	r1, [r3, #8]
 8002910:	687b      	ldr	r3, [r7, #4]
 8002912:	681b      	ldr	r3, [r3, #0]
 8002914:	43db      	mvns	r3, r3
 8002916:	400b      	ands	r3, r1
 8002918:	6093      	str	r3, [r2, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 800291a:	4a1e      	ldr	r2, [pc, #120]	; (8002994 <EXTI_Init+0xdc>)
 800291c:	4b1d      	ldr	r3, [pc, #116]	; (8002994 <EXTI_Init+0xdc>)
 800291e:	68d9      	ldr	r1, [r3, #12]
 8002920:	687b      	ldr	r3, [r7, #4]
 8002922:	681b      	ldr	r3, [r3, #0]
 8002924:	43db      	mvns	r3, r3
 8002926:	400b      	ands	r3, r1
 8002928:	60d3      	str	r3, [r2, #12]

    /* Select the trigger for the selected interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 800292a:	687b      	ldr	r3, [r7, #4]
 800292c:	795b      	ldrb	r3, [r3, #5]
 800292e:	2b10      	cmp	r3, #16
 8002930:	d10e      	bne.n	8002950 <EXTI_Init+0x98>
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 8002932:	4a18      	ldr	r2, [pc, #96]	; (8002994 <EXTI_Init+0xdc>)
 8002934:	4b17      	ldr	r3, [pc, #92]	; (8002994 <EXTI_Init+0xdc>)
 8002936:	6899      	ldr	r1, [r3, #8]
 8002938:	687b      	ldr	r3, [r7, #4]
 800293a:	681b      	ldr	r3, [r3, #0]
 800293c:	430b      	orrs	r3, r1
 800293e:	6093      	str	r3, [r2, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 8002940:	4a14      	ldr	r2, [pc, #80]	; (8002994 <EXTI_Init+0xdc>)
 8002942:	4b14      	ldr	r3, [pc, #80]	; (8002994 <EXTI_Init+0xdc>)
 8002944:	68d9      	ldr	r1, [r3, #12]
 8002946:	687b      	ldr	r3, [r7, #4]
 8002948:	681b      	ldr	r3, [r3, #0]
 800294a:	430b      	orrs	r3, r1
 800294c:	60d3      	str	r3, [r2, #12]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 800294e:	e01d      	b.n	800298c <EXTI_Init+0xd4>
      tmp = (uint32_t)EXTI_BASE;
 8002950:	4b10      	ldr	r3, [pc, #64]	; (8002994 <EXTI_Init+0xdc>)
 8002952:	60fb      	str	r3, [r7, #12]
      tmp += EXTI_InitStruct->EXTI_Trigger;
 8002954:	687b      	ldr	r3, [r7, #4]
 8002956:	795b      	ldrb	r3, [r3, #5]
 8002958:	001a      	movs	r2, r3
 800295a:	68fb      	ldr	r3, [r7, #12]
 800295c:	189b      	adds	r3, r3, r2
 800295e:	60fb      	str	r3, [r7, #12]
      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8002960:	68fb      	ldr	r3, [r7, #12]
 8002962:	68fa      	ldr	r2, [r7, #12]
 8002964:	6811      	ldr	r1, [r2, #0]
 8002966:	687a      	ldr	r2, [r7, #4]
 8002968:	6812      	ldr	r2, [r2, #0]
 800296a:	430a      	orrs	r2, r1
 800296c:	601a      	str	r2, [r3, #0]
}
 800296e:	e00d      	b.n	800298c <EXTI_Init+0xd4>
    tmp += EXTI_InitStruct->EXTI_Mode;
 8002970:	687b      	ldr	r3, [r7, #4]
 8002972:	791b      	ldrb	r3, [r3, #4]
 8002974:	001a      	movs	r2, r3
 8002976:	68fb      	ldr	r3, [r7, #12]
 8002978:	189b      	adds	r3, r3, r2
 800297a:	60fb      	str	r3, [r7, #12]
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 800297c:	68fb      	ldr	r3, [r7, #12]
 800297e:	68fa      	ldr	r2, [r7, #12]
 8002980:	6811      	ldr	r1, [r2, #0]
 8002982:	687a      	ldr	r2, [r7, #4]
 8002984:	6812      	ldr	r2, [r2, #0]
 8002986:	43d2      	mvns	r2, r2
 8002988:	400a      	ands	r2, r1
 800298a:	601a      	str	r2, [r3, #0]
}
 800298c:	46c0      	nop			; (mov r8, r8)
 800298e:	46bd      	mov	sp, r7
 8002990:	b004      	add	sp, #16
 8002992:	bd80      	pop	{r7, pc}
 8002994:	40010400 	.word	0x40010400

08002998 <EXTI_GetITStatus>:
  * @param  EXTI_Line: specifies the EXTI line to check.
  *          This parameter can be EXTI_Linex where x can be (0..27).
  * @retval The new state of EXTI_Line (SET or RESET).
  */
ITStatus EXTI_GetITStatus(uint32_t EXTI_Line)
{
 8002998:	b580      	push	{r7, lr}
 800299a:	b084      	sub	sp, #16
 800299c:	af00      	add	r7, sp, #0
 800299e:	6078      	str	r0, [r7, #4]
  ITStatus bitstatus = RESET;
 80029a0:	230f      	movs	r3, #15
 80029a2:	18fb      	adds	r3, r7, r3
 80029a4:	2200      	movs	r2, #0
 80029a6:	701a      	strb	r2, [r3, #0]

  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));

  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 80029a8:	4b0a      	ldr	r3, [pc, #40]	; (80029d4 <EXTI_GetITStatus+0x3c>)
 80029aa:	695b      	ldr	r3, [r3, #20]
 80029ac:	687a      	ldr	r2, [r7, #4]
 80029ae:	4013      	ands	r3, r2
 80029b0:	d004      	beq.n	80029bc <EXTI_GetITStatus+0x24>
  {
    bitstatus = SET;
 80029b2:	230f      	movs	r3, #15
 80029b4:	18fb      	adds	r3, r7, r3
 80029b6:	2201      	movs	r2, #1
 80029b8:	701a      	strb	r2, [r3, #0]
 80029ba:	e003      	b.n	80029c4 <EXTI_GetITStatus+0x2c>
  }
  else
  {
    bitstatus = RESET;
 80029bc:	230f      	movs	r3, #15
 80029be:	18fb      	adds	r3, r7, r3
 80029c0:	2200      	movs	r2, #0
 80029c2:	701a      	strb	r2, [r3, #0]
  }
  return bitstatus;
 80029c4:	230f      	movs	r3, #15
 80029c6:	18fb      	adds	r3, r7, r3
 80029c8:	781b      	ldrb	r3, [r3, #0]
}
 80029ca:	0018      	movs	r0, r3
 80029cc:	46bd      	mov	sp, r7
 80029ce:	b004      	add	sp, #16
 80029d0:	bd80      	pop	{r7, pc}
 80029d2:	46c0      	nop			; (mov r8, r8)
 80029d4:	40010400 	.word	0x40010400

080029d8 <EXTI_ClearITPendingBit>:
  * @param  EXTI_Line: specifies the EXTI lines to clear.
  *          This parameter can be any combination of EXTI_Linex where x can be (0..27).
  * @retval None
  */
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
 80029d8:	b580      	push	{r7, lr}
 80029da:	b082      	sub	sp, #8
 80029dc:	af00      	add	r7, sp, #0
 80029de:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));

  EXTI->PR = EXTI_Line;
 80029e0:	4b03      	ldr	r3, [pc, #12]	; (80029f0 <EXTI_ClearITPendingBit+0x18>)
 80029e2:	687a      	ldr	r2, [r7, #4]
 80029e4:	615a      	str	r2, [r3, #20]
}
 80029e6:	46c0      	nop			; (mov r8, r8)
 80029e8:	46bd      	mov	sp, r7
 80029ea:	b002      	add	sp, #8
 80029ec:	bd80      	pop	{r7, pc}
 80029ee:	46c0      	nop			; (mov r8, r8)
 80029f0:	40010400 	.word	0x40010400

080029f4 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 80029f4:	b580      	push	{r7, lr}
 80029f6:	b086      	sub	sp, #24
 80029f8:	af00      	add	r7, sp, #0
 80029fa:	6078      	str	r0, [r7, #4]
 80029fc:	6039      	str	r1, [r7, #0]
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 80029fe:	2300      	movs	r3, #0
 8002a00:	617b      	str	r3, [r7, #20]
 8002a02:	2300      	movs	r3, #0
 8002a04:	613b      	str	r3, [r7, #16]
 8002a06:	2300      	movs	r3, #0
 8002a08:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8002a0a:	2300      	movs	r3, #0
 8002a0c:	617b      	str	r3, [r7, #20]
 8002a0e:	e07c      	b.n	8002b0a <GPIO_Init+0x116>
  {
    pos = ((uint32_t)0x01) << pinpos;
 8002a10:	2201      	movs	r2, #1
 8002a12:	697b      	ldr	r3, [r7, #20]
 8002a14:	409a      	lsls	r2, r3
 8002a16:	0013      	movs	r3, r2
 8002a18:	613b      	str	r3, [r7, #16]

    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8002a1a:	683b      	ldr	r3, [r7, #0]
 8002a1c:	681b      	ldr	r3, [r3, #0]
 8002a1e:	693a      	ldr	r2, [r7, #16]
 8002a20:	4013      	ands	r3, r2
 8002a22:	60fb      	str	r3, [r7, #12]

    if (currentpin == pos)
 8002a24:	68fa      	ldr	r2, [r7, #12]
 8002a26:	693b      	ldr	r3, [r7, #16]
 8002a28:	429a      	cmp	r2, r3
 8002a2a:	d16b      	bne.n	8002b04 <GPIO_Init+0x110>
    {
      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8002a2c:	683b      	ldr	r3, [r7, #0]
 8002a2e:	791b      	ldrb	r3, [r3, #4]
 8002a30:	2b01      	cmp	r3, #1
 8002a32:	d003      	beq.n	8002a3c <GPIO_Init+0x48>
 8002a34:	683b      	ldr	r3, [r7, #0]
 8002a36:	791b      	ldrb	r3, [r3, #4]
 8002a38:	2b02      	cmp	r3, #2
 8002a3a:	d134      	bne.n	8002aa6 <GPIO_Init+0xb2>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8002a3c:	687b      	ldr	r3, [r7, #4]
 8002a3e:	689b      	ldr	r3, [r3, #8]
 8002a40:	697a      	ldr	r2, [r7, #20]
 8002a42:	0052      	lsls	r2, r2, #1
 8002a44:	2103      	movs	r1, #3
 8002a46:	4091      	lsls	r1, r2
 8002a48:	000a      	movs	r2, r1
 8002a4a:	43d2      	mvns	r2, r2
 8002a4c:	401a      	ands	r2, r3
 8002a4e:	687b      	ldr	r3, [r7, #4]
 8002a50:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8002a52:	687b      	ldr	r3, [r7, #4]
 8002a54:	689a      	ldr	r2, [r3, #8]
 8002a56:	683b      	ldr	r3, [r7, #0]
 8002a58:	795b      	ldrb	r3, [r3, #5]
 8002a5a:	0019      	movs	r1, r3
 8002a5c:	697b      	ldr	r3, [r7, #20]
 8002a5e:	005b      	lsls	r3, r3, #1
 8002a60:	4099      	lsls	r1, r3
 8002a62:	000b      	movs	r3, r1
 8002a64:	431a      	orrs	r2, r3
 8002a66:	687b      	ldr	r3, [r7, #4]
 8002a68:	609a      	str	r2, [r3, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration */
        GPIOx->OTYPER &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos));
 8002a6a:	687b      	ldr	r3, [r7, #4]
 8002a6c:	889b      	ldrh	r3, [r3, #4]
 8002a6e:	b29b      	uxth	r3, r3
 8002a70:	697a      	ldr	r2, [r7, #20]
 8002a72:	b292      	uxth	r2, r2
 8002a74:	0011      	movs	r1, r2
 8002a76:	2201      	movs	r2, #1
 8002a78:	408a      	lsls	r2, r1
 8002a7a:	b292      	uxth	r2, r2
 8002a7c:	43d2      	mvns	r2, r2
 8002a7e:	b292      	uxth	r2, r2
 8002a80:	4013      	ands	r3, r2
 8002a82:	b29a      	uxth	r2, r3
 8002a84:	687b      	ldr	r3, [r7, #4]
 8002a86:	809a      	strh	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8002a88:	687b      	ldr	r3, [r7, #4]
 8002a8a:	889b      	ldrh	r3, [r3, #4]
 8002a8c:	b29a      	uxth	r2, r3
 8002a8e:	683b      	ldr	r3, [r7, #0]
 8002a90:	799b      	ldrb	r3, [r3, #6]
 8002a92:	0019      	movs	r1, r3
 8002a94:	697b      	ldr	r3, [r7, #20]
 8002a96:	b29b      	uxth	r3, r3
 8002a98:	4099      	lsls	r1, r3
 8002a9a:	000b      	movs	r3, r1
 8002a9c:	b29b      	uxth	r3, r3
 8002a9e:	4313      	orrs	r3, r2
 8002aa0:	b29a      	uxth	r2, r3
 8002aa2:	687b      	ldr	r3, [r7, #4]
 8002aa4:	809a      	strh	r2, [r3, #4]
      }

      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8002aa6:	687b      	ldr	r3, [r7, #4]
 8002aa8:	681b      	ldr	r3, [r3, #0]
 8002aaa:	697a      	ldr	r2, [r7, #20]
 8002aac:	0052      	lsls	r2, r2, #1
 8002aae:	2103      	movs	r1, #3
 8002ab0:	4091      	lsls	r1, r2
 8002ab2:	000a      	movs	r2, r1
 8002ab4:	43d2      	mvns	r2, r2
 8002ab6:	401a      	ands	r2, r3
 8002ab8:	687b      	ldr	r3, [r7, #4]
 8002aba:	601a      	str	r2, [r3, #0]

      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8002abc:	687b      	ldr	r3, [r7, #4]
 8002abe:	681a      	ldr	r2, [r3, #0]
 8002ac0:	683b      	ldr	r3, [r7, #0]
 8002ac2:	791b      	ldrb	r3, [r3, #4]
 8002ac4:	0019      	movs	r1, r3
 8002ac6:	697b      	ldr	r3, [r7, #20]
 8002ac8:	005b      	lsls	r3, r3, #1
 8002aca:	4099      	lsls	r1, r3
 8002acc:	000b      	movs	r3, r1
 8002ace:	431a      	orrs	r2, r3
 8002ad0:	687b      	ldr	r3, [r7, #4]
 8002ad2:	601a      	str	r2, [r3, #0]

      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8002ad4:	687b      	ldr	r3, [r7, #4]
 8002ad6:	68db      	ldr	r3, [r3, #12]
 8002ad8:	697a      	ldr	r2, [r7, #20]
 8002ada:	b292      	uxth	r2, r2
 8002adc:	0052      	lsls	r2, r2, #1
 8002ade:	2103      	movs	r1, #3
 8002ae0:	4091      	lsls	r1, r2
 8002ae2:	000a      	movs	r2, r1
 8002ae4:	43d2      	mvns	r2, r2
 8002ae6:	401a      	ands	r2, r3
 8002ae8:	687b      	ldr	r3, [r7, #4]
 8002aea:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8002aec:	687b      	ldr	r3, [r7, #4]
 8002aee:	68da      	ldr	r2, [r3, #12]
 8002af0:	683b      	ldr	r3, [r7, #0]
 8002af2:	79db      	ldrb	r3, [r3, #7]
 8002af4:	0019      	movs	r1, r3
 8002af6:	697b      	ldr	r3, [r7, #20]
 8002af8:	005b      	lsls	r3, r3, #1
 8002afa:	4099      	lsls	r1, r3
 8002afc:	000b      	movs	r3, r1
 8002afe:	431a      	orrs	r2, r3
 8002b00:	687b      	ldr	r3, [r7, #4]
 8002b02:	60da      	str	r2, [r3, #12]
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8002b04:	697b      	ldr	r3, [r7, #20]
 8002b06:	3301      	adds	r3, #1
 8002b08:	617b      	str	r3, [r7, #20]
 8002b0a:	697b      	ldr	r3, [r7, #20]
 8002b0c:	2b0f      	cmp	r3, #15
 8002b0e:	d800      	bhi.n	8002b12 <GPIO_Init+0x11e>
 8002b10:	e77e      	b.n	8002a10 <GPIO_Init+0x1c>
    }
  }
}
 8002b12:	46c0      	nop			; (mov r8, r8)
 8002b14:	46bd      	mov	sp, r7
 8002b16:	b006      	add	sp, #24
 8002b18:	bd80      	pop	{r7, pc}

08002b1a <GPIO_ReadInputData>:
  * @note   GPIOE is available only for STM32F072.
  * @note   GPIOD is not available for STM32F031.   
  * @retval The input port pin value.
  */
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
 8002b1a:	b580      	push	{r7, lr}
 8002b1c:	b082      	sub	sp, #8
 8002b1e:	af00      	add	r7, sp, #0
 8002b20:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 8002b22:	687b      	ldr	r3, [r7, #4]
 8002b24:	8a1b      	ldrh	r3, [r3, #16]
 8002b26:	b29b      	uxth	r3, r3
}
 8002b28:	0018      	movs	r0, r3
 8002b2a:	46bd      	mov	sp, r7
 8002b2c:	b002      	add	sp, #8
 8002b2e:	bd80      	pop	{r7, pc}

08002b30 <GPIO_ReadOutputData>:
  * @note   GPIOE is available only for STM32F072.
  * @note   GPIOD is not available for STM32F031.    
  * @retval GPIO output data port value.
  */
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
 8002b30:	b580      	push	{r7, lr}
 8002b32:	b082      	sub	sp, #8
 8002b34:	af00      	add	r7, sp, #0
 8002b36:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 8002b38:	687b      	ldr	r3, [r7, #4]
 8002b3a:	8a9b      	ldrh	r3, [r3, #20]
 8002b3c:	b29b      	uxth	r3, r3
}
 8002b3e:	0018      	movs	r0, r3
 8002b40:	46bd      	mov	sp, r7
 8002b42:	b002      	add	sp, #8
 8002b44:	bd80      	pop	{r7, pc}

08002b46 <GPIO_SetBits>:
  *         For STM32F072: (0..15) for GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, (0..10) for GPIOF.
  *         For STM32F031: (0..15) for GPIOA, GPIOB, (13..15) for GPIOC and (0..1, 6..7) for GPIOF. 
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8002b46:	b580      	push	{r7, lr}
 8002b48:	b082      	sub	sp, #8
 8002b4a:	af00      	add	r7, sp, #0
 8002b4c:	6078      	str	r0, [r7, #4]
 8002b4e:	000a      	movs	r2, r1
 8002b50:	1cbb      	adds	r3, r7, #2
 8002b52:	801a      	strh	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRR = GPIO_Pin;
 8002b54:	1cbb      	adds	r3, r7, #2
 8002b56:	881a      	ldrh	r2, [r3, #0]
 8002b58:	687b      	ldr	r3, [r7, #4]
 8002b5a:	619a      	str	r2, [r3, #24]
}
 8002b5c:	46c0      	nop			; (mov r8, r8)
 8002b5e:	46bd      	mov	sp, r7
 8002b60:	b002      	add	sp, #8
 8002b62:	bd80      	pop	{r7, pc}

08002b64 <GPIO_ResetBits>:
  *         For STM32F072: (0..15) for GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, (0..10) for GPIOF.
  *         For STM32F031: (0..15) for GPIOA, GPIOB, (13..15) for GPIOC and (0..1, 6..7) for GPIOF. 
  * @retval None
  */
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8002b64:	b580      	push	{r7, lr}
 8002b66:	b082      	sub	sp, #8
 8002b68:	af00      	add	r7, sp, #0
 8002b6a:	6078      	str	r0, [r7, #4]
 8002b6c:	000a      	movs	r2, r1
 8002b6e:	1cbb      	adds	r3, r7, #2
 8002b70:	801a      	strh	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BRR = GPIO_Pin;
 8002b72:	687b      	ldr	r3, [r7, #4]
 8002b74:	1cba      	adds	r2, r7, #2
 8002b76:	8812      	ldrh	r2, [r2, #0]
 8002b78:	851a      	strh	r2, [r3, #40]	; 0x28
}
 8002b7a:	46c0      	nop			; (mov r8, r8)
 8002b7c:	46bd      	mov	sp, r7
 8002b7e:	b002      	add	sp, #8
 8002b80:	bd80      	pop	{r7, pc}

08002b82 <GPIO_WriteBit>:
  *         For STM32F072: (0..15) for GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, (0..10) for GPIOF.
  *         For STM32F031: (0..15) for GPIOA, GPIOB, (13..15) for GPIOC and (0..1, 6..7) for GPIOF.
  * @retval None
  */
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
{
 8002b82:	b580      	push	{r7, lr}
 8002b84:	b082      	sub	sp, #8
 8002b86:	af00      	add	r7, sp, #0
 8002b88:	6078      	str	r0, [r7, #4]
 8002b8a:	0008      	movs	r0, r1
 8002b8c:	0011      	movs	r1, r2
 8002b8e:	1cbb      	adds	r3, r7, #2
 8002b90:	1c02      	adds	r2, r0, #0
 8002b92:	801a      	strh	r2, [r3, #0]
 8002b94:	1c7b      	adds	r3, r7, #1
 8002b96:	1c0a      	adds	r2, r1, #0
 8002b98:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 8002b9a:	1c7b      	adds	r3, r7, #1
 8002b9c:	781b      	ldrb	r3, [r3, #0]
 8002b9e:	2b00      	cmp	r3, #0
 8002ba0:	d004      	beq.n	8002bac <GPIO_WriteBit+0x2a>
  {
    GPIOx->BSRR = GPIO_Pin;
 8002ba2:	1cbb      	adds	r3, r7, #2
 8002ba4:	881a      	ldrh	r2, [r3, #0]
 8002ba6:	687b      	ldr	r3, [r7, #4]
 8002ba8:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
  }
}
 8002baa:	e003      	b.n	8002bb4 <GPIO_WriteBit+0x32>
    GPIOx->BRR = GPIO_Pin ;
 8002bac:	687b      	ldr	r3, [r7, #4]
 8002bae:	1cba      	adds	r2, r7, #2
 8002bb0:	8812      	ldrh	r2, [r2, #0]
 8002bb2:	851a      	strh	r2, [r3, #40]	; 0x28
}
 8002bb4:	46c0      	nop			; (mov r8, r8)
 8002bb6:	46bd      	mov	sp, r7
 8002bb8:	b002      	add	sp, #8
 8002bba:	bd80      	pop	{r7, pc}

08002bbc <GPIO_Write>:
  * @note   GPIOD is not available for STM32F031.  
  * @param  PortVal: specifies the value to be written to the port output data register.
  * @retval None
  */
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
 8002bbc:	b580      	push	{r7, lr}
 8002bbe:	b082      	sub	sp, #8
 8002bc0:	af00      	add	r7, sp, #0
 8002bc2:	6078      	str	r0, [r7, #4]
 8002bc4:	000a      	movs	r2, r1
 8002bc6:	1cbb      	adds	r3, r7, #2
 8002bc8:	801a      	strh	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 8002bca:	687b      	ldr	r3, [r7, #4]
 8002bcc:	1cba      	adds	r2, r7, #2
 8002bce:	8812      	ldrh	r2, [r2, #0]
 8002bd0:	829a      	strh	r2, [r3, #20]
}
 8002bd2:	46c0      	nop			; (mov r8, r8)
 8002bd4:	46bd      	mov	sp, r7
 8002bd6:	b002      	add	sp, #8
 8002bd8:	bd80      	pop	{r7, pc}

08002bda <GPIO_PinAFConfig>:
  *         for the detailed mapping of the system and peripherals'alternate 
  *         function I/O pins.
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8002bda:	b580      	push	{r7, lr}
 8002bdc:	b084      	sub	sp, #16
 8002bde:	af00      	add	r7, sp, #0
 8002be0:	6078      	str	r0, [r7, #4]
 8002be2:	0008      	movs	r0, r1
 8002be4:	0011      	movs	r1, r2
 8002be6:	1cbb      	adds	r3, r7, #2
 8002be8:	1c02      	adds	r2, r0, #0
 8002bea:	801a      	strh	r2, [r3, #0]
 8002bec:	1c7b      	adds	r3, r7, #1
 8002bee:	1c0a      	adds	r2, r1, #0
 8002bf0:	701a      	strb	r2, [r3, #0]
  uint32_t temp = 0x00;
 8002bf2:	2300      	movs	r3, #0
 8002bf4:	60fb      	str	r3, [r7, #12]
  uint32_t temp_2 = 0x00;
 8002bf6:	2300      	movs	r3, #0
 8002bf8:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));

  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8002bfa:	1c7b      	adds	r3, r7, #1
 8002bfc:	781a      	ldrb	r2, [r3, #0]
 8002bfe:	1cbb      	adds	r3, r7, #2
 8002c00:	881b      	ldrh	r3, [r3, #0]
 8002c02:	2107      	movs	r1, #7
 8002c04:	400b      	ands	r3, r1
 8002c06:	009b      	lsls	r3, r3, #2
 8002c08:	409a      	lsls	r2, r3
 8002c0a:	0013      	movs	r3, r2
 8002c0c:	60fb      	str	r3, [r7, #12]
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8002c0e:	1cbb      	adds	r3, r7, #2
 8002c10:	881b      	ldrh	r3, [r3, #0]
 8002c12:	08db      	lsrs	r3, r3, #3
 8002c14:	b29b      	uxth	r3, r3
 8002c16:	0018      	movs	r0, r3
 8002c18:	1cbb      	adds	r3, r7, #2
 8002c1a:	881b      	ldrh	r3, [r3, #0]
 8002c1c:	08db      	lsrs	r3, r3, #3
 8002c1e:	b29b      	uxth	r3, r3
 8002c20:	001a      	movs	r2, r3
 8002c22:	687b      	ldr	r3, [r7, #4]
 8002c24:	3208      	adds	r2, #8
 8002c26:	0092      	lsls	r2, r2, #2
 8002c28:	58d3      	ldr	r3, [r2, r3]
 8002c2a:	1cba      	adds	r2, r7, #2
 8002c2c:	8812      	ldrh	r2, [r2, #0]
 8002c2e:	2107      	movs	r1, #7
 8002c30:	400a      	ands	r2, r1
 8002c32:	0092      	lsls	r2, r2, #2
 8002c34:	210f      	movs	r1, #15
 8002c36:	4091      	lsls	r1, r2
 8002c38:	000a      	movs	r2, r1
 8002c3a:	43d2      	mvns	r2, r2
 8002c3c:	401a      	ands	r2, r3
 8002c3e:	0011      	movs	r1, r2
 8002c40:	687b      	ldr	r3, [r7, #4]
 8002c42:	0002      	movs	r2, r0
 8002c44:	3208      	adds	r2, #8
 8002c46:	0092      	lsls	r2, r2, #2
 8002c48:	50d1      	str	r1, [r2, r3]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8002c4a:	1cbb      	adds	r3, r7, #2
 8002c4c:	881b      	ldrh	r3, [r3, #0]
 8002c4e:	08db      	lsrs	r3, r3, #3
 8002c50:	b29b      	uxth	r3, r3
 8002c52:	001a      	movs	r2, r3
 8002c54:	687b      	ldr	r3, [r7, #4]
 8002c56:	3208      	adds	r2, #8
 8002c58:	0092      	lsls	r2, r2, #2
 8002c5a:	58d2      	ldr	r2, [r2, r3]
 8002c5c:	68fb      	ldr	r3, [r7, #12]
 8002c5e:	4313      	orrs	r3, r2
 8002c60:	60bb      	str	r3, [r7, #8]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8002c62:	1cbb      	adds	r3, r7, #2
 8002c64:	881b      	ldrh	r3, [r3, #0]
 8002c66:	08db      	lsrs	r3, r3, #3
 8002c68:	b29b      	uxth	r3, r3
 8002c6a:	001a      	movs	r2, r3
 8002c6c:	687b      	ldr	r3, [r7, #4]
 8002c6e:	3208      	adds	r2, #8
 8002c70:	0092      	lsls	r2, r2, #2
 8002c72:	68b9      	ldr	r1, [r7, #8]
 8002c74:	50d1      	str	r1, [r2, r3]
}
 8002c76:	46c0      	nop			; (mov r8, r8)
 8002c78:	46bd      	mov	sp, r7
 8002c7a:	b004      	add	sp, #16
 8002c7c:	bd80      	pop	{r7, pc}
	...

08002c80 <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8002c80:	b580      	push	{r7, lr}
 8002c82:	b084      	sub	sp, #16
 8002c84:	af00      	add	r7, sp, #0
 8002c86:	6078      	str	r0, [r7, #4]
  uint32_t tmppriority = 0x00;
 8002c88:	2300      	movs	r3, #0
 8002c8a:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPriority));  
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8002c8c:	687b      	ldr	r3, [r7, #4]
 8002c8e:	789b      	ldrb	r3, [r3, #2]
 8002c90:	2b00      	cmp	r3, #0
 8002c92:	d039      	beq.n	8002d08 <NVIC_Init+0x88>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel >> 0x02];
 8002c94:	4a24      	ldr	r2, [pc, #144]	; (8002d28 <NVIC_Init+0xa8>)
 8002c96:	687b      	ldr	r3, [r7, #4]
 8002c98:	781b      	ldrb	r3, [r3, #0]
 8002c9a:	089b      	lsrs	r3, r3, #2
 8002c9c:	b2db      	uxtb	r3, r3
 8002c9e:	33c0      	adds	r3, #192	; 0xc0
 8002ca0:	009b      	lsls	r3, r3, #2
 8002ca2:	589b      	ldr	r3, [r3, r2]
 8002ca4:	60fb      	str	r3, [r7, #12]
    tmppriority &= (uint32_t)(~(((uint32_t)0xFF) << ((NVIC_InitStruct->NVIC_IRQChannel & 0x03) * 8)));
 8002ca6:	687b      	ldr	r3, [r7, #4]
 8002ca8:	781b      	ldrb	r3, [r3, #0]
 8002caa:	001a      	movs	r2, r3
 8002cac:	2303      	movs	r3, #3
 8002cae:	4013      	ands	r3, r2
 8002cb0:	00db      	lsls	r3, r3, #3
 8002cb2:	22ff      	movs	r2, #255	; 0xff
 8002cb4:	409a      	lsls	r2, r3
 8002cb6:	0013      	movs	r3, r2
 8002cb8:	43da      	mvns	r2, r3
 8002cba:	68fb      	ldr	r3, [r7, #12]
 8002cbc:	4013      	ands	r3, r2
 8002cbe:	60fb      	str	r3, [r7, #12]
    tmppriority |= (uint32_t)((((uint32_t)NVIC_InitStruct->NVIC_IRQChannelPriority << 6) & 0xFF) << ((NVIC_InitStruct->NVIC_IRQChannel & 0x03) * 8));    
 8002cc0:	687b      	ldr	r3, [r7, #4]
 8002cc2:	785b      	ldrb	r3, [r3, #1]
 8002cc4:	019b      	lsls	r3, r3, #6
 8002cc6:	22ff      	movs	r2, #255	; 0xff
 8002cc8:	401a      	ands	r2, r3
 8002cca:	687b      	ldr	r3, [r7, #4]
 8002ccc:	781b      	ldrb	r3, [r3, #0]
 8002cce:	0019      	movs	r1, r3
 8002cd0:	2303      	movs	r3, #3
 8002cd2:	400b      	ands	r3, r1
 8002cd4:	00db      	lsls	r3, r3, #3
 8002cd6:	409a      	lsls	r2, r3
 8002cd8:	0013      	movs	r3, r2
 8002cda:	68fa      	ldr	r2, [r7, #12]
 8002cdc:	4313      	orrs	r3, r2
 8002cde:	60fb      	str	r3, [r7, #12]
    
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel >> 0x02] = tmppriority;
 8002ce0:	4911      	ldr	r1, [pc, #68]	; (8002d28 <NVIC_Init+0xa8>)
 8002ce2:	687b      	ldr	r3, [r7, #4]
 8002ce4:	781b      	ldrb	r3, [r3, #0]
 8002ce6:	089b      	lsrs	r3, r3, #2
 8002ce8:	b2db      	uxtb	r3, r3
 8002cea:	33c0      	adds	r3, #192	; 0xc0
 8002cec:	009b      	lsls	r3, r3, #2
 8002cee:	68fa      	ldr	r2, [r7, #12]
 8002cf0:	505a      	str	r2, [r3, r1]
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[0] = (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8002cf2:	4b0d      	ldr	r3, [pc, #52]	; (8002d28 <NVIC_Init+0xa8>)
 8002cf4:	687a      	ldr	r2, [r7, #4]
 8002cf6:	7812      	ldrb	r2, [r2, #0]
 8002cf8:	0011      	movs	r1, r2
 8002cfa:	221f      	movs	r2, #31
 8002cfc:	400a      	ands	r2, r1
 8002cfe:	2101      	movs	r1, #1
 8002d00:	4091      	lsls	r1, r2
 8002d02:	000a      	movs	r2, r1
 8002d04:	601a      	str	r2, [r3, #0]
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[0] = (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8002d06:	e00a      	b.n	8002d1e <NVIC_Init+0x9e>
    NVIC->ICER[0] = (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8002d08:	4907      	ldr	r1, [pc, #28]	; (8002d28 <NVIC_Init+0xa8>)
 8002d0a:	687b      	ldr	r3, [r7, #4]
 8002d0c:	781b      	ldrb	r3, [r3, #0]
 8002d0e:	001a      	movs	r2, r3
 8002d10:	231f      	movs	r3, #31
 8002d12:	4013      	ands	r3, r2
 8002d14:	2201      	movs	r2, #1
 8002d16:	409a      	lsls	r2, r3
 8002d18:	0013      	movs	r3, r2
 8002d1a:	2280      	movs	r2, #128	; 0x80
 8002d1c:	508b      	str	r3, [r1, r2]
}
 8002d1e:	46c0      	nop			; (mov r8, r8)
 8002d20:	46bd      	mov	sp, r7
 8002d22:	b004      	add	sp, #16
 8002d24:	bd80      	pop	{r7, pc}
 8002d26:	46c0      	nop			; (mov r8, r8)
 8002d28:	e000e100 	.word	0xe000e100

08002d2c <RCC_HCLKConfig>:
  *            @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
  *            @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
  * @retval None
  */
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
 8002d2c:	b580      	push	{r7, lr}
 8002d2e:	b084      	sub	sp, #16
 8002d30:	af00      	add	r7, sp, #0
 8002d32:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8002d34:	2300      	movs	r3, #0
 8002d36:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  
  tmpreg = RCC->CFGR;
 8002d38:	4b08      	ldr	r3, [pc, #32]	; (8002d5c <RCC_HCLKConfig+0x30>)
 8002d3a:	685b      	ldr	r3, [r3, #4]
 8002d3c:	60fb      	str	r3, [r7, #12]
  
  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 8002d3e:	68fb      	ldr	r3, [r7, #12]
 8002d40:	22f0      	movs	r2, #240	; 0xf0
 8002d42:	4393      	bics	r3, r2
 8002d44:	60fb      	str	r3, [r7, #12]
  
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8002d46:	68fa      	ldr	r2, [r7, #12]
 8002d48:	687b      	ldr	r3, [r7, #4]
 8002d4a:	4313      	orrs	r3, r2
 8002d4c:	60fb      	str	r3, [r7, #12]
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8002d4e:	4b03      	ldr	r3, [pc, #12]	; (8002d5c <RCC_HCLKConfig+0x30>)
 8002d50:	68fa      	ldr	r2, [r7, #12]
 8002d52:	605a      	str	r2, [r3, #4]
}
 8002d54:	46c0      	nop			; (mov r8, r8)
 8002d56:	46bd      	mov	sp, r7
 8002d58:	b004      	add	sp, #16
 8002d5a:	bd80      	pop	{r7, pc}
 8002d5c:	40021000 	.word	0x40021000

08002d60 <RCC_USARTCLKConfig>:
  *             @arg RCC_USART3CLK_LSE: USART3 clock = LSE Clock, applicable only for STM32F091 devices
  *             @arg RCC_USART3CLK_HSI: USART3 clock = HSI Clock, applicable only for STM32F091 devices   
  * @retval None
  */
void RCC_USARTCLKConfig(uint32_t RCC_USARTCLK)
{ 
 8002d60:	b580      	push	{r7, lr}
 8002d62:	b084      	sub	sp, #16
 8002d64:	af00      	add	r7, sp, #0
 8002d66:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0;
 8002d68:	2300      	movs	r3, #0
 8002d6a:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));

  /* Get USART index */
  tmp = (RCC_USARTCLK >> 28);
 8002d6c:	687b      	ldr	r3, [r7, #4]
 8002d6e:	0f1b      	lsrs	r3, r3, #28
 8002d70:	60fb      	str	r3, [r7, #12]

  /* Clear USARTSW[1:0] bit */
  if (tmp == (uint32_t)0x00000001)
 8002d72:	68fb      	ldr	r3, [r7, #12]
 8002d74:	2b01      	cmp	r3, #1
 8002d76:	d106      	bne.n	8002d86 <RCC_USARTCLKConfig+0x26>
  {
    /* Clear USART1SW[1:0] bit */  
    RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
 8002d78:	4b10      	ldr	r3, [pc, #64]	; (8002dbc <RCC_USARTCLKConfig+0x5c>)
 8002d7a:	4a10      	ldr	r2, [pc, #64]	; (8002dbc <RCC_USARTCLKConfig+0x5c>)
 8002d7c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8002d7e:	2103      	movs	r1, #3
 8002d80:	438a      	bics	r2, r1
 8002d82:	631a      	str	r2, [r3, #48]	; 0x30
 8002d84:	e00f      	b.n	8002da6 <RCC_USARTCLKConfig+0x46>
  }
  else if (tmp == (uint32_t)0x00000002)
 8002d86:	68fb      	ldr	r3, [r7, #12]
 8002d88:	2b02      	cmp	r3, #2
 8002d8a:	d106      	bne.n	8002d9a <RCC_USARTCLKConfig+0x3a>
  {
    /* Clear USART2SW[1:0] bit */
    RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
 8002d8c:	4b0b      	ldr	r3, [pc, #44]	; (8002dbc <RCC_USARTCLKConfig+0x5c>)
 8002d8e:	4a0b      	ldr	r2, [pc, #44]	; (8002dbc <RCC_USARTCLKConfig+0x5c>)
 8002d90:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8002d92:	490b      	ldr	r1, [pc, #44]	; (8002dc0 <RCC_USARTCLKConfig+0x60>)
 8002d94:	400a      	ands	r2, r1
 8002d96:	631a      	str	r2, [r3, #48]	; 0x30
 8002d98:	e005      	b.n	8002da6 <RCC_USARTCLKConfig+0x46>
  }
  else 
  {
    /* Clear USART3SW[1:0] bit */
    RCC->CFGR3 &= ~RCC_CFGR3_USART3SW;
 8002d9a:	4b08      	ldr	r3, [pc, #32]	; (8002dbc <RCC_USARTCLKConfig+0x5c>)
 8002d9c:	4a07      	ldr	r2, [pc, #28]	; (8002dbc <RCC_USARTCLKConfig+0x5c>)
 8002d9e:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8002da0:	4908      	ldr	r1, [pc, #32]	; (8002dc4 <RCC_USARTCLKConfig+0x64>)
 8002da2:	400a      	ands	r2, r1
 8002da4:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Set USARTxSW bits according to RCC_USARTCLK value */
  RCC->CFGR3 |= RCC_USARTCLK;
 8002da6:	4b05      	ldr	r3, [pc, #20]	; (8002dbc <RCC_USARTCLKConfig+0x5c>)
 8002da8:	4a04      	ldr	r2, [pc, #16]	; (8002dbc <RCC_USARTCLKConfig+0x5c>)
 8002daa:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8002dac:	687a      	ldr	r2, [r7, #4]
 8002dae:	430a      	orrs	r2, r1
 8002db0:	631a      	str	r2, [r3, #48]	; 0x30
}
 8002db2:	46c0      	nop			; (mov r8, r8)
 8002db4:	46bd      	mov	sp, r7
 8002db6:	b004      	add	sp, #16
 8002db8:	bd80      	pop	{r7, pc}
 8002dba:	46c0      	nop			; (mov r8, r8)
 8002dbc:	40021000 	.word	0x40021000
 8002dc0:	fffcffff 	.word	0xfffcffff
 8002dc4:	fff3ffff 	.word	0xfff3ffff

08002dc8 <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8002dc8:	b580      	push	{r7, lr}
 8002dca:	b088      	sub	sp, #32
 8002dcc:	af00      	add	r7, sp, #0
 8002dce:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
 8002dd0:	2300      	movs	r3, #0
 8002dd2:	61bb      	str	r3, [r7, #24]
 8002dd4:	2300      	movs	r3, #0
 8002dd6:	617b      	str	r3, [r7, #20]
 8002dd8:	2300      	movs	r3, #0
 8002dda:	613b      	str	r3, [r7, #16]
 8002ddc:	2300      	movs	r3, #0
 8002dde:	60fb      	str	r3, [r7, #12]
 8002de0:	2300      	movs	r3, #0
 8002de2:	60bb      	str	r3, [r7, #8]
 8002de4:	2300      	movs	r3, #0
 8002de6:	61fb      	str	r3, [r7, #28]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8002de8:	4ba8      	ldr	r3, [pc, #672]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002dea:	685b      	ldr	r3, [r3, #4]
 8002dec:	220c      	movs	r2, #12
 8002dee:	4013      	ands	r3, r2
 8002df0:	61bb      	str	r3, [r7, #24]
  
  switch (tmp)
 8002df2:	69bb      	ldr	r3, [r7, #24]
 8002df4:	2b04      	cmp	r3, #4
 8002df6:	d00c      	beq.n	8002e12 <RCC_GetClocksFreq+0x4a>
 8002df8:	d802      	bhi.n	8002e00 <RCC_GetClocksFreq+0x38>
 8002dfa:	2b00      	cmp	r3, #0
 8002dfc:	d005      	beq.n	8002e0a <RCC_GetClocksFreq+0x42>
 8002dfe:	e03b      	b.n	8002e78 <RCC_GetClocksFreq+0xb0>
 8002e00:	2b08      	cmp	r3, #8
 8002e02:	d00a      	beq.n	8002e1a <RCC_GetClocksFreq+0x52>
 8002e04:	2b0c      	cmp	r3, #12
 8002e06:	d033      	beq.n	8002e70 <RCC_GetClocksFreq+0xa8>
 8002e08:	e036      	b.n	8002e78 <RCC_GetClocksFreq+0xb0>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8002e0a:	687b      	ldr	r3, [r7, #4]
 8002e0c:	4aa0      	ldr	r2, [pc, #640]	; (8003090 <RCC_GetClocksFreq+0x2c8>)
 8002e0e:	601a      	str	r2, [r3, #0]
      break;
 8002e10:	e036      	b.n	8002e80 <RCC_GetClocksFreq+0xb8>
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8002e12:	687b      	ldr	r3, [r7, #4]
 8002e14:	4a9e      	ldr	r2, [pc, #632]	; (8003090 <RCC_GetClocksFreq+0x2c8>)
 8002e16:	601a      	str	r2, [r3, #0]
      break;
 8002e18:	e032      	b.n	8002e80 <RCC_GetClocksFreq+0xb8>
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 8002e1a:	4b9c      	ldr	r3, [pc, #624]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002e1c:	685a      	ldr	r2, [r3, #4]
 8002e1e:	23f0      	movs	r3, #240	; 0xf0
 8002e20:	039b      	lsls	r3, r3, #14
 8002e22:	4013      	ands	r3, r2
 8002e24:	617b      	str	r3, [r7, #20]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 8002e26:	4b99      	ldr	r3, [pc, #612]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002e28:	685a      	ldr	r2, [r3, #4]
 8002e2a:	23c0      	movs	r3, #192	; 0xc0
 8002e2c:	025b      	lsls	r3, r3, #9
 8002e2e:	4013      	ands	r3, r2
 8002e30:	613b      	str	r3, [r7, #16]
      pllmull = ( pllmull >> 18) + 2;
 8002e32:	697b      	ldr	r3, [r7, #20]
 8002e34:	0c9b      	lsrs	r3, r3, #18
 8002e36:	3302      	adds	r3, #2
 8002e38:	617b      	str	r3, [r7, #20]
      
      if (pllsource == 0x00)
 8002e3a:	693b      	ldr	r3, [r7, #16]
 8002e3c:	2b00      	cmp	r3, #0
 8002e3e:	d104      	bne.n	8002e4a <RCC_GetClocksFreq+0x82>
      {
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        pllclk = (HSI_VALUE >> 1) * pllmull;
 8002e40:	697b      	ldr	r3, [r7, #20]
 8002e42:	4a94      	ldr	r2, [pc, #592]	; (8003094 <RCC_GetClocksFreq+0x2cc>)
 8002e44:	4353      	muls	r3, r2
 8002e46:	61fb      	str	r3, [r7, #28]
 8002e48:	e00e      	b.n	8002e68 <RCC_GetClocksFreq+0xa0>
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 8002e4a:	4b90      	ldr	r3, [pc, #576]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002e4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002e4e:	220f      	movs	r2, #15
 8002e50:	4013      	ands	r3, r2
 8002e52:	3301      	adds	r3, #1
 8002e54:	60fb      	str	r3, [r7, #12]
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
 8002e56:	68f9      	ldr	r1, [r7, #12]
 8002e58:	488d      	ldr	r0, [pc, #564]	; (8003090 <RCC_GetClocksFreq+0x2c8>)
 8002e5a:	f7fd f95f 	bl	800011c <__udivsi3>
 8002e5e:	0003      	movs	r3, r0
 8002e60:	001a      	movs	r2, r3
 8002e62:	697b      	ldr	r3, [r7, #20]
 8002e64:	4353      	muls	r3, r2
 8002e66:	61fb      	str	r3, [r7, #28]
      }
      RCC_Clocks->SYSCLK_Frequency = pllclk;      
 8002e68:	687b      	ldr	r3, [r7, #4]
 8002e6a:	69fa      	ldr	r2, [r7, #28]
 8002e6c:	601a      	str	r2, [r3, #0]
      break;
 8002e6e:	e007      	b.n	8002e80 <RCC_GetClocksFreq+0xb8>
    case 0x0C:  /* HSI48 used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI48_VALUE;
 8002e70:	687b      	ldr	r3, [r7, #4]
 8002e72:	4a89      	ldr	r2, [pc, #548]	; (8003098 <RCC_GetClocksFreq+0x2d0>)
 8002e74:	601a      	str	r2, [r3, #0]
      break;
 8002e76:	e003      	b.n	8002e80 <RCC_GetClocksFreq+0xb8>
    default: /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8002e78:	687b      	ldr	r3, [r7, #4]
 8002e7a:	4a85      	ldr	r2, [pc, #532]	; (8003090 <RCC_GetClocksFreq+0x2c8>)
 8002e7c:	601a      	str	r2, [r3, #0]
      break;
 8002e7e:	46c0      	nop			; (mov r8, r8)
  }
  /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8002e80:	4b82      	ldr	r3, [pc, #520]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002e82:	685b      	ldr	r3, [r3, #4]
 8002e84:	22f0      	movs	r2, #240	; 0xf0
 8002e86:	4013      	ands	r3, r2
 8002e88:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 4;
 8002e8a:	69bb      	ldr	r3, [r7, #24]
 8002e8c:	091b      	lsrs	r3, r3, #4
 8002e8e:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp]; 
 8002e90:	4a82      	ldr	r2, [pc, #520]	; (800309c <RCC_GetClocksFreq+0x2d4>)
 8002e92:	69bb      	ldr	r3, [r7, #24]
 8002e94:	18d3      	adds	r3, r2, r3
 8002e96:	781b      	ldrb	r3, [r3, #0]
 8002e98:	b2db      	uxtb	r3, r3
 8002e9a:	60bb      	str	r3, [r7, #8]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8002e9c:	687b      	ldr	r3, [r7, #4]
 8002e9e:	681a      	ldr	r2, [r3, #0]
 8002ea0:	68bb      	ldr	r3, [r7, #8]
 8002ea2:	40da      	lsrs	r2, r3
 8002ea4:	687b      	ldr	r3, [r7, #4]
 8002ea6:	605a      	str	r2, [r3, #4]

  /* Get PCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE;
 8002ea8:	4b78      	ldr	r3, [pc, #480]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002eaa:	685a      	ldr	r2, [r3, #4]
 8002eac:	23e0      	movs	r3, #224	; 0xe0
 8002eae:	00db      	lsls	r3, r3, #3
 8002eb0:	4013      	ands	r3, r2
 8002eb2:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 8;
 8002eb4:	69bb      	ldr	r3, [r7, #24]
 8002eb6:	0a1b      	lsrs	r3, r3, #8
 8002eb8:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8002eba:	4a78      	ldr	r2, [pc, #480]	; (800309c <RCC_GetClocksFreq+0x2d4>)
 8002ebc:	69bb      	ldr	r3, [r7, #24]
 8002ebe:	18d3      	adds	r3, r2, r3
 8002ec0:	781b      	ldrb	r3, [r3, #0]
 8002ec2:	b2db      	uxtb	r3, r3
 8002ec4:	60bb      	str	r3, [r7, #8]
  /* PCLK clock frequency */
  RCC_Clocks->PCLK_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8002ec6:	687b      	ldr	r3, [r7, #4]
 8002ec8:	685a      	ldr	r2, [r3, #4]
 8002eca:	68bb      	ldr	r3, [r7, #8]
 8002ecc:	40da      	lsrs	r2, r3
 8002ece:	687b      	ldr	r3, [r7, #4]
 8002ed0:	609a      	str	r2, [r3, #8]

  /* ADCCLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_ADCSW) != RCC_CFGR3_ADCSW)
 8002ed2:	4b6e      	ldr	r3, [pc, #440]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002ed4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002ed6:	2380      	movs	r3, #128	; 0x80
 8002ed8:	005b      	lsls	r3, r3, #1
 8002eda:	401a      	ands	r2, r3
 8002edc:	2380      	movs	r3, #128	; 0x80
 8002ede:	005b      	lsls	r3, r3, #1
 8002ee0:	429a      	cmp	r2, r3
 8002ee2:	d003      	beq.n	8002eec <RCC_GetClocksFreq+0x124>
  {
    /* ADC Clock is HSI14 Osc. */
    RCC_Clocks->ADCCLK_Frequency = HSI14_VALUE;
 8002ee4:	687b      	ldr	r3, [r7, #4]
 8002ee6:	4a6e      	ldr	r2, [pc, #440]	; (80030a0 <RCC_GetClocksFreq+0x2d8>)
 8002ee8:	60da      	str	r2, [r3, #12]
 8002eea:	e013      	b.n	8002f14 <RCC_GetClocksFreq+0x14c>
  }
  else
  {
    if((RCC->CFGR & RCC_CFGR_ADCPRE) != RCC_CFGR_ADCPRE)
 8002eec:	4b67      	ldr	r3, [pc, #412]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002eee:	685a      	ldr	r2, [r3, #4]
 8002ef0:	2380      	movs	r3, #128	; 0x80
 8002ef2:	01db      	lsls	r3, r3, #7
 8002ef4:	401a      	ands	r2, r3
 8002ef6:	2380      	movs	r3, #128	; 0x80
 8002ef8:	01db      	lsls	r3, r3, #7
 8002efa:	429a      	cmp	r2, r3
 8002efc:	d005      	beq.n	8002f0a <RCC_GetClocksFreq+0x142>
    {
      /* ADC Clock is derived from PCLK/2 */
      RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK_Frequency >> 1;
 8002efe:	687b      	ldr	r3, [r7, #4]
 8002f00:	689b      	ldr	r3, [r3, #8]
 8002f02:	085a      	lsrs	r2, r3, #1
 8002f04:	687b      	ldr	r3, [r7, #4]
 8002f06:	60da      	str	r2, [r3, #12]
 8002f08:	e004      	b.n	8002f14 <RCC_GetClocksFreq+0x14c>
    }
    else
    {
      /* ADC Clock is derived from PCLK/4 */
      RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK_Frequency >> 2;
 8002f0a:	687b      	ldr	r3, [r7, #4]
 8002f0c:	689b      	ldr	r3, [r3, #8]
 8002f0e:	089a      	lsrs	r2, r3, #2
 8002f10:	687b      	ldr	r3, [r7, #4]
 8002f12:	60da      	str	r2, [r3, #12]
    }
    
  }

  /* CECCLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_CECSW) != RCC_CFGR3_CECSW)
 8002f14:	4b5d      	ldr	r3, [pc, #372]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002f16:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002f18:	2240      	movs	r2, #64	; 0x40
 8002f1a:	4013      	ands	r3, r2
 8002f1c:	2b40      	cmp	r3, #64	; 0x40
 8002f1e:	d003      	beq.n	8002f28 <RCC_GetClocksFreq+0x160>
  {
    /* CEC Clock is HSI/244 */
    RCC_Clocks->CECCLK_Frequency = HSI_VALUE / 244;
 8002f20:	687b      	ldr	r3, [r7, #4]
 8002f22:	4a60      	ldr	r2, [pc, #384]	; (80030a4 <RCC_GetClocksFreq+0x2dc>)
 8002f24:	611a      	str	r2, [r3, #16]
 8002f26:	e003      	b.n	8002f30 <RCC_GetClocksFreq+0x168>
  }
  else
  {
    /* CECC Clock is LSE Osc. */
    RCC_Clocks->CECCLK_Frequency = LSE_VALUE;
 8002f28:	687b      	ldr	r3, [r7, #4]
 8002f2a:	2280      	movs	r2, #128	; 0x80
 8002f2c:	0212      	lsls	r2, r2, #8
 8002f2e:	611a      	str	r2, [r3, #16]
  }

  /* I2C1CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
 8002f30:	4b56      	ldr	r3, [pc, #344]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002f32:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002f34:	2210      	movs	r2, #16
 8002f36:	4013      	ands	r3, r2
 8002f38:	2b10      	cmp	r3, #16
 8002f3a:	d003      	beq.n	8002f44 <RCC_GetClocksFreq+0x17c>
  {
    /* I2C1 Clock is HSI Osc. */
    RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
 8002f3c:	687b      	ldr	r3, [r7, #4]
 8002f3e:	4a54      	ldr	r2, [pc, #336]	; (8003090 <RCC_GetClocksFreq+0x2c8>)
 8002f40:	615a      	str	r2, [r3, #20]
 8002f42:	e003      	b.n	8002f4c <RCC_GetClocksFreq+0x184>
  }
  else
  {
    /* I2C1 Clock is System Clock */
    RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8002f44:	687b      	ldr	r3, [r7, #4]
 8002f46:	681a      	ldr	r2, [r3, #0]
 8002f48:	687b      	ldr	r3, [r7, #4]
 8002f4a:	615a      	str	r2, [r3, #20]
  }

  /* USART1CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
 8002f4c:	4b4f      	ldr	r3, [pc, #316]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002f4e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002f50:	2203      	movs	r2, #3
 8002f52:	4013      	ands	r3, r2
 8002f54:	d104      	bne.n	8002f60 <RCC_GetClocksFreq+0x198>
  {
    /* USART1 Clock is PCLK */
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK_Frequency;
 8002f56:	687b      	ldr	r3, [r7, #4]
 8002f58:	689a      	ldr	r2, [r3, #8]
 8002f5a:	687b      	ldr	r3, [r7, #4]
 8002f5c:	619a      	str	r2, [r3, #24]
 8002f5e:	e01e      	b.n	8002f9e <RCC_GetClocksFreq+0x1d6>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
 8002f60:	4b4a      	ldr	r3, [pc, #296]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002f62:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002f64:	2203      	movs	r2, #3
 8002f66:	4013      	ands	r3, r2
 8002f68:	2b01      	cmp	r3, #1
 8002f6a:	d104      	bne.n	8002f76 <RCC_GetClocksFreq+0x1ae>
  {
    /* USART1 Clock is System Clock */
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8002f6c:	687b      	ldr	r3, [r7, #4]
 8002f6e:	681a      	ldr	r2, [r3, #0]
 8002f70:	687b      	ldr	r3, [r7, #4]
 8002f72:	619a      	str	r2, [r3, #24]
 8002f74:	e013      	b.n	8002f9e <RCC_GetClocksFreq+0x1d6>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
 8002f76:	4b45      	ldr	r3, [pc, #276]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002f78:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002f7a:	2203      	movs	r2, #3
 8002f7c:	4013      	ands	r3, r2
 8002f7e:	2b02      	cmp	r3, #2
 8002f80:	d104      	bne.n	8002f8c <RCC_GetClocksFreq+0x1c4>
  {
    /* USART1 Clock is LSE Osc. */
    RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
 8002f82:	687b      	ldr	r3, [r7, #4]
 8002f84:	2280      	movs	r2, #128	; 0x80
 8002f86:	0212      	lsls	r2, r2, #8
 8002f88:	619a      	str	r2, [r3, #24]
 8002f8a:	e008      	b.n	8002f9e <RCC_GetClocksFreq+0x1d6>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
 8002f8c:	4b3f      	ldr	r3, [pc, #252]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002f8e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002f90:	2203      	movs	r2, #3
 8002f92:	4013      	ands	r3, r2
 8002f94:	2b03      	cmp	r3, #3
 8002f96:	d102      	bne.n	8002f9e <RCC_GetClocksFreq+0x1d6>
  {
    /* USART1 Clock is HSI Osc. */
    RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
 8002f98:	687b      	ldr	r3, [r7, #4]
 8002f9a:	4a3d      	ldr	r2, [pc, #244]	; (8003090 <RCC_GetClocksFreq+0x2c8>)
 8002f9c:	619a      	str	r2, [r3, #24]
  }
  
  /* USART2CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == 0x0)
 8002f9e:	4b3b      	ldr	r3, [pc, #236]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002fa0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002fa2:	23c0      	movs	r3, #192	; 0xc0
 8002fa4:	029b      	lsls	r3, r3, #10
 8002fa6:	4013      	ands	r3, r2
 8002fa8:	d104      	bne.n	8002fb4 <RCC_GetClocksFreq+0x1ec>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK_Frequency;
 8002faa:	687b      	ldr	r3, [r7, #4]
 8002fac:	689a      	ldr	r2, [r3, #8]
 8002fae:	687b      	ldr	r3, [r7, #4]
 8002fb0:	61da      	str	r2, [r3, #28]
 8002fb2:	e027      	b.n	8003004 <RCC_GetClocksFreq+0x23c>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_0)
 8002fb4:	4b35      	ldr	r3, [pc, #212]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002fb6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002fb8:	23c0      	movs	r3, #192	; 0xc0
 8002fba:	029b      	lsls	r3, r3, #10
 8002fbc:	401a      	ands	r2, r3
 8002fbe:	2380      	movs	r3, #128	; 0x80
 8002fc0:	025b      	lsls	r3, r3, #9
 8002fc2:	429a      	cmp	r2, r3
 8002fc4:	d104      	bne.n	8002fd0 <RCC_GetClocksFreq+0x208>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8002fc6:	687b      	ldr	r3, [r7, #4]
 8002fc8:	681a      	ldr	r2, [r3, #0]
 8002fca:	687b      	ldr	r3, [r7, #4]
 8002fcc:	61da      	str	r2, [r3, #28]
 8002fce:	e019      	b.n	8003004 <RCC_GetClocksFreq+0x23c>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_1)
 8002fd0:	4b2e      	ldr	r3, [pc, #184]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002fd2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002fd4:	23c0      	movs	r3, #192	; 0xc0
 8002fd6:	029b      	lsls	r3, r3, #10
 8002fd8:	401a      	ands	r2, r3
 8002fda:	2380      	movs	r3, #128	; 0x80
 8002fdc:	029b      	lsls	r3, r3, #10
 8002fde:	429a      	cmp	r2, r3
 8002fe0:	d104      	bne.n	8002fec <RCC_GetClocksFreq+0x224>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART2CLK_Frequency = LSE_VALUE;
 8002fe2:	687b      	ldr	r3, [r7, #4]
 8002fe4:	2280      	movs	r2, #128	; 0x80
 8002fe6:	0212      	lsls	r2, r2, #8
 8002fe8:	61da      	str	r2, [r3, #28]
 8002fea:	e00b      	b.n	8003004 <RCC_GetClocksFreq+0x23c>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW)
 8002fec:	4b27      	ldr	r3, [pc, #156]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8002fee:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002ff0:	23c0      	movs	r3, #192	; 0xc0
 8002ff2:	029b      	lsls	r3, r3, #10
 8002ff4:	401a      	ands	r2, r3
 8002ff6:	23c0      	movs	r3, #192	; 0xc0
 8002ff8:	029b      	lsls	r3, r3, #10
 8002ffa:	429a      	cmp	r2, r3
 8002ffc:	d102      	bne.n	8003004 <RCC_GetClocksFreq+0x23c>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART2CLK_Frequency = HSI_VALUE;
 8002ffe:	687b      	ldr	r3, [r7, #4]
 8003000:	4a23      	ldr	r2, [pc, #140]	; (8003090 <RCC_GetClocksFreq+0x2c8>)
 8003002:	61da      	str	r2, [r3, #28]
  }
  
  /* USART3CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == 0x0)
 8003004:	4b21      	ldr	r3, [pc, #132]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8003006:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003008:	23c0      	movs	r3, #192	; 0xc0
 800300a:	031b      	lsls	r3, r3, #12
 800300c:	4013      	ands	r3, r2
 800300e:	d104      	bne.n	800301a <RCC_GetClocksFreq+0x252>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->PCLK_Frequency;
 8003010:	687b      	ldr	r3, [r7, #4]
 8003012:	689a      	ldr	r2, [r3, #8]
 8003014:	687b      	ldr	r3, [r7, #4]
 8003016:	621a      	str	r2, [r3, #32]
 8003018:	e027      	b.n	800306a <RCC_GetClocksFreq+0x2a2>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_0)
 800301a:	4b1c      	ldr	r3, [pc, #112]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 800301c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800301e:	23c0      	movs	r3, #192	; 0xc0
 8003020:	031b      	lsls	r3, r3, #12
 8003022:	401a      	ands	r2, r3
 8003024:	2380      	movs	r3, #128	; 0x80
 8003026:	02db      	lsls	r3, r3, #11
 8003028:	429a      	cmp	r2, r3
 800302a:	d104      	bne.n	8003036 <RCC_GetClocksFreq+0x26e>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 800302c:	687b      	ldr	r3, [r7, #4]
 800302e:	681a      	ldr	r2, [r3, #0]
 8003030:	687b      	ldr	r3, [r7, #4]
 8003032:	621a      	str	r2, [r3, #32]
 8003034:	e019      	b.n	800306a <RCC_GetClocksFreq+0x2a2>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_1)
 8003036:	4b15      	ldr	r3, [pc, #84]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8003038:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800303a:	23c0      	movs	r3, #192	; 0xc0
 800303c:	031b      	lsls	r3, r3, #12
 800303e:	401a      	ands	r2, r3
 8003040:	2380      	movs	r3, #128	; 0x80
 8003042:	031b      	lsls	r3, r3, #12
 8003044:	429a      	cmp	r2, r3
 8003046:	d104      	bne.n	8003052 <RCC_GetClocksFreq+0x28a>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART3CLK_Frequency = LSE_VALUE;
 8003048:	687b      	ldr	r3, [r7, #4]
 800304a:	2280      	movs	r2, #128	; 0x80
 800304c:	0212      	lsls	r2, r2, #8
 800304e:	621a      	str	r2, [r3, #32]
 8003050:	e00b      	b.n	800306a <RCC_GetClocksFreq+0x2a2>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW)
 8003052:	4b0e      	ldr	r3, [pc, #56]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 8003054:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003056:	23c0      	movs	r3, #192	; 0xc0
 8003058:	031b      	lsls	r3, r3, #12
 800305a:	401a      	ands	r2, r3
 800305c:	23c0      	movs	r3, #192	; 0xc0
 800305e:	031b      	lsls	r3, r3, #12
 8003060:	429a      	cmp	r2, r3
 8003062:	d102      	bne.n	800306a <RCC_GetClocksFreq+0x2a2>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART3CLK_Frequency = HSI_VALUE;
 8003064:	687b      	ldr	r3, [r7, #4]
 8003066:	4a0a      	ldr	r2, [pc, #40]	; (8003090 <RCC_GetClocksFreq+0x2c8>)
 8003068:	621a      	str	r2, [r3, #32]
  }
  
  /* USBCLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USBSW) != RCC_CFGR3_USBSW)
 800306a:	4b08      	ldr	r3, [pc, #32]	; (800308c <RCC_GetClocksFreq+0x2c4>)
 800306c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800306e:	2280      	movs	r2, #128	; 0x80
 8003070:	4013      	ands	r3, r2
 8003072:	2b80      	cmp	r3, #128	; 0x80
 8003074:	d003      	beq.n	800307e <RCC_GetClocksFreq+0x2b6>
  {
    /* USB Clock is HSI48 */
    RCC_Clocks->USBCLK_Frequency = HSI48_VALUE;
 8003076:	687b      	ldr	r3, [r7, #4]
 8003078:	4a07      	ldr	r2, [pc, #28]	; (8003098 <RCC_GetClocksFreq+0x2d0>)
 800307a:	625a      	str	r2, [r3, #36]	; 0x24
  else
  {
    /* USB Clock is PLL clock */
    RCC_Clocks->USBCLK_Frequency = pllclk;
  }   
}
 800307c:	e002      	b.n	8003084 <RCC_GetClocksFreq+0x2bc>
    RCC_Clocks->USBCLK_Frequency = pllclk;
 800307e:	687b      	ldr	r3, [r7, #4]
 8003080:	69fa      	ldr	r2, [r7, #28]
 8003082:	625a      	str	r2, [r3, #36]	; 0x24
}
 8003084:	46c0      	nop			; (mov r8, r8)
 8003086:	46bd      	mov	sp, r7
 8003088:	b008      	add	sp, #32
 800308a:	bd80      	pop	{r7, pc}
 800308c:	40021000 	.word	0x40021000
 8003090:	007a1200 	.word	0x007a1200
 8003094:	003d0900 	.word	0x003d0900
 8003098:	02dc6c00 	.word	0x02dc6c00
 800309c:	20000000 	.word	0x20000000
 80030a0:	00d59f80 	.word	0x00d59f80
 80030a4:	00008012 	.word	0x00008012

080030a8 <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 80030a8:	b580      	push	{r7, lr}
 80030aa:	b082      	sub	sp, #8
 80030ac:	af00      	add	r7, sp, #0
 80030ae:	6078      	str	r0, [r7, #4]
 80030b0:	000a      	movs	r2, r1
 80030b2:	1cfb      	adds	r3, r7, #3
 80030b4:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80030b6:	1cfb      	adds	r3, r7, #3
 80030b8:	781b      	ldrb	r3, [r3, #0]
 80030ba:	2b00      	cmp	r3, #0
 80030bc:	d006      	beq.n	80030cc <RCC_AHBPeriphClockCmd+0x24>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 80030be:	4b09      	ldr	r3, [pc, #36]	; (80030e4 <RCC_AHBPeriphClockCmd+0x3c>)
 80030c0:	4a08      	ldr	r2, [pc, #32]	; (80030e4 <RCC_AHBPeriphClockCmd+0x3c>)
 80030c2:	6951      	ldr	r1, [r2, #20]
 80030c4:	687a      	ldr	r2, [r7, #4]
 80030c6:	430a      	orrs	r2, r1
 80030c8:	615a      	str	r2, [r3, #20]
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
  }
}
 80030ca:	e006      	b.n	80030da <RCC_AHBPeriphClockCmd+0x32>
    RCC->AHBENR &= ~RCC_AHBPeriph;
 80030cc:	4b05      	ldr	r3, [pc, #20]	; (80030e4 <RCC_AHBPeriphClockCmd+0x3c>)
 80030ce:	4a05      	ldr	r2, [pc, #20]	; (80030e4 <RCC_AHBPeriphClockCmd+0x3c>)
 80030d0:	6952      	ldr	r2, [r2, #20]
 80030d2:	6879      	ldr	r1, [r7, #4]
 80030d4:	43c9      	mvns	r1, r1
 80030d6:	400a      	ands	r2, r1
 80030d8:	615a      	str	r2, [r3, #20]
}
 80030da:	46c0      	nop			; (mov r8, r8)
 80030dc:	46bd      	mov	sp, r7
 80030de:	b002      	add	sp, #8
 80030e0:	bd80      	pop	{r7, pc}
 80030e2:	46c0      	nop			; (mov r8, r8)
 80030e4:	40021000 	.word	0x40021000

080030e8 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 80030e8:	b580      	push	{r7, lr}
 80030ea:	b082      	sub	sp, #8
 80030ec:	af00      	add	r7, sp, #0
 80030ee:	6078      	str	r0, [r7, #4]
 80030f0:	000a      	movs	r2, r1
 80030f2:	1cfb      	adds	r3, r7, #3
 80030f4:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80030f6:	1cfb      	adds	r3, r7, #3
 80030f8:	781b      	ldrb	r3, [r3, #0]
 80030fa:	2b00      	cmp	r3, #0
 80030fc:	d006      	beq.n	800310c <RCC_APB2PeriphClockCmd+0x24>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80030fe:	4b09      	ldr	r3, [pc, #36]	; (8003124 <RCC_APB2PeriphClockCmd+0x3c>)
 8003100:	4a08      	ldr	r2, [pc, #32]	; (8003124 <RCC_APB2PeriphClockCmd+0x3c>)
 8003102:	6991      	ldr	r1, [r2, #24]
 8003104:	687a      	ldr	r2, [r7, #4]
 8003106:	430a      	orrs	r2, r1
 8003108:	619a      	str	r2, [r3, #24]
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
  }
}
 800310a:	e006      	b.n	800311a <RCC_APB2PeriphClockCmd+0x32>
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800310c:	4b05      	ldr	r3, [pc, #20]	; (8003124 <RCC_APB2PeriphClockCmd+0x3c>)
 800310e:	4a05      	ldr	r2, [pc, #20]	; (8003124 <RCC_APB2PeriphClockCmd+0x3c>)
 8003110:	6992      	ldr	r2, [r2, #24]
 8003112:	6879      	ldr	r1, [r7, #4]
 8003114:	43c9      	mvns	r1, r1
 8003116:	400a      	ands	r2, r1
 8003118:	619a      	str	r2, [r3, #24]
}
 800311a:	46c0      	nop			; (mov r8, r8)
 800311c:	46bd      	mov	sp, r7
 800311e:	b002      	add	sp, #8
 8003120:	bd80      	pop	{r7, pc}
 8003122:	46c0      	nop			; (mov r8, r8)
 8003124:	40021000 	.word	0x40021000

08003128 <SYSCFG_EXTILineConfig>:
  *         For STM32F072: (0..15) for GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, (0..10) for GPIOF.
  *         For STM32F031: (0..15) for GPIOA, GPIOB, (13..15) for GPIOC and (0..1, 6..7) for GPIOF.
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 8003128:	b5b0      	push	{r4, r5, r7, lr}
 800312a:	b084      	sub	sp, #16
 800312c:	af00      	add	r7, sp, #0
 800312e:	0002      	movs	r2, r0
 8003130:	1dfb      	adds	r3, r7, #7
 8003132:	701a      	strb	r2, [r3, #0]
 8003134:	1dbb      	adds	r3, r7, #6
 8003136:	1c0a      	adds	r2, r1, #0
 8003138:	701a      	strb	r2, [r3, #0]
  uint32_t tmp = 0x00;
 800313a:	2300      	movs	r3, #0
 800313c:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 800313e:	1dbb      	adds	r3, r7, #6
 8003140:	781b      	ldrb	r3, [r3, #0]
 8003142:	2203      	movs	r2, #3
 8003144:	4013      	ands	r3, r2
 8003146:	009b      	lsls	r3, r3, #2
 8003148:	220f      	movs	r2, #15
 800314a:	409a      	lsls	r2, r3
 800314c:	0013      	movs	r3, r2
 800314e:	60fb      	str	r3, [r7, #12]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 8003150:	4919      	ldr	r1, [pc, #100]	; (80031b8 <SYSCFG_EXTILineConfig+0x90>)
 8003152:	1dbb      	adds	r3, r7, #6
 8003154:	781b      	ldrb	r3, [r3, #0]
 8003156:	089b      	lsrs	r3, r3, #2
 8003158:	b2db      	uxtb	r3, r3
 800315a:	0018      	movs	r0, r3
 800315c:	4a16      	ldr	r2, [pc, #88]	; (80031b8 <SYSCFG_EXTILineConfig+0x90>)
 800315e:	1dbb      	adds	r3, r7, #6
 8003160:	781b      	ldrb	r3, [r3, #0]
 8003162:	089b      	lsrs	r3, r3, #2
 8003164:	b2db      	uxtb	r3, r3
 8003166:	3302      	adds	r3, #2
 8003168:	009b      	lsls	r3, r3, #2
 800316a:	589b      	ldr	r3, [r3, r2]
 800316c:	68fa      	ldr	r2, [r7, #12]
 800316e:	43d2      	mvns	r2, r2
 8003170:	401a      	ands	r2, r3
 8003172:	1c83      	adds	r3, r0, #2
 8003174:	009b      	lsls	r3, r3, #2
 8003176:	505a      	str	r2, [r3, r1]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 8003178:	480f      	ldr	r0, [pc, #60]	; (80031b8 <SYSCFG_EXTILineConfig+0x90>)
 800317a:	1dbb      	adds	r3, r7, #6
 800317c:	781b      	ldrb	r3, [r3, #0]
 800317e:	089b      	lsrs	r3, r3, #2
 8003180:	b2db      	uxtb	r3, r3
 8003182:	001d      	movs	r5, r3
 8003184:	4a0c      	ldr	r2, [pc, #48]	; (80031b8 <SYSCFG_EXTILineConfig+0x90>)
 8003186:	1dbb      	adds	r3, r7, #6
 8003188:	781b      	ldrb	r3, [r3, #0]
 800318a:	089b      	lsrs	r3, r3, #2
 800318c:	b2db      	uxtb	r3, r3
 800318e:	3302      	adds	r3, #2
 8003190:	009b      	lsls	r3, r3, #2
 8003192:	589a      	ldr	r2, [r3, r2]
 8003194:	1dfb      	adds	r3, r7, #7
 8003196:	7819      	ldrb	r1, [r3, #0]
 8003198:	1dbb      	adds	r3, r7, #6
 800319a:	781b      	ldrb	r3, [r3, #0]
 800319c:	2403      	movs	r4, #3
 800319e:	4023      	ands	r3, r4
 80031a0:	009b      	lsls	r3, r3, #2
 80031a2:	4099      	lsls	r1, r3
 80031a4:	000b      	movs	r3, r1
 80031a6:	431a      	orrs	r2, r3
 80031a8:	1cab      	adds	r3, r5, #2
 80031aa:	009b      	lsls	r3, r3, #2
 80031ac:	501a      	str	r2, [r3, r0]
}
 80031ae:	46c0      	nop			; (mov r8, r8)
 80031b0:	46bd      	mov	sp, r7
 80031b2:	b004      	add	sp, #16
 80031b4:	bdb0      	pop	{r4, r5, r7, pc}
 80031b6:	46c0      	nop			; (mov r8, r8)
 80031b8:	40010000 	.word	0x40010000

080031bc <TIM_TimeBaseInit>:
  *         structure that contains the configuration information for
  *         the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 80031bc:	b580      	push	{r7, lr}
 80031be:	b084      	sub	sp, #16
 80031c0:	af00      	add	r7, sp, #0
 80031c2:	6078      	str	r0, [r7, #4]
 80031c4:	6039      	str	r1, [r7, #0]
  uint16_t tmpcr1 = 0;
 80031c6:	230e      	movs	r3, #14
 80031c8:	18fb      	adds	r3, r7, r3
 80031ca:	2200      	movs	r2, #0
 80031cc:	801a      	strh	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 80031ce:	230e      	movs	r3, #14
 80031d0:	18fb      	adds	r3, r7, r3
 80031d2:	687a      	ldr	r2, [r7, #4]
 80031d4:	8812      	ldrh	r2, [r2, #0]
 80031d6:	801a      	strh	r2, [r3, #0]

  if((TIMx == TIM1) || (TIMx == TIM2) || (TIMx == TIM3))
 80031d8:	687b      	ldr	r3, [r7, #4]
 80031da:	4a2d      	ldr	r2, [pc, #180]	; (8003290 <TIM_TimeBaseInit+0xd4>)
 80031dc:	4293      	cmp	r3, r2
 80031de:	d008      	beq.n	80031f2 <TIM_TimeBaseInit+0x36>
 80031e0:	687a      	ldr	r2, [r7, #4]
 80031e2:	2380      	movs	r3, #128	; 0x80
 80031e4:	05db      	lsls	r3, r3, #23
 80031e6:	429a      	cmp	r2, r3
 80031e8:	d003      	beq.n	80031f2 <TIM_TimeBaseInit+0x36>
 80031ea:	687b      	ldr	r3, [r7, #4]
 80031ec:	4a29      	ldr	r2, [pc, #164]	; (8003294 <TIM_TimeBaseInit+0xd8>)
 80031ee:	4293      	cmp	r3, r2
 80031f0:	d110      	bne.n	8003214 <TIM_TimeBaseInit+0x58>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
 80031f2:	230e      	movs	r3, #14
 80031f4:	18fb      	adds	r3, r7, r3
 80031f6:	220e      	movs	r2, #14
 80031f8:	18ba      	adds	r2, r7, r2
 80031fa:	8812      	ldrh	r2, [r2, #0]
 80031fc:	2170      	movs	r1, #112	; 0x70
 80031fe:	438a      	bics	r2, r1
 8003200:	801a      	strh	r2, [r3, #0]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8003202:	683b      	ldr	r3, [r7, #0]
 8003204:	8859      	ldrh	r1, [r3, #2]
 8003206:	230e      	movs	r3, #14
 8003208:	18fb      	adds	r3, r7, r3
 800320a:	220e      	movs	r2, #14
 800320c:	18ba      	adds	r2, r7, r2
 800320e:	8812      	ldrh	r2, [r2, #0]
 8003210:	430a      	orrs	r2, r1
 8003212:	801a      	strh	r2, [r3, #0]
  }
 
  if(TIMx != TIM6)
 8003214:	687b      	ldr	r3, [r7, #4]
 8003216:	4a20      	ldr	r2, [pc, #128]	; (8003298 <TIM_TimeBaseInit+0xdc>)
 8003218:	4293      	cmp	r3, r2
 800321a:	d010      	beq.n	800323e <TIM_TimeBaseInit+0x82>
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
 800321c:	230e      	movs	r3, #14
 800321e:	18fb      	adds	r3, r7, r3
 8003220:	220e      	movs	r2, #14
 8003222:	18ba      	adds	r2, r7, r2
 8003224:	8812      	ldrh	r2, [r2, #0]
 8003226:	491d      	ldr	r1, [pc, #116]	; (800329c <TIM_TimeBaseInit+0xe0>)
 8003228:	400a      	ands	r2, r1
 800322a:	801a      	strh	r2, [r3, #0]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 800322c:	683b      	ldr	r3, [r7, #0]
 800322e:	8919      	ldrh	r1, [r3, #8]
 8003230:	230e      	movs	r3, #14
 8003232:	18fb      	adds	r3, r7, r3
 8003234:	220e      	movs	r2, #14
 8003236:	18ba      	adds	r2, r7, r2
 8003238:	8812      	ldrh	r2, [r2, #0]
 800323a:	430a      	orrs	r2, r1
 800323c:	801a      	strh	r2, [r3, #0]
  }

  TIMx->CR1 = tmpcr1;
 800323e:	687b      	ldr	r3, [r7, #4]
 8003240:	220e      	movs	r2, #14
 8003242:	18ba      	adds	r2, r7, r2
 8003244:	8812      	ldrh	r2, [r2, #0]
 8003246:	801a      	strh	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 8003248:	683b      	ldr	r3, [r7, #0]
 800324a:	685a      	ldr	r2, [r3, #4]
 800324c:	687b      	ldr	r3, [r7, #4]
 800324e:	62da      	str	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8003250:	683b      	ldr	r3, [r7, #0]
 8003252:	881a      	ldrh	r2, [r3, #0]
 8003254:	687b      	ldr	r3, [r7, #4]
 8003256:	851a      	strh	r2, [r3, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
 8003258:	687b      	ldr	r3, [r7, #4]
 800325a:	4a0d      	ldr	r2, [pc, #52]	; (8003290 <TIM_TimeBaseInit+0xd4>)
 800325c:	4293      	cmp	r3, r2
 800325e:	d00b      	beq.n	8003278 <TIM_TimeBaseInit+0xbc>
 8003260:	687b      	ldr	r3, [r7, #4]
 8003262:	4a0f      	ldr	r2, [pc, #60]	; (80032a0 <TIM_TimeBaseInit+0xe4>)
 8003264:	4293      	cmp	r3, r2
 8003266:	d007      	beq.n	8003278 <TIM_TimeBaseInit+0xbc>
 8003268:	687b      	ldr	r3, [r7, #4]
 800326a:	4a0e      	ldr	r2, [pc, #56]	; (80032a4 <TIM_TimeBaseInit+0xe8>)
 800326c:	4293      	cmp	r3, r2
 800326e:	d003      	beq.n	8003278 <TIM_TimeBaseInit+0xbc>
 8003270:	687b      	ldr	r3, [r7, #4]
 8003272:	4a0d      	ldr	r2, [pc, #52]	; (80032a8 <TIM_TimeBaseInit+0xec>)
 8003274:	4293      	cmp	r3, r2
 8003276:	d104      	bne.n	8003282 <TIM_TimeBaseInit+0xc6>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8003278:	683b      	ldr	r3, [r7, #0]
 800327a:	7a9b      	ldrb	r3, [r3, #10]
 800327c:	b29a      	uxth	r2, r3
 800327e:	687b      	ldr	r3, [r7, #4]
 8003280:	861a      	strh	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler and the Repetition counter
     values immediately */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;           
 8003282:	687b      	ldr	r3, [r7, #4]
 8003284:	2201      	movs	r2, #1
 8003286:	829a      	strh	r2, [r3, #20]
}
 8003288:	46c0      	nop			; (mov r8, r8)
 800328a:	46bd      	mov	sp, r7
 800328c:	b004      	add	sp, #16
 800328e:	bd80      	pop	{r7, pc}
 8003290:	40012c00 	.word	0x40012c00
 8003294:	40000400 	.word	0x40000400
 8003298:	40001000 	.word	0x40001000
 800329c:	fffffcff 	.word	0xfffffcff
 80032a0:	40014000 	.word	0x40014000
 80032a4:	40014400 	.word	0x40014400
 80032a8:	40014800 	.word	0x40014800

080032ac <TIM_TimeBaseStructInit>:
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
  *         which will be initialized.
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 80032ac:	b580      	push	{r7, lr}
 80032ae:	b082      	sub	sp, #8
 80032b0:	af00      	add	r7, sp, #0
 80032b2:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
 80032b4:	687b      	ldr	r3, [r7, #4]
 80032b6:	2201      	movs	r2, #1
 80032b8:	4252      	negs	r2, r2
 80032ba:	605a      	str	r2, [r3, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 80032bc:	687b      	ldr	r3, [r7, #4]
 80032be:	2200      	movs	r2, #0
 80032c0:	801a      	strh	r2, [r3, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 80032c2:	687b      	ldr	r3, [r7, #4]
 80032c4:	2200      	movs	r2, #0
 80032c6:	811a      	strh	r2, [r3, #8]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 80032c8:	687b      	ldr	r3, [r7, #4]
 80032ca:	2200      	movs	r2, #0
 80032cc:	805a      	strh	r2, [r3, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 80032ce:	687b      	ldr	r3, [r7, #4]
 80032d0:	2200      	movs	r2, #0
 80032d2:	729a      	strb	r2, [r3, #10]
}
 80032d4:	46c0      	nop			; (mov r8, r8)
 80032d6:	46bd      	mov	sp, r7
 80032d8:	b002      	add	sp, #8
 80032da:	bd80      	pop	{r7, pc}

080032dc <TIM_Cmd>:
  * @param  NewState: new state of the TIMx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 80032dc:	b580      	push	{r7, lr}
 80032de:	b082      	sub	sp, #8
 80032e0:	af00      	add	r7, sp, #0
 80032e2:	6078      	str	r0, [r7, #4]
 80032e4:	000a      	movs	r2, r1
 80032e6:	1cfb      	adds	r3, r7, #3
 80032e8:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80032ea:	1cfb      	adds	r3, r7, #3
 80032ec:	781b      	ldrb	r3, [r3, #0]
 80032ee:	2b00      	cmp	r3, #0
 80032f0:	d008      	beq.n	8003304 <TIM_Cmd+0x28>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 80032f2:	687b      	ldr	r3, [r7, #4]
 80032f4:	881b      	ldrh	r3, [r3, #0]
 80032f6:	b29b      	uxth	r3, r3
 80032f8:	2201      	movs	r2, #1
 80032fa:	4313      	orrs	r3, r2
 80032fc:	b29a      	uxth	r2, r3
 80032fe:	687b      	ldr	r3, [r7, #4]
 8003300:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
  }
}
 8003302:	e007      	b.n	8003314 <TIM_Cmd+0x38>
    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
 8003304:	687b      	ldr	r3, [r7, #4]
 8003306:	881b      	ldrh	r3, [r3, #0]
 8003308:	b29b      	uxth	r3, r3
 800330a:	2201      	movs	r2, #1
 800330c:	4393      	bics	r3, r2
 800330e:	b29a      	uxth	r2, r3
 8003310:	687b      	ldr	r3, [r7, #4]
 8003312:	801a      	strh	r2, [r3, #0]
}
 8003314:	46c0      	nop			; (mov r8, r8)
 8003316:	46bd      	mov	sp, r7
 8003318:	b002      	add	sp, #8
 800331a:	bd80      	pop	{r7, pc}

0800331c <TIM_CtrlPWMOutputs>:
  * @param  NewState: new state of the TIM peripheral Main Outputs.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 800331c:	b580      	push	{r7, lr}
 800331e:	b082      	sub	sp, #8
 8003320:	af00      	add	r7, sp, #0
 8003322:	6078      	str	r0, [r7, #4]
 8003324:	000a      	movs	r2, r1
 8003326:	1cfb      	adds	r3, r7, #3
 8003328:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800332a:	1cfb      	adds	r3, r7, #3
 800332c:	781b      	ldrb	r3, [r3, #0]
 800332e:	2b00      	cmp	r3, #0
 8003330:	d00a      	beq.n	8003348 <TIM_CtrlPWMOutputs+0x2c>
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 8003332:	687b      	ldr	r3, [r7, #4]
 8003334:	2244      	movs	r2, #68	; 0x44
 8003336:	5a9b      	ldrh	r3, [r3, r2]
 8003338:	b29b      	uxth	r3, r3
 800333a:	4a0a      	ldr	r2, [pc, #40]	; (8003364 <TIM_CtrlPWMOutputs+0x48>)
 800333c:	4313      	orrs	r3, r2
 800333e:	b299      	uxth	r1, r3
 8003340:	687b      	ldr	r3, [r7, #4]
 8003342:	2244      	movs	r2, #68	; 0x44
 8003344:	5299      	strh	r1, [r3, r2]
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
  }  
}
 8003346:	e009      	b.n	800335c <TIM_CtrlPWMOutputs+0x40>
    TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
 8003348:	687b      	ldr	r3, [r7, #4]
 800334a:	2244      	movs	r2, #68	; 0x44
 800334c:	5a9b      	ldrh	r3, [r3, r2]
 800334e:	b29b      	uxth	r3, r3
 8003350:	045b      	lsls	r3, r3, #17
 8003352:	0c5b      	lsrs	r3, r3, #17
 8003354:	b299      	uxth	r1, r3
 8003356:	687b      	ldr	r3, [r7, #4]
 8003358:	2244      	movs	r2, #68	; 0x44
 800335a:	5299      	strh	r1, [r3, r2]
}
 800335c:	46c0      	nop			; (mov r8, r8)
 800335e:	46bd      	mov	sp, r7
 8003360:	b002      	add	sp, #8
 8003362:	bd80      	pop	{r7, pc}
 8003364:	ffff8000 	.word	0xffff8000

08003368 <TIM_OC1Init>:
  *         that contains the configuration information for the specified TIM 
  *         peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8003368:	b580      	push	{r7, lr}
 800336a:	b084      	sub	sp, #16
 800336c:	af00      	add	r7, sp, #0
 800336e:	6078      	str	r0, [r7, #4]
 8003370:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 8003372:	230a      	movs	r3, #10
 8003374:	18fb      	adds	r3, r7, r3
 8003376:	2200      	movs	r2, #0
 8003378:	801a      	strh	r2, [r3, #0]
 800337a:	230e      	movs	r3, #14
 800337c:	18fb      	adds	r3, r7, r3
 800337e:	2200      	movs	r2, #0
 8003380:	801a      	strh	r2, [r3, #0]
 8003382:	230c      	movs	r3, #12
 8003384:	18fb      	adds	r3, r7, r3
 8003386:	2200      	movs	r2, #0
 8003388:	801a      	strh	r2, [r3, #0]
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
 /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
 800338a:	687b      	ldr	r3, [r7, #4]
 800338c:	8c1b      	ldrh	r3, [r3, #32]
 800338e:	b29b      	uxth	r3, r3
 8003390:	2201      	movs	r2, #1
 8003392:	4393      	bics	r3, r2
 8003394:	b29a      	uxth	r2, r3
 8003396:	687b      	ldr	r3, [r7, #4]
 8003398:	841a      	strh	r2, [r3, #32]
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800339a:	230e      	movs	r3, #14
 800339c:	18fb      	adds	r3, r7, r3
 800339e:	687a      	ldr	r2, [r7, #4]
 80033a0:	8c12      	ldrh	r2, [r2, #32]
 80033a2:	801a      	strh	r2, [r3, #0]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80033a4:	230c      	movs	r3, #12
 80033a6:	18fb      	adds	r3, r7, r3
 80033a8:	687a      	ldr	r2, [r7, #4]
 80033aa:	8892      	ldrh	r2, [r2, #4]
 80033ac:	801a      	strh	r2, [r3, #0]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 80033ae:	230a      	movs	r3, #10
 80033b0:	18fb      	adds	r3, r7, r3
 80033b2:	687a      	ldr	r2, [r7, #4]
 80033b4:	8b12      	ldrh	r2, [r2, #24]
 80033b6:	801a      	strh	r2, [r3, #0]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
 80033b8:	230a      	movs	r3, #10
 80033ba:	18fb      	adds	r3, r7, r3
 80033bc:	220a      	movs	r2, #10
 80033be:	18ba      	adds	r2, r7, r2
 80033c0:	8812      	ldrh	r2, [r2, #0]
 80033c2:	2170      	movs	r1, #112	; 0x70
 80033c4:	438a      	bics	r2, r1
 80033c6:	801a      	strh	r2, [r3, #0]
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
 80033c8:	230a      	movs	r3, #10
 80033ca:	18fb      	adds	r3, r7, r3
 80033cc:	220a      	movs	r2, #10
 80033ce:	18ba      	adds	r2, r7, r2
 80033d0:	8812      	ldrh	r2, [r2, #0]
 80033d2:	2103      	movs	r1, #3
 80033d4:	438a      	bics	r2, r1
 80033d6:	801a      	strh	r2, [r3, #0]

  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 80033d8:	683b      	ldr	r3, [r7, #0]
 80033da:	8819      	ldrh	r1, [r3, #0]
 80033dc:	230a      	movs	r3, #10
 80033de:	18fb      	adds	r3, r7, r3
 80033e0:	220a      	movs	r2, #10
 80033e2:	18ba      	adds	r2, r7, r2
 80033e4:	8812      	ldrh	r2, [r2, #0]
 80033e6:	430a      	orrs	r2, r1
 80033e8:	801a      	strh	r2, [r3, #0]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
 80033ea:	230e      	movs	r3, #14
 80033ec:	18fb      	adds	r3, r7, r3
 80033ee:	220e      	movs	r2, #14
 80033f0:	18ba      	adds	r2, r7, r2
 80033f2:	8812      	ldrh	r2, [r2, #0]
 80033f4:	2102      	movs	r1, #2
 80033f6:	438a      	bics	r2, r1
 80033f8:	801a      	strh	r2, [r3, #0]
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 80033fa:	683b      	ldr	r3, [r7, #0]
 80033fc:	8999      	ldrh	r1, [r3, #12]
 80033fe:	230e      	movs	r3, #14
 8003400:	18fb      	adds	r3, r7, r3
 8003402:	220e      	movs	r2, #14
 8003404:	18ba      	adds	r2, r7, r2
 8003406:	8812      	ldrh	r2, [r2, #0]
 8003408:	430a      	orrs	r2, r1
 800340a:	801a      	strh	r2, [r3, #0]
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 800340c:	683b      	ldr	r3, [r7, #0]
 800340e:	8859      	ldrh	r1, [r3, #2]
 8003410:	230e      	movs	r3, #14
 8003412:	18fb      	adds	r3, r7, r3
 8003414:	220e      	movs	r2, #14
 8003416:	18ba      	adds	r2, r7, r2
 8003418:	8812      	ldrh	r2, [r2, #0]
 800341a:	430a      	orrs	r2, r1
 800341c:	801a      	strh	r2, [r3, #0]
    
  if((TIMx == TIM1) || (TIMx == TIM15) || (TIMx == TIM16) || (TIMx == TIM17))
 800341e:	687b      	ldr	r3, [r7, #4]
 8003420:	4a34      	ldr	r2, [pc, #208]	; (80034f4 <TIM_OC1Init+0x18c>)
 8003422:	4293      	cmp	r3, r2
 8003424:	d00b      	beq.n	800343e <TIM_OC1Init+0xd6>
 8003426:	687b      	ldr	r3, [r7, #4]
 8003428:	4a33      	ldr	r2, [pc, #204]	; (80034f8 <TIM_OC1Init+0x190>)
 800342a:	4293      	cmp	r3, r2
 800342c:	d007      	beq.n	800343e <TIM_OC1Init+0xd6>
 800342e:	687b      	ldr	r3, [r7, #4]
 8003430:	4a32      	ldr	r2, [pc, #200]	; (80034fc <TIM_OC1Init+0x194>)
 8003432:	4293      	cmp	r3, r2
 8003434:	d003      	beq.n	800343e <TIM_OC1Init+0xd6>
 8003436:	687b      	ldr	r3, [r7, #4]
 8003438:	4a31      	ldr	r2, [pc, #196]	; (8003500 <TIM_OC1Init+0x198>)
 800343a:	4293      	cmp	r3, r2
 800343c:	d143      	bne.n	80034c6 <TIM_OC1Init+0x15e>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
 800343e:	230e      	movs	r3, #14
 8003440:	18fb      	adds	r3, r7, r3
 8003442:	220e      	movs	r2, #14
 8003444:	18ba      	adds	r2, r7, r2
 8003446:	8812      	ldrh	r2, [r2, #0]
 8003448:	2108      	movs	r1, #8
 800344a:	438a      	bics	r2, r1
 800344c:	801a      	strh	r2, [r3, #0]
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 800344e:	683b      	ldr	r3, [r7, #0]
 8003450:	89d9      	ldrh	r1, [r3, #14]
 8003452:	230e      	movs	r3, #14
 8003454:	18fb      	adds	r3, r7, r3
 8003456:	220e      	movs	r2, #14
 8003458:	18ba      	adds	r2, r7, r2
 800345a:	8812      	ldrh	r2, [r2, #0]
 800345c:	430a      	orrs	r2, r1
 800345e:	801a      	strh	r2, [r3, #0]
    
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
 8003460:	230e      	movs	r3, #14
 8003462:	18fb      	adds	r3, r7, r3
 8003464:	220e      	movs	r2, #14
 8003466:	18ba      	adds	r2, r7, r2
 8003468:	8812      	ldrh	r2, [r2, #0]
 800346a:	2104      	movs	r1, #4
 800346c:	438a      	bics	r2, r1
 800346e:	801a      	strh	r2, [r3, #0]
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8003470:	683b      	ldr	r3, [r7, #0]
 8003472:	8899      	ldrh	r1, [r3, #4]
 8003474:	230e      	movs	r3, #14
 8003476:	18fb      	adds	r3, r7, r3
 8003478:	220e      	movs	r2, #14
 800347a:	18ba      	adds	r2, r7, r2
 800347c:	8812      	ldrh	r2, [r2, #0]
 800347e:	430a      	orrs	r2, r1
 8003480:	801a      	strh	r2, [r3, #0]
    
    /* Reset the Ouput Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
 8003482:	230c      	movs	r3, #12
 8003484:	18fb      	adds	r3, r7, r3
 8003486:	220c      	movs	r2, #12
 8003488:	18ba      	adds	r2, r7, r2
 800348a:	8812      	ldrh	r2, [r2, #0]
 800348c:	491d      	ldr	r1, [pc, #116]	; (8003504 <TIM_OC1Init+0x19c>)
 800348e:	400a      	ands	r2, r1
 8003490:	801a      	strh	r2, [r3, #0]
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
 8003492:	230c      	movs	r3, #12
 8003494:	18fb      	adds	r3, r7, r3
 8003496:	220c      	movs	r2, #12
 8003498:	18ba      	adds	r2, r7, r2
 800349a:	8812      	ldrh	r2, [r2, #0]
 800349c:	491a      	ldr	r1, [pc, #104]	; (8003508 <TIM_OC1Init+0x1a0>)
 800349e:	400a      	ands	r2, r1
 80034a0:	801a      	strh	r2, [r3, #0]
    
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 80034a2:	683b      	ldr	r3, [r7, #0]
 80034a4:	8a19      	ldrh	r1, [r3, #16]
 80034a6:	230c      	movs	r3, #12
 80034a8:	18fb      	adds	r3, r7, r3
 80034aa:	220c      	movs	r2, #12
 80034ac:	18ba      	adds	r2, r7, r2
 80034ae:	8812      	ldrh	r2, [r2, #0]
 80034b0:	430a      	orrs	r2, r1
 80034b2:	801a      	strh	r2, [r3, #0]
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 80034b4:	683b      	ldr	r3, [r7, #0]
 80034b6:	8a59      	ldrh	r1, [r3, #18]
 80034b8:	230c      	movs	r3, #12
 80034ba:	18fb      	adds	r3, r7, r3
 80034bc:	220c      	movs	r2, #12
 80034be:	18ba      	adds	r2, r7, r2
 80034c0:	8812      	ldrh	r2, [r2, #0]
 80034c2:	430a      	orrs	r2, r1
 80034c4:	801a      	strh	r2, [r3, #0]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80034c6:	687b      	ldr	r3, [r7, #4]
 80034c8:	220c      	movs	r2, #12
 80034ca:	18ba      	adds	r2, r7, r2
 80034cc:	8812      	ldrh	r2, [r2, #0]
 80034ce:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 80034d0:	687b      	ldr	r3, [r7, #4]
 80034d2:	220a      	movs	r2, #10
 80034d4:	18ba      	adds	r2, r7, r2
 80034d6:	8812      	ldrh	r2, [r2, #0]
 80034d8:	831a      	strh	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
 80034da:	683b      	ldr	r3, [r7, #0]
 80034dc:	689a      	ldr	r2, [r3, #8]
 80034de:	687b      	ldr	r3, [r7, #4]
 80034e0:	635a      	str	r2, [r3, #52]	; 0x34
 
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80034e2:	687b      	ldr	r3, [r7, #4]
 80034e4:	220e      	movs	r2, #14
 80034e6:	18ba      	adds	r2, r7, r2
 80034e8:	8812      	ldrh	r2, [r2, #0]
 80034ea:	841a      	strh	r2, [r3, #32]
}
 80034ec:	46c0      	nop			; (mov r8, r8)
 80034ee:	46bd      	mov	sp, r7
 80034f0:	b004      	add	sp, #16
 80034f2:	bd80      	pop	{r7, pc}
 80034f4:	40012c00 	.word	0x40012c00
 80034f8:	40014000 	.word	0x40014000
 80034fc:	40014400 	.word	0x40014400
 8003500:	40014800 	.word	0x40014800
 8003504:	fffffeff 	.word	0xfffffeff
 8003508:	fffffdff 	.word	0xfffffdff

0800350c <TIM_OC1PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 800350c:	b580      	push	{r7, lr}
 800350e:	b084      	sub	sp, #16
 8003510:	af00      	add	r7, sp, #0
 8003512:	6078      	str	r0, [r7, #4]
 8003514:	000a      	movs	r2, r1
 8003516:	1cbb      	adds	r3, r7, #2
 8003518:	801a      	strh	r2, [r3, #0]
  uint16_t tmpccmr1 = 0;
 800351a:	230e      	movs	r3, #14
 800351c:	18fb      	adds	r3, r7, r3
 800351e:	2200      	movs	r2, #0
 8003520:	801a      	strh	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  
  tmpccmr1 = TIMx->CCMR1;
 8003522:	230e      	movs	r3, #14
 8003524:	18fb      	adds	r3, r7, r3
 8003526:	687a      	ldr	r2, [r7, #4]
 8003528:	8b12      	ldrh	r2, [r2, #24]
 800352a:	801a      	strh	r2, [r3, #0]
  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
 800352c:	230e      	movs	r3, #14
 800352e:	18fb      	adds	r3, r7, r3
 8003530:	220e      	movs	r2, #14
 8003532:	18ba      	adds	r2, r7, r2
 8003534:	8812      	ldrh	r2, [r2, #0]
 8003536:	2108      	movs	r1, #8
 8003538:	438a      	bics	r2, r1
 800353a:	801a      	strh	r2, [r3, #0]
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= TIM_OCPreload;
 800353c:	230e      	movs	r3, #14
 800353e:	18fb      	adds	r3, r7, r3
 8003540:	220e      	movs	r2, #14
 8003542:	18b9      	adds	r1, r7, r2
 8003544:	1cba      	adds	r2, r7, #2
 8003546:	8809      	ldrh	r1, [r1, #0]
 8003548:	8812      	ldrh	r2, [r2, #0]
 800354a:	430a      	orrs	r2, r1
 800354c:	801a      	strh	r2, [r3, #0]
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800354e:	687b      	ldr	r3, [r7, #4]
 8003550:	220e      	movs	r2, #14
 8003552:	18ba      	adds	r2, r7, r2
 8003554:	8812      	ldrh	r2, [r2, #0]
 8003556:	831a      	strh	r2, [r3, #24]
}
 8003558:	46c0      	nop			; (mov r8, r8)
 800355a:	46bd      	mov	sp, r7
 800355c:	b004      	add	sp, #16
 800355e:	bd80      	pop	{r7, pc}

08003560 <TIM_ITConfig>:
  * @param  NewState: new state of the TIM interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
{  
 8003560:	b580      	push	{r7, lr}
 8003562:	b082      	sub	sp, #8
 8003564:	af00      	add	r7, sp, #0
 8003566:	6078      	str	r0, [r7, #4]
 8003568:	0008      	movs	r0, r1
 800356a:	0011      	movs	r1, r2
 800356c:	1cbb      	adds	r3, r7, #2
 800356e:	1c02      	adds	r2, r0, #0
 8003570:	801a      	strh	r2, [r3, #0]
 8003572:	1c7b      	adds	r3, r7, #1
 8003574:	1c0a      	adds	r2, r1, #0
 8003576:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003578:	1c7b      	adds	r3, r7, #1
 800357a:	781b      	ldrb	r3, [r3, #0]
 800357c:	2b00      	cmp	r3, #0
 800357e:	d009      	beq.n	8003594 <TIM_ITConfig+0x34>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 8003580:	687b      	ldr	r3, [r7, #4]
 8003582:	899b      	ldrh	r3, [r3, #12]
 8003584:	b29a      	uxth	r2, r3
 8003586:	1cbb      	adds	r3, r7, #2
 8003588:	881b      	ldrh	r3, [r3, #0]
 800358a:	4313      	orrs	r3, r2
 800358c:	b29a      	uxth	r2, r3
 800358e:	687b      	ldr	r3, [r7, #4]
 8003590:	819a      	strh	r2, [r3, #12]
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
  }
}
 8003592:	e00a      	b.n	80035aa <TIM_ITConfig+0x4a>
    TIMx->DIER &= (uint16_t)~TIM_IT;
 8003594:	687b      	ldr	r3, [r7, #4]
 8003596:	899b      	ldrh	r3, [r3, #12]
 8003598:	b29b      	uxth	r3, r3
 800359a:	1cba      	adds	r2, r7, #2
 800359c:	8812      	ldrh	r2, [r2, #0]
 800359e:	43d2      	mvns	r2, r2
 80035a0:	b292      	uxth	r2, r2
 80035a2:	4013      	ands	r3, r2
 80035a4:	b29a      	uxth	r2, r3
 80035a6:	687b      	ldr	r3, [r7, #4]
 80035a8:	819a      	strh	r2, [r3, #12]
}
 80035aa:	46c0      	nop			; (mov r8, r8)
 80035ac:	46bd      	mov	sp, r7
 80035ae:	b002      	add	sp, #8
 80035b0:	bd80      	pop	{r7, pc}

080035b2 <TIM_ClearITPendingBit>:
  * @note   TIM_IT_COM is used only with TIM1, TIM15, TIM16 and TIM17.
  *
  * @retval None
  */
void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 80035b2:	b580      	push	{r7, lr}
 80035b4:	b082      	sub	sp, #8
 80035b6:	af00      	add	r7, sp, #0
 80035b8:	6078      	str	r0, [r7, #4]
 80035ba:	000a      	movs	r2, r1
 80035bc:	1cbb      	adds	r3, r7, #2
 80035be:	801a      	strh	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
   
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 80035c0:	1cbb      	adds	r3, r7, #2
 80035c2:	881b      	ldrh	r3, [r3, #0]
 80035c4:	43db      	mvns	r3, r3
 80035c6:	b29a      	uxth	r2, r3
 80035c8:	687b      	ldr	r3, [r7, #4]
 80035ca:	821a      	strh	r2, [r3, #16]
}
 80035cc:	46c0      	nop			; (mov r8, r8)
 80035ce:	46bd      	mov	sp, r7
 80035d0:	b002      	add	sp, #8
 80035d2:	bd80      	pop	{r7, pc}

080035d4 <USART_Init>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 80035d4:	b580      	push	{r7, lr}
 80035d6:	b090      	sub	sp, #64	; 0x40
 80035d8:	af00      	add	r7, sp, #0
 80035da:	6078      	str	r0, [r7, #4]
 80035dc:	6039      	str	r1, [r7, #0]
  uint32_t divider = 0, apbclock = 0, tmpreg = 0;
 80035de:	2300      	movs	r3, #0
 80035e0:	63fb      	str	r3, [r7, #60]	; 0x3c
 80035e2:	2300      	movs	r3, #0
 80035e4:	63bb      	str	r3, [r7, #56]	; 0x38
 80035e6:	2300      	movs	r3, #0
 80035e8:	637b      	str	r3, [r7, #52]	; 0x34
  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
  
  /* Disable USART */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 80035ea:	687b      	ldr	r3, [r7, #4]
 80035ec:	681b      	ldr	r3, [r3, #0]
 80035ee:	2201      	movs	r2, #1
 80035f0:	4393      	bics	r3, r2
 80035f2:	001a      	movs	r2, r3
 80035f4:	687b      	ldr	r3, [r7, #4]
 80035f6:	601a      	str	r2, [r3, #0]
  
  /*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 80035f8:	687b      	ldr	r3, [r7, #4]
 80035fa:	685b      	ldr	r3, [r3, #4]
 80035fc:	637b      	str	r3, [r7, #52]	; 0x34
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 80035fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003600:	4a50      	ldr	r2, [pc, #320]	; (8003744 <USART_Init+0x170>)
 8003602:	4013      	ands	r3, r2
 8003604:	637b      	str	r3, [r7, #52]	; 0x34
  
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8003606:	683b      	ldr	r3, [r7, #0]
 8003608:	689b      	ldr	r3, [r3, #8]
 800360a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800360c:	4313      	orrs	r3, r2
 800360e:	637b      	str	r3, [r7, #52]	; 0x34
  
  /* Write to USART CR2 */
  USARTx->CR2 = tmpreg;
 8003610:	687b      	ldr	r3, [r7, #4]
 8003612:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8003614:	605a      	str	r2, [r3, #4]
  
  /*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8003616:	687b      	ldr	r3, [r7, #4]
 8003618:	681b      	ldr	r3, [r3, #0]
 800361a:	637b      	str	r3, [r7, #52]	; 0x34
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 800361c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800361e:	4a4a      	ldr	r2, [pc, #296]	; (8003748 <USART_Init+0x174>)
 8003620:	4013      	ands	r3, r2
 8003622:	637b      	str	r3, [r7, #52]	; 0x34
  
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8003624:	683b      	ldr	r3, [r7, #0]
 8003626:	685a      	ldr	r2, [r3, #4]
 8003628:	683b      	ldr	r3, [r7, #0]
 800362a:	68db      	ldr	r3, [r3, #12]
 800362c:	431a      	orrs	r2, r3
    USART_InitStruct->USART_Mode;
 800362e:	683b      	ldr	r3, [r7, #0]
 8003630:	691b      	ldr	r3, [r3, #16]
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8003632:	4313      	orrs	r3, r2
 8003634:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8003636:	4313      	orrs	r3, r2
 8003638:	637b      	str	r3, [r7, #52]	; 0x34
  
  /* Write to USART CR1 */
  USARTx->CR1 = tmpreg;
 800363a:	687b      	ldr	r3, [r7, #4]
 800363c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800363e:	601a      	str	r2, [r3, #0]
  
  /*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8003640:	687b      	ldr	r3, [r7, #4]
 8003642:	689b      	ldr	r3, [r3, #8]
 8003644:	637b      	str	r3, [r7, #52]	; 0x34
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 8003646:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003648:	4a40      	ldr	r2, [pc, #256]	; (800374c <USART_Init+0x178>)
 800364a:	4013      	ands	r3, r2
 800364c:	637b      	str	r3, [r7, #52]	; 0x34
  
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 800364e:	683b      	ldr	r3, [r7, #0]
 8003650:	695b      	ldr	r3, [r3, #20]
 8003652:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8003654:	4313      	orrs	r3, r2
 8003656:	637b      	str	r3, [r7, #52]	; 0x34
  
  /* Write to USART CR3 */
  USARTx->CR3 = tmpreg;
 8003658:	687b      	ldr	r3, [r7, #4]
 800365a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800365c:	609a      	str	r2, [r3, #8]
  
  /*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 800365e:	230c      	movs	r3, #12
 8003660:	18fb      	adds	r3, r7, r3
 8003662:	0018      	movs	r0, r3
 8003664:	f7ff fbb0 	bl	8002dc8 <RCC_GetClocksFreq>
  
  if (USARTx == USART1)
 8003668:	687b      	ldr	r3, [r7, #4]
 800366a:	4a39      	ldr	r2, [pc, #228]	; (8003750 <USART_Init+0x17c>)
 800366c:	4293      	cmp	r3, r2
 800366e:	d104      	bne.n	800367a <USART_Init+0xa6>
  {
    apbclock = RCC_ClocksStatus.USART1CLK_Frequency;
 8003670:	230c      	movs	r3, #12
 8003672:	18fb      	adds	r3, r7, r3
 8003674:	699b      	ldr	r3, [r3, #24]
 8003676:	63bb      	str	r3, [r7, #56]	; 0x38
 8003678:	e015      	b.n	80036a6 <USART_Init+0xd2>
  }
  else if (USARTx == USART2)
 800367a:	687b      	ldr	r3, [r7, #4]
 800367c:	4a35      	ldr	r2, [pc, #212]	; (8003754 <USART_Init+0x180>)
 800367e:	4293      	cmp	r3, r2
 8003680:	d104      	bne.n	800368c <USART_Init+0xb8>
  {
    apbclock = RCC_ClocksStatus.USART2CLK_Frequency;
 8003682:	230c      	movs	r3, #12
 8003684:	18fb      	adds	r3, r7, r3
 8003686:	69db      	ldr	r3, [r3, #28]
 8003688:	63bb      	str	r3, [r7, #56]	; 0x38
 800368a:	e00c      	b.n	80036a6 <USART_Init+0xd2>
  }
   else if (USARTx == USART3)
 800368c:	687b      	ldr	r3, [r7, #4]
 800368e:	4a32      	ldr	r2, [pc, #200]	; (8003758 <USART_Init+0x184>)
 8003690:	4293      	cmp	r3, r2
 8003692:	d104      	bne.n	800369e <USART_Init+0xca>
  {
    apbclock = RCC_ClocksStatus.USART3CLK_Frequency;
 8003694:	230c      	movs	r3, #12
 8003696:	18fb      	adds	r3, r7, r3
 8003698:	6a1b      	ldr	r3, [r3, #32]
 800369a:	63bb      	str	r3, [r7, #56]	; 0x38
 800369c:	e003      	b.n	80036a6 <USART_Init+0xd2>
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK_Frequency;
 800369e:	230c      	movs	r3, #12
 80036a0:	18fb      	adds	r3, r7, r3
 80036a2:	689b      	ldr	r3, [r3, #8]
 80036a4:	63bb      	str	r3, [r7, #56]	; 0x38
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 80036a6:	687b      	ldr	r3, [r7, #4]
 80036a8:	681a      	ldr	r2, [r3, #0]
 80036aa:	2380      	movs	r3, #128	; 0x80
 80036ac:	021b      	lsls	r3, r3, #8
 80036ae:	4013      	ands	r3, r2
 80036b0:	d014      	beq.n	80036dc <USART_Init+0x108>
  {
    /* (divider * 10) computing in case Oversampling mode is 8 Samples */
    divider = (uint32_t)((2 * apbclock) / (USART_InitStruct->USART_BaudRate));
 80036b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80036b4:	005a      	lsls	r2, r3, #1
 80036b6:	683b      	ldr	r3, [r7, #0]
 80036b8:	681b      	ldr	r3, [r3, #0]
 80036ba:	0019      	movs	r1, r3
 80036bc:	0010      	movs	r0, r2
 80036be:	f7fc fd2d 	bl	800011c <__udivsi3>
 80036c2:	0003      	movs	r3, r0
 80036c4:	63fb      	str	r3, [r7, #60]	; 0x3c
    tmpreg  = (uint32_t)((2 * apbclock) % (USART_InitStruct->USART_BaudRate));
 80036c6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80036c8:	005a      	lsls	r2, r3, #1
 80036ca:	683b      	ldr	r3, [r7, #0]
 80036cc:	681b      	ldr	r3, [r3, #0]
 80036ce:	0019      	movs	r1, r3
 80036d0:	0010      	movs	r0, r2
 80036d2:	f7fc fda9 	bl	8000228 <__aeabi_uidivmod>
 80036d6:	000b      	movs	r3, r1
 80036d8:	637b      	str	r3, [r7, #52]	; 0x34
 80036da:	e010      	b.n	80036fe <USART_Init+0x12a>
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* (divider * 10) computing in case Oversampling mode is 16 Samples */
    divider = (uint32_t)((apbclock) / (USART_InitStruct->USART_BaudRate));
 80036dc:	683b      	ldr	r3, [r7, #0]
 80036de:	681b      	ldr	r3, [r3, #0]
 80036e0:	0019      	movs	r1, r3
 80036e2:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80036e4:	f7fc fd1a 	bl	800011c <__udivsi3>
 80036e8:	0003      	movs	r3, r0
 80036ea:	63fb      	str	r3, [r7, #60]	; 0x3c
    tmpreg  = (uint32_t)((apbclock) % (USART_InitStruct->USART_BaudRate));
 80036ec:	683b      	ldr	r3, [r7, #0]
 80036ee:	681a      	ldr	r2, [r3, #0]
 80036f0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80036f2:	0011      	movs	r1, r2
 80036f4:	0018      	movs	r0, r3
 80036f6:	f7fc fd97 	bl	8000228 <__aeabi_uidivmod>
 80036fa:	000b      	movs	r3, r1
 80036fc:	637b      	str	r3, [r7, #52]	; 0x34
  }
  
  /* round the divider : if fractional part i greater than 0.5 increment divider */
  if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
 80036fe:	683b      	ldr	r3, [r7, #0]
 8003700:	681b      	ldr	r3, [r3, #0]
 8003702:	085a      	lsrs	r2, r3, #1
 8003704:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003706:	429a      	cmp	r2, r3
 8003708:	d802      	bhi.n	8003710 <USART_Init+0x13c>
  {
    divider++;
 800370a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800370c:	3301      	adds	r3, #1
 800370e:	63fb      	str	r3, [r7, #60]	; 0x3c
  } 
  
  /* Implement the divider in case Oversampling mode is 8 Samples */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8003710:	687b      	ldr	r3, [r7, #4]
 8003712:	681a      	ldr	r2, [r3, #0]
 8003714:	2380      	movs	r3, #128	; 0x80
 8003716:	021b      	lsls	r3, r3, #8
 8003718:	4013      	ands	r3, r2
 800371a:	d00a      	beq.n	8003732 <USART_Init+0x15e>
  {
    /* get the LSB of divider and shift it to the right by 1 bit */
    tmpreg = (divider & (uint16_t)0x000F) >> 1;
 800371c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800371e:	085b      	lsrs	r3, r3, #1
 8003720:	2207      	movs	r2, #7
 8003722:	4013      	ands	r3, r2
 8003724:	637b      	str	r3, [r7, #52]	; 0x34
    
    /* update the divider value */
    divider = (divider & (uint16_t)0xFFF0) | tmpreg;
 8003726:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003728:	4a0c      	ldr	r2, [pc, #48]	; (800375c <USART_Init+0x188>)
 800372a:	401a      	ands	r2, r3
 800372c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800372e:	4313      	orrs	r3, r2
 8003730:	63fb      	str	r3, [r7, #60]	; 0x3c
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)divider;
 8003732:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8003734:	b29a      	uxth	r2, r3
 8003736:	687b      	ldr	r3, [r7, #4]
 8003738:	819a      	strh	r2, [r3, #12]
}
 800373a:	46c0      	nop			; (mov r8, r8)
 800373c:	46bd      	mov	sp, r7
 800373e:	b010      	add	sp, #64	; 0x40
 8003740:	bd80      	pop	{r7, pc}
 8003742:	46c0      	nop			; (mov r8, r8)
 8003744:	ffffcfff 	.word	0xffffcfff
 8003748:	ffffe9f3 	.word	0xffffe9f3
 800374c:	fffffcff 	.word	0xfffffcff
 8003750:	40013800 	.word	0x40013800
 8003754:	40004400 	.word	0x40004400
 8003758:	40004800 	.word	0x40004800
 800375c:	0000fff0 	.word	0x0000fff0

08003760 <USART_Cmd>:
  * @param  NewState: new state of the USARTx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 8003760:	b580      	push	{r7, lr}
 8003762:	b082      	sub	sp, #8
 8003764:	af00      	add	r7, sp, #0
 8003766:	6078      	str	r0, [r7, #4]
 8003768:	000a      	movs	r2, r1
 800376a:	1cfb      	adds	r3, r7, #3
 800376c:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800376e:	1cfb      	adds	r3, r7, #3
 8003770:	781b      	ldrb	r3, [r3, #0]
 8003772:	2b00      	cmp	r3, #0
 8003774:	d006      	beq.n	8003784 <USART_Cmd+0x24>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8003776:	687b      	ldr	r3, [r7, #4]
 8003778:	681b      	ldr	r3, [r3, #0]
 800377a:	2201      	movs	r2, #1
 800377c:	431a      	orrs	r2, r3
 800377e:	687b      	ldr	r3, [r7, #4]
 8003780:	601a      	str	r2, [r3, #0]
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
  }
}
 8003782:	e006      	b.n	8003792 <USART_Cmd+0x32>
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 8003784:	687b      	ldr	r3, [r7, #4]
 8003786:	681b      	ldr	r3, [r3, #0]
 8003788:	2201      	movs	r2, #1
 800378a:	4393      	bics	r3, r2
 800378c:	001a      	movs	r2, r3
 800378e:	687b      	ldr	r3, [r7, #4]
 8003790:	601a      	str	r2, [r3, #0]
}
 8003792:	46c0      	nop			; (mov r8, r8)
 8003794:	46bd      	mov	sp, r7
 8003796:	b002      	add	sp, #8
 8003798:	bd80      	pop	{r7, pc}

0800379a <USART_SendData>:
  * @note   USART2 is not available for STM32F031 devices.  
  * @param  Data: the data to transmit.
  * @retval None
  */
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
{
 800379a:	b580      	push	{r7, lr}
 800379c:	b082      	sub	sp, #8
 800379e:	af00      	add	r7, sp, #0
 80037a0:	6078      	str	r0, [r7, #4]
 80037a2:	000a      	movs	r2, r1
 80037a4:	1cbb      	adds	r3, r7, #2
 80037a6:	801a      	strh	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->TDR = (Data & (uint16_t)0x01FF);
 80037a8:	1cbb      	adds	r3, r7, #2
 80037aa:	881b      	ldrh	r3, [r3, #0]
 80037ac:	05db      	lsls	r3, r3, #23
 80037ae:	0ddb      	lsrs	r3, r3, #23
 80037b0:	b29a      	uxth	r2, r3
 80037b2:	687b      	ldr	r3, [r7, #4]
 80037b4:	851a      	strh	r2, [r3, #40]	; 0x28
}
 80037b6:	46c0      	nop			; (mov r8, r8)
 80037b8:	46bd      	mov	sp, r7
 80037ba:	b002      	add	sp, #8
 80037bc:	bd80      	pop	{r7, pc}

080037be <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState)
{
 80037be:	b580      	push	{r7, lr}
 80037c0:	b088      	sub	sp, #32
 80037c2:	af00      	add	r7, sp, #0
 80037c4:	60f8      	str	r0, [r7, #12]
 80037c6:	60b9      	str	r1, [r7, #8]
 80037c8:	1dfb      	adds	r3, r7, #7
 80037ca:	701a      	strb	r2, [r3, #0]
  uint32_t usartreg = 0, itpos = 0, itmask = 0;
 80037cc:	2300      	movs	r3, #0
 80037ce:	61bb      	str	r3, [r7, #24]
 80037d0:	2300      	movs	r3, #0
 80037d2:	617b      	str	r3, [r7, #20]
 80037d4:	2300      	movs	r3, #0
 80037d6:	613b      	str	r3, [r7, #16]
  uint32_t usartxbase = 0;
 80037d8:	2300      	movs	r3, #0
 80037da:	61fb      	str	r3, [r7, #28]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CONFIG_IT(USART_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  usartxbase = (uint32_t)USARTx;
 80037dc:	68fb      	ldr	r3, [r7, #12]
 80037de:	61fb      	str	r3, [r7, #28]
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
 80037e0:	68bb      	ldr	r3, [r7, #8]
 80037e2:	b29b      	uxth	r3, r3
 80037e4:	0a1b      	lsrs	r3, r3, #8
 80037e6:	b29b      	uxth	r3, r3
 80037e8:	61bb      	str	r3, [r7, #24]
  
  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
 80037ea:	68bb      	ldr	r3, [r7, #8]
 80037ec:	22ff      	movs	r2, #255	; 0xff
 80037ee:	4013      	ands	r3, r2
 80037f0:	617b      	str	r3, [r7, #20]
  itmask = (((uint32_t)0x01) << itpos);
 80037f2:	2201      	movs	r2, #1
 80037f4:	697b      	ldr	r3, [r7, #20]
 80037f6:	409a      	lsls	r2, r3
 80037f8:	0013      	movs	r3, r2
 80037fa:	613b      	str	r3, [r7, #16]
  
  if (usartreg == 0x02) /* The IT is in CR2 register */
 80037fc:	69bb      	ldr	r3, [r7, #24]
 80037fe:	2b02      	cmp	r3, #2
 8003800:	d103      	bne.n	800380a <USART_ITConfig+0x4c>
  {
    usartxbase += 0x04;
 8003802:	69fb      	ldr	r3, [r7, #28]
 8003804:	3304      	adds	r3, #4
 8003806:	61fb      	str	r3, [r7, #28]
 8003808:	e005      	b.n	8003816 <USART_ITConfig+0x58>
  }
  else if (usartreg == 0x03) /* The IT is in CR3 register */
 800380a:	69bb      	ldr	r3, [r7, #24]
 800380c:	2b03      	cmp	r3, #3
 800380e:	d102      	bne.n	8003816 <USART_ITConfig+0x58>
  {
    usartxbase += 0x08;
 8003810:	69fb      	ldr	r3, [r7, #28]
 8003812:	3308      	adds	r3, #8
 8003814:	61fb      	str	r3, [r7, #28]
  }
  else /* The IT is in CR1 register */
  {
  }
  if (NewState != DISABLE)
 8003816:	1dfb      	adds	r3, r7, #7
 8003818:	781b      	ldrb	r3, [r3, #0]
 800381a:	2b00      	cmp	r3, #0
 800381c:	d006      	beq.n	800382c <USART_ITConfig+0x6e>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 800381e:	69fb      	ldr	r3, [r7, #28]
 8003820:	69fa      	ldr	r2, [r7, #28]
 8003822:	6811      	ldr	r1, [r2, #0]
 8003824:	693a      	ldr	r2, [r7, #16]
 8003826:	430a      	orrs	r2, r1
 8003828:	601a      	str	r2, [r3, #0]
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
  }
}
 800382a:	e006      	b.n	800383a <USART_ITConfig+0x7c>
    *(__IO uint32_t*)usartxbase &= ~itmask;
 800382c:	69fb      	ldr	r3, [r7, #28]
 800382e:	69fa      	ldr	r2, [r7, #28]
 8003830:	6812      	ldr	r2, [r2, #0]
 8003832:	6939      	ldr	r1, [r7, #16]
 8003834:	43c9      	mvns	r1, r1
 8003836:	400a      	ands	r2, r1
 8003838:	601a      	str	r2, [r3, #0]
}
 800383a:	46c0      	nop			; (mov r8, r8)
 800383c:	46bd      	mov	sp, r7
 800383e:	b008      	add	sp, #32
 8003840:	bd80      	pop	{r7, pc}

08003842 <coolant_get_state>:
}


// Returns current coolant output state. Overrides may alter it from programmed state.
uint8_t coolant_get_state()
{
 8003842:	b580      	push	{r7, lr}
 8003844:	b082      	sub	sp, #8
 8003846:	af00      	add	r7, sp, #0
  uint8_t cl_state = COOLANT_STATE_DISABLE;
 8003848:	1dfb      	adds	r3, r7, #7
 800384a:	2200      	movs	r2, #0
 800384c:	701a      	strb	r2, [r3, #0]
    #endif
      cl_state |= COOLANT_STATE_MIST;
    }
  #endif
#endif
  return(cl_state);
 800384e:	1dfb      	adds	r3, r7, #7
 8003850:	781b      	ldrb	r3, [r3, #0]
}
 8003852:	0018      	movs	r0, r3
 8003854:	46bd      	mov	sp, r7
 8003856:	b002      	add	sp, #8
 8003858:	bd80      	pop	{r7, pc}

0800385a <coolant_stop>:


// Directly called by coolant_init(), coolant_set_state(), and mc_reset(), which can be at
// an interrupt-level. No report flag set, but only called by routines that don't need it.
void coolant_stop()
{
 800385a:	b580      	push	{r7, lr}
 800385c:	af00      	add	r7, sp, #0
	GPIO_ResetBits(COOLANT_MIST_PORT, 1 << COOLANT_MIST_BIT);
#endif
    #endif
  #endif
#endif
}
 800385e:	46c0      	nop			; (mov r8, r8)
 8003860:	46bd      	mov	sp, r7
 8003862:	bd80      	pop	{r7, pc}

08003864 <coolant_set_state>:
// Main program only. Immediately sets flood coolant running state and also mist coolant, 
// if enabled. Also sets a flag to report an update to a coolant state.
// Called by coolant toggle override, parking restore, parking retract, sleep mode, g-code
// parser program end, and g-code parser coolant_sync().
void coolant_set_state(uint8_t mode)
{
 8003864:	b580      	push	{r7, lr}
 8003866:	b082      	sub	sp, #8
 8003868:	af00      	add	r7, sp, #0
 800386a:	0002      	movs	r2, r0
 800386c:	1dfb      	adds	r3, r7, #7
 800386e:	701a      	strb	r2, [r3, #0]
  if (sys.abort) { return; } // Block during abort.  
 8003870:	4b08      	ldr	r3, [pc, #32]	; (8003894 <coolant_set_state+0x30>)
 8003872:	785b      	ldrb	r3, [r3, #1]
 8003874:	2b00      	cmp	r3, #0
 8003876:	d109      	bne.n	800388c <coolant_set_state+0x28>
  
  if (mode == COOLANT_DISABLE) {
 8003878:	1dfb      	adds	r3, r7, #7
 800387a:	781b      	ldrb	r3, [r3, #0]
 800387c:	2b00      	cmp	r3, #0
 800387e:	d101      	bne.n	8003884 <coolant_set_state+0x20>
  
    coolant_stop(); 
 8003880:	f7ff ffeb 	bl	800385a <coolant_stop>
        #endif
      }
    #endif
#endif  
  }
  sys.report_ovr_counter = 0; // Set to report change immediately
 8003884:	4b03      	ldr	r3, [pc, #12]	; (8003894 <coolant_set_state+0x30>)
 8003886:	2200      	movs	r2, #0
 8003888:	72da      	strb	r2, [r3, #11]
 800388a:	e000      	b.n	800388e <coolant_set_state+0x2a>
  if (sys.abort) { return; } // Block during abort.  
 800388c:	46c0      	nop			; (mov r8, r8)
}
 800388e:	46bd      	mov	sp, r7
 8003890:	b002      	add	sp, #8
 8003892:	bd80      	pop	{r7, pc}
 8003894:	20000bb4 	.word	0x20000bb4

08003898 <coolant_sync>:


// G-code parser entry-point for setting coolant state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void coolant_sync(uint8_t mode)
{
 8003898:	b580      	push	{r7, lr}
 800389a:	b082      	sub	sp, #8
 800389c:	af00      	add	r7, sp, #0
 800389e:	0002      	movs	r2, r0
 80038a0:	1dfb      	adds	r3, r7, #7
 80038a2:	701a      	strb	r2, [r3, #0]
  if (sys.state == STATE_CHECK_MODE) { return; }
 80038a4:	4b07      	ldr	r3, [pc, #28]	; (80038c4 <coolant_sync+0x2c>)
 80038a6:	781b      	ldrb	r3, [r3, #0]
 80038a8:	2b02      	cmp	r3, #2
 80038aa:	d007      	beq.n	80038bc <coolant_sync+0x24>
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.
 80038ac:	f004 fa44 	bl	8007d38 <protocol_buffer_synchronize>
  coolant_set_state(mode);
 80038b0:	1dfb      	adds	r3, r7, #7
 80038b2:	781b      	ldrb	r3, [r3, #0]
 80038b4:	0018      	movs	r0, r3
 80038b6:	f7ff ffd5 	bl	8003864 <coolant_set_state>
 80038ba:	e000      	b.n	80038be <coolant_sync+0x26>
  if (sys.state == STATE_CHECK_MODE) { return; }
 80038bc:	46c0      	nop			; (mov r8, r8)
}
 80038be:	46bd      	mov	sp, r7
 80038c0:	b002      	add	sp, #8
 80038c2:	bd80      	pop	{r7, pc}
 80038c4:	20000bb4 	.word	0x20000bb4

080038c8 <eeprom_get_char>:
 *
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
 80038c8:	b580      	push	{r7, lr}
 80038ca:	b082      	sub	sp, #8
 80038cc:	af00      	add	r7, sp, #0
 80038ce:	6078      	str	r0, [r7, #4]
	EEAR = addr; // Set EEPROM address register.
	EECR = (1<<EERE); // Start EEPROM read operation.
	return EEDR; // Return the byte read from EEPROM.
#endif
#if defined(WIN32) || defined(STM32F103C8) || defined(STM32F0DISCOVERY)
	return EE_Buffer[addr];
 80038d0:	4a03      	ldr	r2, [pc, #12]	; (80038e0 <eeprom_get_char+0x18>)
 80038d2:	687b      	ldr	r3, [r7, #4]
 80038d4:	18d3      	adds	r3, r2, r3
 80038d6:	781b      	ldrb	r3, [r3, #0]
#endif
}
 80038d8:	0018      	movs	r0, r3
 80038da:	46bd      	mov	sp, r7
 80038dc:	b002      	add	sp, #8
 80038de:	bd80      	pop	{r7, pc}
 80038e0:	200005c4 	.word	0x200005c4

080038e4 <eeprom_put_char>:
 *
 *  \param  addr  EEPROM address to write to.
 *  \param  new_value  New EEPROM value.
 */
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
 80038e4:	b580      	push	{r7, lr}
 80038e6:	b082      	sub	sp, #8
 80038e8:	af00      	add	r7, sp, #0
 80038ea:	6078      	str	r0, [r7, #4]
 80038ec:	000a      	movs	r2, r1
 80038ee:	1cfb      	adds	r3, r7, #3
 80038f0:	701a      	strb	r2, [r3, #0]
	}
	
	sei(); // Restore interrupt flag state.
#endif
#if defined(WIN32) || defined(STM32F103C8) || defined(STM32F0DISCOVERY)
	EE_Buffer[addr] = new_value;
 80038f2:	4a05      	ldr	r2, [pc, #20]	; (8003908 <eeprom_put_char+0x24>)
 80038f4:	687b      	ldr	r3, [r7, #4]
 80038f6:	18d3      	adds	r3, r2, r3
 80038f8:	1cfa      	adds	r2, r7, #3
 80038fa:	7812      	ldrb	r2, [r2, #0]
 80038fc:	701a      	strb	r2, [r3, #0]
#endif
}
 80038fe:	46c0      	nop			; (mov r8, r8)
 8003900:	46bd      	mov	sp, r7
 8003902:	b002      	add	sp, #8
 8003904:	bd80      	pop	{r7, pc}
 8003906:	46c0      	nop			; (mov r8, r8)
 8003908:	200005c4 	.word	0x200005c4

0800390c <memcpy_to_eeprom_with_checksum>:

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
 800390c:	b580      	push	{r7, lr}
 800390e:	b086      	sub	sp, #24
 8003910:	af00      	add	r7, sp, #0
 8003912:	60f8      	str	r0, [r7, #12]
 8003914:	60b9      	str	r1, [r7, #8]
 8003916:	607a      	str	r2, [r7, #4]
  unsigned char checksum = 0;
 8003918:	2317      	movs	r3, #23
 800391a:	18fb      	adds	r3, r7, r3
 800391c:	2200      	movs	r2, #0
 800391e:	701a      	strb	r2, [r3, #0]
  for(; size > 0; size--) { 
 8003920:	e027      	b.n	8003972 <memcpy_to_eeprom_with_checksum+0x66>
    checksum = (checksum << 1) || (checksum >> 7);
 8003922:	2317      	movs	r3, #23
 8003924:	18fb      	adds	r3, r7, r3
 8003926:	781b      	ldrb	r3, [r3, #0]
 8003928:	005b      	lsls	r3, r3, #1
 800392a:	d105      	bne.n	8003938 <memcpy_to_eeprom_with_checksum+0x2c>
 800392c:	2317      	movs	r3, #23
 800392e:	18fb      	adds	r3, r7, r3
 8003930:	781b      	ldrb	r3, [r3, #0]
 8003932:	b25b      	sxtb	r3, r3
 8003934:	2b00      	cmp	r3, #0
 8003936:	da01      	bge.n	800393c <memcpy_to_eeprom_with_checksum+0x30>
 8003938:	2201      	movs	r2, #1
 800393a:	e000      	b.n	800393e <memcpy_to_eeprom_with_checksum+0x32>
 800393c:	2200      	movs	r2, #0
 800393e:	2317      	movs	r3, #23
 8003940:	18fb      	adds	r3, r7, r3
 8003942:	701a      	strb	r2, [r3, #0]
    checksum += *source;
 8003944:	68bb      	ldr	r3, [r7, #8]
 8003946:	7819      	ldrb	r1, [r3, #0]
 8003948:	2317      	movs	r3, #23
 800394a:	18fb      	adds	r3, r7, r3
 800394c:	2217      	movs	r2, #23
 800394e:	18ba      	adds	r2, r7, r2
 8003950:	7812      	ldrb	r2, [r2, #0]
 8003952:	188a      	adds	r2, r1, r2
 8003954:	701a      	strb	r2, [r3, #0]
    eeprom_put_char(destination++, *(source++)); 
 8003956:	68fa      	ldr	r2, [r7, #12]
 8003958:	1c53      	adds	r3, r2, #1
 800395a:	60fb      	str	r3, [r7, #12]
 800395c:	68bb      	ldr	r3, [r7, #8]
 800395e:	1c59      	adds	r1, r3, #1
 8003960:	60b9      	str	r1, [r7, #8]
 8003962:	781b      	ldrb	r3, [r3, #0]
 8003964:	0019      	movs	r1, r3
 8003966:	0010      	movs	r0, r2
 8003968:	f7ff ffbc 	bl	80038e4 <eeprom_put_char>
  for(; size > 0; size--) { 
 800396c:	687b      	ldr	r3, [r7, #4]
 800396e:	3b01      	subs	r3, #1
 8003970:	607b      	str	r3, [r7, #4]
 8003972:	687b      	ldr	r3, [r7, #4]
 8003974:	2b00      	cmp	r3, #0
 8003976:	d1d4      	bne.n	8003922 <memcpy_to_eeprom_with_checksum+0x16>
  }
  eeprom_put_char(destination, checksum);
 8003978:	2317      	movs	r3, #23
 800397a:	18fb      	adds	r3, r7, r3
 800397c:	781a      	ldrb	r2, [r3, #0]
 800397e:	68fb      	ldr	r3, [r7, #12]
 8003980:	0011      	movs	r1, r2
 8003982:	0018      	movs	r0, r3
 8003984:	f7ff ffae 	bl	80038e4 <eeprom_put_char>
#if defined(WIN32) || defined(STM32F103C8) || defined(STM32F0DISCOVERY)
#ifndef NOEEPROMSUPPORT
  eeprom_flush();
#endif
#endif
}
 8003988:	46c0      	nop			; (mov r8, r8)
 800398a:	46bd      	mov	sp, r7
 800398c:	b006      	add	sp, #24
 800398e:	bd80      	pop	{r7, pc}

08003990 <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
 8003990:	b590      	push	{r4, r7, lr}
 8003992:	b087      	sub	sp, #28
 8003994:	af00      	add	r7, sp, #0
 8003996:	60f8      	str	r0, [r7, #12]
 8003998:	60b9      	str	r1, [r7, #8]
 800399a:	607a      	str	r2, [r7, #4]
  unsigned char data, checksum = 0;
 800399c:	2317      	movs	r3, #23
 800399e:	18fb      	adds	r3, r7, r3
 80039a0:	2200      	movs	r2, #0
 80039a2:	701a      	strb	r2, [r3, #0]
  for(; size > 0; size--) { 
 80039a4:	e02e      	b.n	8003a04 <memcpy_from_eeprom_with_checksum+0x74>
    data = eeprom_get_char(source++);
 80039a6:	68bb      	ldr	r3, [r7, #8]
 80039a8:	1c5a      	adds	r2, r3, #1
 80039aa:	60ba      	str	r2, [r7, #8]
 80039ac:	2216      	movs	r2, #22
 80039ae:	18bc      	adds	r4, r7, r2
 80039b0:	0018      	movs	r0, r3
 80039b2:	f7ff ff89 	bl	80038c8 <eeprom_get_char>
 80039b6:	0003      	movs	r3, r0
 80039b8:	7023      	strb	r3, [r4, #0]
    checksum = (checksum << 1) || (checksum >> 7);
 80039ba:	2317      	movs	r3, #23
 80039bc:	18fb      	adds	r3, r7, r3
 80039be:	781b      	ldrb	r3, [r3, #0]
 80039c0:	005b      	lsls	r3, r3, #1
 80039c2:	d105      	bne.n	80039d0 <memcpy_from_eeprom_with_checksum+0x40>
 80039c4:	2317      	movs	r3, #23
 80039c6:	18fb      	adds	r3, r7, r3
 80039c8:	781b      	ldrb	r3, [r3, #0]
 80039ca:	b25b      	sxtb	r3, r3
 80039cc:	2b00      	cmp	r3, #0
 80039ce:	da01      	bge.n	80039d4 <memcpy_from_eeprom_with_checksum+0x44>
 80039d0:	2201      	movs	r2, #1
 80039d2:	e000      	b.n	80039d6 <memcpy_from_eeprom_with_checksum+0x46>
 80039d4:	2200      	movs	r2, #0
 80039d6:	2317      	movs	r3, #23
 80039d8:	18fb      	adds	r3, r7, r3
 80039da:	701a      	strb	r2, [r3, #0]
    checksum += data;    
 80039dc:	2317      	movs	r3, #23
 80039de:	18fb      	adds	r3, r7, r3
 80039e0:	2217      	movs	r2, #23
 80039e2:	18b9      	adds	r1, r7, r2
 80039e4:	2216      	movs	r2, #22
 80039e6:	18ba      	adds	r2, r7, r2
 80039e8:	7809      	ldrb	r1, [r1, #0]
 80039ea:	7812      	ldrb	r2, [r2, #0]
 80039ec:	188a      	adds	r2, r1, r2
 80039ee:	701a      	strb	r2, [r3, #0]
    *(destination++) = data; 
 80039f0:	68fb      	ldr	r3, [r7, #12]
 80039f2:	1c5a      	adds	r2, r3, #1
 80039f4:	60fa      	str	r2, [r7, #12]
 80039f6:	2216      	movs	r2, #22
 80039f8:	18ba      	adds	r2, r7, r2
 80039fa:	7812      	ldrb	r2, [r2, #0]
 80039fc:	701a      	strb	r2, [r3, #0]
  for(; size > 0; size--) { 
 80039fe:	687b      	ldr	r3, [r7, #4]
 8003a00:	3b01      	subs	r3, #1
 8003a02:	607b      	str	r3, [r7, #4]
 8003a04:	687b      	ldr	r3, [r7, #4]
 8003a06:	2b00      	cmp	r3, #0
 8003a08:	d1cd      	bne.n	80039a6 <memcpy_from_eeprom_with_checksum+0x16>
  }
  return(checksum == eeprom_get_char(source));
 8003a0a:	68bb      	ldr	r3, [r7, #8]
 8003a0c:	0018      	movs	r0, r3
 8003a0e:	f7ff ff5b 	bl	80038c8 <eeprom_get_char>
 8003a12:	0003      	movs	r3, r0
 8003a14:	001a      	movs	r2, r3
 8003a16:	2317      	movs	r3, #23
 8003a18:	18fb      	adds	r3, r7, r3
 8003a1a:	781b      	ldrb	r3, [r3, #0]
 8003a1c:	1a9b      	subs	r3, r3, r2
 8003a1e:	425a      	negs	r2, r3
 8003a20:	4153      	adcs	r3, r2
 8003a22:	b2db      	uxtb	r3, r3
}
 8003a24:	0018      	movs	r0, r3
 8003a26:	46bd      	mov	sp, r7
 8003a28:	b007      	add	sp, #28
 8003a2a:	bd90      	pop	{r4, r7, pc}

08003a2c <gc_init>:

#define FAIL(status) return(status);


void gc_init()
{
 8003a2c:	b580      	push	{r7, lr}
 8003a2e:	af00      	add	r7, sp, #0
  memset(&gc_state, 0, sizeof(parser_state_t));
 8003a30:	4b0a      	ldr	r3, [pc, #40]	; (8003a5c <gc_init+0x30>)
 8003a32:	2250      	movs	r2, #80	; 0x50
 8003a34:	2100      	movs	r1, #0
 8003a36:	0018      	movs	r0, r3
 8003a38:	f008 fe64 	bl	800c704 <memset>

  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) {
 8003a3c:	4b07      	ldr	r3, [pc, #28]	; (8003a5c <gc_init+0x30>)
 8003a3e:	799b      	ldrb	r3, [r3, #6]
 8003a40:	4a07      	ldr	r2, [pc, #28]	; (8003a60 <gc_init+0x34>)
 8003a42:	0011      	movs	r1, r2
 8003a44:	0018      	movs	r0, r3
 8003a46:	f005 ffcf 	bl	80099e8 <settings_read_coord_data>
 8003a4a:	1e03      	subs	r3, r0, #0
 8003a4c:	d102      	bne.n	8003a54 <gc_init+0x28>
    report_status_message(STATUS_SETTING_READ_FAIL);
 8003a4e:	2007      	movs	r0, #7
 8003a50:	f004 fea2 	bl	8008798 <report_status_message>
  }
}
 8003a54:	46c0      	nop			; (mov r8, r8)
 8003a56:	46bd      	mov	sp, r7
 8003a58:	bd80      	pop	{r7, pc}
 8003a5a:	46c0      	nop			; (mov r8, r8)
 8003a5c:	200009c4 	.word	0x200009c4
 8003a60:	200009f0 	.word	0x200009f0

08003a64 <gc_sync_position>:


// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position()
{
 8003a64:	b580      	push	{r7, lr}
 8003a66:	af00      	add	r7, sp, #0
  system_convert_array_steps_to_mpos(gc_state.position,sys_position);
 8003a68:	4a04      	ldr	r2, [pc, #16]	; (8003a7c <gc_sync_position+0x18>)
 8003a6a:	4b05      	ldr	r3, [pc, #20]	; (8003a80 <gc_sync_position+0x1c>)
 8003a6c:	0011      	movs	r1, r2
 8003a6e:	0018      	movs	r0, r3
 8003a70:	f008 fa8c 	bl	800bf8c <system_convert_array_steps_to_mpos>
}
 8003a74:	46c0      	nop			; (mov r8, r8)
 8003a76:	46bd      	mov	sp, r7
 8003a78:	bd80      	pop	{r7, pc}
 8003a7a:	46c0      	nop			; (mov r8, r8)
 8003a7c:	20000bdc 	.word	0x20000bdc
 8003a80:	200009e0 	.word	0x200009e0

08003a84 <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine
// coordinates, respectively.
uint8_t gc_execute_line(char *line)
{
 8003a84:	b5b0      	push	{r4, r5, r7, lr}
 8003a86:	b09e      	sub	sp, #120	; 0x78
 8003a88:	af06      	add	r7, sp, #24
 8003a8a:	6078      	str	r0, [r7, #4]
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
 8003a8c:	4bd9      	ldr	r3, [pc, #868]	; (8003df4 <gc_execute_line+0x370>)
 8003a8e:	2244      	movs	r2, #68	; 0x44
 8003a90:	2100      	movs	r1, #0
 8003a92:	0018      	movs	r0, r3
 8003a94:	f008 fe36 	bl	800c704 <memset>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
 8003a98:	4bd6      	ldr	r3, [pc, #856]	; (8003df4 <gc_execute_line+0x370>)
 8003a9a:	2201      	movs	r2, #1
 8003a9c:	49d6      	ldr	r1, [pc, #856]	; (8003df8 <gc_execute_line+0x374>)
 8003a9e:	189b      	adds	r3, r3, r2
 8003aa0:	220b      	movs	r2, #11
 8003aa2:	0018      	movs	r0, r3
 8003aa4:	f008 fe25 	bl	800c6f2 <memcpy>

  uint8_t axis_command = AXIS_COMMAND_NONE;
 8003aa8:	235f      	movs	r3, #95	; 0x5f
 8003aaa:	18fb      	adds	r3, r7, r3
 8003aac:	2200      	movs	r2, #0
 8003aae:	701a      	strb	r2, [r3, #0]
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
 8003ab0:	235b      	movs	r3, #91	; 0x5b
 8003ab2:	18fb      	adds	r3, r7, r3
 8003ab4:	2200      	movs	r2, #0
 8003ab6:	701a      	strb	r2, [r3, #0]

  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
 8003ab8:	235a      	movs	r3, #90	; 0x5a
 8003aba:	18fb      	adds	r3, r7, r3
 8003abc:	2200      	movs	r2, #0
 8003abe:	701a      	strb	r2, [r3, #0]
  uint8_t ijk_words = 0; // IJK tracking
 8003ac0:	2359      	movs	r3, #89	; 0x59
 8003ac2:	18fb      	adds	r3, r7, r3
 8003ac4:	2200      	movs	r2, #0
 8003ac6:	701a      	strb	r2, [r3, #0]

  // Initialize command and value words and parser flags variables.
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
 8003ac8:	2356      	movs	r3, #86	; 0x56
 8003aca:	18fb      	adds	r3, r7, r3
 8003acc:	2200      	movs	r2, #0
 8003ace:	801a      	strh	r2, [r3, #0]
  uint16_t value_words = 0; // Tracks value words.
 8003ad0:	2354      	movs	r3, #84	; 0x54
 8003ad2:	18fb      	adds	r3, r7, r3
 8003ad4:	2200      	movs	r2, #0
 8003ad6:	801a      	strh	r2, [r3, #0]
  uint8_t gc_parser_flags = GC_PARSER_NONE;
 8003ad8:	2353      	movs	r3, #83	; 0x53
 8003ada:	18fb      	adds	r3, r7, r3
 8003adc:	2200      	movs	r2, #0
 8003ade:	701a      	strb	r2, [r3, #0]

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
 8003ae0:	687b      	ldr	r3, [r7, #4]
 8003ae2:	781b      	ldrb	r3, [r3, #0]
 8003ae4:	2b24      	cmp	r3, #36	; 0x24
 8003ae6:	d10d      	bne.n	8003b04 <gc_execute_line+0x80>
						// Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
 8003ae8:	2353      	movs	r3, #83	; 0x53
 8003aea:	18fb      	adds	r3, r7, r3
 8003aec:	2253      	movs	r2, #83	; 0x53
 8003aee:	18ba      	adds	r2, r7, r2
 8003af0:	7812      	ldrb	r2, [r2, #0]
 8003af2:	2101      	movs	r1, #1
 8003af4:	430a      	orrs	r2, r1
 8003af6:	701a      	strb	r2, [r3, #0]
	gc_block.modal.motion = MOTION_MODE_LINEAR;
 8003af8:	4bbe      	ldr	r3, [pc, #760]	; (8003df4 <gc_execute_line+0x370>)
 8003afa:	2201      	movs	r2, #1
 8003afc:	705a      	strb	r2, [r3, #1]
    gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
 8003afe:	4bbd      	ldr	r3, [pc, #756]	; (8003df4 <gc_execute_line+0x370>)
 8003b00:	2200      	movs	r2, #0
 8003b02:	709a      	strb	r2, [r3, #2]

  uint8_t word_bit; // Bit-value for assigning tracking variables
  uint8_t char_counter;
  char letter;
  float value;
  uint8_t int_value = 0;
 8003b04:	2346      	movs	r3, #70	; 0x46
 8003b06:	18fb      	adds	r3, r7, r3
 8003b08:	2200      	movs	r2, #0
 8003b0a:	701a      	strb	r2, [r3, #0]
  uint16_t mantissa = 0;
 8003b0c:	2350      	movs	r3, #80	; 0x50
 8003b0e:	18fb      	adds	r3, r7, r3
 8003b10:	2200      	movs	r2, #0
 8003b12:	801a      	strh	r2, [r3, #0]
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
 8003b14:	2353      	movs	r3, #83	; 0x53
 8003b16:	18fb      	adds	r3, r7, r3
 8003b18:	781b      	ldrb	r3, [r3, #0]
 8003b1a:	2201      	movs	r2, #1
 8003b1c:	4013      	ands	r3, r2
 8003b1e:	d005      	beq.n	8003b2c <gc_execute_line+0xa8>
 8003b20:	232e      	movs	r3, #46	; 0x2e
 8003b22:	18fb      	adds	r3, r7, r3
 8003b24:	2203      	movs	r2, #3
 8003b26:	701a      	strb	r2, [r3, #0]
 8003b28:	f000 fb92 	bl	8004250 <gc_execute_line+0x7cc>
  else { char_counter = 0; }
 8003b2c:	232e      	movs	r3, #46	; 0x2e
 8003b2e:	18fb      	adds	r3, r7, r3
 8003b30:	2200      	movs	r2, #0
 8003b32:	701a      	strb	r2, [r3, #0]

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
 8003b34:	f000 fb8c 	bl	8004250 <gc_execute_line+0x7cc>

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
 8003b38:	232e      	movs	r3, #46	; 0x2e
 8003b3a:	18fb      	adds	r3, r7, r3
 8003b3c:	781b      	ldrb	r3, [r3, #0]
 8003b3e:	001a      	movs	r2, r3
 8003b40:	687b      	ldr	r3, [r7, #4]
 8003b42:	189a      	adds	r2, r3, r2
 8003b44:	2345      	movs	r3, #69	; 0x45
 8003b46:	18fb      	adds	r3, r7, r3
 8003b48:	7812      	ldrb	r2, [r2, #0]
 8003b4a:	701a      	strb	r2, [r3, #0]
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
 8003b4c:	2345      	movs	r3, #69	; 0x45
 8003b4e:	18fb      	adds	r3, r7, r3
 8003b50:	781b      	ldrb	r3, [r3, #0]
 8003b52:	2b40      	cmp	r3, #64	; 0x40
 8003b54:	d904      	bls.n	8003b60 <gc_execute_line+0xdc>
 8003b56:	2345      	movs	r3, #69	; 0x45
 8003b58:	18fb      	adds	r3, r7, r3
 8003b5a:	781b      	ldrb	r3, [r3, #0]
 8003b5c:	2b5a      	cmp	r3, #90	; 0x5a
 8003b5e:	d902      	bls.n	8003b66 <gc_execute_line+0xe2>
 8003b60:	2301      	movs	r3, #1
 8003b62:	f001 fcd4 	bl	800550e <gc_execute_line+0x1a8a>
    char_counter++;
 8003b66:	232e      	movs	r3, #46	; 0x2e
 8003b68:	18fb      	adds	r3, r7, r3
 8003b6a:	781b      	ldrb	r3, [r3, #0]
 8003b6c:	3301      	adds	r3, #1
 8003b6e:	b2da      	uxtb	r2, r3
 8003b70:	232e      	movs	r3, #46	; 0x2e
 8003b72:	18fb      	adds	r3, r7, r3
 8003b74:	701a      	strb	r2, [r3, #0]
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
 8003b76:	2328      	movs	r3, #40	; 0x28
 8003b78:	18fa      	adds	r2, r7, r3
 8003b7a:	232e      	movs	r3, #46	; 0x2e
 8003b7c:	18f9      	adds	r1, r7, r3
 8003b7e:	687b      	ldr	r3, [r7, #4]
 8003b80:	0018      	movs	r0, r3
 8003b82:	f002 fd2f 	bl	80065e4 <read_float>
 8003b86:	1e03      	subs	r3, r0, #0
 8003b88:	d102      	bne.n	8003b90 <gc_execute_line+0x10c>
 8003b8a:	2302      	movs	r3, #2
 8003b8c:	f001 fcbf 	bl	800550e <gc_execute_line+0x1a8a>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant,
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later.
    int_value = trunc(value);
 8003b90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003b92:	1c18      	adds	r0, r3, #0
 8003b94:	f7fe fd96 	bl	80026c4 <__aeabi_f2d>
 8003b98:	0003      	movs	r3, r0
 8003b9a:	000c      	movs	r4, r1
 8003b9c:	0018      	movs	r0, r3
 8003b9e:	0021      	movs	r1, r4
 8003ba0:	f008 fe06 	bl	800c7b0 <trunc>
 8003ba4:	0002      	movs	r2, r0
 8003ba6:	000b      	movs	r3, r1
 8003ba8:	2146      	movs	r1, #70	; 0x46
 8003baa:	187c      	adds	r4, r7, r1
 8003bac:	0010      	movs	r0, r2
 8003bae:	0019      	movs	r1, r3
 8003bb0:	f7fc fbd0 	bl	8000354 <__aeabi_d2uiz>
 8003bb4:	0003      	movs	r3, r0
 8003bb6:	7023      	strb	r3, [r4, #0]
	mantissa = (uint16_t)roundf(100 * (value - int_value)); // Compute mantissa for Gxx.x commands.
 8003bb8:	6abc      	ldr	r4, [r7, #40]	; 0x28
 8003bba:	2346      	movs	r3, #70	; 0x46
 8003bbc:	18fb      	adds	r3, r7, r3
 8003bbe:	781b      	ldrb	r3, [r3, #0]
 8003bc0:	0018      	movs	r0, r3
 8003bc2:	f7fd fa5b 	bl	800107c <__aeabi_i2f>
 8003bc6:	1c03      	adds	r3, r0, #0
 8003bc8:	1c19      	adds	r1, r3, #0
 8003bca:	1c20      	adds	r0, r4, #0
 8003bcc:	f7fd f882 	bl	8000cd4 <__aeabi_fsub>
 8003bd0:	1c03      	adds	r3, r0, #0
 8003bd2:	498a      	ldr	r1, [pc, #552]	; (8003dfc <gc_execute_line+0x378>)
 8003bd4:	1c18      	adds	r0, r3, #0
 8003bd6:	f7fc ff5d 	bl	8000a94 <__aeabi_fmul>
 8003bda:	1c03      	adds	r3, r0, #0
 8003bdc:	1c18      	adds	r0, r3, #0
 8003bde:	f008 fec9 	bl	800c974 <roundf>
 8003be2:	1c03      	adds	r3, r0, #0
 8003be4:	2250      	movs	r2, #80	; 0x50
 8003be6:	18bc      	adds	r4, r7, r2
 8003be8:	1c18      	adds	r0, r3, #0
 8003bea:	f7fc fb9b 	bl	8000324 <__aeabi_f2uiz>
 8003bee:	0003      	movs	r3, r0
 8003bf0:	8023      	strh	r3, [r4, #0]
    // NOTE: Rounding must be used to catch small floating point errors.

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
 8003bf2:	2345      	movs	r3, #69	; 0x45
 8003bf4:	18fb      	adds	r3, r7, r3
 8003bf6:	781b      	ldrb	r3, [r3, #0]
 8003bf8:	2b47      	cmp	r3, #71	; 0x47
 8003bfa:	d003      	beq.n	8003c04 <gc_execute_line+0x180>
 8003bfc:	2b4d      	cmp	r3, #77	; 0x4d
 8003bfe:	d100      	bne.n	8003c02 <gc_execute_line+0x17e>
 8003c00:	e177      	b.n	8003ef2 <gc_execute_line+0x46e>
 8003c02:	e20a      	b.n	800401a <gc_execute_line+0x596>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */

      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
 8003c04:	2346      	movs	r3, #70	; 0x46
 8003c06:	18fb      	adds	r3, r7, r3
 8003c08:	781b      	ldrb	r3, [r3, #0]
 8003c0a:	2b5e      	cmp	r3, #94	; 0x5e
 8003c0c:	d900      	bls.n	8003c10 <gc_execute_line+0x18c>
 8003c0e:	e12f      	b.n	8003e70 <gc_execute_line+0x3ec>
 8003c10:	009a      	lsls	r2, r3, #2
 8003c12:	4b7b      	ldr	r3, [pc, #492]	; (8003e00 <gc_execute_line+0x37c>)
 8003c14:	18d3      	adds	r3, r2, r3
 8003c16:	681b      	ldr	r3, [r3, #0]
 8003c18:	469f      	mov	pc, r3
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
 8003c1a:	2350      	movs	r3, #80	; 0x50
 8003c1c:	18fb      	adds	r3, r7, r3
 8003c1e:	881b      	ldrh	r3, [r3, #0]
 8003c20:	2b00      	cmp	r3, #0
 8003c22:	d10b      	bne.n	8003c3c <gc_execute_line+0x1b8>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
 8003c24:	235f      	movs	r3, #95	; 0x5f
 8003c26:	18fb      	adds	r3, r7, r3
 8003c28:	781b      	ldrb	r3, [r3, #0]
 8003c2a:	2b00      	cmp	r3, #0
 8003c2c:	d002      	beq.n	8003c34 <gc_execute_line+0x1b0>
 8003c2e:	2318      	movs	r3, #24
 8003c30:	f001 fc6d 	bl	800550e <gc_execute_line+0x1a8a>
              axis_command = AXIS_COMMAND_NON_MODAL;
 8003c34:	235f      	movs	r3, #95	; 0x5f
 8003c36:	18fb      	adds	r3, r7, r3
 8003c38:	2201      	movs	r2, #1
 8003c3a:	701a      	strb	r2, [r3, #0]
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
 8003c3c:	2352      	movs	r3, #82	; 0x52
 8003c3e:	18fb      	adds	r3, r7, r3
 8003c40:	2200      	movs	r2, #0
 8003c42:	701a      	strb	r2, [r3, #0]
            gc_block.non_modal_command = int_value;
 8003c44:	4b6b      	ldr	r3, [pc, #428]	; (8003df4 <gc_execute_line+0x370>)
 8003c46:	2246      	movs	r2, #70	; 0x46
 8003c48:	18ba      	adds	r2, r7, r2
 8003c4a:	7812      	ldrb	r2, [r2, #0]
 8003c4c:	701a      	strb	r2, [r3, #0]
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
 8003c4e:	2346      	movs	r3, #70	; 0x46
 8003c50:	18fb      	adds	r3, r7, r3
 8003c52:	781b      	ldrb	r3, [r3, #0]
 8003c54:	2b1c      	cmp	r3, #28
 8003c56:	d00a      	beq.n	8003c6e <gc_execute_line+0x1ea>
 8003c58:	2346      	movs	r3, #70	; 0x46
 8003c5a:	18fb      	adds	r3, r7, r3
 8003c5c:	781b      	ldrb	r3, [r3, #0]
 8003c5e:	2b1e      	cmp	r3, #30
 8003c60:	d005      	beq.n	8003c6e <gc_execute_line+0x1ea>
 8003c62:	2346      	movs	r3, #70	; 0x46
 8003c64:	18fb      	adds	r3, r7, r3
 8003c66:	781b      	ldrb	r3, [r3, #0]
 8003c68:	2b5c      	cmp	r3, #92	; 0x5c
 8003c6a:	d000      	beq.n	8003c6e <gc_execute_line+0x1ea>
 8003c6c:	e103      	b.n	8003e76 <gc_execute_line+0x3f2>
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
 8003c6e:	2350      	movs	r3, #80	; 0x50
 8003c70:	18fb      	adds	r3, r7, r3
 8003c72:	881b      	ldrh	r3, [r3, #0]
 8003c74:	2b00      	cmp	r3, #0
 8003c76:	d007      	beq.n	8003c88 <gc_execute_line+0x204>
 8003c78:	2350      	movs	r3, #80	; 0x50
 8003c7a:	18fb      	adds	r3, r7, r3
 8003c7c:	881b      	ldrh	r3, [r3, #0]
 8003c7e:	2b0a      	cmp	r3, #10
 8003c80:	d002      	beq.n	8003c88 <gc_execute_line+0x204>
 8003c82:	2314      	movs	r3, #20
 8003c84:	f001 fc43 	bl	800550e <gc_execute_line+0x1a8a>
              gc_block.non_modal_command += mantissa;
 8003c88:	4b5a      	ldr	r3, [pc, #360]	; (8003df4 <gc_execute_line+0x370>)
 8003c8a:	781a      	ldrb	r2, [r3, #0]
 8003c8c:	2350      	movs	r3, #80	; 0x50
 8003c8e:	18fb      	adds	r3, r7, r3
 8003c90:	881b      	ldrh	r3, [r3, #0]
 8003c92:	b2db      	uxtb	r3, r3
 8003c94:	18d3      	adds	r3, r2, r3
 8003c96:	b2da      	uxtb	r2, r3
 8003c98:	4b56      	ldr	r3, [pc, #344]	; (8003df4 <gc_execute_line+0x370>)
 8003c9a:	701a      	strb	r2, [r3, #0]
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
 8003c9c:	2350      	movs	r3, #80	; 0x50
 8003c9e:	18fb      	adds	r3, r7, r3
 8003ca0:	2200      	movs	r2, #0
 8003ca2:	801a      	strh	r2, [r3, #0]
            }                
            break;
 8003ca4:	e0e7      	b.n	8003e76 <gc_execute_line+0x3f2>
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
 8003ca6:	235f      	movs	r3, #95	; 0x5f
 8003ca8:	18fb      	adds	r3, r7, r3
 8003caa:	781b      	ldrb	r3, [r3, #0]
 8003cac:	2b00      	cmp	r3, #0
 8003cae:	d002      	beq.n	8003cb6 <gc_execute_line+0x232>
 8003cb0:	2318      	movs	r3, #24
 8003cb2:	f001 fc2c 	bl	800550e <gc_execute_line+0x1a8a>
            axis_command = AXIS_COMMAND_MOTION_MODE;
 8003cb6:	235f      	movs	r3, #95	; 0x5f
 8003cb8:	18fb      	adds	r3, r7, r3
 8003cba:	2202      	movs	r2, #2
 8003cbc:	701a      	strb	r2, [r3, #0]
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
 8003cbe:	2352      	movs	r3, #82	; 0x52
 8003cc0:	18fb      	adds	r3, r7, r3
 8003cc2:	2201      	movs	r2, #1
 8003cc4:	701a      	strb	r2, [r3, #0]
            gc_block.modal.motion = int_value;
 8003cc6:	4b4b      	ldr	r3, [pc, #300]	; (8003df4 <gc_execute_line+0x370>)
 8003cc8:	2246      	movs	r2, #70	; 0x46
 8003cca:	18ba      	adds	r2, r7, r2
 8003ccc:	7812      	ldrb	r2, [r2, #0]
 8003cce:	705a      	strb	r2, [r3, #1]
            if (int_value == 38){
 8003cd0:	2346      	movs	r3, #70	; 0x46
 8003cd2:	18fb      	adds	r3, r7, r3
 8003cd4:	781b      	ldrb	r3, [r3, #0]
 8003cd6:	2b26      	cmp	r3, #38	; 0x26
 8003cd8:	d000      	beq.n	8003cdc <gc_execute_line+0x258>
 8003cda:	e0ce      	b.n	8003e7a <gc_execute_line+0x3f6>
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
 8003cdc:	2350      	movs	r3, #80	; 0x50
 8003cde:	18fb      	adds	r3, r7, r3
 8003ce0:	881b      	ldrh	r3, [r3, #0]
 8003ce2:	2b14      	cmp	r3, #20
 8003ce4:	d011      	beq.n	8003d0a <gc_execute_line+0x286>
 8003ce6:	2350      	movs	r3, #80	; 0x50
 8003ce8:	18fb      	adds	r3, r7, r3
 8003cea:	881b      	ldrh	r3, [r3, #0]
 8003cec:	2b1e      	cmp	r3, #30
 8003cee:	d00c      	beq.n	8003d0a <gc_execute_line+0x286>
 8003cf0:	2350      	movs	r3, #80	; 0x50
 8003cf2:	18fb      	adds	r3, r7, r3
 8003cf4:	881b      	ldrh	r3, [r3, #0]
 8003cf6:	2b28      	cmp	r3, #40	; 0x28
 8003cf8:	d007      	beq.n	8003d0a <gc_execute_line+0x286>
 8003cfa:	2350      	movs	r3, #80	; 0x50
 8003cfc:	18fb      	adds	r3, r7, r3
 8003cfe:	881b      	ldrh	r3, [r3, #0]
 8003d00:	2b32      	cmp	r3, #50	; 0x32
 8003d02:	d002      	beq.n	8003d0a <gc_execute_line+0x286>
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
 8003d04:	2314      	movs	r3, #20
 8003d06:	f001 fc02 	bl	800550e <gc_execute_line+0x1a8a>
              }
              gc_block.modal.motion += (mantissa/10)+100;
 8003d0a:	4b3a      	ldr	r3, [pc, #232]	; (8003df4 <gc_execute_line+0x370>)
 8003d0c:	785c      	ldrb	r4, [r3, #1]
 8003d0e:	2350      	movs	r3, #80	; 0x50
 8003d10:	18fb      	adds	r3, r7, r3
 8003d12:	881b      	ldrh	r3, [r3, #0]
 8003d14:	210a      	movs	r1, #10
 8003d16:	0018      	movs	r0, r3
 8003d18:	f7fc fa00 	bl	800011c <__udivsi3>
 8003d1c:	0003      	movs	r3, r0
 8003d1e:	b29b      	uxth	r3, r3
 8003d20:	b2db      	uxtb	r3, r3
 8003d22:	18e3      	adds	r3, r4, r3
 8003d24:	b2db      	uxtb	r3, r3
 8003d26:	3364      	adds	r3, #100	; 0x64
 8003d28:	b2da      	uxtb	r2, r3
 8003d2a:	4b32      	ldr	r3, [pc, #200]	; (8003df4 <gc_execute_line+0x370>)
 8003d2c:	705a      	strb	r2, [r3, #1]
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
 8003d2e:	2350      	movs	r3, #80	; 0x50
 8003d30:	18fb      	adds	r3, r7, r3
 8003d32:	2200      	movs	r2, #0
 8003d34:	801a      	strh	r2, [r3, #0]
            }  
            break;
 8003d36:	e0a0      	b.n	8003e7a <gc_execute_line+0x3f6>
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
 8003d38:	2352      	movs	r3, #82	; 0x52
 8003d3a:	18fb      	adds	r3, r7, r3
 8003d3c:	2202      	movs	r2, #2
 8003d3e:	701a      	strb	r2, [r3, #0]
            gc_block.modal.plane_select = int_value - 17;
 8003d40:	2346      	movs	r3, #70	; 0x46
 8003d42:	18fb      	adds	r3, r7, r3
 8003d44:	781b      	ldrb	r3, [r3, #0]
 8003d46:	3b11      	subs	r3, #17
 8003d48:	b2da      	uxtb	r2, r3
 8003d4a:	4b2a      	ldr	r3, [pc, #168]	; (8003df4 <gc_execute_line+0x370>)
 8003d4c:	715a      	strb	r2, [r3, #5]
            break;
 8003d4e:	e097      	b.n	8003e80 <gc_execute_line+0x3fc>
          case 90: case 91:
            if (mantissa == 0) {
 8003d50:	2350      	movs	r3, #80	; 0x50
 8003d52:	18fb      	adds	r3, r7, r3
 8003d54:	881b      	ldrh	r3, [r3, #0]
 8003d56:	2b00      	cmp	r3, #0
 8003d58:	d10b      	bne.n	8003d72 <gc_execute_line+0x2ee>
              word_bit = MODAL_GROUP_G3;
 8003d5a:	2352      	movs	r3, #82	; 0x52
 8003d5c:	18fb      	adds	r3, r7, r3
 8003d5e:	2203      	movs	r2, #3
 8003d60:	701a      	strb	r2, [r3, #0]
              gc_block.modal.distance = int_value - 90;
 8003d62:	2346      	movs	r3, #70	; 0x46
 8003d64:	18fb      	adds	r3, r7, r3
 8003d66:	781b      	ldrb	r3, [r3, #0]
 8003d68:	3b5a      	subs	r3, #90	; 0x5a
 8003d6a:	b2da      	uxtb	r2, r3
 8003d6c:	4b21      	ldr	r3, [pc, #132]	; (8003df4 <gc_execute_line+0x370>)
 8003d6e:	711a      	strb	r2, [r3, #4]
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
 8003d70:	e086      	b.n	8003e80 <gc_execute_line+0x3fc>
              word_bit = MODAL_GROUP_G4;
 8003d72:	2352      	movs	r3, #82	; 0x52
 8003d74:	18fb      	adds	r3, r7, r3
 8003d76:	2204      	movs	r2, #4
 8003d78:	701a      	strb	r2, [r3, #0]
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
 8003d7a:	2350      	movs	r3, #80	; 0x50
 8003d7c:	18fb      	adds	r3, r7, r3
 8003d7e:	881b      	ldrh	r3, [r3, #0]
 8003d80:	2b0a      	cmp	r3, #10
 8003d82:	d104      	bne.n	8003d8e <gc_execute_line+0x30a>
 8003d84:	2346      	movs	r3, #70	; 0x46
 8003d86:	18fb      	adds	r3, r7, r3
 8003d88:	781b      	ldrb	r3, [r3, #0]
 8003d8a:	2b5a      	cmp	r3, #90	; 0x5a
 8003d8c:	d102      	bne.n	8003d94 <gc_execute_line+0x310>
 8003d8e:	2314      	movs	r3, #20
 8003d90:	f001 fbbd 	bl	800550e <gc_execute_line+0x1a8a>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
 8003d94:	2350      	movs	r3, #80	; 0x50
 8003d96:	18fb      	adds	r3, r7, r3
 8003d98:	2200      	movs	r2, #0
 8003d9a:	801a      	strh	r2, [r3, #0]
            break;
 8003d9c:	e070      	b.n	8003e80 <gc_execute_line+0x3fc>
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
 8003d9e:	2352      	movs	r3, #82	; 0x52
 8003da0:	18fb      	adds	r3, r7, r3
 8003da2:	2205      	movs	r2, #5
 8003da4:	701a      	strb	r2, [r3, #0]
            gc_block.modal.feed_rate = 94 - int_value;
 8003da6:	2346      	movs	r3, #70	; 0x46
 8003da8:	18fb      	adds	r3, r7, r3
 8003daa:	781b      	ldrb	r3, [r3, #0]
 8003dac:	225e      	movs	r2, #94	; 0x5e
 8003dae:	1ad3      	subs	r3, r2, r3
 8003db0:	b2da      	uxtb	r2, r3
 8003db2:	4b10      	ldr	r3, [pc, #64]	; (8003df4 <gc_execute_line+0x370>)
 8003db4:	709a      	strb	r2, [r3, #2]
            break;
 8003db6:	e063      	b.n	8003e80 <gc_execute_line+0x3fc>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
 8003db8:	2352      	movs	r3, #82	; 0x52
 8003dba:	18fb      	adds	r3, r7, r3
 8003dbc:	2206      	movs	r2, #6
 8003dbe:	701a      	strb	r2, [r3, #0]
            gc_block.modal.units = 21 - int_value;
 8003dc0:	2346      	movs	r3, #70	; 0x46
 8003dc2:	18fb      	adds	r3, r7, r3
 8003dc4:	781b      	ldrb	r3, [r3, #0]
 8003dc6:	2215      	movs	r2, #21
 8003dc8:	1ad3      	subs	r3, r2, r3
 8003dca:	b2da      	uxtb	r2, r3
 8003dcc:	4b09      	ldr	r3, [pc, #36]	; (8003df4 <gc_execute_line+0x370>)
 8003dce:	70da      	strb	r2, [r3, #3]
            break;
 8003dd0:	e056      	b.n	8003e80 <gc_execute_line+0x3fc>
          case 40:
            word_bit = MODAL_GROUP_G7;
 8003dd2:	2352      	movs	r3, #82	; 0x52
 8003dd4:	18fb      	adds	r3, r7, r3
 8003dd6:	2207      	movs	r2, #7
 8003dd8:	701a      	strb	r2, [r3, #0]
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
 8003dda:	e051      	b.n	8003e80 <gc_execute_line+0x3fc>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
 8003ddc:	2352      	movs	r3, #82	; 0x52
 8003dde:	18fb      	adds	r3, r7, r3
 8003de0:	2208      	movs	r2, #8
 8003de2:	701a      	strb	r2, [r3, #0]
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
 8003de4:	235f      	movs	r3, #95	; 0x5f
 8003de6:	18fb      	adds	r3, r7, r3
 8003de8:	781b      	ldrb	r3, [r3, #0]
 8003dea:	2b00      	cmp	r3, #0
 8003dec:	d00a      	beq.n	8003e04 <gc_execute_line+0x380>
 8003dee:	2318      	movs	r3, #24
 8003df0:	f001 fb8d 	bl	800550e <gc_execute_line+0x1a8a>
 8003df4:	20000a14 	.word	0x20000a14
 8003df8:	200009c4 	.word	0x200009c4
 8003dfc:	42c80000 	.word	0x42c80000
 8003e00:	0800dd24 	.word	0x0800dd24
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
 8003e04:	235f      	movs	r3, #95	; 0x5f
 8003e06:	18fb      	adds	r3, r7, r3
 8003e08:	2203      	movs	r2, #3
 8003e0a:	701a      	strb	r2, [r3, #0]
            if (int_value == 49) { // G49
 8003e0c:	2346      	movs	r3, #70	; 0x46
 8003e0e:	18fb      	adds	r3, r7, r3
 8003e10:	781b      	ldrb	r3, [r3, #0]
 8003e12:	2b31      	cmp	r3, #49	; 0x31
 8003e14:	d103      	bne.n	8003e1e <gc_execute_line+0x39a>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
 8003e16:	4bd2      	ldr	r3, [pc, #840]	; (8004160 <gc_execute_line+0x6dc>)
 8003e18:	2200      	movs	r2, #0
 8003e1a:	719a      	strb	r2, [r3, #6]
 8003e1c:	e00b      	b.n	8003e36 <gc_execute_line+0x3b2>
            } else if (mantissa == 10) { // G43.1
 8003e1e:	2350      	movs	r3, #80	; 0x50
 8003e20:	18fb      	adds	r3, r7, r3
 8003e22:	881b      	ldrh	r3, [r3, #0]
 8003e24:	2b0a      	cmp	r3, #10
 8003e26:	d103      	bne.n	8003e30 <gc_execute_line+0x3ac>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
 8003e28:	4bcd      	ldr	r3, [pc, #820]	; (8004160 <gc_execute_line+0x6dc>)
 8003e2a:	2201      	movs	r2, #1
 8003e2c:	719a      	strb	r2, [r3, #6]
 8003e2e:	e002      	b.n	8003e36 <gc_execute_line+0x3b2>
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
 8003e30:	2314      	movs	r3, #20
 8003e32:	f001 fb6c 	bl	800550e <gc_execute_line+0x1a8a>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
 8003e36:	2350      	movs	r3, #80	; 0x50
 8003e38:	18fb      	adds	r3, r7, r3
 8003e3a:	2200      	movs	r2, #0
 8003e3c:	801a      	strh	r2, [r3, #0]
            break;
 8003e3e:	e01f      	b.n	8003e80 <gc_execute_line+0x3fc>
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
 8003e40:	2352      	movs	r3, #82	; 0x52
 8003e42:	18fb      	adds	r3, r7, r3
 8003e44:	2209      	movs	r2, #9
 8003e46:	701a      	strb	r2, [r3, #0]
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
 8003e48:	2346      	movs	r3, #70	; 0x46
 8003e4a:	18fb      	adds	r3, r7, r3
 8003e4c:	781b      	ldrb	r3, [r3, #0]
 8003e4e:	3b36      	subs	r3, #54	; 0x36
 8003e50:	b2da      	uxtb	r2, r3
 8003e52:	4bc3      	ldr	r3, [pc, #780]	; (8004160 <gc_execute_line+0x6dc>)
 8003e54:	71da      	strb	r2, [r3, #7]
            break;
 8003e56:	e013      	b.n	8003e80 <gc_execute_line+0x3fc>
          case 61:
            word_bit = MODAL_GROUP_G13;
 8003e58:	2352      	movs	r3, #82	; 0x52
 8003e5a:	18fb      	adds	r3, r7, r3
 8003e5c:	220a      	movs	r2, #10
 8003e5e:	701a      	strb	r2, [r3, #0]
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
 8003e60:	2350      	movs	r3, #80	; 0x50
 8003e62:	18fb      	adds	r3, r7, r3
 8003e64:	881b      	ldrh	r3, [r3, #0]
 8003e66:	2b00      	cmp	r3, #0
 8003e68:	d009      	beq.n	8003e7e <gc_execute_line+0x3fa>
 8003e6a:	2314      	movs	r3, #20
 8003e6c:	f001 fb4f 	bl	800550e <gc_execute_line+0x1a8a>
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
 8003e70:	2314      	movs	r3, #20
 8003e72:	f001 fb4c 	bl	800550e <gc_execute_line+0x1a8a>
            break;
 8003e76:	46c0      	nop			; (mov r8, r8)
 8003e78:	e002      	b.n	8003e80 <gc_execute_line+0x3fc>
            break;
 8003e7a:	46c0      	nop			; (mov r8, r8)
 8003e7c:	e000      	b.n	8003e80 <gc_execute_line+0x3fc>
            break;
 8003e7e:	46c0      	nop			; (mov r8, r8)
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
 8003e80:	2350      	movs	r3, #80	; 0x50
 8003e82:	18fb      	adds	r3, r7, r3
 8003e84:	881b      	ldrh	r3, [r3, #0]
 8003e86:	2b00      	cmp	r3, #0
 8003e88:	d002      	beq.n	8003e90 <gc_execute_line+0x40c>
 8003e8a:	2317      	movs	r3, #23
 8003e8c:	f001 fb3f 	bl	800550e <gc_execute_line+0x1a8a>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
 8003e90:	2356      	movs	r3, #86	; 0x56
 8003e92:	18fb      	adds	r3, r7, r3
 8003e94:	881a      	ldrh	r2, [r3, #0]
 8003e96:	2352      	movs	r3, #82	; 0x52
 8003e98:	18fb      	adds	r3, r7, r3
 8003e9a:	781b      	ldrb	r3, [r3, #0]
 8003e9c:	411a      	asrs	r2, r3
 8003e9e:	0013      	movs	r3, r2
 8003ea0:	2201      	movs	r2, #1
 8003ea2:	4013      	ands	r3, r2
 8003ea4:	d002      	beq.n	8003eac <gc_execute_line+0x428>
 8003ea6:	2315      	movs	r3, #21
 8003ea8:	f001 fb31 	bl	800550e <gc_execute_line+0x1a8a>
        command_words |= bit(word_bit);
 8003eac:	2352      	movs	r3, #82	; 0x52
 8003eae:	18fb      	adds	r3, r7, r3
 8003eb0:	781b      	ldrb	r3, [r3, #0]
 8003eb2:	2201      	movs	r2, #1
 8003eb4:	409a      	lsls	r2, r3
 8003eb6:	0013      	movs	r3, r2
 8003eb8:	b21a      	sxth	r2, r3
 8003eba:	2356      	movs	r3, #86	; 0x56
 8003ebc:	18fb      	adds	r3, r7, r3
 8003ebe:	2100      	movs	r1, #0
 8003ec0:	5e5b      	ldrsh	r3, [r3, r1]
 8003ec2:	4313      	orrs	r3, r2
 8003ec4:	b21a      	sxth	r2, r3
 8003ec6:	2356      	movs	r3, #86	; 0x56
 8003ec8:	18fb      	adds	r3, r7, r3
 8003eca:	801a      	strh	r2, [r3, #0]
 8003ecc:	235a      	movs	r3, #90	; 0x5a
 8003ece:	18fb      	adds	r3, r7, r3
 8003ed0:	225a      	movs	r2, #90	; 0x5a
 8003ed2:	18ba      	adds	r2, r7, r2
 8003ed4:	7812      	ldrb	r2, [r2, #0]
 8003ed6:	701a      	strb	r2, [r3, #0]
 8003ed8:	2359      	movs	r3, #89	; 0x59
 8003eda:	18fb      	adds	r3, r7, r3
 8003edc:	2259      	movs	r2, #89	; 0x59
 8003ede:	18ba      	adds	r2, r7, r2
 8003ee0:	7812      	ldrb	r2, [r2, #0]
 8003ee2:	701a      	strb	r2, [r3, #0]
 8003ee4:	2354      	movs	r3, #84	; 0x54
 8003ee6:	18fb      	adds	r3, r7, r3
 8003ee8:	2254      	movs	r2, #84	; 0x54
 8003eea:	18ba      	adds	r2, r7, r2
 8003eec:	8812      	ldrh	r2, [r2, #0]
 8003eee:	801a      	strh	r2, [r3, #0]
        break;
 8003ef0:	e1ae      	b.n	8004250 <gc_execute_line+0x7cc>

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
 8003ef2:	2350      	movs	r3, #80	; 0x50
 8003ef4:	18fb      	adds	r3, r7, r3
 8003ef6:	881b      	ldrh	r3, [r3, #0]
 8003ef8:	2b00      	cmp	r3, #0
 8003efa:	d002      	beq.n	8003f02 <gc_execute_line+0x47e>
 8003efc:	2317      	movs	r3, #23
 8003efe:	f001 fb06 	bl	800550e <gc_execute_line+0x1a8a>
        switch(int_value) {
 8003f02:	2346      	movs	r3, #70	; 0x46
 8003f04:	18fb      	adds	r3, r7, r3
 8003f06:	781b      	ldrb	r3, [r3, #0]
 8003f08:	2b1e      	cmp	r3, #30
 8003f0a:	d84c      	bhi.n	8003fa6 <gc_execute_line+0x522>
 8003f0c:	009a      	lsls	r2, r3, #2
 8003f0e:	4b95      	ldr	r3, [pc, #596]	; (8004164 <gc_execute_line+0x6e0>)
 8003f10:	18d3      	adds	r3, r2, r3
 8003f12:	681b      	ldr	r3, [r3, #0]
 8003f14:	469f      	mov	pc, r3
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
 8003f16:	2352      	movs	r3, #82	; 0x52
 8003f18:	18fb      	adds	r3, r7, r3
 8003f1a:	220b      	movs	r2, #11
 8003f1c:	701a      	strb	r2, [r3, #0]
            switch(int_value) {
 8003f1e:	2346      	movs	r3, #70	; 0x46
 8003f20:	18fb      	adds	r3, r7, r3
 8003f22:	781b      	ldrb	r3, [r3, #0]
 8003f24:	2b00      	cmp	r3, #0
 8003f26:	d002      	beq.n	8003f2e <gc_execute_line+0x4aa>
 8003f28:	2b01      	cmp	r3, #1
 8003f2a:	d00a      	beq.n	8003f42 <gc_execute_line+0x4be>
 8003f2c:	e003      	b.n	8003f36 <gc_execute_line+0x4b2>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
 8003f2e:	4b8c      	ldr	r3, [pc, #560]	; (8004160 <gc_execute_line+0x6dc>)
 8003f30:	2203      	movs	r2, #3
 8003f32:	721a      	strb	r2, [r3, #8]
 8003f34:	e006      	b.n	8003f44 <gc_execute_line+0x4c0>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
 8003f36:	4b8a      	ldr	r3, [pc, #552]	; (8004160 <gc_execute_line+0x6dc>)
 8003f38:	2246      	movs	r2, #70	; 0x46
 8003f3a:	18ba      	adds	r2, r7, r2
 8003f3c:	7812      	ldrb	r2, [r2, #0]
 8003f3e:	721a      	strb	r2, [r3, #8]
            }
            break;
 8003f40:	e034      	b.n	8003fac <gc_execute_line+0x528>
              case 1: break; // Optional stop not supported. Ignore.
 8003f42:	46c0      	nop			; (mov r8, r8)
            break;
 8003f44:	e032      	b.n	8003fac <gc_execute_line+0x528>
					case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
 8003f46:	2352      	movs	r3, #82	; 0x52
 8003f48:	18fb      	adds	r3, r7, r3
 8003f4a:	220c      	movs	r2, #12
 8003f4c:	701a      	strb	r2, [r3, #0]
            switch(int_value) {
 8003f4e:	2346      	movs	r3, #70	; 0x46
 8003f50:	18fb      	adds	r3, r7, r3
 8003f52:	781b      	ldrb	r3, [r3, #0]
 8003f54:	2b04      	cmp	r3, #4
 8003f56:	d008      	beq.n	8003f6a <gc_execute_line+0x4e6>
 8003f58:	2b05      	cmp	r3, #5
 8003f5a:	d00a      	beq.n	8003f72 <gc_execute_line+0x4ee>
 8003f5c:	2b03      	cmp	r3, #3
 8003f5e:	d000      	beq.n	8003f62 <gc_execute_line+0x4de>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
            }
            break;
 8003f60:	e024      	b.n	8003fac <gc_execute_line+0x528>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
 8003f62:	4b7f      	ldr	r3, [pc, #508]	; (8004160 <gc_execute_line+0x6dc>)
 8003f64:	2210      	movs	r2, #16
 8003f66:	729a      	strb	r2, [r3, #10]
 8003f68:	e007      	b.n	8003f7a <gc_execute_line+0x4f6>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
 8003f6a:	4b7d      	ldr	r3, [pc, #500]	; (8004160 <gc_execute_line+0x6dc>)
 8003f6c:	2220      	movs	r2, #32
 8003f6e:	729a      	strb	r2, [r3, #10]
 8003f70:	e003      	b.n	8003f7a <gc_execute_line+0x4f6>
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
 8003f72:	4b7b      	ldr	r3, [pc, #492]	; (8004160 <gc_execute_line+0x6dc>)
 8003f74:	2200      	movs	r2, #0
 8003f76:	729a      	strb	r2, [r3, #10]
 8003f78:	46c0      	nop			; (mov r8, r8)
            break;
 8003f7a:	e017      	b.n	8003fac <gc_execute_line+0x528>
          #ifdef ENABLE_M7
            case 7: case 8: case 9:
          #else
            case 8: case 9:
          #endif
            word_bit = MODAL_GROUP_M8;
 8003f7c:	2352      	movs	r3, #82	; 0x52
 8003f7e:	18fb      	adds	r3, r7, r3
 8003f80:	220d      	movs	r2, #13
 8003f82:	701a      	strb	r2, [r3, #0]
            switch(int_value) {
 8003f84:	2346      	movs	r3, #70	; 0x46
 8003f86:	18fb      	adds	r3, r7, r3
 8003f88:	781b      	ldrb	r3, [r3, #0]
 8003f8a:	2b08      	cmp	r3, #8
 8003f8c:	d002      	beq.n	8003f94 <gc_execute_line+0x510>
 8003f8e:	2b09      	cmp	r3, #9
 8003f90:	d004      	beq.n	8003f9c <gc_execute_line+0x518>
                case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
              #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
            }
            break;
 8003f92:	e00b      	b.n	8003fac <gc_execute_line+0x528>
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
 8003f94:	4b72      	ldr	r3, [pc, #456]	; (8004160 <gc_execute_line+0x6dc>)
 8003f96:	2240      	movs	r2, #64	; 0x40
 8003f98:	725a      	strb	r2, [r3, #9]
 8003f9a:	e003      	b.n	8003fa4 <gc_execute_line+0x520>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
 8003f9c:	4b70      	ldr	r3, [pc, #448]	; (8004160 <gc_execute_line+0x6dc>)
 8003f9e:	2200      	movs	r2, #0
 8003fa0:	725a      	strb	r2, [r3, #9]
 8003fa2:	46c0      	nop			; (mov r8, r8)
            break;
 8003fa4:	e002      	b.n	8003fac <gc_execute_line+0x528>
						case 56:
							word_bit = MODAL_GROUP_M9;
							gc_block.modal.override = OVERRIDE_PARKING_MOTION;
							break;
					#endif
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
 8003fa6:	2314      	movs	r3, #20
 8003fa8:	f001 fab1 	bl	800550e <gc_execute_line+0x1a8a>
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
 8003fac:	2356      	movs	r3, #86	; 0x56
 8003fae:	18fb      	adds	r3, r7, r3
 8003fb0:	881a      	ldrh	r2, [r3, #0]
 8003fb2:	2352      	movs	r3, #82	; 0x52
 8003fb4:	18fb      	adds	r3, r7, r3
 8003fb6:	781b      	ldrb	r3, [r3, #0]
 8003fb8:	411a      	asrs	r2, r3
 8003fba:	0013      	movs	r3, r2
 8003fbc:	2201      	movs	r2, #1
 8003fbe:	4013      	ands	r3, r2
 8003fc0:	d002      	beq.n	8003fc8 <gc_execute_line+0x544>
 8003fc2:	2315      	movs	r3, #21
 8003fc4:	f001 faa3 	bl	800550e <gc_execute_line+0x1a8a>
        command_words |= bit(word_bit);
 8003fc8:	2352      	movs	r3, #82	; 0x52
 8003fca:	18fb      	adds	r3, r7, r3
 8003fcc:	781b      	ldrb	r3, [r3, #0]
 8003fce:	2201      	movs	r2, #1
 8003fd0:	409a      	lsls	r2, r3
 8003fd2:	0013      	movs	r3, r2
 8003fd4:	b21a      	sxth	r2, r3
 8003fd6:	2356      	movs	r3, #86	; 0x56
 8003fd8:	18fb      	adds	r3, r7, r3
 8003fda:	2100      	movs	r1, #0
 8003fdc:	5e5b      	ldrsh	r3, [r3, r1]
 8003fde:	4313      	orrs	r3, r2
 8003fe0:	b21a      	sxth	r2, r3
 8003fe2:	2356      	movs	r3, #86	; 0x56
 8003fe4:	18fb      	adds	r3, r7, r3
 8003fe6:	801a      	strh	r2, [r3, #0]
 8003fe8:	235f      	movs	r3, #95	; 0x5f
 8003fea:	18fb      	adds	r3, r7, r3
 8003fec:	225f      	movs	r2, #95	; 0x5f
 8003fee:	18ba      	adds	r2, r7, r2
 8003ff0:	7812      	ldrb	r2, [r2, #0]
 8003ff2:	701a      	strb	r2, [r3, #0]
 8003ff4:	235a      	movs	r3, #90	; 0x5a
 8003ff6:	18fb      	adds	r3, r7, r3
 8003ff8:	225a      	movs	r2, #90	; 0x5a
 8003ffa:	18ba      	adds	r2, r7, r2
 8003ffc:	7812      	ldrb	r2, [r2, #0]
 8003ffe:	701a      	strb	r2, [r3, #0]
 8004000:	2359      	movs	r3, #89	; 0x59
 8004002:	18fb      	adds	r3, r7, r3
 8004004:	2259      	movs	r2, #89	; 0x59
 8004006:	18ba      	adds	r2, r7, r2
 8004008:	7812      	ldrb	r2, [r2, #0]
 800400a:	701a      	strb	r2, [r3, #0]
 800400c:	2354      	movs	r3, #84	; 0x54
 800400e:	18fb      	adds	r3, r7, r3
 8004010:	2254      	movs	r2, #84	; 0x54
 8004012:	18ba      	adds	r2, r7, r2
 8004014:	8812      	ldrh	r2, [r2, #0]
 8004016:	801a      	strh	r2, [r3, #0]
        break;
 8004018:	e11a      	b.n	8004250 <gc_execute_line+0x7cc>
      default:

        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
 800401a:	2345      	movs	r3, #69	; 0x45
 800401c:	18fb      	adds	r3, r7, r3
 800401e:	781b      	ldrb	r3, [r3, #0]
 8004020:	3b41      	subs	r3, #65	; 0x41
 8004022:	2b19      	cmp	r3, #25
 8004024:	d900      	bls.n	8004028 <gc_execute_line+0x5a4>
 8004026:	e0d3      	b.n	80041d0 <gc_execute_line+0x74c>
 8004028:	009a      	lsls	r2, r3, #2
 800402a:	4b4f      	ldr	r3, [pc, #316]	; (8004168 <gc_execute_line+0x6e4>)
 800402c:	18d3      	adds	r3, r2, r3
 800402e:	681b      	ldr	r3, [r3, #0]
 8004030:	469f      	mov	pc, r3
          // case 'A': // Not supported
#ifdef A_AXIS
          case 'A': word_bit = WORD_A; gc_block.values.xyz[A_AXIS] = value; axis_words |= (1<<A_AXIS); break;
 8004032:	2352      	movs	r3, #82	; 0x52
 8004034:	18fb      	adds	r3, r7, r3
 8004036:	220d      	movs	r2, #13
 8004038:	701a      	strb	r2, [r3, #0]
 800403a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800403c:	4b48      	ldr	r3, [pc, #288]	; (8004160 <gc_execute_line+0x6dc>)
 800403e:	641a      	str	r2, [r3, #64]	; 0x40
 8004040:	235a      	movs	r3, #90	; 0x5a
 8004042:	18fb      	adds	r3, r7, r3
 8004044:	225a      	movs	r2, #90	; 0x5a
 8004046:	18ba      	adds	r2, r7, r2
 8004048:	7812      	ldrb	r2, [r2, #0]
 800404a:	2108      	movs	r1, #8
 800404c:	430a      	orrs	r2, r1
 800404e:	701a      	strb	r2, [r3, #0]
 8004050:	e0c1      	b.n	80041d6 <gc_execute_line+0x752>
#endif
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
 8004052:	2352      	movs	r3, #82	; 0x52
 8004054:	18fb      	adds	r3, r7, r3
 8004056:	2200      	movs	r2, #0
 8004058:	701a      	strb	r2, [r3, #0]
 800405a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800405c:	4b40      	ldr	r3, [pc, #256]	; (8004160 <gc_execute_line+0x6dc>)
 800405e:	60da      	str	r2, [r3, #12]
 8004060:	e0b9      	b.n	80041d6 <gc_execute_line+0x752>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
 8004062:	2352      	movs	r3, #82	; 0x52
 8004064:	18fb      	adds	r3, r7, r3
 8004066:	2201      	movs	r2, #1
 8004068:	701a      	strb	r2, [r3, #0]
 800406a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800406c:	4b3c      	ldr	r3, [pc, #240]	; (8004160 <gc_execute_line+0x6dc>)
 800406e:	611a      	str	r2, [r3, #16]
 8004070:	2359      	movs	r3, #89	; 0x59
 8004072:	18fb      	adds	r3, r7, r3
 8004074:	2259      	movs	r2, #89	; 0x59
 8004076:	18ba      	adds	r2, r7, r2
 8004078:	7812      	ldrb	r2, [r2, #0]
 800407a:	2101      	movs	r1, #1
 800407c:	430a      	orrs	r2, r1
 800407e:	701a      	strb	r2, [r3, #0]
 8004080:	e0a9      	b.n	80041d6 <gc_execute_line+0x752>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
 8004082:	2352      	movs	r3, #82	; 0x52
 8004084:	18fb      	adds	r3, r7, r3
 8004086:	2202      	movs	r2, #2
 8004088:	701a      	strb	r2, [r3, #0]
 800408a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800408c:	4b34      	ldr	r3, [pc, #208]	; (8004160 <gc_execute_line+0x6dc>)
 800408e:	615a      	str	r2, [r3, #20]
 8004090:	2359      	movs	r3, #89	; 0x59
 8004092:	18fb      	adds	r3, r7, r3
 8004094:	2259      	movs	r2, #89	; 0x59
 8004096:	18ba      	adds	r2, r7, r2
 8004098:	7812      	ldrb	r2, [r2, #0]
 800409a:	2102      	movs	r1, #2
 800409c:	430a      	orrs	r2, r1
 800409e:	701a      	strb	r2, [r3, #0]
 80040a0:	e099      	b.n	80041d6 <gc_execute_line+0x752>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
 80040a2:	2352      	movs	r3, #82	; 0x52
 80040a4:	18fb      	adds	r3, r7, r3
 80040a6:	2203      	movs	r2, #3
 80040a8:	701a      	strb	r2, [r3, #0]
 80040aa:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80040ac:	4b2c      	ldr	r3, [pc, #176]	; (8004160 <gc_execute_line+0x6dc>)
 80040ae:	619a      	str	r2, [r3, #24]
 80040b0:	2359      	movs	r3, #89	; 0x59
 80040b2:	18fb      	adds	r3, r7, r3
 80040b4:	2259      	movs	r2, #89	; 0x59
 80040b6:	18ba      	adds	r2, r7, r2
 80040b8:	7812      	ldrb	r2, [r2, #0]
 80040ba:	2104      	movs	r1, #4
 80040bc:	430a      	orrs	r2, r1
 80040be:	701a      	strb	r2, [r3, #0]
 80040c0:	e089      	b.n	80041d6 <gc_execute_line+0x752>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
 80040c2:	2352      	movs	r3, #82	; 0x52
 80040c4:	18fb      	adds	r3, r7, r3
 80040c6:	2204      	movs	r2, #4
 80040c8:	701a      	strb	r2, [r3, #0]
 80040ca:	4b25      	ldr	r3, [pc, #148]	; (8004160 <gc_execute_line+0x6dc>)
 80040cc:	2246      	movs	r2, #70	; 0x46
 80040ce:	18ba      	adds	r2, r7, r2
 80040d0:	7812      	ldrb	r2, [r2, #0]
 80040d2:	771a      	strb	r2, [r3, #28]
 80040d4:	e07f      	b.n	80041d6 <gc_execute_line+0x752>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
 80040d6:	2352      	movs	r3, #82	; 0x52
 80040d8:	18fb      	adds	r3, r7, r3
 80040da:	2205      	movs	r2, #5
 80040dc:	701a      	strb	r2, [r3, #0]
 80040de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80040e0:	1c18      	adds	r0, r3, #0
 80040e2:	f7fe faef 	bl	80026c4 <__aeabi_f2d>
 80040e6:	0003      	movs	r3, r0
 80040e8:	000c      	movs	r4, r1
 80040ea:	0018      	movs	r0, r3
 80040ec:	0021      	movs	r1, r4
 80040ee:	f008 fb5f 	bl	800c7b0 <trunc>
 80040f2:	0003      	movs	r3, r0
 80040f4:	000c      	movs	r4, r1
 80040f6:	0018      	movs	r0, r3
 80040f8:	0021      	movs	r1, r4
 80040fa:	f7fe faaf 	bl	800265c <__aeabi_d2iz>
 80040fe:	0002      	movs	r2, r0
 8004100:	4b17      	ldr	r3, [pc, #92]	; (8004160 <gc_execute_line+0x6dc>)
 8004102:	621a      	str	r2, [r3, #32]
 8004104:	e067      	b.n	80041d6 <gc_execute_line+0x752>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
 8004106:	2352      	movs	r3, #82	; 0x52
 8004108:	18fb      	adds	r3, r7, r3
 800410a:	2206      	movs	r2, #6
 800410c:	701a      	strb	r2, [r3, #0]
 800410e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004110:	4b13      	ldr	r3, [pc, #76]	; (8004160 <gc_execute_line+0x6dc>)
 8004112:	625a      	str	r2, [r3, #36]	; 0x24
 8004114:	e05f      	b.n	80041d6 <gc_execute_line+0x752>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
 8004116:	2352      	movs	r3, #82	; 0x52
 8004118:	18fb      	adds	r3, r7, r3
 800411a:	2207      	movs	r2, #7
 800411c:	701a      	strb	r2, [r3, #0]
 800411e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004120:	4b0f      	ldr	r3, [pc, #60]	; (8004160 <gc_execute_line+0x6dc>)
 8004122:	629a      	str	r2, [r3, #40]	; 0x28
 8004124:	e057      	b.n	80041d6 <gc_execute_line+0x752>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
 8004126:	2352      	movs	r3, #82	; 0x52
 8004128:	18fb      	adds	r3, r7, r3
 800412a:	2208      	movs	r2, #8
 800412c:	701a      	strb	r2, [r3, #0]
 800412e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004130:	4b0b      	ldr	r3, [pc, #44]	; (8004160 <gc_execute_line+0x6dc>)
 8004132:	62da      	str	r2, [r3, #44]	; 0x2c
 8004134:	e04f      	b.n	80041d6 <gc_execute_line+0x752>
          case 'T': word_bit = WORD_T; 
 8004136:	2352      	movs	r3, #82	; 0x52
 8004138:	18fb      	adds	r3, r7, r3
 800413a:	2209      	movs	r2, #9
 800413c:	701a      	strb	r2, [r3, #0]
					  if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
 800413e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004140:	490a      	ldr	r1, [pc, #40]	; (800416c <gc_execute_line+0x6e8>)
 8004142:	1c18      	adds	r0, r3, #0
 8004144:	f7fc f8da 	bl	80002fc <__aeabi_fcmpgt>
 8004148:	1e03      	subs	r3, r0, #0
 800414a:	d002      	beq.n	8004152 <gc_execute_line+0x6ce>
 800414c:	2326      	movs	r3, #38	; 0x26
 800414e:	f001 f9de 	bl	800550e <gc_execute_line+0x1a8a>
            gc_block.values.t = int_value;
 8004152:	4b03      	ldr	r3, [pc, #12]	; (8004160 <gc_execute_line+0x6dc>)
 8004154:	2246      	movs	r2, #70	; 0x46
 8004156:	18ba      	adds	r2, r7, r2
 8004158:	2130      	movs	r1, #48	; 0x30
 800415a:	7812      	ldrb	r2, [r2, #0]
 800415c:	545a      	strb	r2, [r3, r1]
						break;
 800415e:	e03a      	b.n	80041d6 <gc_execute_line+0x752>
 8004160:	20000a14 	.word	0x20000a14
 8004164:	0800dea0 	.word	0x0800dea0
 8004168:	0800df1c 	.word	0x0800df1c
 800416c:	437f0000 	.word	0x437f0000
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
 8004170:	2352      	movs	r3, #82	; 0x52
 8004172:	18fb      	adds	r3, r7, r3
 8004174:	220a      	movs	r2, #10
 8004176:	701a      	strb	r2, [r3, #0]
 8004178:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800417a:	4bc9      	ldr	r3, [pc, #804]	; (80044a0 <gc_execute_line+0xa1c>)
 800417c:	635a      	str	r2, [r3, #52]	; 0x34
 800417e:	235a      	movs	r3, #90	; 0x5a
 8004180:	18fb      	adds	r3, r7, r3
 8004182:	225a      	movs	r2, #90	; 0x5a
 8004184:	18ba      	adds	r2, r7, r2
 8004186:	7812      	ldrb	r2, [r2, #0]
 8004188:	2101      	movs	r1, #1
 800418a:	430a      	orrs	r2, r1
 800418c:	701a      	strb	r2, [r3, #0]
 800418e:	e022      	b.n	80041d6 <gc_execute_line+0x752>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
 8004190:	2352      	movs	r3, #82	; 0x52
 8004192:	18fb      	adds	r3, r7, r3
 8004194:	220b      	movs	r2, #11
 8004196:	701a      	strb	r2, [r3, #0]
 8004198:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800419a:	4bc1      	ldr	r3, [pc, #772]	; (80044a0 <gc_execute_line+0xa1c>)
 800419c:	639a      	str	r2, [r3, #56]	; 0x38
 800419e:	235a      	movs	r3, #90	; 0x5a
 80041a0:	18fb      	adds	r3, r7, r3
 80041a2:	225a      	movs	r2, #90	; 0x5a
 80041a4:	18ba      	adds	r2, r7, r2
 80041a6:	7812      	ldrb	r2, [r2, #0]
 80041a8:	2102      	movs	r1, #2
 80041aa:	430a      	orrs	r2, r1
 80041ac:	701a      	strb	r2, [r3, #0]
 80041ae:	e012      	b.n	80041d6 <gc_execute_line+0x752>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
 80041b0:	2352      	movs	r3, #82	; 0x52
 80041b2:	18fb      	adds	r3, r7, r3
 80041b4:	220c      	movs	r2, #12
 80041b6:	701a      	strb	r2, [r3, #0]
 80041b8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80041ba:	4bb9      	ldr	r3, [pc, #740]	; (80044a0 <gc_execute_line+0xa1c>)
 80041bc:	63da      	str	r2, [r3, #60]	; 0x3c
 80041be:	235a      	movs	r3, #90	; 0x5a
 80041c0:	18fb      	adds	r3, r7, r3
 80041c2:	225a      	movs	r2, #90	; 0x5a
 80041c4:	18ba      	adds	r2, r7, r2
 80041c6:	7812      	ldrb	r2, [r2, #0]
 80041c8:	2104      	movs	r1, #4
 80041ca:	430a      	orrs	r2, r1
 80041cc:	701a      	strb	r2, [r3, #0]
 80041ce:	e002      	b.n	80041d6 <gc_execute_line+0x752>
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
 80041d0:	2314      	movs	r3, #20
 80041d2:	f001 f99c 	bl	800550e <gc_execute_line+0x1a8a>
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
 80041d6:	2354      	movs	r3, #84	; 0x54
 80041d8:	18fb      	adds	r3, r7, r3
 80041da:	881a      	ldrh	r2, [r3, #0]
 80041dc:	2352      	movs	r3, #82	; 0x52
 80041de:	18fb      	adds	r3, r7, r3
 80041e0:	781b      	ldrb	r3, [r3, #0]
 80041e2:	411a      	asrs	r2, r3
 80041e4:	0013      	movs	r3, r2
 80041e6:	2201      	movs	r2, #1
 80041e8:	4013      	ands	r3, r2
 80041ea:	d002      	beq.n	80041f2 <gc_execute_line+0x76e>
 80041ec:	2319      	movs	r3, #25
 80041ee:	f001 f98e 	bl	800550e <gc_execute_line+0x1a8a>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
 80041f2:	2352      	movs	r3, #82	; 0x52
 80041f4:	18fb      	adds	r3, r7, r3
 80041f6:	781b      	ldrb	r3, [r3, #0]
 80041f8:	4aaa      	ldr	r2, [pc, #680]	; (80044a4 <gc_execute_line+0xa20>)
 80041fa:	411a      	asrs	r2, r3
 80041fc:	0013      	movs	r3, r2
 80041fe:	2201      	movs	r2, #1
 8004200:	4013      	ands	r3, r2
 8004202:	d009      	beq.n	8004218 <gc_execute_line+0x794>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
 8004204:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004206:	2100      	movs	r1, #0
 8004208:	1c18      	adds	r0, r3, #0
 800420a:	f7fc f863 	bl	80002d4 <__aeabi_fcmplt>
 800420e:	1e03      	subs	r3, r0, #0
 8004210:	d002      	beq.n	8004218 <gc_execute_line+0x794>
 8004212:	2304      	movs	r3, #4
 8004214:	f001 f97b 	bl	800550e <gc_execute_line+0x1a8a>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
 8004218:	2352      	movs	r3, #82	; 0x52
 800421a:	18fb      	adds	r3, r7, r3
 800421c:	781b      	ldrb	r3, [r3, #0]
 800421e:	2201      	movs	r2, #1
 8004220:	409a      	lsls	r2, r3
 8004222:	0013      	movs	r3, r2
 8004224:	b21a      	sxth	r2, r3
 8004226:	2354      	movs	r3, #84	; 0x54
 8004228:	18fb      	adds	r3, r7, r3
 800422a:	2100      	movs	r1, #0
 800422c:	5e5b      	ldrsh	r3, [r3, r1]
 800422e:	4313      	orrs	r3, r2
 8004230:	b21a      	sxth	r2, r3
 8004232:	2354      	movs	r3, #84	; 0x54
 8004234:	18fb      	adds	r3, r7, r3
 8004236:	801a      	strh	r2, [r3, #0]
 8004238:	235f      	movs	r3, #95	; 0x5f
 800423a:	18fb      	adds	r3, r7, r3
 800423c:	225f      	movs	r2, #95	; 0x5f
 800423e:	18ba      	adds	r2, r7, r2
 8004240:	7812      	ldrb	r2, [r2, #0]
 8004242:	701a      	strb	r2, [r3, #0]
 8004244:	2356      	movs	r3, #86	; 0x56
 8004246:	18fb      	adds	r3, r7, r3
 8004248:	2256      	movs	r2, #86	; 0x56
 800424a:	18ba      	adds	r2, r7, r2
 800424c:	8812      	ldrh	r2, [r2, #0]
 800424e:	801a      	strh	r2, [r3, #0]
  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
 8004250:	232e      	movs	r3, #46	; 0x2e
 8004252:	18fb      	adds	r3, r7, r3
 8004254:	781b      	ldrb	r3, [r3, #0]
 8004256:	001a      	movs	r2, r3
 8004258:	687b      	ldr	r3, [r7, #4]
 800425a:	189b      	adds	r3, r3, r2
 800425c:	781b      	ldrb	r3, [r3, #0]
 800425e:	2b00      	cmp	r3, #0
 8004260:	d000      	beq.n	8004264 <gc_execute_line+0x7e0>
 8004262:	e469      	b.n	8003b38 <gc_execute_line+0xb4>

  // [0. Non-specific/common error-checks and miscellaneous setup]:

  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
 8004264:	235a      	movs	r3, #90	; 0x5a
 8004266:	18fb      	adds	r3, r7, r3
 8004268:	781b      	ldrb	r3, [r3, #0]
 800426a:	2b00      	cmp	r3, #0
 800426c:	d008      	beq.n	8004280 <gc_execute_line+0x7fc>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
 800426e:	235f      	movs	r3, #95	; 0x5f
 8004270:	18fb      	adds	r3, r7, r3
 8004272:	781b      	ldrb	r3, [r3, #0]
 8004274:	2b00      	cmp	r3, #0
 8004276:	d103      	bne.n	8004280 <gc_execute_line+0x7fc>
 8004278:	235f      	movs	r3, #95	; 0x5f
 800427a:	18fb      	adds	r3, r7, r3
 800427c:	2202      	movs	r2, #2
 800427e:	701a      	strb	r2, [r3, #0]
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
 8004280:	2354      	movs	r3, #84	; 0x54
 8004282:	18fb      	adds	r3, r7, r3
 8004284:	881b      	ldrh	r3, [r3, #0]
 8004286:	2220      	movs	r2, #32
 8004288:	4013      	ands	r3, r2
 800428a:	d007      	beq.n	800429c <gc_execute_line+0x818>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
 800428c:	4b84      	ldr	r3, [pc, #528]	; (80044a0 <gc_execute_line+0xa1c>)
 800428e:	6a1b      	ldr	r3, [r3, #32]
 8004290:	4a85      	ldr	r2, [pc, #532]	; (80044a8 <gc_execute_line+0xa24>)
 8004292:	4293      	cmp	r3, r2
 8004294:	dd02      	ble.n	800429c <gc_execute_line+0x818>
 8004296:	231b      	movs	r3, #27
 8004298:	f001 f939 	bl	800550e <gc_execute_line+0x1a8a>
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
 800429c:	2353      	movs	r3, #83	; 0x53
 800429e:	18fb      	adds	r3, r7, r3
 80042a0:	781b      	ldrb	r3, [r3, #0]
 80042a2:	2201      	movs	r2, #1
 80042a4:	4013      	ands	r3, r2
 80042a6:	d017      	beq.n	80042d8 <gc_execute_line+0x854>
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
 80042a8:	2354      	movs	r3, #84	; 0x54
 80042aa:	18fb      	adds	r3, r7, r3
 80042ac:	881b      	ldrh	r3, [r3, #0]
 80042ae:	2201      	movs	r2, #1
 80042b0:	4013      	ands	r3, r2
 80042b2:	d102      	bne.n	80042ba <gc_execute_line+0x836>
 80042b4:	2316      	movs	r3, #22
 80042b6:	f001 f92a 	bl	800550e <gc_execute_line+0x1a8a>
    if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
 80042ba:	4b79      	ldr	r3, [pc, #484]	; (80044a0 <gc_execute_line+0xa1c>)
 80042bc:	78db      	ldrb	r3, [r3, #3]
 80042be:	2b01      	cmp	r3, #1
 80042c0:	d141      	bne.n	8004346 <gc_execute_line+0x8c2>
 80042c2:	4b77      	ldr	r3, [pc, #476]	; (80044a0 <gc_execute_line+0xa1c>)
 80042c4:	68db      	ldr	r3, [r3, #12]
 80042c6:	4979      	ldr	r1, [pc, #484]	; (80044ac <gc_execute_line+0xa28>)
 80042c8:	1c18      	adds	r0, r3, #0
 80042ca:	f7fc fbe3 	bl	8000a94 <__aeabi_fmul>
 80042ce:	1c03      	adds	r3, r0, #0
 80042d0:	1c1a      	adds	r2, r3, #0
 80042d2:	4b73      	ldr	r3, [pc, #460]	; (80044a0 <gc_execute_line+0xa1c>)
 80042d4:	60da      	str	r2, [r3, #12]
 80042d6:	e036      	b.n	8004346 <gc_execute_line+0x8c2>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
 80042d8:	4b71      	ldr	r3, [pc, #452]	; (80044a0 <gc_execute_line+0xa1c>)
 80042da:	789b      	ldrb	r3, [r3, #2]
 80042dc:	2b01      	cmp	r3, #1
 80042de:	d115      	bne.n	800430c <gc_execute_line+0x888>
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
 80042e0:	235f      	movs	r3, #95	; 0x5f
 80042e2:	18fb      	adds	r3, r7, r3
 80042e4:	781b      	ldrb	r3, [r3, #0]
 80042e6:	2b02      	cmp	r3, #2
 80042e8:	d12d      	bne.n	8004346 <gc_execute_line+0x8c2>
				if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
 80042ea:	4b6d      	ldr	r3, [pc, #436]	; (80044a0 <gc_execute_line+0xa1c>)
 80042ec:	785b      	ldrb	r3, [r3, #1]
 80042ee:	2b50      	cmp	r3, #80	; 0x50
 80042f0:	d029      	beq.n	8004346 <gc_execute_line+0x8c2>
 80042f2:	4b6b      	ldr	r3, [pc, #428]	; (80044a0 <gc_execute_line+0xa1c>)
 80042f4:	785b      	ldrb	r3, [r3, #1]
 80042f6:	2b00      	cmp	r3, #0
 80042f8:	d025      	beq.n	8004346 <gc_execute_line+0x8c2>
					if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
 80042fa:	2354      	movs	r3, #84	; 0x54
 80042fc:	18fb      	adds	r3, r7, r3
 80042fe:	881b      	ldrh	r3, [r3, #0]
 8004300:	2201      	movs	r2, #1
 8004302:	4013      	ands	r3, r2
 8004304:	d11f      	bne.n	8004346 <gc_execute_line+0x8c2>
 8004306:	2316      	movs	r3, #22
 8004308:	f001 f901 	bl	800550e <gc_execute_line+0x1a8a>
      // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error
      // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
      // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
    } else { // = G94
      // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
      if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
 800430c:	4b68      	ldr	r3, [pc, #416]	; (80044b0 <gc_execute_line+0xa2c>)
 800430e:	785b      	ldrb	r3, [r3, #1]
 8004310:	2b00      	cmp	r3, #0
 8004312:	d118      	bne.n	8004346 <gc_execute_line+0x8c2>
        if (bit_istrue(value_words,bit(WORD_F))) {
 8004314:	2354      	movs	r3, #84	; 0x54
 8004316:	18fb      	adds	r3, r7, r3
 8004318:	881b      	ldrh	r3, [r3, #0]
 800431a:	2201      	movs	r2, #1
 800431c:	4013      	ands	r3, r2
 800431e:	d00e      	beq.n	800433e <gc_execute_line+0x8ba>
          if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
 8004320:	4b5f      	ldr	r3, [pc, #380]	; (80044a0 <gc_execute_line+0xa1c>)
 8004322:	78db      	ldrb	r3, [r3, #3]
 8004324:	2b01      	cmp	r3, #1
 8004326:	d10e      	bne.n	8004346 <gc_execute_line+0x8c2>
 8004328:	4b5d      	ldr	r3, [pc, #372]	; (80044a0 <gc_execute_line+0xa1c>)
 800432a:	68db      	ldr	r3, [r3, #12]
 800432c:	495f      	ldr	r1, [pc, #380]	; (80044ac <gc_execute_line+0xa28>)
 800432e:	1c18      	adds	r0, r3, #0
 8004330:	f7fc fbb0 	bl	8000a94 <__aeabi_fmul>
 8004334:	1c03      	adds	r3, r0, #0
 8004336:	1c1a      	adds	r2, r3, #0
 8004338:	4b59      	ldr	r3, [pc, #356]	; (80044a0 <gc_execute_line+0xa1c>)
 800433a:	60da      	str	r2, [r3, #12]
 800433c:	e003      	b.n	8004346 <gc_execute_line+0x8c2>
        } else {
          gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
 800433e:	4b5c      	ldr	r3, [pc, #368]	; (80044b0 <gc_execute_line+0xa2c>)
 8004340:	691a      	ldr	r2, [r3, #16]
 8004342:	4b57      	ldr	r3, [pc, #348]	; (80044a0 <gc_execute_line+0xa1c>)
 8004344:	60da      	str	r2, [r3, #12]
    }
  }
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.

  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
 8004346:	2354      	movs	r3, #84	; 0x54
 8004348:	18fb      	adds	r3, r7, r3
 800434a:	881a      	ldrh	r2, [r3, #0]
 800434c:	2380      	movs	r3, #128	; 0x80
 800434e:	005b      	lsls	r3, r3, #1
 8004350:	4013      	ands	r3, r2
 8004352:	d103      	bne.n	800435c <gc_execute_line+0x8d8>
 8004354:	4b56      	ldr	r3, [pc, #344]	; (80044b0 <gc_execute_line+0xa2c>)
 8004356:	68da      	ldr	r2, [r3, #12]
 8004358:	4b51      	ldr	r3, [pc, #324]	; (80044a0 <gc_execute_line+0xa1c>)
 800435a:	62da      	str	r2, [r3, #44]	; 0x2c
			}
		}
	#endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
 800435c:	4b50      	ldr	r3, [pc, #320]	; (80044a0 <gc_execute_line+0xa1c>)
 800435e:	781b      	ldrb	r3, [r3, #0]
 8004360:	2b04      	cmp	r3, #4
 8004362:	d110      	bne.n	8004386 <gc_execute_line+0x902>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
 8004364:	2354      	movs	r3, #84	; 0x54
 8004366:	18fb      	adds	r3, r7, r3
 8004368:	881b      	ldrh	r3, [r3, #0]
 800436a:	2240      	movs	r2, #64	; 0x40
 800436c:	4013      	ands	r3, r2
 800436e:	d102      	bne.n	8004376 <gc_execute_line+0x8f2>
 8004370:	231c      	movs	r3, #28
 8004372:	f001 f8cc 	bl	800550e <gc_execute_line+0x1a8a>
    bit_false(value_words,bit(WORD_P));
 8004376:	2354      	movs	r3, #84	; 0x54
 8004378:	18fb      	adds	r3, r7, r3
 800437a:	2254      	movs	r2, #84	; 0x54
 800437c:	18ba      	adds	r2, r7, r2
 800437e:	8812      	ldrh	r2, [r2, #0]
 8004380:	2140      	movs	r1, #64	; 0x40
 8004382:	438a      	bics	r2, r1
 8004384:	801a      	strh	r2, [r3, #0]
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
 8004386:	4b46      	ldr	r3, [pc, #280]	; (80044a0 <gc_execute_line+0xa1c>)
 8004388:	795b      	ldrb	r3, [r3, #5]
 800438a:	2b00      	cmp	r3, #0
 800438c:	d002      	beq.n	8004394 <gc_execute_line+0x910>
 800438e:	2b01      	cmp	r3, #1
 8004390:	d00d      	beq.n	80043ae <gc_execute_line+0x92a>
 8004392:	e019      	b.n	80043c8 <gc_execute_line+0x944>
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
 8004394:	235e      	movs	r3, #94	; 0x5e
 8004396:	18fb      	adds	r3, r7, r3
 8004398:	2200      	movs	r2, #0
 800439a:	701a      	strb	r2, [r3, #0]
      axis_1 = Y_AXIS;
 800439c:	235d      	movs	r3, #93	; 0x5d
 800439e:	18fb      	adds	r3, r7, r3
 80043a0:	2201      	movs	r2, #1
 80043a2:	701a      	strb	r2, [r3, #0]
      axis_linear = Z_AXIS;
 80043a4:	235c      	movs	r3, #92	; 0x5c
 80043a6:	18fb      	adds	r3, r7, r3
 80043a8:	2202      	movs	r2, #2
 80043aa:	701a      	strb	r2, [r3, #0]
      break;
 80043ac:	e018      	b.n	80043e0 <gc_execute_line+0x95c>
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
 80043ae:	235e      	movs	r3, #94	; 0x5e
 80043b0:	18fb      	adds	r3, r7, r3
 80043b2:	2202      	movs	r2, #2
 80043b4:	701a      	strb	r2, [r3, #0]
      axis_1 = X_AXIS;
 80043b6:	235d      	movs	r3, #93	; 0x5d
 80043b8:	18fb      	adds	r3, r7, r3
 80043ba:	2200      	movs	r2, #0
 80043bc:	701a      	strb	r2, [r3, #0]
      axis_linear = Y_AXIS;
 80043be:	235c      	movs	r3, #92	; 0x5c
 80043c0:	18fb      	adds	r3, r7, r3
 80043c2:	2201      	movs	r2, #1
 80043c4:	701a      	strb	r2, [r3, #0]
      break;
 80043c6:	e00b      	b.n	80043e0 <gc_execute_line+0x95c>
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
 80043c8:	235e      	movs	r3, #94	; 0x5e
 80043ca:	18fb      	adds	r3, r7, r3
 80043cc:	2201      	movs	r2, #1
 80043ce:	701a      	strb	r2, [r3, #0]
      axis_1 = Z_AXIS;
 80043d0:	235d      	movs	r3, #93	; 0x5d
 80043d2:	18fb      	adds	r3, r7, r3
 80043d4:	2202      	movs	r2, #2
 80043d6:	701a      	strb	r2, [r3, #0]
      axis_linear = X_AXIS;
 80043d8:	235c      	movs	r3, #92	; 0x5c
 80043da:	18fb      	adds	r3, r7, r3
 80043dc:	2200      	movs	r2, #0
 80043de:	701a      	strb	r2, [r3, #0]
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
 80043e0:	4b2f      	ldr	r3, [pc, #188]	; (80044a0 <gc_execute_line+0xa1c>)
 80043e2:	78db      	ldrb	r3, [r3, #3]
 80043e4:	2b01      	cmp	r3, #1
 80043e6:	d134      	bne.n	8004452 <gc_execute_line+0x9ce>
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 80043e8:	234f      	movs	r3, #79	; 0x4f
 80043ea:	18fb      	adds	r3, r7, r3
 80043ec:	2200      	movs	r2, #0
 80043ee:	701a      	strb	r2, [r3, #0]
 80043f0:	e02a      	b.n	8004448 <gc_execute_line+0x9c4>
      if (bit_istrue(axis_words,bit(idx)) ) {
 80043f2:	235a      	movs	r3, #90	; 0x5a
 80043f4:	18fb      	adds	r3, r7, r3
 80043f6:	781a      	ldrb	r2, [r3, #0]
 80043f8:	234f      	movs	r3, #79	; 0x4f
 80043fa:	18fb      	adds	r3, r7, r3
 80043fc:	781b      	ldrb	r3, [r3, #0]
 80043fe:	411a      	asrs	r2, r3
 8004400:	0013      	movs	r3, r2
 8004402:	2201      	movs	r2, #1
 8004404:	4013      	ands	r3, r2
 8004406:	d018      	beq.n	800443a <gc_execute_line+0x9b6>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
 8004408:	234f      	movs	r3, #79	; 0x4f
 800440a:	18fb      	adds	r3, r7, r3
 800440c:	781c      	ldrb	r4, [r3, #0]
 800440e:	234f      	movs	r3, #79	; 0x4f
 8004410:	18fb      	adds	r3, r7, r3
 8004412:	781b      	ldrb	r3, [r3, #0]
 8004414:	4a22      	ldr	r2, [pc, #136]	; (80044a0 <gc_execute_line+0xa1c>)
 8004416:	330c      	adds	r3, #12
 8004418:	009b      	lsls	r3, r3, #2
 800441a:	18d3      	adds	r3, r2, r3
 800441c:	3304      	adds	r3, #4
 800441e:	681b      	ldr	r3, [r3, #0]
 8004420:	4922      	ldr	r1, [pc, #136]	; (80044ac <gc_execute_line+0xa28>)
 8004422:	1c18      	adds	r0, r3, #0
 8004424:	f7fc fb36 	bl	8000a94 <__aeabi_fmul>
 8004428:	1c03      	adds	r3, r0, #0
 800442a:	1c19      	adds	r1, r3, #0
 800442c:	4a1c      	ldr	r2, [pc, #112]	; (80044a0 <gc_execute_line+0xa1c>)
 800442e:	0023      	movs	r3, r4
 8004430:	330c      	adds	r3, #12
 8004432:	009b      	lsls	r3, r3, #2
 8004434:	18d3      	adds	r3, r2, r3
 8004436:	3304      	adds	r3, #4
 8004438:	6019      	str	r1, [r3, #0]
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 800443a:	234f      	movs	r3, #79	; 0x4f
 800443c:	18fb      	adds	r3, r7, r3
 800443e:	781a      	ldrb	r2, [r3, #0]
 8004440:	234f      	movs	r3, #79	; 0x4f
 8004442:	18fb      	adds	r3, r7, r3
 8004444:	3201      	adds	r2, #1
 8004446:	701a      	strb	r2, [r3, #0]
 8004448:	234f      	movs	r3, #79	; 0x4f
 800444a:	18fb      	adds	r3, r7, r3
 800444c:	781b      	ldrb	r3, [r3, #0]
 800444e:	2b03      	cmp	r3, #3
 8004450:	d9cf      	bls.n	80043f2 <gc_execute_line+0x96e>
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are.
  // [G43.1 Errors]: Motion command in same line.
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
 8004452:	235f      	movs	r3, #95	; 0x5f
 8004454:	18fb      	adds	r3, r7, r3
 8004456:	781b      	ldrb	r3, [r3, #0]
 8004458:	2b03      	cmp	r3, #3
 800445a:	d10b      	bne.n	8004474 <gc_execute_line+0x9f0>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
 800445c:	4b10      	ldr	r3, [pc, #64]	; (80044a0 <gc_execute_line+0xa1c>)
 800445e:	799b      	ldrb	r3, [r3, #6]
 8004460:	2b01      	cmp	r3, #1
 8004462:	d107      	bne.n	8004474 <gc_execute_line+0x9f0>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
 8004464:	235a      	movs	r3, #90	; 0x5a
 8004466:	18fb      	adds	r3, r7, r3
 8004468:	781b      	ldrb	r3, [r3, #0]
 800446a:	2b04      	cmp	r3, #4
 800446c:	d002      	beq.n	8004474 <gc_execute_line+0x9f0>
 800446e:	2325      	movs	r3, #37	; 0x25
 8004470:	f001 f84d 	bl	800550e <gc_execute_line+0x1a8a>
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
 8004474:	2318      	movs	r3, #24
 8004476:	18fa      	adds	r2, r7, r3
 8004478:	4b0d      	ldr	r3, [pc, #52]	; (80044b0 <gc_execute_line+0xa2c>)
 800447a:	332c      	adds	r3, #44	; 0x2c
 800447c:	cb13      	ldmia	r3!, {r0, r1, r4}
 800447e:	c213      	stmia	r2!, {r0, r1, r4}
 8004480:	681b      	ldr	r3, [r3, #0]
 8004482:	6013      	str	r3, [r2, #0]
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
 8004484:	2356      	movs	r3, #86	; 0x56
 8004486:	18fb      	adds	r3, r7, r3
 8004488:	881a      	ldrh	r2, [r3, #0]
 800448a:	2380      	movs	r3, #128	; 0x80
 800448c:	009b      	lsls	r3, r3, #2
 800448e:	4013      	ands	r3, r2
 8004490:	d023      	beq.n	80044da <gc_execute_line+0xa56>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
 8004492:	4b03      	ldr	r3, [pc, #12]	; (80044a0 <gc_execute_line+0xa1c>)
 8004494:	79db      	ldrb	r3, [r3, #7]
 8004496:	2b06      	cmp	r3, #6
 8004498:	d90c      	bls.n	80044b4 <gc_execute_line+0xa30>
 800449a:	231d      	movs	r3, #29
 800449c:	f001 f837 	bl	800550e <gc_execute_line+0x1a8a>
 80044a0:	20000a14 	.word	0x20000a14
 80044a4:	00000361 	.word	0x00000361
 80044a8:	00989680 	.word	0x00989680
 80044ac:	41cb3333 	.word	0x41cb3333
 80044b0:	200009c4 	.word	0x200009c4
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
 80044b4:	4bdd      	ldr	r3, [pc, #884]	; (800482c <gc_execute_line+0xda8>)
 80044b6:	799a      	ldrb	r2, [r3, #6]
 80044b8:	4bdd      	ldr	r3, [pc, #884]	; (8004830 <gc_execute_line+0xdac>)
 80044ba:	79db      	ldrb	r3, [r3, #7]
 80044bc:	429a      	cmp	r2, r3
 80044be:	d00c      	beq.n	80044da <gc_execute_line+0xa56>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
 80044c0:	4bdb      	ldr	r3, [pc, #876]	; (8004830 <gc_execute_line+0xdac>)
 80044c2:	79db      	ldrb	r3, [r3, #7]
 80044c4:	2218      	movs	r2, #24
 80044c6:	18ba      	adds	r2, r7, r2
 80044c8:	0011      	movs	r1, r2
 80044ca:	0018      	movs	r0, r3
 80044cc:	f005 fa8c 	bl	80099e8 <settings_read_coord_data>
 80044d0:	1e03      	subs	r3, r0, #0
 80044d2:	d102      	bne.n	80044da <gc_execute_line+0xa56>
 80044d4:	2307      	movs	r3, #7
 80044d6:	f001 f81a 	bl	800550e <gc_execute_line+0x1a8a>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets.
  switch (gc_block.non_modal_command) {
 80044da:	4bd5      	ldr	r3, [pc, #852]	; (8004830 <gc_execute_line+0xdac>)
 80044dc:	781b      	ldrb	r3, [r3, #0]
 80044de:	2b0a      	cmp	r3, #10
 80044e0:	d003      	beq.n	80044ea <gc_execute_line+0xa66>
 80044e2:	2b5c      	cmp	r3, #92	; 0x5c
 80044e4:	d100      	bne.n	80044e8 <gc_execute_line+0xa64>
 80044e6:	e0ea      	b.n	80046be <gc_execute_line+0xc3a>
 80044e8:	e16f      	b.n	80047ca <gc_execute_line+0xd46>
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
 80044ea:	235a      	movs	r3, #90	; 0x5a
 80044ec:	18fb      	adds	r3, r7, r3
 80044ee:	781b      	ldrb	r3, [r3, #0]
 80044f0:	2b00      	cmp	r3, #0
 80044f2:	d102      	bne.n	80044fa <gc_execute_line+0xa76>
 80044f4:	231a      	movs	r3, #26
 80044f6:	f001 f80a 	bl	800550e <gc_execute_line+0x1a8a>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
 80044fa:	2354      	movs	r3, #84	; 0x54
 80044fc:	18fb      	adds	r3, r7, r3
 80044fe:	881b      	ldrh	r3, [r3, #0]
 8004500:	2250      	movs	r2, #80	; 0x50
 8004502:	4013      	ands	r3, r2
 8004504:	d102      	bne.n	800450c <gc_execute_line+0xa88>
 8004506:	231c      	movs	r3, #28
 8004508:	f001 f801 	bl	800550e <gc_execute_line+0x1a8a>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
 800450c:	4bc8      	ldr	r3, [pc, #800]	; (8004830 <gc_execute_line+0xdac>)
 800450e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004510:	1c18      	adds	r0, r3, #0
 8004512:	f7fe f8d7 	bl	80026c4 <__aeabi_f2d>
 8004516:	0003      	movs	r3, r0
 8004518:	000c      	movs	r4, r1
 800451a:	0018      	movs	r0, r3
 800451c:	0021      	movs	r1, r4
 800451e:	f008 f947 	bl	800c7b0 <trunc>
 8004522:	0002      	movs	r2, r0
 8004524:	000b      	movs	r3, r1
 8004526:	215b      	movs	r1, #91	; 0x5b
 8004528:	187c      	adds	r4, r7, r1
 800452a:	0010      	movs	r0, r2
 800452c:	0019      	movs	r1, r3
 800452e:	f7fb ff11 	bl	8000354 <__aeabi_d2uiz>
 8004532:	0003      	movs	r3, r0
 8004534:	7023      	strb	r3, [r4, #0]
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
 8004536:	235b      	movs	r3, #91	; 0x5b
 8004538:	18fb      	adds	r3, r7, r3
 800453a:	781b      	ldrb	r3, [r3, #0]
 800453c:	2b06      	cmp	r3, #6
 800453e:	d902      	bls.n	8004546 <gc_execute_line+0xac2>
 8004540:	231d      	movs	r3, #29
 8004542:	f000 ffe4 	bl	800550e <gc_execute_line+0x1a8a>
      if (gc_block.values.l != 20) {
 8004546:	4bba      	ldr	r3, [pc, #744]	; (8004830 <gc_execute_line+0xdac>)
 8004548:	7f1b      	ldrb	r3, [r3, #28]
 800454a:	2b14      	cmp	r3, #20
 800454c:	d00f      	beq.n	800456e <gc_execute_line+0xaea>
        if (gc_block.values.l == 2) {
 800454e:	4bb8      	ldr	r3, [pc, #736]	; (8004830 <gc_execute_line+0xdac>)
 8004550:	7f1b      	ldrb	r3, [r3, #28]
 8004552:	2b02      	cmp	r3, #2
 8004554:	d108      	bne.n	8004568 <gc_execute_line+0xae4>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
 8004556:	2354      	movs	r3, #84	; 0x54
 8004558:	18fb      	adds	r3, r7, r3
 800455a:	881b      	ldrh	r3, [r3, #0]
 800455c:	2280      	movs	r2, #128	; 0x80
 800455e:	4013      	ands	r3, r2
 8004560:	d005      	beq.n	800456e <gc_execute_line+0xaea>
 8004562:	2314      	movs	r3, #20
 8004564:	f000 ffd3 	bl	800550e <gc_execute_line+0x1a8a>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
 8004568:	2314      	movs	r3, #20
 800456a:	f000 ffd0 	bl	800550e <gc_execute_line+0x1a8a>
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
 800456e:	2354      	movs	r3, #84	; 0x54
 8004570:	18fb      	adds	r3, r7, r3
 8004572:	2254      	movs	r2, #84	; 0x54
 8004574:	18ba      	adds	r2, r7, r2
 8004576:	8812      	ldrh	r2, [r2, #0]
 8004578:	2150      	movs	r1, #80	; 0x50
 800457a:	438a      	bics	r2, r1
 800457c:	801a      	strh	r2, [r3, #0]

      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
 800457e:	235b      	movs	r3, #91	; 0x5b
 8004580:	18fb      	adds	r3, r7, r3
 8004582:	781b      	ldrb	r3, [r3, #0]
 8004584:	2b00      	cmp	r3, #0
 8004586:	d007      	beq.n	8004598 <gc_execute_line+0xb14>
 8004588:	235b      	movs	r3, #91	; 0x5b
 800458a:	18fb      	adds	r3, r7, r3
 800458c:	781a      	ldrb	r2, [r3, #0]
 800458e:	235b      	movs	r3, #91	; 0x5b
 8004590:	18fb      	adds	r3, r7, r3
 8004592:	3a01      	subs	r2, #1
 8004594:	701a      	strb	r2, [r3, #0]
 8004596:	e004      	b.n	80045a2 <gc_execute_line+0xb1e>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
 8004598:	235b      	movs	r3, #91	; 0x5b
 800459a:	18fb      	adds	r3, r7, r3
 800459c:	4aa4      	ldr	r2, [pc, #656]	; (8004830 <gc_execute_line+0xdac>)
 800459e:	79d2      	ldrb	r2, [r2, #7]
 80045a0:	701a      	strb	r2, [r3, #0]
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
 80045a2:	4aa4      	ldr	r2, [pc, #656]	; (8004834 <gc_execute_line+0xdb0>)
 80045a4:	235b      	movs	r3, #91	; 0x5b
 80045a6:	18fb      	adds	r3, r7, r3
 80045a8:	781b      	ldrb	r3, [r3, #0]
 80045aa:	0011      	movs	r1, r2
 80045ac:	0018      	movs	r0, r3
 80045ae:	f005 fa1b 	bl	80099e8 <settings_read_coord_data>
 80045b2:	1e03      	subs	r3, r0, #0
 80045b4:	d102      	bne.n	80045bc <gc_execute_line+0xb38>
 80045b6:	2307      	movs	r3, #7
 80045b8:	f000 ffa9 	bl	800550e <gc_execute_line+0x1a8a>

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 80045bc:	234f      	movs	r3, #79	; 0x4f
 80045be:	18fb      	adds	r3, r7, r3
 80045c0:	2200      	movs	r2, #0
 80045c2:	701a      	strb	r2, [r3, #0]
 80045c4:	e075      	b.n	80046b2 <gc_execute_line+0xc2e>
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
 80045c6:	235a      	movs	r3, #90	; 0x5a
 80045c8:	18fb      	adds	r3, r7, r3
 80045ca:	781a      	ldrb	r2, [r3, #0]
 80045cc:	234f      	movs	r3, #79	; 0x4f
 80045ce:	18fb      	adds	r3, r7, r3
 80045d0:	781b      	ldrb	r3, [r3, #0]
 80045d2:	411a      	asrs	r2, r3
 80045d4:	0013      	movs	r3, r2
 80045d6:	2201      	movs	r2, #1
 80045d8:	4013      	ands	r3, r2
 80045da:	d063      	beq.n	80046a4 <gc_execute_line+0xc20>
          if (gc_block.values.l == 20) {
 80045dc:	4b94      	ldr	r3, [pc, #592]	; (8004830 <gc_execute_line+0xdac>)
 80045de:	7f1b      	ldrb	r3, [r3, #28]
 80045e0:	2b14      	cmp	r3, #20
 80045e2:	d14d      	bne.n	8004680 <gc_execute_line+0xbfc>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
 80045e4:	234f      	movs	r3, #79	; 0x4f
 80045e6:	18fb      	adds	r3, r7, r3
 80045e8:	781c      	ldrb	r4, [r3, #0]
 80045ea:	234f      	movs	r3, #79	; 0x4f
 80045ec:	18fb      	adds	r3, r7, r3
 80045ee:	781b      	ldrb	r3, [r3, #0]
 80045f0:	4a8e      	ldr	r2, [pc, #568]	; (800482c <gc_execute_line+0xda8>)
 80045f2:	3306      	adds	r3, #6
 80045f4:	009b      	lsls	r3, r3, #2
 80045f6:	18d3      	adds	r3, r2, r3
 80045f8:	3304      	adds	r3, #4
 80045fa:	6818      	ldr	r0, [r3, #0]
 80045fc:	234f      	movs	r3, #79	; 0x4f
 80045fe:	18fb      	adds	r3, r7, r3
 8004600:	781b      	ldrb	r3, [r3, #0]
 8004602:	4a8a      	ldr	r2, [pc, #552]	; (800482c <gc_execute_line+0xda8>)
 8004604:	330e      	adds	r3, #14
 8004606:	009b      	lsls	r3, r3, #2
 8004608:	18d3      	adds	r3, r2, r3
 800460a:	3304      	adds	r3, #4
 800460c:	681b      	ldr	r3, [r3, #0]
 800460e:	1c19      	adds	r1, r3, #0
 8004610:	f7fc fb60 	bl	8000cd4 <__aeabi_fsub>
 8004614:	1c03      	adds	r3, r0, #0
 8004616:	1c18      	adds	r0, r3, #0
 8004618:	234f      	movs	r3, #79	; 0x4f
 800461a:	18fb      	adds	r3, r7, r3
 800461c:	781b      	ldrb	r3, [r3, #0]
 800461e:	4a84      	ldr	r2, [pc, #528]	; (8004830 <gc_execute_line+0xdac>)
 8004620:	330c      	adds	r3, #12
 8004622:	009b      	lsls	r3, r3, #2
 8004624:	18d3      	adds	r3, r2, r3
 8004626:	3304      	adds	r3, #4
 8004628:	681b      	ldr	r3, [r3, #0]
 800462a:	1c19      	adds	r1, r3, #0
 800462c:	f7fc fb52 	bl	8000cd4 <__aeabi_fsub>
 8004630:	1c03      	adds	r3, r0, #0
 8004632:	1c19      	adds	r1, r3, #0
 8004634:	4a7e      	ldr	r2, [pc, #504]	; (8004830 <gc_execute_line+0xdac>)
 8004636:	1ca3      	adds	r3, r4, #2
 8004638:	009b      	lsls	r3, r3, #2
 800463a:	18d3      	adds	r3, r2, r3
 800463c:	3308      	adds	r3, #8
 800463e:	6019      	str	r1, [r3, #0]
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
 8004640:	234f      	movs	r3, #79	; 0x4f
 8004642:	18fb      	adds	r3, r7, r3
 8004644:	781b      	ldrb	r3, [r3, #0]
 8004646:	2b02      	cmp	r3, #2
 8004648:	d12c      	bne.n	80046a4 <gc_execute_line+0xc20>
 800464a:	234f      	movs	r3, #79	; 0x4f
 800464c:	18fb      	adds	r3, r7, r3
 800464e:	781c      	ldrb	r4, [r3, #0]
 8004650:	234f      	movs	r3, #79	; 0x4f
 8004652:	18fb      	adds	r3, r7, r3
 8004654:	781b      	ldrb	r3, [r3, #0]
 8004656:	4a76      	ldr	r2, [pc, #472]	; (8004830 <gc_execute_line+0xdac>)
 8004658:	3302      	adds	r3, #2
 800465a:	009b      	lsls	r3, r3, #2
 800465c:	18d3      	adds	r3, r2, r3
 800465e:	3308      	adds	r3, #8
 8004660:	681a      	ldr	r2, [r3, #0]
 8004662:	4b72      	ldr	r3, [pc, #456]	; (800482c <gc_execute_line+0xda8>)
 8004664:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004666:	1c19      	adds	r1, r3, #0
 8004668:	1c10      	adds	r0, r2, #0
 800466a:	f7fc fb33 	bl	8000cd4 <__aeabi_fsub>
 800466e:	1c03      	adds	r3, r0, #0
 8004670:	1c19      	adds	r1, r3, #0
 8004672:	4a6f      	ldr	r2, [pc, #444]	; (8004830 <gc_execute_line+0xdac>)
 8004674:	1ca3      	adds	r3, r4, #2
 8004676:	009b      	lsls	r3, r3, #2
 8004678:	18d3      	adds	r3, r2, r3
 800467a:	3308      	adds	r3, #8
 800467c:	6019      	str	r1, [r3, #0]
 800467e:	e011      	b.n	80046a4 <gc_execute_line+0xc20>
          } else {
            // L2: Update coordinate system axis to programmed value.
            gc_block.values.ijk[idx] = gc_block.values.xyz[idx];
 8004680:	234f      	movs	r3, #79	; 0x4f
 8004682:	18fb      	adds	r3, r7, r3
 8004684:	7818      	ldrb	r0, [r3, #0]
 8004686:	234f      	movs	r3, #79	; 0x4f
 8004688:	18fb      	adds	r3, r7, r3
 800468a:	781b      	ldrb	r3, [r3, #0]
 800468c:	4a68      	ldr	r2, [pc, #416]	; (8004830 <gc_execute_line+0xdac>)
 800468e:	330c      	adds	r3, #12
 8004690:	009b      	lsls	r3, r3, #2
 8004692:	18d3      	adds	r3, r2, r3
 8004694:	3304      	adds	r3, #4
 8004696:	681a      	ldr	r2, [r3, #0]
 8004698:	4965      	ldr	r1, [pc, #404]	; (8004830 <gc_execute_line+0xdac>)
 800469a:	1c83      	adds	r3, r0, #2
 800469c:	009b      	lsls	r3, r3, #2
 800469e:	18cb      	adds	r3, r1, r3
 80046a0:	3308      	adds	r3, #8
 80046a2:	601a      	str	r2, [r3, #0]
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 80046a4:	234f      	movs	r3, #79	; 0x4f
 80046a6:	18fb      	adds	r3, r7, r3
 80046a8:	781a      	ldrb	r2, [r3, #0]
 80046aa:	234f      	movs	r3, #79	; 0x4f
 80046ac:	18fb      	adds	r3, r7, r3
 80046ae:	3201      	adds	r2, #1
 80046b0:	701a      	strb	r2, [r3, #0]
 80046b2:	234f      	movs	r3, #79	; 0x4f
 80046b4:	18fb      	adds	r3, r7, r3
 80046b6:	781b      	ldrb	r3, [r3, #0]
 80046b8:	2b03      	cmp	r3, #3
 80046ba:	d984      	bls.n	80045c6 <gc_execute_line+0xb42>
          }
        } // Else, keep current stored value.
      }
      break;
 80046bc:	e1ad      	b.n	8004a1a <gc_execute_line+0xf96>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
 80046be:	235a      	movs	r3, #90	; 0x5a
 80046c0:	18fb      	adds	r3, r7, r3
 80046c2:	781b      	ldrb	r3, [r3, #0]
 80046c4:	2b00      	cmp	r3, #0
 80046c6:	d102      	bne.n	80046ce <gc_execute_line+0xc4a>
 80046c8:	231a      	movs	r3, #26
 80046ca:	f000 ff20 	bl	800550e <gc_execute_line+0x1a8a>

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 80046ce:	234f      	movs	r3, #79	; 0x4f
 80046d0:	18fb      	adds	r3, r7, r3
 80046d2:	2200      	movs	r2, #0
 80046d4:	701a      	strb	r2, [r3, #0]
 80046d6:	e072      	b.n	80047be <gc_execute_line+0xd3a>
        if (bit_istrue(axis_words,bit(idx)) ) {
 80046d8:	235a      	movs	r3, #90	; 0x5a
 80046da:	18fb      	adds	r3, r7, r3
 80046dc:	781a      	ldrb	r2, [r3, #0]
 80046de:	234f      	movs	r3, #79	; 0x4f
 80046e0:	18fb      	adds	r3, r7, r3
 80046e2:	781b      	ldrb	r3, [r3, #0]
 80046e4:	411a      	asrs	r2, r3
 80046e6:	0013      	movs	r3, r2
 80046e8:	2201      	movs	r2, #1
 80046ea:	4013      	ands	r3, r2
 80046ec:	d04d      	beq.n	800478a <gc_execute_line+0xd06>
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
 80046ee:	234f      	movs	r3, #79	; 0x4f
 80046f0:	18fb      	adds	r3, r7, r3
 80046f2:	781c      	ldrb	r4, [r3, #0]
 80046f4:	234f      	movs	r3, #79	; 0x4f
 80046f6:	18fb      	adds	r3, r7, r3
 80046f8:	781b      	ldrb	r3, [r3, #0]
 80046fa:	4a4c      	ldr	r2, [pc, #304]	; (800482c <gc_execute_line+0xda8>)
 80046fc:	3306      	adds	r3, #6
 80046fe:	009b      	lsls	r3, r3, #2
 8004700:	18d3      	adds	r3, r2, r3
 8004702:	3304      	adds	r3, #4
 8004704:	6818      	ldr	r0, [r3, #0]
 8004706:	234f      	movs	r3, #79	; 0x4f
 8004708:	18fb      	adds	r3, r7, r3
 800470a:	781a      	ldrb	r2, [r3, #0]
 800470c:	2318      	movs	r3, #24
 800470e:	18fb      	adds	r3, r7, r3
 8004710:	0092      	lsls	r2, r2, #2
 8004712:	58d3      	ldr	r3, [r2, r3]
 8004714:	1c19      	adds	r1, r3, #0
 8004716:	f7fc fadd 	bl	8000cd4 <__aeabi_fsub>
 800471a:	1c03      	adds	r3, r0, #0
 800471c:	1c18      	adds	r0, r3, #0
 800471e:	234f      	movs	r3, #79	; 0x4f
 8004720:	18fb      	adds	r3, r7, r3
 8004722:	781b      	ldrb	r3, [r3, #0]
 8004724:	4a42      	ldr	r2, [pc, #264]	; (8004830 <gc_execute_line+0xdac>)
 8004726:	330c      	adds	r3, #12
 8004728:	009b      	lsls	r3, r3, #2
 800472a:	18d3      	adds	r3, r2, r3
 800472c:	3304      	adds	r3, #4
 800472e:	681b      	ldr	r3, [r3, #0]
 8004730:	1c19      	adds	r1, r3, #0
 8004732:	f7fc facf 	bl	8000cd4 <__aeabi_fsub>
 8004736:	1c03      	adds	r3, r0, #0
 8004738:	1c19      	adds	r1, r3, #0
 800473a:	4a3d      	ldr	r2, [pc, #244]	; (8004830 <gc_execute_line+0xdac>)
 800473c:	0023      	movs	r3, r4
 800473e:	330c      	adds	r3, #12
 8004740:	009b      	lsls	r3, r3, #2
 8004742:	18d3      	adds	r3, r2, r3
 8004744:	3304      	adds	r3, #4
 8004746:	6019      	str	r1, [r3, #0]
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
 8004748:	234f      	movs	r3, #79	; 0x4f
 800474a:	18fb      	adds	r3, r7, r3
 800474c:	781b      	ldrb	r3, [r3, #0]
 800474e:	2b02      	cmp	r3, #2
 8004750:	d12e      	bne.n	80047b0 <gc_execute_line+0xd2c>
 8004752:	234f      	movs	r3, #79	; 0x4f
 8004754:	18fb      	adds	r3, r7, r3
 8004756:	781c      	ldrb	r4, [r3, #0]
 8004758:	234f      	movs	r3, #79	; 0x4f
 800475a:	18fb      	adds	r3, r7, r3
 800475c:	781b      	ldrb	r3, [r3, #0]
 800475e:	4a34      	ldr	r2, [pc, #208]	; (8004830 <gc_execute_line+0xdac>)
 8004760:	330c      	adds	r3, #12
 8004762:	009b      	lsls	r3, r3, #2
 8004764:	18d3      	adds	r3, r2, r3
 8004766:	3304      	adds	r3, #4
 8004768:	681a      	ldr	r2, [r3, #0]
 800476a:	4b30      	ldr	r3, [pc, #192]	; (800482c <gc_execute_line+0xda8>)
 800476c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800476e:	1c19      	adds	r1, r3, #0
 8004770:	1c10      	adds	r0, r2, #0
 8004772:	f7fc faaf 	bl	8000cd4 <__aeabi_fsub>
 8004776:	1c03      	adds	r3, r0, #0
 8004778:	1c19      	adds	r1, r3, #0
 800477a:	4a2d      	ldr	r2, [pc, #180]	; (8004830 <gc_execute_line+0xdac>)
 800477c:	0023      	movs	r3, r4
 800477e:	330c      	adds	r3, #12
 8004780:	009b      	lsls	r3, r3, #2
 8004782:	18d3      	adds	r3, r2, r3
 8004784:	3304      	adds	r3, #4
 8004786:	6019      	str	r1, [r3, #0]
 8004788:	e012      	b.n	80047b0 <gc_execute_line+0xd2c>
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
 800478a:	234f      	movs	r3, #79	; 0x4f
 800478c:	18fb      	adds	r3, r7, r3
 800478e:	7818      	ldrb	r0, [r3, #0]
 8004790:	234f      	movs	r3, #79	; 0x4f
 8004792:	18fb      	adds	r3, r7, r3
 8004794:	781b      	ldrb	r3, [r3, #0]
 8004796:	4a25      	ldr	r2, [pc, #148]	; (800482c <gc_execute_line+0xda8>)
 8004798:	330e      	adds	r3, #14
 800479a:	009b      	lsls	r3, r3, #2
 800479c:	18d3      	adds	r3, r2, r3
 800479e:	3304      	adds	r3, #4
 80047a0:	681a      	ldr	r2, [r3, #0]
 80047a2:	4923      	ldr	r1, [pc, #140]	; (8004830 <gc_execute_line+0xdac>)
 80047a4:	0003      	movs	r3, r0
 80047a6:	330c      	adds	r3, #12
 80047a8:	009b      	lsls	r3, r3, #2
 80047aa:	18cb      	adds	r3, r1, r3
 80047ac:	3304      	adds	r3, #4
 80047ae:	601a      	str	r2, [r3, #0]
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
 80047b0:	234f      	movs	r3, #79	; 0x4f
 80047b2:	18fb      	adds	r3, r7, r3
 80047b4:	781a      	ldrb	r2, [r3, #0]
 80047b6:	234f      	movs	r3, #79	; 0x4f
 80047b8:	18fb      	adds	r3, r7, r3
 80047ba:	3201      	adds	r2, #1
 80047bc:	701a      	strb	r2, [r3, #0]
 80047be:	234f      	movs	r3, #79	; 0x4f
 80047c0:	18fb      	adds	r3, r7, r3
 80047c2:	781b      	ldrb	r3, [r3, #0]
 80047c4:	2b03      	cmp	r3, #3
 80047c6:	d987      	bls.n	80046d8 <gc_execute_line+0xc54>
        }
      }
      break;
 80047c8:	e127      	b.n	8004a1a <gc_execute_line+0xf96>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
 80047ca:	235f      	movs	r3, #95	; 0x5f
 80047cc:	18fb      	adds	r3, r7, r3
 80047ce:	781b      	ldrb	r3, [r3, #0]
 80047d0:	2b03      	cmp	r3, #3
 80047d2:	d100      	bne.n	80047d6 <gc_execute_line+0xd52>
 80047d4:	e0b4      	b.n	8004940 <gc_execute_line+0xebc>
        if (axis_words) {
 80047d6:	235a      	movs	r3, #90	; 0x5a
 80047d8:	18fb      	adds	r3, r7, r3
 80047da:	781b      	ldrb	r3, [r3, #0]
 80047dc:	2b00      	cmp	r3, #0
 80047de:	d100      	bne.n	80047e2 <gc_execute_line+0xd5e>
 80047e0:	e0ae      	b.n	8004940 <gc_execute_line+0xebc>
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
 80047e2:	234f      	movs	r3, #79	; 0x4f
 80047e4:	18fb      	adds	r3, r7, r3
 80047e6:	2200      	movs	r2, #0
 80047e8:	701a      	strb	r2, [r3, #0]
 80047ea:	e0a3      	b.n	8004934 <gc_execute_line+0xeb0>
            if ( bit_isfalse(axis_words,bit(idx)) ) {
 80047ec:	235a      	movs	r3, #90	; 0x5a
 80047ee:	18fb      	adds	r3, r7, r3
 80047f0:	781a      	ldrb	r2, [r3, #0]
 80047f2:	234f      	movs	r3, #79	; 0x4f
 80047f4:	18fb      	adds	r3, r7, r3
 80047f6:	781b      	ldrb	r3, [r3, #0]
 80047f8:	411a      	asrs	r2, r3
 80047fa:	0013      	movs	r3, r2
 80047fc:	2201      	movs	r2, #1
 80047fe:	4013      	ands	r3, r2
 8004800:	d11a      	bne.n	8004838 <gc_execute_line+0xdb4>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
 8004802:	234f      	movs	r3, #79	; 0x4f
 8004804:	18fb      	adds	r3, r7, r3
 8004806:	7818      	ldrb	r0, [r3, #0]
 8004808:	234f      	movs	r3, #79	; 0x4f
 800480a:	18fb      	adds	r3, r7, r3
 800480c:	781b      	ldrb	r3, [r3, #0]
 800480e:	4a07      	ldr	r2, [pc, #28]	; (800482c <gc_execute_line+0xda8>)
 8004810:	3306      	adds	r3, #6
 8004812:	009b      	lsls	r3, r3, #2
 8004814:	18d3      	adds	r3, r2, r3
 8004816:	3304      	adds	r3, #4
 8004818:	681a      	ldr	r2, [r3, #0]
 800481a:	4905      	ldr	r1, [pc, #20]	; (8004830 <gc_execute_line+0xdac>)
 800481c:	0003      	movs	r3, r0
 800481e:	330c      	adds	r3, #12
 8004820:	009b      	lsls	r3, r3, #2
 8004822:	18cb      	adds	r3, r1, r3
 8004824:	3304      	adds	r3, #4
 8004826:	601a      	str	r2, [r3, #0]
 8004828:	e07d      	b.n	8004926 <gc_execute_line+0xea2>
 800482a:	46c0      	nop			; (mov r8, r8)
 800482c:	200009c4 	.word	0x200009c4
 8004830:	20000a14 	.word	0x20000a14
 8004834:	20000a24 	.word	0x20000a24
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
 8004838:	4bb1      	ldr	r3, [pc, #708]	; (8004b00 <gc_execute_line+0x107c>)
 800483a:	781b      	ldrb	r3, [r3, #0]
 800483c:	2b35      	cmp	r3, #53	; 0x35
 800483e:	d072      	beq.n	8004926 <gc_execute_line+0xea2>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
 8004840:	4baf      	ldr	r3, [pc, #700]	; (8004b00 <gc_execute_line+0x107c>)
 8004842:	791b      	ldrb	r3, [r3, #4]
 8004844:	2b00      	cmp	r3, #0
 8004846:	d14d      	bne.n	80048e4 <gc_execute_line+0xe60>
                  gc_block.values.xyz[idx] += block_coord_system[idx] + gc_state.coord_offset[idx];
 8004848:	234f      	movs	r3, #79	; 0x4f
 800484a:	18fb      	adds	r3, r7, r3
 800484c:	781c      	ldrb	r4, [r3, #0]
 800484e:	234f      	movs	r3, #79	; 0x4f
 8004850:	18fb      	adds	r3, r7, r3
 8004852:	781b      	ldrb	r3, [r3, #0]
 8004854:	4aaa      	ldr	r2, [pc, #680]	; (8004b00 <gc_execute_line+0x107c>)
 8004856:	330c      	adds	r3, #12
 8004858:	009b      	lsls	r3, r3, #2
 800485a:	18d3      	adds	r3, r2, r3
 800485c:	3304      	adds	r3, #4
 800485e:	681d      	ldr	r5, [r3, #0]
 8004860:	234f      	movs	r3, #79	; 0x4f
 8004862:	18fb      	adds	r3, r7, r3
 8004864:	781a      	ldrb	r2, [r3, #0]
 8004866:	2318      	movs	r3, #24
 8004868:	18fb      	adds	r3, r7, r3
 800486a:	0092      	lsls	r2, r2, #2
 800486c:	58d0      	ldr	r0, [r2, r3]
 800486e:	234f      	movs	r3, #79	; 0x4f
 8004870:	18fb      	adds	r3, r7, r3
 8004872:	781b      	ldrb	r3, [r3, #0]
 8004874:	4aa3      	ldr	r2, [pc, #652]	; (8004b04 <gc_execute_line+0x1080>)
 8004876:	330e      	adds	r3, #14
 8004878:	009b      	lsls	r3, r3, #2
 800487a:	18d3      	adds	r3, r2, r3
 800487c:	3304      	adds	r3, #4
 800487e:	681b      	ldr	r3, [r3, #0]
 8004880:	1c19      	adds	r1, r3, #0
 8004882:	f7fb fd85 	bl	8000390 <__aeabi_fadd>
 8004886:	1c03      	adds	r3, r0, #0
 8004888:	1c19      	adds	r1, r3, #0
 800488a:	1c28      	adds	r0, r5, #0
 800488c:	f7fb fd80 	bl	8000390 <__aeabi_fadd>
 8004890:	1c03      	adds	r3, r0, #0
 8004892:	1c19      	adds	r1, r3, #0
 8004894:	4a9a      	ldr	r2, [pc, #616]	; (8004b00 <gc_execute_line+0x107c>)
 8004896:	0023      	movs	r3, r4
 8004898:	330c      	adds	r3, #12
 800489a:	009b      	lsls	r3, r3, #2
 800489c:	18d3      	adds	r3, r2, r3
 800489e:	3304      	adds	r3, #4
 80048a0:	6019      	str	r1, [r3, #0]
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
 80048a2:	234f      	movs	r3, #79	; 0x4f
 80048a4:	18fb      	adds	r3, r7, r3
 80048a6:	781b      	ldrb	r3, [r3, #0]
 80048a8:	2b02      	cmp	r3, #2
 80048aa:	d13c      	bne.n	8004926 <gc_execute_line+0xea2>
 80048ac:	234f      	movs	r3, #79	; 0x4f
 80048ae:	18fb      	adds	r3, r7, r3
 80048b0:	781c      	ldrb	r4, [r3, #0]
 80048b2:	234f      	movs	r3, #79	; 0x4f
 80048b4:	18fb      	adds	r3, r7, r3
 80048b6:	781b      	ldrb	r3, [r3, #0]
 80048b8:	4a91      	ldr	r2, [pc, #580]	; (8004b00 <gc_execute_line+0x107c>)
 80048ba:	330c      	adds	r3, #12
 80048bc:	009b      	lsls	r3, r3, #2
 80048be:	18d3      	adds	r3, r2, r3
 80048c0:	3304      	adds	r3, #4
 80048c2:	681a      	ldr	r2, [r3, #0]
 80048c4:	4b8f      	ldr	r3, [pc, #572]	; (8004b04 <gc_execute_line+0x1080>)
 80048c6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80048c8:	1c19      	adds	r1, r3, #0
 80048ca:	1c10      	adds	r0, r2, #0
 80048cc:	f7fb fd60 	bl	8000390 <__aeabi_fadd>
 80048d0:	1c03      	adds	r3, r0, #0
 80048d2:	1c19      	adds	r1, r3, #0
 80048d4:	4a8a      	ldr	r2, [pc, #552]	; (8004b00 <gc_execute_line+0x107c>)
 80048d6:	0023      	movs	r3, r4
 80048d8:	330c      	adds	r3, #12
 80048da:	009b      	lsls	r3, r3, #2
 80048dc:	18d3      	adds	r3, r2, r3
 80048de:	3304      	adds	r3, #4
 80048e0:	6019      	str	r1, [r3, #0]
 80048e2:	e020      	b.n	8004926 <gc_execute_line+0xea2>
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
 80048e4:	234f      	movs	r3, #79	; 0x4f
 80048e6:	18fb      	adds	r3, r7, r3
 80048e8:	781c      	ldrb	r4, [r3, #0]
 80048ea:	234f      	movs	r3, #79	; 0x4f
 80048ec:	18fb      	adds	r3, r7, r3
 80048ee:	781b      	ldrb	r3, [r3, #0]
 80048f0:	4a83      	ldr	r2, [pc, #524]	; (8004b00 <gc_execute_line+0x107c>)
 80048f2:	330c      	adds	r3, #12
 80048f4:	009b      	lsls	r3, r3, #2
 80048f6:	18d3      	adds	r3, r2, r3
 80048f8:	3304      	adds	r3, #4
 80048fa:	6818      	ldr	r0, [r3, #0]
 80048fc:	234f      	movs	r3, #79	; 0x4f
 80048fe:	18fb      	adds	r3, r7, r3
 8004900:	781b      	ldrb	r3, [r3, #0]
 8004902:	4a80      	ldr	r2, [pc, #512]	; (8004b04 <gc_execute_line+0x1080>)
 8004904:	3306      	adds	r3, #6
 8004906:	009b      	lsls	r3, r3, #2
 8004908:	18d3      	adds	r3, r2, r3
 800490a:	3304      	adds	r3, #4
 800490c:	681b      	ldr	r3, [r3, #0]
 800490e:	1c19      	adds	r1, r3, #0
 8004910:	f7fb fd3e 	bl	8000390 <__aeabi_fadd>
 8004914:	1c03      	adds	r3, r0, #0
 8004916:	1c19      	adds	r1, r3, #0
 8004918:	4a79      	ldr	r2, [pc, #484]	; (8004b00 <gc_execute_line+0x107c>)
 800491a:	0023      	movs	r3, r4
 800491c:	330c      	adds	r3, #12
 800491e:	009b      	lsls	r3, r3, #2
 8004920:	18d3      	adds	r3, r2, r3
 8004922:	3304      	adds	r3, #4
 8004924:	6019      	str	r1, [r3, #0]
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
 8004926:	234f      	movs	r3, #79	; 0x4f
 8004928:	18fb      	adds	r3, r7, r3
 800492a:	781a      	ldrb	r2, [r3, #0]
 800492c:	234f      	movs	r3, #79	; 0x4f
 800492e:	18fb      	adds	r3, r7, r3
 8004930:	3201      	adds	r2, #1
 8004932:	701a      	strb	r2, [r3, #0]
 8004934:	234f      	movs	r3, #79	; 0x4f
 8004936:	18fb      	adds	r3, r7, r3
 8004938:	781b      	ldrb	r3, [r3, #0]
 800493a:	2b03      	cmp	r3, #3
 800493c:	d800      	bhi.n	8004940 <gc_execute_line+0xebc>
 800493e:	e755      	b.n	80047ec <gc_execute_line+0xd68>
          }
        }
      }

      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {
 8004940:	4b6f      	ldr	r3, [pc, #444]	; (8004b00 <gc_execute_line+0x107c>)
 8004942:	781b      	ldrb	r3, [r3, #0]
 8004944:	2b26      	cmp	r3, #38	; 0x26
 8004946:	d100      	bne.n	800494a <gc_execute_line+0xec6>
 8004948:	e064      	b.n	8004a14 <gc_execute_line+0xf90>
 800494a:	dc04      	bgt.n	8004956 <gc_execute_line+0xed2>
 800494c:	2b1c      	cmp	r3, #28
 800494e:	d005      	beq.n	800495c <gc_execute_line+0xed8>
 8004950:	2b1e      	cmp	r3, #30
 8004952:	d003      	beq.n	800495c <gc_execute_line+0xed8>
 8004954:	e061      	b.n	8004a1a <gc_execute_line+0xf96>
 8004956:	2b35      	cmp	r3, #53	; 0x35
 8004958:	d051      	beq.n	80049fe <gc_execute_line+0xf7a>
          // [G28.1/30.1 Errors]: Cutter compensation is enabled.
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_RESET_COORDINATE_OFFSET:
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
 800495a:	e05e      	b.n	8004a1a <gc_execute_line+0xf96>
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
 800495c:	4b68      	ldr	r3, [pc, #416]	; (8004b00 <gc_execute_line+0x107c>)
 800495e:	781b      	ldrb	r3, [r3, #0]
 8004960:	2b1c      	cmp	r3, #28
 8004962:	d109      	bne.n	8004978 <gc_execute_line+0xef4>
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
 8004964:	4b68      	ldr	r3, [pc, #416]	; (8004b08 <gc_execute_line+0x1084>)
 8004966:	0019      	movs	r1, r3
 8004968:	2006      	movs	r0, #6
 800496a:	f005 f83d 	bl	80099e8 <settings_read_coord_data>
 800496e:	1e03      	subs	r3, r0, #0
 8004970:	d10c      	bne.n	800498c <gc_execute_line+0xf08>
 8004972:	2307      	movs	r3, #7
 8004974:	f000 fdcb 	bl	800550e <gc_execute_line+0x1a8a>
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
 8004978:	4b63      	ldr	r3, [pc, #396]	; (8004b08 <gc_execute_line+0x1084>)
 800497a:	0019      	movs	r1, r3
 800497c:	2007      	movs	r0, #7
 800497e:	f005 f833 	bl	80099e8 <settings_read_coord_data>
 8004982:	1e03      	subs	r3, r0, #0
 8004984:	d102      	bne.n	800498c <gc_execute_line+0xf08>
 8004986:	2307      	movs	r3, #7
 8004988:	f000 fdc1 	bl	800550e <gc_execute_line+0x1a8a>
          if (axis_words) {
 800498c:	235a      	movs	r3, #90	; 0x5a
 800498e:	18fb      	adds	r3, r7, r3
 8004990:	781b      	ldrb	r3, [r3, #0]
 8004992:	2b00      	cmp	r3, #0
 8004994:	d02e      	beq.n	80049f4 <gc_execute_line+0xf70>
            for (idx=0; idx<N_AXIS; idx++) {
 8004996:	234f      	movs	r3, #79	; 0x4f
 8004998:	18fb      	adds	r3, r7, r3
 800499a:	2200      	movs	r2, #0
 800499c:	701a      	strb	r2, [r3, #0]
 800499e:	e023      	b.n	80049e8 <gc_execute_line+0xf64>
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
 80049a0:	235a      	movs	r3, #90	; 0x5a
 80049a2:	18fb      	adds	r3, r7, r3
 80049a4:	781a      	ldrb	r2, [r3, #0]
 80049a6:	234f      	movs	r3, #79	; 0x4f
 80049a8:	18fb      	adds	r3, r7, r3
 80049aa:	781b      	ldrb	r3, [r3, #0]
 80049ac:	411a      	asrs	r2, r3
 80049ae:	0013      	movs	r3, r2
 80049b0:	2201      	movs	r2, #1
 80049b2:	4013      	ands	r3, r2
 80049b4:	d111      	bne.n	80049da <gc_execute_line+0xf56>
 80049b6:	234f      	movs	r3, #79	; 0x4f
 80049b8:	18fb      	adds	r3, r7, r3
 80049ba:	7818      	ldrb	r0, [r3, #0]
 80049bc:	234f      	movs	r3, #79	; 0x4f
 80049be:	18fb      	adds	r3, r7, r3
 80049c0:	781b      	ldrb	r3, [r3, #0]
 80049c2:	4a50      	ldr	r2, [pc, #320]	; (8004b04 <gc_execute_line+0x1080>)
 80049c4:	3306      	adds	r3, #6
 80049c6:	009b      	lsls	r3, r3, #2
 80049c8:	18d3      	adds	r3, r2, r3
 80049ca:	3304      	adds	r3, #4
 80049cc:	681a      	ldr	r2, [r3, #0]
 80049ce:	494c      	ldr	r1, [pc, #304]	; (8004b00 <gc_execute_line+0x107c>)
 80049d0:	1c83      	adds	r3, r0, #2
 80049d2:	009b      	lsls	r3, r3, #2
 80049d4:	18cb      	adds	r3, r1, r3
 80049d6:	3308      	adds	r3, #8
 80049d8:	601a      	str	r2, [r3, #0]
            for (idx=0; idx<N_AXIS; idx++) {
 80049da:	234f      	movs	r3, #79	; 0x4f
 80049dc:	18fb      	adds	r3, r7, r3
 80049de:	781a      	ldrb	r2, [r3, #0]
 80049e0:	234f      	movs	r3, #79	; 0x4f
 80049e2:	18fb      	adds	r3, r7, r3
 80049e4:	3201      	adds	r2, #1
 80049e6:	701a      	strb	r2, [r3, #0]
 80049e8:	234f      	movs	r3, #79	; 0x4f
 80049ea:	18fb      	adds	r3, r7, r3
 80049ec:	781b      	ldrb	r3, [r3, #0]
 80049ee:	2b03      	cmp	r3, #3
 80049f0:	d9d6      	bls.n	80049a0 <gc_execute_line+0xf1c>
          break;
 80049f2:	e012      	b.n	8004a1a <gc_execute_line+0xf96>
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
 80049f4:	235f      	movs	r3, #95	; 0x5f
 80049f6:	18fb      	adds	r3, r7, r3
 80049f8:	2200      	movs	r2, #0
 80049fa:	701a      	strb	r2, [r3, #0]
          break;
 80049fc:	e00d      	b.n	8004a1a <gc_execute_line+0xf96>
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
 80049fe:	4b40      	ldr	r3, [pc, #256]	; (8004b00 <gc_execute_line+0x107c>)
 8004a00:	785b      	ldrb	r3, [r3, #1]
 8004a02:	2b00      	cmp	r3, #0
 8004a04:	d008      	beq.n	8004a18 <gc_execute_line+0xf94>
 8004a06:	4b3e      	ldr	r3, [pc, #248]	; (8004b00 <gc_execute_line+0x107c>)
 8004a08:	785b      	ldrb	r3, [r3, #1]
 8004a0a:	2b01      	cmp	r3, #1
 8004a0c:	d004      	beq.n	8004a18 <gc_execute_line+0xf94>
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
 8004a0e:	231e      	movs	r3, #30
 8004a10:	f000 fd7d 	bl	800550e <gc_execute_line+0x1a8a>
          break;
 8004a14:	46c0      	nop			; (mov r8, r8)
 8004a16:	e000      	b.n	8004a1a <gc_execute_line+0xf96>
          }
          break;
 8004a18:	46c0      	nop			; (mov r8, r8)
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
 8004a1a:	4b39      	ldr	r3, [pc, #228]	; (8004b00 <gc_execute_line+0x107c>)
 8004a1c:	785b      	ldrb	r3, [r3, #1]
 8004a1e:	2b50      	cmp	r3, #80	; 0x50
 8004a20:	d108      	bne.n	8004a34 <gc_execute_line+0xfb0>
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
 8004a22:	235a      	movs	r3, #90	; 0x5a
 8004a24:	18fb      	adds	r3, r7, r3
 8004a26:	781b      	ldrb	r3, [r3, #0]
 8004a28:	2b00      	cmp	r3, #0
 8004a2a:	d100      	bne.n	8004a2e <gc_execute_line+0xfaa>
 8004a2c:	e255      	b.n	8004eda <gc_execute_line+0x1456>
 8004a2e:	231f      	movs	r3, #31
 8004a30:	f000 fd6d 	bl	800550e <gc_execute_line+0x1a8a>

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
 8004a34:	235f      	movs	r3, #95	; 0x5f
 8004a36:	18fb      	adds	r3, r7, r3
 8004a38:	781b      	ldrb	r3, [r3, #0]
 8004a3a:	2b02      	cmp	r3, #2
 8004a3c:	d000      	beq.n	8004a40 <gc_execute_line+0xfbc>
 8004a3e:	e24c      	b.n	8004eda <gc_execute_line+0x1456>

    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
 8004a40:	4b2f      	ldr	r3, [pc, #188]	; (8004b00 <gc_execute_line+0x107c>)
 8004a42:	785b      	ldrb	r3, [r3, #1]
 8004a44:	2b00      	cmp	r3, #0
 8004a46:	d10a      	bne.n	8004a5e <gc_execute_line+0xfda>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
 8004a48:	235a      	movs	r3, #90	; 0x5a
 8004a4a:	18fb      	adds	r3, r7, r3
 8004a4c:	781b      	ldrb	r3, [r3, #0]
 8004a4e:	2b00      	cmp	r3, #0
 8004a50:	d000      	beq.n	8004a54 <gc_execute_line+0xfd0>
 8004a52:	e242      	b.n	8004eda <gc_execute_line+0x1456>
 8004a54:	235f      	movs	r3, #95	; 0x5f
 8004a56:	18fb      	adds	r3, r7, r3
 8004a58:	2200      	movs	r2, #0
 8004a5a:	701a      	strb	r2, [r3, #0]
 8004a5c:	e23d      	b.n	8004eda <gc_execute_line+0x1456>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0f) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
 8004a5e:	4b28      	ldr	r3, [pc, #160]	; (8004b00 <gc_execute_line+0x107c>)
 8004a60:	68db      	ldr	r3, [r3, #12]
 8004a62:	2100      	movs	r1, #0
 8004a64:	1c18      	adds	r0, r3, #0
 8004a66:	f7fb fc2f 	bl	80002c8 <__aeabi_fcmpeq>
 8004a6a:	1e03      	subs	r3, r0, #0
 8004a6c:	d002      	beq.n	8004a74 <gc_execute_line+0xff0>
 8004a6e:	2316      	movs	r3, #22
 8004a70:	f000 fd4d 	bl	800550e <gc_execute_line+0x1a8a>

      switch (gc_block.modal.motion) {
 8004a74:	4b22      	ldr	r3, [pc, #136]	; (8004b00 <gc_execute_line+0x107c>)
 8004a76:	785b      	ldrb	r3, [r3, #1]
 8004a78:	2b8c      	cmp	r3, #140	; 0x8c
 8004a7a:	d100      	bne.n	8004a7e <gc_execute_line+0xffa>
 8004a7c:	e1fa      	b.n	8004e74 <gc_execute_line+0x13f0>
 8004a7e:	dc06      	bgt.n	8004a8e <gc_execute_line+0x100a>
 8004a80:	2b02      	cmp	r3, #2
 8004a82:	d018      	beq.n	8004ab6 <gc_execute_line+0x1032>
 8004a84:	2b03      	cmp	r3, #3
 8004a86:	d01e      	beq.n	8004ac6 <gc_execute_line+0x1042>
 8004a88:	2b01      	cmp	r3, #1
 8004a8a:	d009      	beq.n	8004aa0 <gc_execute_line+0x101c>
 8004a8c:	e225      	b.n	8004eda <gc_execute_line+0x1456>
 8004a8e:	2b8e      	cmp	r3, #142	; 0x8e
 8004a90:	d100      	bne.n	8004a94 <gc_execute_line+0x1010>
 8004a92:	e1ef      	b.n	8004e74 <gc_execute_line+0x13f0>
 8004a94:	da00      	bge.n	8004a98 <gc_execute_line+0x1014>
 8004a96:	e1e5      	b.n	8004e64 <gc_execute_line+0x13e0>
 8004a98:	2b8f      	cmp	r3, #143	; 0x8f
 8004a9a:	d100      	bne.n	8004a9e <gc_execute_line+0x101a>
 8004a9c:	e1e2      	b.n	8004e64 <gc_execute_line+0x13e0>
 8004a9e:	e21c      	b.n	8004eda <gc_execute_line+0x1456>
        case MOTION_MODE_LINEAR:
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
 8004aa0:	235a      	movs	r3, #90	; 0x5a
 8004aa2:	18fb      	adds	r3, r7, r3
 8004aa4:	781b      	ldrb	r3, [r3, #0]
 8004aa6:	2b00      	cmp	r3, #0
 8004aa8:	d000      	beq.n	8004aac <gc_execute_line+0x1028>
 8004aaa:	e213      	b.n	8004ed4 <gc_execute_line+0x1450>
 8004aac:	235f      	movs	r3, #95	; 0x5f
 8004aae:	18fb      	adds	r3, r7, r3
 8004ab0:	2200      	movs	r2, #0
 8004ab2:	701a      	strb	r2, [r3, #0]

          break;
 8004ab4:	e20e      	b.n	8004ed4 <gc_execute_line+0x1450>
        case MOTION_MODE_CW_ARC: 
          gc_parser_flags |= GC_PARSER_ARC_IS_CLOCKWISE; // No break intentional.
 8004ab6:	2353      	movs	r3, #83	; 0x53
 8004ab8:	18fb      	adds	r3, r7, r3
 8004aba:	2253      	movs	r2, #83	; 0x53
 8004abc:	18ba      	adds	r2, r7, r2
 8004abe:	7812      	ldrb	r2, [r2, #0]
 8004ac0:	2104      	movs	r1, #4
 8004ac2:	430a      	orrs	r2, r1
 8004ac4:	701a      	strb	r2, [r3, #0]
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
 8004ac6:	235a      	movs	r3, #90	; 0x5a
 8004ac8:	18fb      	adds	r3, r7, r3
 8004aca:	781b      	ldrb	r3, [r3, #0]
 8004acc:	2b00      	cmp	r3, #0
 8004ace:	d102      	bne.n	8004ad6 <gc_execute_line+0x1052>
 8004ad0:	231a      	movs	r3, #26
 8004ad2:	f000 fd1c 	bl	800550e <gc_execute_line+0x1a8a>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
 8004ad6:	235a      	movs	r3, #90	; 0x5a
 8004ad8:	18fb      	adds	r3, r7, r3
 8004ada:	781b      	ldrb	r3, [r3, #0]
 8004adc:	225e      	movs	r2, #94	; 0x5e
 8004ade:	18ba      	adds	r2, r7, r2
 8004ae0:	7812      	ldrb	r2, [r2, #0]
 8004ae2:	2101      	movs	r1, #1
 8004ae4:	4091      	lsls	r1, r2
 8004ae6:	225d      	movs	r2, #93	; 0x5d
 8004ae8:	18ba      	adds	r2, r7, r2
 8004aea:	7812      	ldrb	r2, [r2, #0]
 8004aec:	2001      	movs	r0, #1
 8004aee:	4090      	lsls	r0, r2
 8004af0:	0002      	movs	r2, r0
 8004af2:	430a      	orrs	r2, r1
 8004af4:	4013      	ands	r3, r2
 8004af6:	d109      	bne.n	8004b0c <gc_execute_line+0x1088>
 8004af8:	2320      	movs	r3, #32
 8004afa:	f000 fd08 	bl	800550e <gc_execute_line+0x1a8a>
 8004afe:	46c0      	nop			; (mov r8, r8)
 8004b00:	20000a14 	.word	0x20000a14
 8004b04:	200009c4 	.word	0x200009c4
 8004b08:	20000a24 	.word	0x20000a24

          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
 8004b0c:	235e      	movs	r3, #94	; 0x5e
 8004b0e:	18fb      	adds	r3, r7, r3
 8004b10:	781b      	ldrb	r3, [r3, #0]
 8004b12:	4ae4      	ldr	r2, [pc, #912]	; (8004ea4 <gc_execute_line+0x1420>)
 8004b14:	330c      	adds	r3, #12
 8004b16:	009b      	lsls	r3, r3, #2
 8004b18:	18d3      	adds	r3, r2, r3
 8004b1a:	3304      	adds	r3, #4
 8004b1c:	6818      	ldr	r0, [r3, #0]
 8004b1e:	235e      	movs	r3, #94	; 0x5e
 8004b20:	18fb      	adds	r3, r7, r3
 8004b22:	781b      	ldrb	r3, [r3, #0]
 8004b24:	4ae0      	ldr	r2, [pc, #896]	; (8004ea8 <gc_execute_line+0x1424>)
 8004b26:	3306      	adds	r3, #6
 8004b28:	009b      	lsls	r3, r3, #2
 8004b2a:	18d3      	adds	r3, r2, r3
 8004b2c:	3304      	adds	r3, #4
 8004b2e:	681b      	ldr	r3, [r3, #0]
 8004b30:	1c19      	adds	r1, r3, #0
 8004b32:	f7fc f8cf 	bl	8000cd4 <__aeabi_fsub>
 8004b36:	1c03      	adds	r3, r0, #0
 8004b38:	643b      	str	r3, [r7, #64]	; 0x40
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
 8004b3a:	235d      	movs	r3, #93	; 0x5d
 8004b3c:	18fb      	adds	r3, r7, r3
 8004b3e:	781b      	ldrb	r3, [r3, #0]
 8004b40:	4ad8      	ldr	r2, [pc, #864]	; (8004ea4 <gc_execute_line+0x1420>)
 8004b42:	330c      	adds	r3, #12
 8004b44:	009b      	lsls	r3, r3, #2
 8004b46:	18d3      	adds	r3, r2, r3
 8004b48:	3304      	adds	r3, #4
 8004b4a:	6818      	ldr	r0, [r3, #0]
 8004b4c:	235d      	movs	r3, #93	; 0x5d
 8004b4e:	18fb      	adds	r3, r7, r3
 8004b50:	781b      	ldrb	r3, [r3, #0]
 8004b52:	4ad5      	ldr	r2, [pc, #852]	; (8004ea8 <gc_execute_line+0x1424>)
 8004b54:	3306      	adds	r3, #6
 8004b56:	009b      	lsls	r3, r3, #2
 8004b58:	18d3      	adds	r3, r2, r3
 8004b5a:	3304      	adds	r3, #4
 8004b5c:	681b      	ldr	r3, [r3, #0]
 8004b5e:	1c19      	adds	r1, r3, #0
 8004b60:	f7fc f8b8 	bl	8000cd4 <__aeabi_fsub>
 8004b64:	1c03      	adds	r3, r0, #0
 8004b66:	63fb      	str	r3, [r7, #60]	; 0x3c

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
 8004b68:	2354      	movs	r3, #84	; 0x54
 8004b6a:	18fb      	adds	r3, r7, r3
 8004b6c:	881b      	ldrh	r3, [r3, #0]
 8004b6e:	2280      	movs	r2, #128	; 0x80
 8004b70:	4013      	ands	r3, r2
 8004b72:	d100      	bne.n	8004b76 <gc_execute_line+0x10f2>
 8004b74:	e0b8      	b.n	8004ce8 <gc_execute_line+0x1264>
            bit_false(value_words,bit(WORD_R));
 8004b76:	2354      	movs	r3, #84	; 0x54
 8004b78:	18fb      	adds	r3, r7, r3
 8004b7a:	2254      	movs	r2, #84	; 0x54
 8004b7c:	18ba      	adds	r2, r7, r2
 8004b7e:	8812      	ldrh	r2, [r2, #0]
 8004b80:	2180      	movs	r1, #128	; 0x80
 8004b82:	438a      	bics	r2, r1
 8004b84:	801a      	strh	r2, [r3, #0]
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
 8004b86:	49c9      	ldr	r1, [pc, #804]	; (8004eac <gc_execute_line+0x1428>)
 8004b88:	4bc9      	ldr	r3, [pc, #804]	; (8004eb0 <gc_execute_line+0x142c>)
 8004b8a:	2210      	movs	r2, #16
 8004b8c:	0018      	movs	r0, r3
 8004b8e:	f007 fda1 	bl	800c6d4 <memcmp>
 8004b92:	1e03      	subs	r3, r0, #0
 8004b94:	d102      	bne.n	8004b9c <gc_execute_line+0x1118>
 8004b96:	2321      	movs	r3, #33	; 0x21
 8004b98:	f000 fcb9 	bl	800550e <gc_execute_line+0x1a8a>

            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
 8004b9c:	4bc1      	ldr	r3, [pc, #772]	; (8004ea4 <gc_execute_line+0x1420>)
 8004b9e:	78db      	ldrb	r3, [r3, #3]
 8004ba0:	2b01      	cmp	r3, #1
 8004ba2:	d109      	bne.n	8004bb8 <gc_execute_line+0x1134>
 8004ba4:	4bbf      	ldr	r3, [pc, #764]	; (8004ea4 <gc_execute_line+0x1420>)
 8004ba6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004ba8:	49c2      	ldr	r1, [pc, #776]	; (8004eb4 <gc_execute_line+0x1430>)
 8004baa:	1c18      	adds	r0, r3, #0
 8004bac:	f7fb ff72 	bl	8000a94 <__aeabi_fmul>
 8004bb0:	1c03      	adds	r3, r0, #0
 8004bb2:	1c1a      	adds	r2, r3, #0
 8004bb4:	4bbb      	ldr	r3, [pc, #748]	; (8004ea4 <gc_execute_line+0x1420>)
 8004bb6:	629a      	str	r2, [r3, #40]	; 0x28
                j = (y + (x * h_x2_div_d))/2
            */

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0f * gc_block.values.r*gc_block.values.r - x*x - y*y;
 8004bb8:	4bba      	ldr	r3, [pc, #744]	; (8004ea4 <gc_execute_line+0x1420>)
 8004bba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004bbc:	2181      	movs	r1, #129	; 0x81
 8004bbe:	05c9      	lsls	r1, r1, #23
 8004bc0:	1c18      	adds	r0, r3, #0
 8004bc2:	f7fb ff67 	bl	8000a94 <__aeabi_fmul>
 8004bc6:	1c03      	adds	r3, r0, #0
 8004bc8:	1c1a      	adds	r2, r3, #0
 8004bca:	4bb6      	ldr	r3, [pc, #728]	; (8004ea4 <gc_execute_line+0x1420>)
 8004bcc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004bce:	1c19      	adds	r1, r3, #0
 8004bd0:	1c10      	adds	r0, r2, #0
 8004bd2:	f7fb ff5f 	bl	8000a94 <__aeabi_fmul>
 8004bd6:	1c03      	adds	r3, r0, #0
 8004bd8:	1c1c      	adds	r4, r3, #0
 8004bda:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8004bdc:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8004bde:	f7fb ff59 	bl	8000a94 <__aeabi_fmul>
 8004be2:	1c03      	adds	r3, r0, #0
 8004be4:	1c19      	adds	r1, r3, #0
 8004be6:	1c20      	adds	r0, r4, #0
 8004be8:	f7fc f874 	bl	8000cd4 <__aeabi_fsub>
 8004bec:	1c03      	adds	r3, r0, #0
 8004bee:	1c1c      	adds	r4, r3, #0
 8004bf0:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8004bf2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8004bf4:	f7fb ff4e 	bl	8000a94 <__aeabi_fmul>
 8004bf8:	1c03      	adds	r3, r0, #0
 8004bfa:	1c19      	adds	r1, r3, #0
 8004bfc:	1c20      	adds	r0, r4, #0
 8004bfe:	f7fc f869 	bl	8000cd4 <__aeabi_fsub>
 8004c02:	1c03      	adds	r3, r0, #0
 8004c04:	64bb      	str	r3, [r7, #72]	; 0x48

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
 8004c06:	2100      	movs	r1, #0
 8004c08:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8004c0a:	f7fb fb63 	bl	80002d4 <__aeabi_fcmplt>
 8004c0e:	1e03      	subs	r3, r0, #0
 8004c10:	d002      	beq.n	8004c18 <gc_execute_line+0x1194>
 8004c12:	2322      	movs	r3, #34	; 0x22
 8004c14:	f000 fc7b 	bl	800550e <gc_execute_line+0x1a8a>

            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrtf(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
 8004c18:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8004c1a:	1c18      	adds	r0, r3, #0
 8004c1c:	f007 ff0a 	bl	800ca34 <sqrtf>
 8004c20:	1c02      	adds	r2, r0, #0
 8004c22:	2380      	movs	r3, #128	; 0x80
 8004c24:	061b      	lsls	r3, r3, #24
 8004c26:	4053      	eors	r3, r2
 8004c28:	001c      	movs	r4, r3
 8004c2a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8004c2c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8004c2e:	1c11      	adds	r1, r2, #0
 8004c30:	1c18      	adds	r0, r3, #0
 8004c32:	f001 fe28 	bl	8006886 <hypot_f>
 8004c36:	1c03      	adds	r3, r0, #0
 8004c38:	1c19      	adds	r1, r3, #0
 8004c3a:	1c20      	adds	r0, r4, #0
 8004c3c:	f7fb fd3a 	bl	80006b4 <__aeabi_fdiv>
 8004c40:	1c03      	adds	r3, r0, #0
 8004c42:	64bb      	str	r3, [r7, #72]	; 0x48
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }
 8004c44:	4b97      	ldr	r3, [pc, #604]	; (8004ea4 <gc_execute_line+0x1420>)
 8004c46:	785b      	ldrb	r3, [r3, #1]
 8004c48:	2b03      	cmp	r3, #3
 8004c4a:	d104      	bne.n	8004c56 <gc_execute_line+0x11d2>
 8004c4c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8004c4e:	2280      	movs	r2, #128	; 0x80
 8004c50:	0612      	lsls	r2, r2, #24
 8004c52:	4053      	eors	r3, r2
 8004c54:	64bb      	str	r3, [r7, #72]	; 0x48
            */
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!),
            // even though it is advised against ever generating such circles in a single line of g-code. By
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) {
 8004c56:	4b93      	ldr	r3, [pc, #588]	; (8004ea4 <gc_execute_line+0x1420>)
 8004c58:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004c5a:	2100      	movs	r1, #0
 8004c5c:	1c18      	adds	r0, r3, #0
 8004c5e:	f7fb fb39 	bl	80002d4 <__aeabi_fcmplt>
 8004c62:	1e03      	subs	r3, r0, #0
 8004c64:	d00b      	beq.n	8004c7e <gc_execute_line+0x11fa>
                h_x2_div_d = -h_x2_div_d;
 8004c66:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8004c68:	2280      	movs	r2, #128	; 0x80
 8004c6a:	0612      	lsls	r2, r2, #24
 8004c6c:	4053      	eors	r3, r2
 8004c6e:	64bb      	str	r3, [r7, #72]	; 0x48
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
 8004c70:	4b8c      	ldr	r3, [pc, #560]	; (8004ea4 <gc_execute_line+0x1420>)
 8004c72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004c74:	2280      	movs	r2, #128	; 0x80
 8004c76:	0612      	lsls	r2, r2, #24
 8004c78:	405a      	eors	r2, r3
 8004c7a:	4b8a      	ldr	r3, [pc, #552]	; (8004ea4 <gc_execute_line+0x1420>)
 8004c7c:	629a      	str	r2, [r3, #40]	; 0x28
            }
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5f*(x-(y*h_x2_div_d));
 8004c7e:	235e      	movs	r3, #94	; 0x5e
 8004c80:	18fb      	adds	r3, r7, r3
 8004c82:	781c      	ldrb	r4, [r3, #0]
 8004c84:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8004c86:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8004c88:	f7fb ff04 	bl	8000a94 <__aeabi_fmul>
 8004c8c:	1c03      	adds	r3, r0, #0
 8004c8e:	1c19      	adds	r1, r3, #0
 8004c90:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8004c92:	f7fc f81f 	bl	8000cd4 <__aeabi_fsub>
 8004c96:	1c03      	adds	r3, r0, #0
 8004c98:	21fc      	movs	r1, #252	; 0xfc
 8004c9a:	0589      	lsls	r1, r1, #22
 8004c9c:	1c18      	adds	r0, r3, #0
 8004c9e:	f7fb fef9 	bl	8000a94 <__aeabi_fmul>
 8004ca2:	1c03      	adds	r3, r0, #0
 8004ca4:	1c19      	adds	r1, r3, #0
 8004ca6:	4a7f      	ldr	r2, [pc, #508]	; (8004ea4 <gc_execute_line+0x1420>)
 8004ca8:	1ca3      	adds	r3, r4, #2
 8004caa:	009b      	lsls	r3, r3, #2
 8004cac:	18d3      	adds	r3, r2, r3
 8004cae:	3308      	adds	r3, #8
 8004cb0:	6019      	str	r1, [r3, #0]
            gc_block.values.ijk[axis_1] = 0.5f*(y+(x*h_x2_div_d));
 8004cb2:	235d      	movs	r3, #93	; 0x5d
 8004cb4:	18fb      	adds	r3, r7, r3
 8004cb6:	781c      	ldrb	r4, [r3, #0]
 8004cb8:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8004cba:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8004cbc:	f7fb feea 	bl	8000a94 <__aeabi_fmul>
 8004cc0:	1c03      	adds	r3, r0, #0
 8004cc2:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8004cc4:	1c18      	adds	r0, r3, #0
 8004cc6:	f7fb fb63 	bl	8000390 <__aeabi_fadd>
 8004cca:	1c03      	adds	r3, r0, #0
 8004ccc:	21fc      	movs	r1, #252	; 0xfc
 8004cce:	0589      	lsls	r1, r1, #22
 8004cd0:	1c18      	adds	r0, r3, #0
 8004cd2:	f7fb fedf 	bl	8000a94 <__aeabi_fmul>
 8004cd6:	1c03      	adds	r3, r0, #0
 8004cd8:	1c19      	adds	r1, r3, #0
 8004cda:	4a72      	ldr	r2, [pc, #456]	; (8004ea4 <gc_execute_line+0x1420>)
 8004cdc:	1ca3      	adds	r3, r4, #2
 8004cde:	009b      	lsls	r3, r3, #2
 8004ce0:	18d3      	adds	r3, r2, r3
 8004ce2:	3308      	adds	r3, #8
 8004ce4:	6019      	str	r1, [r3, #0]
            if (delta_r > 0.005f) {
              if (delta_r > 0.5f) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
              if (delta_r > (0.001f*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
            }
          }
          break;
 8004ce6:	e0f8      	b.n	8004eda <gc_execute_line+0x1456>
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
 8004ce8:	2359      	movs	r3, #89	; 0x59
 8004cea:	18fb      	adds	r3, r7, r3
 8004cec:	781b      	ldrb	r3, [r3, #0]
 8004cee:	225e      	movs	r2, #94	; 0x5e
 8004cf0:	18ba      	adds	r2, r7, r2
 8004cf2:	7812      	ldrb	r2, [r2, #0]
 8004cf4:	2101      	movs	r1, #1
 8004cf6:	4091      	lsls	r1, r2
 8004cf8:	225d      	movs	r2, #93	; 0x5d
 8004cfa:	18ba      	adds	r2, r7, r2
 8004cfc:	7812      	ldrb	r2, [r2, #0]
 8004cfe:	2001      	movs	r0, #1
 8004d00:	4090      	lsls	r0, r2
 8004d02:	0002      	movs	r2, r0
 8004d04:	430a      	orrs	r2, r1
 8004d06:	4013      	ands	r3, r2
 8004d08:	d102      	bne.n	8004d10 <gc_execute_line+0x128c>
 8004d0a:	2323      	movs	r3, #35	; 0x23
 8004d0c:	f000 fbff 	bl	800550e <gc_execute_line+0x1a8a>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));
 8004d10:	2354      	movs	r3, #84	; 0x54
 8004d12:	18fb      	adds	r3, r7, r3
 8004d14:	2254      	movs	r2, #84	; 0x54
 8004d16:	18ba      	adds	r2, r7, r2
 8004d18:	8812      	ldrh	r2, [r2, #0]
 8004d1a:	210e      	movs	r1, #14
 8004d1c:	438a      	bics	r2, r1
 8004d1e:	801a      	strh	r2, [r3, #0]
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
 8004d20:	4b60      	ldr	r3, [pc, #384]	; (8004ea4 <gc_execute_line+0x1420>)
 8004d22:	78db      	ldrb	r3, [r3, #3]
 8004d24:	2b01      	cmp	r3, #1
 8004d26:	d133      	bne.n	8004d90 <gc_execute_line+0x130c>
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
 8004d28:	234f      	movs	r3, #79	; 0x4f
 8004d2a:	18fb      	adds	r3, r7, r3
 8004d2c:	2200      	movs	r2, #0
 8004d2e:	701a      	strb	r2, [r3, #0]
 8004d30:	e029      	b.n	8004d86 <gc_execute_line+0x1302>
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
 8004d32:	2359      	movs	r3, #89	; 0x59
 8004d34:	18fb      	adds	r3, r7, r3
 8004d36:	781a      	ldrb	r2, [r3, #0]
 8004d38:	234f      	movs	r3, #79	; 0x4f
 8004d3a:	18fb      	adds	r3, r7, r3
 8004d3c:	781b      	ldrb	r3, [r3, #0]
 8004d3e:	411a      	asrs	r2, r3
 8004d40:	0013      	movs	r3, r2
 8004d42:	2201      	movs	r2, #1
 8004d44:	4013      	ands	r3, r2
 8004d46:	d017      	beq.n	8004d78 <gc_execute_line+0x12f4>
 8004d48:	234f      	movs	r3, #79	; 0x4f
 8004d4a:	18fb      	adds	r3, r7, r3
 8004d4c:	781c      	ldrb	r4, [r3, #0]
 8004d4e:	234f      	movs	r3, #79	; 0x4f
 8004d50:	18fb      	adds	r3, r7, r3
 8004d52:	781b      	ldrb	r3, [r3, #0]
 8004d54:	4a53      	ldr	r2, [pc, #332]	; (8004ea4 <gc_execute_line+0x1420>)
 8004d56:	3302      	adds	r3, #2
 8004d58:	009b      	lsls	r3, r3, #2
 8004d5a:	18d3      	adds	r3, r2, r3
 8004d5c:	3308      	adds	r3, #8
 8004d5e:	681b      	ldr	r3, [r3, #0]
 8004d60:	4954      	ldr	r1, [pc, #336]	; (8004eb4 <gc_execute_line+0x1430>)
 8004d62:	1c18      	adds	r0, r3, #0
 8004d64:	f7fb fe96 	bl	8000a94 <__aeabi_fmul>
 8004d68:	1c03      	adds	r3, r0, #0
 8004d6a:	1c19      	adds	r1, r3, #0
 8004d6c:	4a4d      	ldr	r2, [pc, #308]	; (8004ea4 <gc_execute_line+0x1420>)
 8004d6e:	1ca3      	adds	r3, r4, #2
 8004d70:	009b      	lsls	r3, r3, #2
 8004d72:	18d3      	adds	r3, r2, r3
 8004d74:	3308      	adds	r3, #8
 8004d76:	6019      	str	r1, [r3, #0]
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
 8004d78:	234f      	movs	r3, #79	; 0x4f
 8004d7a:	18fb      	adds	r3, r7, r3
 8004d7c:	781a      	ldrb	r2, [r3, #0]
 8004d7e:	234f      	movs	r3, #79	; 0x4f
 8004d80:	18fb      	adds	r3, r7, r3
 8004d82:	3201      	adds	r2, #1
 8004d84:	701a      	strb	r2, [r3, #0]
 8004d86:	234f      	movs	r3, #79	; 0x4f
 8004d88:	18fb      	adds	r3, r7, r3
 8004d8a:	781b      	ldrb	r3, [r3, #0]
 8004d8c:	2b03      	cmp	r3, #3
 8004d8e:	d9d0      	bls.n	8004d32 <gc_execute_line+0x12ae>
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
 8004d90:	235e      	movs	r3, #94	; 0x5e
 8004d92:	18fb      	adds	r3, r7, r3
 8004d94:	781b      	ldrb	r3, [r3, #0]
 8004d96:	4a43      	ldr	r2, [pc, #268]	; (8004ea4 <gc_execute_line+0x1420>)
 8004d98:	3302      	adds	r3, #2
 8004d9a:	009b      	lsls	r3, r3, #2
 8004d9c:	18d3      	adds	r3, r2, r3
 8004d9e:	3308      	adds	r3, #8
 8004da0:	681b      	ldr	r3, [r3, #0]
 8004da2:	1c19      	adds	r1, r3, #0
 8004da4:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8004da6:	f7fb ff95 	bl	8000cd4 <__aeabi_fsub>
 8004daa:	1c03      	adds	r3, r0, #0
 8004dac:	643b      	str	r3, [r7, #64]	; 0x40
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
 8004dae:	235d      	movs	r3, #93	; 0x5d
 8004db0:	18fb      	adds	r3, r7, r3
 8004db2:	781b      	ldrb	r3, [r3, #0]
 8004db4:	4a3b      	ldr	r2, [pc, #236]	; (8004ea4 <gc_execute_line+0x1420>)
 8004db6:	3302      	adds	r3, #2
 8004db8:	009b      	lsls	r3, r3, #2
 8004dba:	18d3      	adds	r3, r2, r3
 8004dbc:	3308      	adds	r3, #8
 8004dbe:	681b      	ldr	r3, [r3, #0]
 8004dc0:	1c19      	adds	r1, r3, #0
 8004dc2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8004dc4:	f7fb ff86 	bl	8000cd4 <__aeabi_fsub>
 8004dc8:	1c03      	adds	r3, r0, #0
 8004dca:	63fb      	str	r3, [r7, #60]	; 0x3c
            float target_r = hypot_f(x,y);
 8004dcc:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8004dce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8004dd0:	1c11      	adds	r1, r2, #0
 8004dd2:	1c18      	adds	r0, r3, #0
 8004dd4:	f001 fd57 	bl	8006886 <hypot_f>
 8004dd8:	1c03      	adds	r3, r0, #0
 8004dda:	63bb      	str	r3, [r7, #56]	; 0x38
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);
 8004ddc:	235e      	movs	r3, #94	; 0x5e
 8004dde:	18fb      	adds	r3, r7, r3
 8004de0:	781b      	ldrb	r3, [r3, #0]
 8004de2:	4a30      	ldr	r2, [pc, #192]	; (8004ea4 <gc_execute_line+0x1420>)
 8004de4:	3302      	adds	r3, #2
 8004de6:	009b      	lsls	r3, r3, #2
 8004de8:	18d3      	adds	r3, r2, r3
 8004dea:	3308      	adds	r3, #8
 8004dec:	6818      	ldr	r0, [r3, #0]
 8004dee:	235d      	movs	r3, #93	; 0x5d
 8004df0:	18fb      	adds	r3, r7, r3
 8004df2:	781b      	ldrb	r3, [r3, #0]
 8004df4:	4a2b      	ldr	r2, [pc, #172]	; (8004ea4 <gc_execute_line+0x1420>)
 8004df6:	3302      	adds	r3, #2
 8004df8:	009b      	lsls	r3, r3, #2
 8004dfa:	18d3      	adds	r3, r2, r3
 8004dfc:	3308      	adds	r3, #8
 8004dfe:	681b      	ldr	r3, [r3, #0]
 8004e00:	1c19      	adds	r1, r3, #0
 8004e02:	f001 fd40 	bl	8006886 <hypot_f>
 8004e06:	1c02      	adds	r2, r0, #0
 8004e08:	4b26      	ldr	r3, [pc, #152]	; (8004ea4 <gc_execute_line+0x1420>)
 8004e0a:	629a      	str	r2, [r3, #40]	; 0x28
            float delta_r = fabsf(target_r-gc_block.values.r);
 8004e0c:	4b25      	ldr	r3, [pc, #148]	; (8004ea4 <gc_execute_line+0x1420>)
 8004e0e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004e10:	1c19      	adds	r1, r3, #0
 8004e12:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8004e14:	f7fb ff5e 	bl	8000cd4 <__aeabi_fsub>
 8004e18:	1c03      	adds	r3, r0, #0
 8004e1a:	005b      	lsls	r3, r3, #1
 8004e1c:	085b      	lsrs	r3, r3, #1
 8004e1e:	637b      	str	r3, [r7, #52]	; 0x34
            if (delta_r > 0.005f) {
 8004e20:	4925      	ldr	r1, [pc, #148]	; (8004eb8 <gc_execute_line+0x1434>)
 8004e22:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8004e24:	f7fb fa6a 	bl	80002fc <__aeabi_fcmpgt>
 8004e28:	1e03      	subs	r3, r0, #0
 8004e2a:	d100      	bne.n	8004e2e <gc_execute_line+0x13aa>
          break;
 8004e2c:	e055      	b.n	8004eda <gc_execute_line+0x1456>
              if (delta_r > 0.5f) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
 8004e2e:	21fc      	movs	r1, #252	; 0xfc
 8004e30:	0589      	lsls	r1, r1, #22
 8004e32:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8004e34:	f7fb fa62 	bl	80002fc <__aeabi_fcmpgt>
 8004e38:	1e03      	subs	r3, r0, #0
 8004e3a:	d002      	beq.n	8004e42 <gc_execute_line+0x13be>
 8004e3c:	2321      	movs	r3, #33	; 0x21
 8004e3e:	f000 fb66 	bl	800550e <gc_execute_line+0x1a8a>
              if (delta_r > (0.001f*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
 8004e42:	4b18      	ldr	r3, [pc, #96]	; (8004ea4 <gc_execute_line+0x1420>)
 8004e44:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004e46:	491d      	ldr	r1, [pc, #116]	; (8004ebc <gc_execute_line+0x1438>)
 8004e48:	1c18      	adds	r0, r3, #0
 8004e4a:	f7fb fe23 	bl	8000a94 <__aeabi_fmul>
 8004e4e:	1c03      	adds	r3, r0, #0
 8004e50:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8004e52:	1c18      	adds	r0, r3, #0
 8004e54:	f7fb fa3e 	bl	80002d4 <__aeabi_fcmplt>
 8004e58:	1e03      	subs	r3, r0, #0
 8004e5a:	d100      	bne.n	8004e5e <gc_execute_line+0x13da>
          break;
 8004e5c:	e03d      	b.n	8004eda <gc_execute_line+0x1456>
              if (delta_r > (0.001f*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
 8004e5e:	2321      	movs	r3, #33	; 0x21
 8004e60:	f000 fb55 	bl	800550e <gc_execute_line+0x1a8a>
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
            gc_parser_flags |= GC_PARSER_PROBE_IS_NO_ERROR; // No break intentional.
 8004e64:	2353      	movs	r3, #83	; 0x53
 8004e66:	18fb      	adds	r3, r7, r3
 8004e68:	2253      	movs	r2, #83	; 0x53
 8004e6a:	18ba      	adds	r2, r7, r2
 8004e6c:	7812      	ldrb	r2, [r2, #0]
 8004e6e:	2110      	movs	r1, #16
 8004e70:	430a      	orrs	r2, r1
 8004e72:	701a      	strb	r2, [r3, #0]
        case MOTION_MODE_PROBE_TOWARD: case MOTION_MODE_PROBE_AWAY:
            if ((gc_block.modal.motion == MOTION_MODE_PROBE_AWAY) ||
 8004e74:	4b0b      	ldr	r3, [pc, #44]	; (8004ea4 <gc_execute_line+0x1420>)
 8004e76:	785b      	ldrb	r3, [r3, #1]
 8004e78:	2b8e      	cmp	r3, #142	; 0x8e
 8004e7a:	d003      	beq.n	8004e84 <gc_execute_line+0x1400>
                (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
 8004e7c:	4b09      	ldr	r3, [pc, #36]	; (8004ea4 <gc_execute_line+0x1420>)
 8004e7e:	785b      	ldrb	r3, [r3, #1]
            if ((gc_block.modal.motion == MOTION_MODE_PROBE_AWAY) ||
 8004e80:	2b8f      	cmp	r3, #143	; 0x8f
 8004e82:	d107      	bne.n	8004e94 <gc_execute_line+0x1410>
                (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
 8004e84:	2353      	movs	r3, #83	; 0x53
 8004e86:	18fb      	adds	r3, r7, r3
 8004e88:	2253      	movs	r2, #83	; 0x53
 8004e8a:	18ba      	adds	r2, r7, r2
 8004e8c:	7812      	ldrb	r2, [r2, #0]
 8004e8e:	2108      	movs	r1, #8
 8004e90:	430a      	orrs	r2, r1
 8004e92:	701a      	strb	r2, [r3, #0]
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
 8004e94:	235a      	movs	r3, #90	; 0x5a
 8004e96:	18fb      	adds	r3, r7, r3
 8004e98:	781b      	ldrb	r3, [r3, #0]
 8004e9a:	2b00      	cmp	r3, #0
 8004e9c:	d110      	bne.n	8004ec0 <gc_execute_line+0x143c>
 8004e9e:	231a      	movs	r3, #26
 8004ea0:	e335      	b.n	800550e <gc_execute_line+0x1a8a>
 8004ea2:	46c0      	nop			; (mov r8, r8)
 8004ea4:	20000a14 	.word	0x20000a14
 8004ea8:	200009c4 	.word	0x200009c4
 8004eac:	20000a48 	.word	0x20000a48
 8004eb0:	200009e0 	.word	0x200009e0
 8004eb4:	41cb3333 	.word	0x41cb3333
 8004eb8:	3ba3d70a 	.word	0x3ba3d70a
 8004ebc:	3a83126f 	.word	0x3a83126f
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
 8004ec0:	49b4      	ldr	r1, [pc, #720]	; (8005194 <gc_execute_line+0x1710>)
 8004ec2:	4bb5      	ldr	r3, [pc, #724]	; (8005198 <gc_execute_line+0x1714>)
 8004ec4:	2210      	movs	r2, #16
 8004ec6:	0018      	movs	r0, r3
 8004ec8:	f007 fc04 	bl	800c6d4 <memcmp>
 8004ecc:	1e03      	subs	r3, r0, #0
 8004ece:	d103      	bne.n	8004ed8 <gc_execute_line+0x1454>
 8004ed0:	2321      	movs	r3, #33	; 0x21
 8004ed2:	e31c      	b.n	800550e <gc_execute_line+0x1a8a>
          break;
 8004ed4:	46c0      	nop			; (mov r8, r8)
 8004ed6:	e000      	b.n	8004eda <gc_execute_line+0x1456>
          break;
 8004ed8:	46c0      	nop			; (mov r8, r8)

  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
 8004eda:	2353      	movs	r3, #83	; 0x53
 8004edc:	18fb      	adds	r3, r7, r3
 8004ede:	781b      	ldrb	r3, [r3, #0]
 8004ee0:	2201      	movs	r2, #1
 8004ee2:	4013      	ands	r3, r2
 8004ee4:	d008      	beq.n	8004ef8 <gc_execute_line+0x1474>
      // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
      bit_false(value_words, (bit(WORD_N) | bit(WORD_F)));
 8004ee6:	2354      	movs	r3, #84	; 0x54
 8004ee8:	18fb      	adds	r3, r7, r3
 8004eea:	2254      	movs	r2, #84	; 0x54
 8004eec:	18ba      	adds	r2, r7, r2
 8004eee:	8812      	ldrh	r2, [r2, #0]
 8004ef0:	2121      	movs	r1, #33	; 0x21
 8004ef2:	438a      	bics	r2, r1
 8004ef4:	801a      	strh	r2, [r3, #0]
 8004ef6:	e007      	b.n	8004f08 <gc_execute_line+0x1484>
  } else {
      bit_false(value_words, (bit(WORD_N) | bit(WORD_F) | bit(WORD_S) | bit(WORD_T))); // Remove single-meaning value words.
 8004ef8:	2354      	movs	r3, #84	; 0x54
 8004efa:	18fb      	adds	r3, r7, r3
 8004efc:	2254      	movs	r2, #84	; 0x54
 8004efe:	18ba      	adds	r2, r7, r2
 8004f00:	8812      	ldrh	r2, [r2, #0]
 8004f02:	49a6      	ldr	r1, [pc, #664]	; (800519c <gc_execute_line+0x1718>)
 8004f04:	400a      	ands	r2, r1
 8004f06:	801a      	strh	r2, [r3, #0]
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z)|bit(WORD_A))); } // Remove axis words.
 8004f08:	235f      	movs	r3, #95	; 0x5f
 8004f0a:	18fb      	adds	r3, r7, r3
 8004f0c:	781b      	ldrb	r3, [r3, #0]
 8004f0e:	2b00      	cmp	r3, #0
 8004f10:	d007      	beq.n	8004f22 <gc_execute_line+0x149e>
 8004f12:	2354      	movs	r3, #84	; 0x54
 8004f14:	18fb      	adds	r3, r7, r3
 8004f16:	2254      	movs	r2, #84	; 0x54
 8004f18:	18ba      	adds	r2, r7, r2
 8004f1a:	8812      	ldrh	r2, [r2, #0]
 8004f1c:	49a0      	ldr	r1, [pc, #640]	; (80051a0 <gc_execute_line+0x171c>)
 8004f1e:	400a      	ands	r2, r1
 8004f20:	801a      	strh	r2, [r3, #0]
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
 8004f22:	2354      	movs	r3, #84	; 0x54
 8004f24:	18fb      	adds	r3, r7, r3
 8004f26:	881b      	ldrh	r3, [r3, #0]
 8004f28:	2b00      	cmp	r3, #0
 8004f2a:	d001      	beq.n	8004f30 <gc_execute_line+0x14ac>
 8004f2c:	2324      	movs	r3, #36	; 0x24
 8004f2e:	e2ee      	b.n	800550e <gc_execute_line+0x1a8a>
     need to update the state and execute the block according to the order-of-execution.
  */

  // Initialize planner data struct for motion blocks.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
 8004f30:	230c      	movs	r3, #12
 8004f32:	18fb      	adds	r3, r7, r3
 8004f34:	633b      	str	r3, [r7, #48]	; 0x30
  memset(pl_data,0,sizeof(plan_line_data_t)); // Zero pl_data struct
 8004f36:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004f38:	220c      	movs	r2, #12
 8004f3a:	2100      	movs	r1, #0
 8004f3c:	0018      	movs	r0, r3
 8004f3e:	f007 fbe1 	bl	800c704 <memset>

                                              // Intercept jog commands and complete error checking for valid jog commands and execute.
                                              // NOTE: G-code parser state is not updated, except the position to ensure sequential jog
                                              // targets are computed correctly. The final parser position after a jog is updated in
                                              // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
 8004f42:	2353      	movs	r3, #83	; 0x53
 8004f44:	18fb      	adds	r3, r7, r3
 8004f46:	781b      	ldrb	r3, [r3, #0]
 8004f48:	2201      	movs	r2, #1
 8004f4a:	4013      	ands	r3, r2
 8004f4c:	d03a      	beq.n	8004fc4 <gc_execute_line+0x1540>
      // Only distance and unit modal commands and G53 absolute override command are allowed.
      // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
      if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6 | bit(MODAL_GROUP_G0)))) { FAIL(STATUS_INVALID_JOG_COMMAND) };
 8004f4e:	2356      	movs	r3, #86	; 0x56
 8004f50:	18fb      	adds	r3, r7, r3
 8004f52:	881b      	ldrh	r3, [r3, #0]
 8004f54:	2249      	movs	r2, #73	; 0x49
 8004f56:	4393      	bics	r3, r2
 8004f58:	d001      	beq.n	8004f5e <gc_execute_line+0x14da>
 8004f5a:	2310      	movs	r3, #16
 8004f5c:	e2d7      	b.n	800550e <gc_execute_line+0x1a8a>
      if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
 8004f5e:	4b91      	ldr	r3, [pc, #580]	; (80051a4 <gc_execute_line+0x1720>)
 8004f60:	781b      	ldrb	r3, [r3, #0]
 8004f62:	2b35      	cmp	r3, #53	; 0x35
 8004f64:	d005      	beq.n	8004f72 <gc_execute_line+0x14ee>
 8004f66:	4b8f      	ldr	r3, [pc, #572]	; (80051a4 <gc_execute_line+0x1720>)
 8004f68:	781b      	ldrb	r3, [r3, #0]
 8004f6a:	2b00      	cmp	r3, #0
 8004f6c:	d001      	beq.n	8004f72 <gc_execute_line+0x14ee>
 8004f6e:	2310      	movs	r3, #16
 8004f70:	e2cd      	b.n	800550e <gc_execute_line+0x1a8a>

      // Initialize planner data to current spindle and coolant modal state.
      pl_data->spindle_speed = gc_state.spindle_speed;
 8004f72:	4b8d      	ldr	r3, [pc, #564]	; (80051a8 <gc_execute_line+0x1724>)
 8004f74:	68da      	ldr	r2, [r3, #12]
 8004f76:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004f78:	605a      	str	r2, [r3, #4]
      plan_data.condition = (gc_state.modal.spindle | gc_state.modal.coolant);
 8004f7a:	4b8b      	ldr	r3, [pc, #556]	; (80051a8 <gc_execute_line+0x1724>)
 8004f7c:	7a5a      	ldrb	r2, [r3, #9]
 8004f7e:	4b8a      	ldr	r3, [pc, #552]	; (80051a8 <gc_execute_line+0x1724>)
 8004f80:	7a1b      	ldrb	r3, [r3, #8]
 8004f82:	4313      	orrs	r3, r2
 8004f84:	b2da      	uxtb	r2, r3
 8004f86:	230c      	movs	r3, #12
 8004f88:	18fb      	adds	r3, r7, r3
 8004f8a:	721a      	strb	r2, [r3, #8]

      uint8_t status = jog_execute(&plan_data, &gc_block);
 8004f8c:	232f      	movs	r3, #47	; 0x2f
 8004f8e:	18fc      	adds	r4, r7, r3
 8004f90:	4a84      	ldr	r2, [pc, #528]	; (80051a4 <gc_execute_line+0x1720>)
 8004f92:	230c      	movs	r3, #12
 8004f94:	18fb      	adds	r3, r7, r3
 8004f96:	0011      	movs	r1, r2
 8004f98:	0018      	movs	r0, r3
 8004f9a:	f000 fabf 	bl	800551c <jog_execute>
 8004f9e:	0003      	movs	r3, r0
 8004fa0:	7023      	strb	r3, [r4, #0]
      if (status == STATUS_OK) { memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); }
 8004fa2:	232f      	movs	r3, #47	; 0x2f
 8004fa4:	18fb      	adds	r3, r7, r3
 8004fa6:	781b      	ldrb	r3, [r3, #0]
 8004fa8:	2b00      	cmp	r3, #0
 8004faa:	d107      	bne.n	8004fbc <gc_execute_line+0x1538>
 8004fac:	4b7e      	ldr	r3, [pc, #504]	; (80051a8 <gc_execute_line+0x1724>)
 8004fae:	4a7d      	ldr	r2, [pc, #500]	; (80051a4 <gc_execute_line+0x1720>)
 8004fb0:	331c      	adds	r3, #28
 8004fb2:	3234      	adds	r2, #52	; 0x34
 8004fb4:	ca13      	ldmia	r2!, {r0, r1, r4}
 8004fb6:	c313      	stmia	r3!, {r0, r1, r4}
 8004fb8:	6812      	ldr	r2, [r2, #0]
 8004fba:	601a      	str	r2, [r3, #0]
      return(status);
 8004fbc:	232f      	movs	r3, #47	; 0x2f
 8004fbe:	18fb      	adds	r3, r7, r3
 8004fc0:	781b      	ldrb	r3, [r3, #0]
 8004fc2:	e2a4      	b.n	800550e <gc_execute_line+0x1a8a>
  }

  // If in laser mode, setup laser power based on current and past parser conditions.
  if (bit_istrue(settings.flags, BITFLAG_LASER_MODE)) {
 8004fc4:	4b79      	ldr	r3, [pc, #484]	; (80051ac <gc_execute_line+0x1728>)
 8004fc6:	2258      	movs	r2, #88	; 0x58
 8004fc8:	5c9b      	ldrb	r3, [r3, r2]
 8004fca:	001a      	movs	r2, r3
 8004fcc:	2302      	movs	r3, #2
 8004fce:	4013      	ands	r3, r2
 8004fd0:	d054      	beq.n	800507c <gc_execute_line+0x15f8>
      if (!((gc_block.modal.motion == MOTION_MODE_LINEAR) || (gc_block.modal.motion == MOTION_MODE_CW_ARC)
 8004fd2:	4b74      	ldr	r3, [pc, #464]	; (80051a4 <gc_execute_line+0x1720>)
 8004fd4:	785b      	ldrb	r3, [r3, #1]
 8004fd6:	2b01      	cmp	r3, #1
 8004fd8:	d00f      	beq.n	8004ffa <gc_execute_line+0x1576>
 8004fda:	4b72      	ldr	r3, [pc, #456]	; (80051a4 <gc_execute_line+0x1720>)
 8004fdc:	785b      	ldrb	r3, [r3, #1]
 8004fde:	2b02      	cmp	r3, #2
 8004fe0:	d00b      	beq.n	8004ffa <gc_execute_line+0x1576>
          || (gc_block.modal.motion == MOTION_MODE_CCW_ARC))) {
 8004fe2:	4b70      	ldr	r3, [pc, #448]	; (80051a4 <gc_execute_line+0x1720>)
 8004fe4:	785b      	ldrb	r3, [r3, #1]
      if (!((gc_block.modal.motion == MOTION_MODE_LINEAR) || (gc_block.modal.motion == MOTION_MODE_CW_ARC)
 8004fe6:	2b03      	cmp	r3, #3
 8004fe8:	d007      	beq.n	8004ffa <gc_execute_line+0x1576>
          gc_parser_flags |= GC_PARSER_LASER_DISABLE;
 8004fea:	2353      	movs	r3, #83	; 0x53
 8004fec:	18fb      	adds	r3, r7, r3
 8004fee:	2253      	movs	r2, #83	; 0x53
 8004ff0:	18ba      	adds	r2, r7, r2
 8004ff2:	7812      	ldrb	r2, [r2, #0]
 8004ff4:	2140      	movs	r1, #64	; 0x40
 8004ff6:	430a      	orrs	r2, r1
 8004ff8:	701a      	strb	r2, [r3, #0]
      }

      // Any motion mode with axis words is allowed to be passed from a spindle speed update. 
      // NOTE: G1 and G0 without axis words sets axis_command to none. G28/30 are intentionally omitted.
      // TODO: Check sync conditions for M3 enabled motions that don't enter the planner. (zero length).
      if (axis_words && (axis_command == AXIS_COMMAND_MOTION_MODE)) {
 8004ffa:	235a      	movs	r3, #90	; 0x5a
 8004ffc:	18fb      	adds	r3, r7, r3
 8004ffe:	781b      	ldrb	r3, [r3, #0]
 8005000:	2b00      	cmp	r3, #0
 8005002:	d00e      	beq.n	8005022 <gc_execute_line+0x159e>
 8005004:	235f      	movs	r3, #95	; 0x5f
 8005006:	18fb      	adds	r3, r7, r3
 8005008:	781b      	ldrb	r3, [r3, #0]
 800500a:	2b02      	cmp	r3, #2
 800500c:	d109      	bne.n	8005022 <gc_execute_line+0x159e>
        gc_parser_flags |= GC_PARSER_LASER_ISMOTION;
 800500e:	2353      	movs	r3, #83	; 0x53
 8005010:	18fb      	adds	r3, r7, r3
 8005012:	2253      	movs	r2, #83	; 0x53
 8005014:	18ba      	adds	r2, r7, r2
 8005016:	7812      	ldrb	r2, [r2, #0]
 8005018:	2180      	movs	r1, #128	; 0x80
 800501a:	4249      	negs	r1, r1
 800501c:	430a      	orrs	r2, r1
 800501e:	701a      	strb	r2, [r3, #0]
 8005020:	e02c      	b.n	800507c <gc_execute_line+0x15f8>
      }
      else {
        // M3 constant power laser requires planner syncs to update the laser when changing between
        // a G1/2/3 motion mode state and vice versa when there is no motion in the line.
        if (gc_state.modal.spindle == SPINDLE_ENABLE_CW) {
 8005022:	4b61      	ldr	r3, [pc, #388]	; (80051a8 <gc_execute_line+0x1724>)
 8005024:	7a5b      	ldrb	r3, [r3, #9]
 8005026:	2b10      	cmp	r3, #16
 8005028:	d128      	bne.n	800507c <gc_execute_line+0x15f8>
          if ((gc_state.modal.motion == MOTION_MODE_LINEAR) || (gc_state.modal.motion == MOTION_MODE_CW_ARC)
 800502a:	4b5f      	ldr	r3, [pc, #380]	; (80051a8 <gc_execute_line+0x1724>)
 800502c:	781b      	ldrb	r3, [r3, #0]
 800502e:	2b01      	cmp	r3, #1
 8005030:	d007      	beq.n	8005042 <gc_execute_line+0x15be>
 8005032:	4b5d      	ldr	r3, [pc, #372]	; (80051a8 <gc_execute_line+0x1724>)
 8005034:	781b      	ldrb	r3, [r3, #0]
 8005036:	2b02      	cmp	r3, #2
 8005038:	d003      	beq.n	8005042 <gc_execute_line+0x15be>
            || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
 800503a:	4b5b      	ldr	r3, [pc, #364]	; (80051a8 <gc_execute_line+0x1724>)
 800503c:	781b      	ldrb	r3, [r3, #0]
 800503e:	2b03      	cmp	r3, #3
 8005040:	d10e      	bne.n	8005060 <gc_execute_line+0x15dc>
            if (bit_istrue(gc_parser_flags, GC_PARSER_LASER_DISABLE)) {
 8005042:	2353      	movs	r3, #83	; 0x53
 8005044:	18fb      	adds	r3, r7, r3
 8005046:	781b      	ldrb	r3, [r3, #0]
 8005048:	2240      	movs	r2, #64	; 0x40
 800504a:	4013      	ands	r3, r2
 800504c:	d016      	beq.n	800507c <gc_execute_line+0x15f8>
              gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC; // Change from G1/2/3 motion mode.
 800504e:	2353      	movs	r3, #83	; 0x53
 8005050:	18fb      	adds	r3, r7, r3
 8005052:	2253      	movs	r2, #83	; 0x53
 8005054:	18ba      	adds	r2, r7, r2
 8005056:	7812      	ldrb	r2, [r2, #0]
 8005058:	2120      	movs	r1, #32
 800505a:	430a      	orrs	r2, r1
 800505c:	701a      	strb	r2, [r3, #0]
            if (bit_istrue(gc_parser_flags, GC_PARSER_LASER_DISABLE)) {
 800505e:	e00d      	b.n	800507c <gc_execute_line+0x15f8>
            }
          }
          else {
            // When changing to a G1 motion mode without axis words from a non-G1/2/3 motion mode.
            if (bit_isfalse(gc_parser_flags, GC_PARSER_LASER_DISABLE)) {
 8005060:	2353      	movs	r3, #83	; 0x53
 8005062:	18fb      	adds	r3, r7, r3
 8005064:	781b      	ldrb	r3, [r3, #0]
 8005066:	2240      	movs	r2, #64	; 0x40
 8005068:	4013      	ands	r3, r2
 800506a:	d107      	bne.n	800507c <gc_execute_line+0x15f8>
              gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC;
 800506c:	2353      	movs	r3, #83	; 0x53
 800506e:	18fb      	adds	r3, r7, r3
 8005070:	2253      	movs	r2, #83	; 0x53
 8005072:	18ba      	adds	r2, r7, r2
 8005074:	7812      	ldrb	r2, [r2, #0]
 8005076:	2120      	movs	r1, #32
 8005078:	430a      	orrs	r2, r1
 800507a:	701a      	strb	r2, [r3, #0]
      }
  }

  // [0. Non-specific/common error-checks and miscellaneous setup]:
  // NOTE: If no line number is present, the value is zero.
  gc_state.line_number = gc_block.values.n;
 800507c:	4b49      	ldr	r3, [pc, #292]	; (80051a4 <gc_execute_line+0x1720>)
 800507e:	6a1a      	ldr	r2, [r3, #32]
 8005080:	4b49      	ldr	r3, [pc, #292]	; (80051a8 <gc_execute_line+0x1724>)
 8005082:	619a      	str	r2, [r3, #24]
  #endif

  // [1. Comments feedback ]:  NOT SUPPORTED

  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
 8005084:	4b47      	ldr	r3, [pc, #284]	; (80051a4 <gc_execute_line+0x1720>)
 8005086:	789a      	ldrb	r2, [r3, #2]
 8005088:	4b47      	ldr	r3, [pc, #284]	; (80051a8 <gc_execute_line+0x1724>)
 800508a:	705a      	strb	r2, [r3, #1]
  if (gc_state.modal.feed_rate) { pl_data->condition |= PL_COND_FLAG_INVERSE_TIME; } // Set condition flag for planner use.
 800508c:	4b46      	ldr	r3, [pc, #280]	; (80051a8 <gc_execute_line+0x1724>)
 800508e:	785b      	ldrb	r3, [r3, #1]
 8005090:	2b00      	cmp	r3, #0
 8005092:	d006      	beq.n	80050a2 <gc_execute_line+0x161e>
 8005094:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005096:	7a1b      	ldrb	r3, [r3, #8]
 8005098:	2208      	movs	r2, #8
 800509a:	4313      	orrs	r3, r2
 800509c:	b2da      	uxtb	r2, r3
 800509e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80050a0:	721a      	strb	r2, [r3, #8]

  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
 80050a2:	4b40      	ldr	r3, [pc, #256]	; (80051a4 <gc_execute_line+0x1720>)
 80050a4:	68da      	ldr	r2, [r3, #12]
 80050a6:	4b40      	ldr	r3, [pc, #256]	; (80051a8 <gc_execute_line+0x1724>)
 80050a8:	611a      	str	r2, [r3, #16]
  pl_data->feed_rate = gc_state.feed_rate; // Record data for planner use.
 80050aa:	4b3f      	ldr	r3, [pc, #252]	; (80051a8 <gc_execute_line+0x1724>)
 80050ac:	691a      	ldr	r2, [r3, #16]
 80050ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80050b0:	601a      	str	r2, [r3, #0]

  // [4. Set spindle speed ]:
  if ((gc_state.spindle_speed != gc_block.values.s) || bit_istrue(gc_parser_flags, GC_PARSER_LASER_FORCE_SYNC)) {
 80050b2:	4b3d      	ldr	r3, [pc, #244]	; (80051a8 <gc_execute_line+0x1724>)
 80050b4:	68da      	ldr	r2, [r3, #12]
 80050b6:	4b3b      	ldr	r3, [pc, #236]	; (80051a4 <gc_execute_line+0x1720>)
 80050b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80050ba:	1c19      	adds	r1, r3, #0
 80050bc:	1c10      	adds	r0, r2, #0
 80050be:	f7fb f903 	bl	80002c8 <__aeabi_fcmpeq>
 80050c2:	1e03      	subs	r3, r0, #0
 80050c4:	d005      	beq.n	80050d2 <gc_execute_line+0x164e>
 80050c6:	2353      	movs	r3, #83	; 0x53
 80050c8:	18fb      	adds	r3, r7, r3
 80050ca:	781b      	ldrb	r3, [r3, #0]
 80050cc:	2220      	movs	r2, #32
 80050ce:	4013      	ands	r3, r2
 80050d0:	d023      	beq.n	800511a <gc_execute_line+0x1696>
      if (gc_state.modal.spindle != SPINDLE_DISABLE) {
 80050d2:	4b35      	ldr	r3, [pc, #212]	; (80051a8 <gc_execute_line+0x1724>)
 80050d4:	7a5b      	ldrb	r3, [r3, #9]
 80050d6:	2b00      	cmp	r3, #0
 80050d8:	d01b      	beq.n	8005112 <gc_execute_line+0x168e>
#ifdef VARIABLE_SPINDLE
        if (bit_isfalse(gc_parser_flags, GC_PARSER_LASER_ISMOTION)) {
 80050da:	2353      	movs	r3, #83	; 0x53
 80050dc:	18fb      	adds	r3, r7, r3
 80050de:	781b      	ldrb	r3, [r3, #0]
 80050e0:	b25b      	sxtb	r3, r3
 80050e2:	2b00      	cmp	r3, #0
 80050e4:	db15      	blt.n	8005112 <gc_execute_line+0x168e>
          if (bit_istrue(gc_parser_flags, GC_PARSER_LASER_DISABLE)) {
 80050e6:	2353      	movs	r3, #83	; 0x53
 80050e8:	18fb      	adds	r3, r7, r3
 80050ea:	781b      	ldrb	r3, [r3, #0]
 80050ec:	2240      	movs	r2, #64	; 0x40
 80050ee:	4013      	ands	r3, r2
 80050f0:	d007      	beq.n	8005102 <gc_execute_line+0x167e>
            spindle_sync(gc_state.modal.spindle, 0.0);
 80050f2:	4b2d      	ldr	r3, [pc, #180]	; (80051a8 <gc_execute_line+0x1724>)
 80050f4:	7a5b      	ldrb	r3, [r3, #9]
 80050f6:	2200      	movs	r2, #0
 80050f8:	1c11      	adds	r1, r2, #0
 80050fa:	0018      	movs	r0, r3
 80050fc:	f005 f88e 	bl	800a21c <spindle_sync>
 8005100:	e007      	b.n	8005112 <gc_execute_line+0x168e>
          }
          else { spindle_sync(gc_state.modal.spindle, gc_block.values.s); }
 8005102:	4b29      	ldr	r3, [pc, #164]	; (80051a8 <gc_execute_line+0x1724>)
 8005104:	7a5a      	ldrb	r2, [r3, #9]
 8005106:	4b27      	ldr	r3, [pc, #156]	; (80051a4 <gc_execute_line+0x1720>)
 8005108:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800510a:	1c19      	adds	r1, r3, #0
 800510c:	0010      	movs	r0, r2
 800510e:	f005 f885 	bl	800a21c <spindle_sync>
        }
#else
          spindle_sync(gc_state.modal.spindle, 0.0);
#endif
      }
      gc_state.spindle_speed = gc_block.values.s; // Update spindle speed state.
 8005112:	4b24      	ldr	r3, [pc, #144]	; (80051a4 <gc_execute_line+0x1720>)
 8005114:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005116:	4b24      	ldr	r3, [pc, #144]	; (80051a8 <gc_execute_line+0x1724>)
 8005118:	60da      	str	r2, [r3, #12]
  }
  // NOTE: Pass zero spindle speed for all restricted laser motions.
  if (bit_isfalse(gc_parser_flags, GC_PARSER_LASER_DISABLE)) {
 800511a:	2353      	movs	r3, #83	; 0x53
 800511c:	18fb      	adds	r3, r7, r3
 800511e:	781b      	ldrb	r3, [r3, #0]
 8005120:	2240      	movs	r2, #64	; 0x40
 8005122:	4013      	ands	r3, r2
 8005124:	d103      	bne.n	800512e <gc_execute_line+0x16aa>
      pl_data->spindle_speed = gc_state.spindle_speed; // Record data for planner use. 
 8005126:	4b20      	ldr	r3, [pc, #128]	; (80051a8 <gc_execute_line+0x1724>)
 8005128:	68da      	ldr	r2, [r3, #12]
 800512a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800512c:	605a      	str	r2, [r3, #4]
  } // else { pl_data->spindle_speed = 0.0; } // Initialized as zero already.

  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
 800512e:	4b1d      	ldr	r3, [pc, #116]	; (80051a4 <gc_execute_line+0x1720>)
 8005130:	2230      	movs	r2, #48	; 0x30
 8005132:	5c9a      	ldrb	r2, [r3, r2]
 8005134:	4b1c      	ldr	r3, [pc, #112]	; (80051a8 <gc_execute_line+0x1724>)
 8005136:	751a      	strb	r2, [r3, #20]

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
 8005138:	4b1b      	ldr	r3, [pc, #108]	; (80051a8 <gc_execute_line+0x1724>)
 800513a:	7a5a      	ldrb	r2, [r3, #9]
 800513c:	4b19      	ldr	r3, [pc, #100]	; (80051a4 <gc_execute_line+0x1720>)
 800513e:	7a9b      	ldrb	r3, [r3, #10]
 8005140:	429a      	cmp	r2, r3
 8005142:	d00b      	beq.n	800515c <gc_execute_line+0x16d8>
    // Update spindle control and apply spindle speed when enabling it in this block.
    // NOTE: All spindle state changes are synced, even in laser mode. Also, pl_data,
    // rather than gc_state, is used to manage laser state for non-laser motions.
    spindle_sync(gc_block.modal.spindle, pl_data->spindle_speed);
 8005144:	4b17      	ldr	r3, [pc, #92]	; (80051a4 <gc_execute_line+0x1720>)
 8005146:	7a9a      	ldrb	r2, [r3, #10]
 8005148:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800514a:	685b      	ldr	r3, [r3, #4]
 800514c:	1c19      	adds	r1, r3, #0
 800514e:	0010      	movs	r0, r2
 8005150:	f005 f864 	bl	800a21c <spindle_sync>
    gc_state.modal.spindle = gc_block.modal.spindle;
 8005154:	4b13      	ldr	r3, [pc, #76]	; (80051a4 <gc_execute_line+0x1720>)
 8005156:	7a9a      	ldrb	r2, [r3, #10]
 8005158:	4b13      	ldr	r3, [pc, #76]	; (80051a8 <gc_execute_line+0x1724>)
 800515a:	725a      	strb	r2, [r3, #9]
  }
  pl_data->condition |= gc_state.modal.spindle; // Set condition flag for planner use.
 800515c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800515e:	7a1a      	ldrb	r2, [r3, #8]
 8005160:	4b11      	ldr	r3, [pc, #68]	; (80051a8 <gc_execute_line+0x1724>)
 8005162:	7a5b      	ldrb	r3, [r3, #9]
 8005164:	4313      	orrs	r3, r2
 8005166:	b2da      	uxtb	r2, r3
 8005168:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800516a:	721a      	strb	r2, [r3, #8]

  // [8. Coolant control ]:
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
 800516c:	4b0e      	ldr	r3, [pc, #56]	; (80051a8 <gc_execute_line+0x1724>)
 800516e:	7a1a      	ldrb	r2, [r3, #8]
 8005170:	4b0c      	ldr	r3, [pc, #48]	; (80051a4 <gc_execute_line+0x1720>)
 8005172:	7a5b      	ldrb	r3, [r3, #9]
 8005174:	429a      	cmp	r2, r3
 8005176:	d023      	beq.n	80051c0 <gc_execute_line+0x173c>
    // NOTE: Coolant M-codes are modal. Only one command per line is allowed. But, multiple states
    // can exist at the same time, while coolant disable clears all states.
    coolant_sync(gc_block.modal.coolant);
 8005178:	4b0a      	ldr	r3, [pc, #40]	; (80051a4 <gc_execute_line+0x1720>)
 800517a:	7a5b      	ldrb	r3, [r3, #9]
 800517c:	0018      	movs	r0, r3
 800517e:	f7fe fb8b 	bl	8003898 <coolant_sync>
    if (gc_block.modal.coolant == COOLANT_DISABLE) { gc_state.modal.coolant = COOLANT_DISABLE; }
 8005182:	4b08      	ldr	r3, [pc, #32]	; (80051a4 <gc_execute_line+0x1720>)
 8005184:	7a5b      	ldrb	r3, [r3, #9]
 8005186:	2b00      	cmp	r3, #0
 8005188:	d112      	bne.n	80051b0 <gc_execute_line+0x172c>
 800518a:	4b07      	ldr	r3, [pc, #28]	; (80051a8 <gc_execute_line+0x1724>)
 800518c:	2200      	movs	r2, #0
 800518e:	721a      	strb	r2, [r3, #8]
 8005190:	e016      	b.n	80051c0 <gc_execute_line+0x173c>
 8005192:	46c0      	nop			; (mov r8, r8)
 8005194:	20000a48 	.word	0x20000a48
 8005198:	200009e0 	.word	0x200009e0
 800519c:	fffffcde 	.word	0xfffffcde
 80051a0:	ffffc3ff 	.word	0xffffc3ff
 80051a4:	20000a14 	.word	0x20000a14
 80051a8:	200009c4 	.word	0x200009c4
 80051ac:	20000b44 	.word	0x20000b44
    else { gc_state.modal.coolant |= gc_block.modal.coolant; }
 80051b0:	4bc6      	ldr	r3, [pc, #792]	; (80054cc <gc_execute_line+0x1a48>)
 80051b2:	7a1a      	ldrb	r2, [r3, #8]
 80051b4:	4bc6      	ldr	r3, [pc, #792]	; (80054d0 <gc_execute_line+0x1a4c>)
 80051b6:	7a5b      	ldrb	r3, [r3, #9]
 80051b8:	4313      	orrs	r3, r2
 80051ba:	b2da      	uxtb	r2, r3
 80051bc:	4bc3      	ldr	r3, [pc, #780]	; (80054cc <gc_execute_line+0x1a48>)
 80051be:	721a      	strb	r2, [r3, #8]
  }
  pl_data->condition |= gc_state.modal.coolant; // Set condition flag for planner use.
 80051c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80051c2:	7a1a      	ldrb	r2, [r3, #8]
 80051c4:	4bc1      	ldr	r3, [pc, #772]	; (80054cc <gc_execute_line+0x1a48>)
 80051c6:	7a1b      	ldrb	r3, [r3, #8]
 80051c8:	4313      	orrs	r3, r2
 80051ca:	b2da      	uxtb	r2, r3
 80051cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80051ce:	721a      	strb	r2, [r3, #8]
			mc_override_ctrl_update(gc_state.modal.override);
		}
	#endif
	
  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
 80051d0:	4bbf      	ldr	r3, [pc, #764]	; (80054d0 <gc_execute_line+0x1a4c>)
 80051d2:	781b      	ldrb	r3, [r3, #0]
 80051d4:	2b04      	cmp	r3, #4
 80051d6:	d104      	bne.n	80051e2 <gc_execute_line+0x175e>
 80051d8:	4bbd      	ldr	r3, [pc, #756]	; (80054d0 <gc_execute_line+0x1a4c>)
 80051da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80051dc:	1c18      	adds	r0, r3, #0
 80051de:	f001 f8fb 	bl	80063d8 <mc_dwell>

  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;
 80051e2:	4bbb      	ldr	r3, [pc, #748]	; (80054d0 <gc_execute_line+0x1a4c>)
 80051e4:	795a      	ldrb	r2, [r3, #5]
 80051e6:	4bb9      	ldr	r3, [pc, #740]	; (80054cc <gc_execute_line+0x1a48>)
 80051e8:	711a      	strb	r2, [r3, #4]

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
 80051ea:	4bb9      	ldr	r3, [pc, #740]	; (80054d0 <gc_execute_line+0x1a4c>)
 80051ec:	78da      	ldrb	r2, [r3, #3]
 80051ee:	4bb7      	ldr	r3, [pc, #732]	; (80054cc <gc_execute_line+0x1a48>)
 80051f0:	709a      	strb	r2, [r3, #2]

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
 80051f2:	235f      	movs	r3, #95	; 0x5f
 80051f4:	18fb      	adds	r3, r7, r3
 80051f6:	781b      	ldrb	r3, [r3, #0]
 80051f8:	2b03      	cmp	r3, #3
 80051fa:	d11a      	bne.n	8005232 <gc_execute_line+0x17ae>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
 80051fc:	4bb4      	ldr	r3, [pc, #720]	; (80054d0 <gc_execute_line+0x1a4c>)
 80051fe:	799a      	ldrb	r2, [r3, #6]
 8005200:	4bb2      	ldr	r3, [pc, #712]	; (80054cc <gc_execute_line+0x1a48>)
 8005202:	715a      	strb	r2, [r3, #5]
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_CANCEL) { // G49
 8005204:	4bb1      	ldr	r3, [pc, #708]	; (80054cc <gc_execute_line+0x1a48>)
 8005206:	795b      	ldrb	r3, [r3, #5]
 8005208:	2b00      	cmp	r3, #0
 800520a:	d102      	bne.n	8005212 <gc_execute_line+0x178e>
      gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] = 0.0f;
 800520c:	4bb0      	ldr	r3, [pc, #704]	; (80054d0 <gc_execute_line+0x1a4c>)
 800520e:	2200      	movs	r2, #0
 8005210:	63da      	str	r2, [r3, #60]	; 0x3c
    } // else G43.1
    if ( gc_state.tool_length_offset != gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] ) {
 8005212:	4bae      	ldr	r3, [pc, #696]	; (80054cc <gc_execute_line+0x1a48>)
 8005214:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8005216:	4bae      	ldr	r3, [pc, #696]	; (80054d0 <gc_execute_line+0x1a4c>)
 8005218:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800521a:	1c19      	adds	r1, r3, #0
 800521c:	1c10      	adds	r0, r2, #0
 800521e:	f7fb f853 	bl	80002c8 <__aeabi_fcmpeq>
 8005222:	1e03      	subs	r3, r0, #0
 8005224:	d105      	bne.n	8005232 <gc_execute_line+0x17ae>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
 8005226:	4baa      	ldr	r3, [pc, #680]	; (80054d0 <gc_execute_line+0x1a4c>)
 8005228:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800522a:	4ba8      	ldr	r3, [pc, #672]	; (80054cc <gc_execute_line+0x1a48>)
 800522c:	64da      	str	r2, [r3, #76]	; 0x4c
      system_flag_wco_change();
 800522e:	f006 fe51 	bl	800bed4 <system_flag_wco_change>
    }
  }

  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
 8005232:	4ba6      	ldr	r3, [pc, #664]	; (80054cc <gc_execute_line+0x1a48>)
 8005234:	799a      	ldrb	r2, [r3, #6]
 8005236:	4ba6      	ldr	r3, [pc, #664]	; (80054d0 <gc_execute_line+0x1a4c>)
 8005238:	79db      	ldrb	r3, [r3, #7]
 800523a:	429a      	cmp	r2, r3
 800523c:	d00d      	beq.n	800525a <gc_execute_line+0x17d6>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
 800523e:	4ba4      	ldr	r3, [pc, #656]	; (80054d0 <gc_execute_line+0x1a4c>)
 8005240:	79da      	ldrb	r2, [r3, #7]
 8005242:	4ba2      	ldr	r3, [pc, #648]	; (80054cc <gc_execute_line+0x1a48>)
 8005244:	719a      	strb	r2, [r3, #6]
    memcpy(gc_state.coord_system,block_coord_system,N_AXIS*sizeof(float));
 8005246:	4ba1      	ldr	r3, [pc, #644]	; (80054cc <gc_execute_line+0x1a48>)
 8005248:	2218      	movs	r2, #24
 800524a:	18ba      	adds	r2, r7, r2
 800524c:	332c      	adds	r3, #44	; 0x2c
 800524e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8005250:	c313      	stmia	r3!, {r0, r1, r4}
 8005252:	6812      	ldr	r2, [r2, #0]
 8005254:	601a      	str	r2, [r3, #0]
    system_flag_wco_change();
 8005256:	f006 fe3d 	bl	800bed4 <system_flag_wco_change>

  // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
  // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.

  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
 800525a:	4b9d      	ldr	r3, [pc, #628]	; (80054d0 <gc_execute_line+0x1a4c>)
 800525c:	791a      	ldrb	r2, [r3, #4]
 800525e:	4b9b      	ldr	r3, [pc, #620]	; (80054cc <gc_execute_line+0x1a48>)
 8005260:	70da      	strb	r2, [r3, #3]

  // [18. Set retract mode ]: NOT SUPPORTED

  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
 8005262:	4b9b      	ldr	r3, [pc, #620]	; (80054d0 <gc_execute_line+0x1a4c>)
 8005264:	781b      	ldrb	r3, [r3, #0]
 8005266:	2b26      	cmp	r3, #38	; 0x26
 8005268:	d049      	beq.n	80052fe <gc_execute_line+0x187a>
 800526a:	dc06      	bgt.n	800527a <gc_execute_line+0x17f6>
 800526c:	2b1c      	cmp	r3, #28
 800526e:	d025      	beq.n	80052bc <gc_execute_line+0x1838>
 8005270:	2b1e      	cmp	r3, #30
 8005272:	d023      	beq.n	80052bc <gc_execute_line+0x1838>
 8005274:	2b0a      	cmp	r3, #10
 8005276:	d007      	beq.n	8005288 <gc_execute_line+0x1804>
 8005278:	e062      	b.n	8005340 <gc_execute_line+0x18bc>
 800527a:	2b5c      	cmp	r3, #92	; 0x5c
 800527c:	d04b      	beq.n	8005316 <gc_execute_line+0x1892>
 800527e:	2b66      	cmp	r3, #102	; 0x66
 8005280:	d054      	beq.n	800532c <gc_execute_line+0x18a8>
 8005282:	2b28      	cmp	r3, #40	; 0x28
 8005284:	d041      	beq.n	800530a <gc_execute_line+0x1886>
 8005286:	e05b      	b.n	8005340 <gc_execute_line+0x18bc>
    case NON_MODAL_SET_COORDINATE_DATA:
      settings_write_coord_data(coord_select,gc_block.values.ijk);
 8005288:	4a92      	ldr	r2, [pc, #584]	; (80054d4 <gc_execute_line+0x1a50>)
 800528a:	235b      	movs	r3, #91	; 0x5b
 800528c:	18fb      	adds	r3, r7, r3
 800528e:	781b      	ldrb	r3, [r3, #0]
 8005290:	0011      	movs	r1, r2
 8005292:	0018      	movs	r0, r3
 8005294:	f004 fa32 	bl	80096fc <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) {
 8005298:	4b8c      	ldr	r3, [pc, #560]	; (80054cc <gc_execute_line+0x1a48>)
 800529a:	799b      	ldrb	r3, [r3, #6]
 800529c:	225b      	movs	r2, #91	; 0x5b
 800529e:	18ba      	adds	r2, r7, r2
 80052a0:	7812      	ldrb	r2, [r2, #0]
 80052a2:	429a      	cmp	r2, r3
 80052a4:	d14b      	bne.n	800533e <gc_execute_line+0x18ba>
        memcpy(gc_state.coord_system,gc_block.values.ijk,N_AXIS*sizeof(float));
 80052a6:	4b89      	ldr	r3, [pc, #548]	; (80054cc <gc_execute_line+0x1a48>)
 80052a8:	4a89      	ldr	r2, [pc, #548]	; (80054d0 <gc_execute_line+0x1a4c>)
 80052aa:	332c      	adds	r3, #44	; 0x2c
 80052ac:	3210      	adds	r2, #16
 80052ae:	ca13      	ldmia	r2!, {r0, r1, r4}
 80052b0:	c313      	stmia	r3!, {r0, r1, r4}
 80052b2:	6812      	ldr	r2, [r2, #0]
 80052b4:	601a      	str	r2, [r3, #0]
        system_flag_wco_change();
 80052b6:	f006 fe0d 	bl	800bed4 <system_flag_wco_change>
      }
      break;
 80052ba:	e040      	b.n	800533e <gc_execute_line+0x18ba>
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1:
      // Move to intermediate position before going home. Obeys current coordinate system and offsets
      // and absolute and incremental modes.
      pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
 80052bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80052be:	7a1b      	ldrb	r3, [r3, #8]
 80052c0:	2201      	movs	r2, #1
 80052c2:	4313      	orrs	r3, r2
 80052c4:	b2da      	uxtb	r2, r3
 80052c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80052c8:	721a      	strb	r2, [r3, #8]
      if (axis_command) { mc_line(gc_block.values.xyz, pl_data); }
 80052ca:	235f      	movs	r3, #95	; 0x5f
 80052cc:	18fb      	adds	r3, r7, r3
 80052ce:	781b      	ldrb	r3, [r3, #0]
 80052d0:	2b00      	cmp	r3, #0
 80052d2:	d005      	beq.n	80052e0 <gc_execute_line+0x185c>
 80052d4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80052d6:	4b80      	ldr	r3, [pc, #512]	; (80054d8 <gc_execute_line+0x1a54>)
 80052d8:	0011      	movs	r1, r2
 80052da:	0018      	movs	r0, r3
 80052dc:	f000 fdc6 	bl	8005e6c <mc_line>
      mc_line(gc_block.values.ijk, pl_data);
 80052e0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80052e2:	4b7c      	ldr	r3, [pc, #496]	; (80054d4 <gc_execute_line+0x1a50>)
 80052e4:	0011      	movs	r1, r2
 80052e6:	0018      	movs	r0, r3
 80052e8:	f000 fdc0 	bl	8005e6c <mc_line>
      memcpy(gc_state.position, gc_block.values.ijk, N_AXIS*sizeof(float));
 80052ec:	4b77      	ldr	r3, [pc, #476]	; (80054cc <gc_execute_line+0x1a48>)
 80052ee:	4a78      	ldr	r2, [pc, #480]	; (80054d0 <gc_execute_line+0x1a4c>)
 80052f0:	331c      	adds	r3, #28
 80052f2:	3210      	adds	r2, #16
 80052f4:	ca13      	ldmia	r2!, {r0, r1, r4}
 80052f6:	c313      	stmia	r3!, {r0, r1, r4}
 80052f8:	6812      	ldr	r2, [r2, #0]
 80052fa:	601a      	str	r2, [r3, #0]
      break;
 80052fc:	e020      	b.n	8005340 <gc_execute_line+0x18bc>
    case NON_MODAL_SET_HOME_0:
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
 80052fe:	4b77      	ldr	r3, [pc, #476]	; (80054dc <gc_execute_line+0x1a58>)
 8005300:	0019      	movs	r1, r3
 8005302:	2006      	movs	r0, #6
 8005304:	f004 f9fa 	bl	80096fc <settings_write_coord_data>
      break;
 8005308:	e01a      	b.n	8005340 <gc_execute_line+0x18bc>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
 800530a:	4b74      	ldr	r3, [pc, #464]	; (80054dc <gc_execute_line+0x1a58>)
 800530c:	0019      	movs	r1, r3
 800530e:	2007      	movs	r0, #7
 8005310:	f004 f9f4 	bl	80096fc <settings_write_coord_data>
      break;
 8005314:	e014      	b.n	8005340 <gc_execute_line+0x18bc>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
 8005316:	4b6d      	ldr	r3, [pc, #436]	; (80054cc <gc_execute_line+0x1a48>)
 8005318:	4a6d      	ldr	r2, [pc, #436]	; (80054d0 <gc_execute_line+0x1a4c>)
 800531a:	333c      	adds	r3, #60	; 0x3c
 800531c:	3234      	adds	r2, #52	; 0x34
 800531e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8005320:	c313      	stmia	r3!, {r0, r1, r4}
 8005322:	6812      	ldr	r2, [r2, #0]
 8005324:	601a      	str	r2, [r3, #0]
      system_flag_wco_change();
 8005326:	f006 fdd5 	bl	800bed4 <system_flag_wco_change>
      break;
 800532a:	e009      	b.n	8005340 <gc_execute_line+0x18bc>
    case NON_MODAL_RESET_COORDINATE_OFFSET:
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
 800532c:	4b6c      	ldr	r3, [pc, #432]	; (80054e0 <gc_execute_line+0x1a5c>)
 800532e:	2210      	movs	r2, #16
 8005330:	2100      	movs	r1, #0
 8005332:	0018      	movs	r0, r3
 8005334:	f007 f9e6 	bl	800c704 <memset>
      system_flag_wco_change();
 8005338:	f006 fdcc 	bl	800bed4 <system_flag_wco_change>
      break;
 800533c:	e000      	b.n	8005340 <gc_execute_line+0x18bc>
      break;
 800533e:	46c0      	nop			; (mov r8, r8)


  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
 8005340:	4b63      	ldr	r3, [pc, #396]	; (80054d0 <gc_execute_line+0x1a4c>)
 8005342:	785a      	ldrb	r2, [r3, #1]
 8005344:	4b61      	ldr	r3, [pc, #388]	; (80054cc <gc_execute_line+0x1a48>)
 8005346:	701a      	strb	r2, [r3, #0]
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
 8005348:	4b60      	ldr	r3, [pc, #384]	; (80054cc <gc_execute_line+0x1a48>)
 800534a:	781b      	ldrb	r3, [r3, #0]
 800534c:	2b50      	cmp	r3, #80	; 0x50
 800534e:	d100      	bne.n	8005352 <gc_execute_line+0x18ce>
 8005350:	e077      	b.n	8005442 <gc_execute_line+0x19be>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
 8005352:	235f      	movs	r3, #95	; 0x5f
 8005354:	18fb      	adds	r3, r7, r3
 8005356:	781b      	ldrb	r3, [r3, #0]
 8005358:	2b02      	cmp	r3, #2
 800535a:	d000      	beq.n	800535e <gc_execute_line+0x18da>
 800535c:	e071      	b.n	8005442 <gc_execute_line+0x19be>
      uint8_t gc_update_pos = GC_UPDATE_POS_TARGET;
 800535e:	2347      	movs	r3, #71	; 0x47
 8005360:	18fb      	adds	r3, r7, r3
 8005362:	2200      	movs	r2, #0
 8005364:	701a      	strb	r2, [r3, #0]
      if (gc_state.modal.motion == MOTION_MODE_LINEAR) {
 8005366:	4b59      	ldr	r3, [pc, #356]	; (80054cc <gc_execute_line+0x1a48>)
 8005368:	781b      	ldrb	r3, [r3, #0]
 800536a:	2b01      	cmp	r3, #1
 800536c:	d106      	bne.n	800537c <gc_execute_line+0x18f8>
        mc_line(gc_block.values.xyz, pl_data);
 800536e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8005370:	4b59      	ldr	r3, [pc, #356]	; (80054d8 <gc_execute_line+0x1a54>)
 8005372:	0011      	movs	r1, r2
 8005374:	0018      	movs	r0, r3
 8005376:	f000 fd79 	bl	8005e6c <mc_line>
 800537a:	e04d      	b.n	8005418 <gc_execute_line+0x1994>
      } else if (gc_state.modal.motion == MOTION_MODE_SEEK) {
 800537c:	4b53      	ldr	r3, [pc, #332]	; (80054cc <gc_execute_line+0x1a48>)
 800537e:	781b      	ldrb	r3, [r3, #0]
 8005380:	2b00      	cmp	r3, #0
 8005382:	d10d      	bne.n	80053a0 <gc_execute_line+0x191c>
        pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
 8005384:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005386:	7a1b      	ldrb	r3, [r3, #8]
 8005388:	2201      	movs	r2, #1
 800538a:	4313      	orrs	r3, r2
 800538c:	b2da      	uxtb	r2, r3
 800538e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005390:	721a      	strb	r2, [r3, #8]
        mc_line(gc_block.values.xyz, pl_data);
 8005392:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8005394:	4b50      	ldr	r3, [pc, #320]	; (80054d8 <gc_execute_line+0x1a54>)
 8005396:	0011      	movs	r1, r2
 8005398:	0018      	movs	r0, r3
 800539a:	f000 fd67 	bl	8005e6c <mc_line>
 800539e:	e03b      	b.n	8005418 <gc_execute_line+0x1994>
      } else if ((gc_state.modal.motion == MOTION_MODE_CW_ARC) || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
 80053a0:	4b4a      	ldr	r3, [pc, #296]	; (80054cc <gc_execute_line+0x1a48>)
 80053a2:	781b      	ldrb	r3, [r3, #0]
 80053a4:	2b02      	cmp	r3, #2
 80053a6:	d003      	beq.n	80053b0 <gc_execute_line+0x192c>
 80053a8:	4b48      	ldr	r3, [pc, #288]	; (80054cc <gc_execute_line+0x1a48>)
 80053aa:	781b      	ldrb	r3, [r3, #0]
 80053ac:	2b03      	cmp	r3, #3
 80053ae:	d120      	bne.n	80053f2 <gc_execute_line+0x196e>
          mc_arc(gc_block.values.xyz, pl_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
 80053b0:	4b47      	ldr	r3, [pc, #284]	; (80054d0 <gc_execute_line+0x1a4c>)
 80053b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
              axis_0, axis_1, axis_linear, bit_istrue(gc_parser_flags, GC_PARSER_ARC_IS_CLOCKWISE));
 80053b4:	2253      	movs	r2, #83	; 0x53
 80053b6:	18ba      	adds	r2, r7, r2
 80053b8:	7812      	ldrb	r2, [r2, #0]
 80053ba:	2104      	movs	r1, #4
 80053bc:	400a      	ands	r2, r1
          mc_arc(gc_block.values.xyz, pl_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
 80053be:	1e51      	subs	r1, r2, #1
 80053c0:	418a      	sbcs	r2, r1
 80053c2:	b2d2      	uxtb	r2, r2
 80053c4:	4d43      	ldr	r5, [pc, #268]	; (80054d4 <gc_execute_line+0x1a50>)
 80053c6:	4c45      	ldr	r4, [pc, #276]	; (80054dc <gc_execute_line+0x1a58>)
 80053c8:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80053ca:	4843      	ldr	r0, [pc, #268]	; (80054d8 <gc_execute_line+0x1a54>)
 80053cc:	9204      	str	r2, [sp, #16]
 80053ce:	225c      	movs	r2, #92	; 0x5c
 80053d0:	18ba      	adds	r2, r7, r2
 80053d2:	7812      	ldrb	r2, [r2, #0]
 80053d4:	9203      	str	r2, [sp, #12]
 80053d6:	225d      	movs	r2, #93	; 0x5d
 80053d8:	18ba      	adds	r2, r7, r2
 80053da:	7812      	ldrb	r2, [r2, #0]
 80053dc:	9202      	str	r2, [sp, #8]
 80053de:	225e      	movs	r2, #94	; 0x5e
 80053e0:	18ba      	adds	r2, r7, r2
 80053e2:	7812      	ldrb	r2, [r2, #0]
 80053e4:	9201      	str	r2, [sp, #4]
 80053e6:	9300      	str	r3, [sp, #0]
 80053e8:	002b      	movs	r3, r5
 80053ea:	0022      	movs	r2, r4
 80053ec:	f000 fd8a 	bl	8005f04 <mc_arc>
 80053f0:	e012      	b.n	8005418 <gc_execute_line+0x1994>
      } else {
        // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
        // upon a successful probing cycle, the machine position and the returned value should be the same.
        #ifndef ALLOW_FEED_OVERRIDE_DURING_PROBE_CYCLES
          pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
 80053f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80053f4:	7a1b      	ldrb	r3, [r3, #8]
 80053f6:	2204      	movs	r2, #4
 80053f8:	4313      	orrs	r3, r2
 80053fa:	b2da      	uxtb	r2, r3
 80053fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80053fe:	721a      	strb	r2, [r3, #8]
        #endif
        gc_update_pos = mc_probe_cycle(gc_block.values.xyz, pl_data, gc_parser_flags);
 8005400:	2347      	movs	r3, #71	; 0x47
 8005402:	18fc      	adds	r4, r7, r3
 8005404:	2353      	movs	r3, #83	; 0x53
 8005406:	18fb      	adds	r3, r7, r3
 8005408:	781a      	ldrb	r2, [r3, #0]
 800540a:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800540c:	4b32      	ldr	r3, [pc, #200]	; (80054d8 <gc_execute_line+0x1a54>)
 800540e:	0018      	movs	r0, r3
 8005410:	f001 f81c 	bl	800644c <mc_probe_cycle>
 8005414:	0003      	movs	r3, r0
 8005416:	7023      	strb	r3, [r4, #0]
    }  
     
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      if (gc_update_pos == GC_UPDATE_POS_TARGET) {
 8005418:	2347      	movs	r3, #71	; 0x47
 800541a:	18fb      	adds	r3, r7, r3
 800541c:	781b      	ldrb	r3, [r3, #0]
 800541e:	2b00      	cmp	r3, #0
 8005420:	d108      	bne.n	8005434 <gc_execute_line+0x19b0>
        memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
 8005422:	4b2a      	ldr	r3, [pc, #168]	; (80054cc <gc_execute_line+0x1a48>)
 8005424:	4a2a      	ldr	r2, [pc, #168]	; (80054d0 <gc_execute_line+0x1a4c>)
 8005426:	331c      	adds	r3, #28
 8005428:	3234      	adds	r2, #52	; 0x34
 800542a:	ca13      	ldmia	r2!, {r0, r1, r4}
 800542c:	c313      	stmia	r3!, {r0, r1, r4}
 800542e:	6812      	ldr	r2, [r2, #0]
 8005430:	601a      	str	r2, [r3, #0]
 8005432:	e006      	b.n	8005442 <gc_execute_line+0x19be>
      } else if (gc_update_pos == GC_UPDATE_POS_SYSTEM) {
 8005434:	2347      	movs	r3, #71	; 0x47
 8005436:	18fb      	adds	r3, r7, r3
 8005438:	781b      	ldrb	r3, [r3, #0]
 800543a:	2b01      	cmp	r3, #1
 800543c:	d101      	bne.n	8005442 <gc_execute_line+0x19be>
        gc_sync_position(); // gc_state.position[] = sys_position
 800543e:	f7fe fb11 	bl	8003a64 <gc_sync_position>
  }

  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
 8005442:	4b23      	ldr	r3, [pc, #140]	; (80054d0 <gc_execute_line+0x1a4c>)
 8005444:	7a1a      	ldrb	r2, [r3, #8]
 8005446:	4b21      	ldr	r3, [pc, #132]	; (80054cc <gc_execute_line+0x1a48>)
 8005448:	71da      	strb	r2, [r3, #7]
  if (gc_state.modal.program_flow) {
 800544a:	4b20      	ldr	r3, [pc, #128]	; (80054cc <gc_execute_line+0x1a48>)
 800544c:	79db      	ldrb	r3, [r3, #7]
 800544e:	2b00      	cmp	r3, #0
 8005450:	d05c      	beq.n	800550c <gc_execute_line+0x1a88>
    protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
 8005452:	f002 fc71 	bl	8007d38 <protocol_buffer_synchronize>
    if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
 8005456:	4b1d      	ldr	r3, [pc, #116]	; (80054cc <gc_execute_line+0x1a48>)
 8005458:	79db      	ldrb	r3, [r3, #7]
 800545a:	2b03      	cmp	r3, #3
 800545c:	d109      	bne.n	8005472 <gc_execute_line+0x19ee>
      if (sys.state != STATE_CHECK_MODE) {
 800545e:	4b21      	ldr	r3, [pc, #132]	; (80054e4 <gc_execute_line+0x1a60>)
 8005460:	781b      	ldrb	r3, [r3, #0]
 8005462:	2b02      	cmp	r3, #2
 8005464:	d04f      	beq.n	8005506 <gc_execute_line+0x1a82>
        system_set_exec_state_flag(EXEC_FEED_HOLD); // Use feed hold for program pause.
 8005466:	2008      	movs	r0, #8
 8005468:	f006 fe1c 	bl	800c0a4 <system_set_exec_state_flag>
        protocol_execute_realtime(); // Execute suspend.
 800546c:	f002 fc88 	bl	8007d80 <protocol_execute_realtime>
 8005470:	e049      	b.n	8005506 <gc_execute_line+0x1a82>
    } else { // == PROGRAM_FLOW_COMPLETED
      // Upon program complete, only a subset of g-codes reset to certain defaults, according to
      // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
      // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
      // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
      gc_state.modal.motion = MOTION_MODE_LINEAR;
 8005472:	4b16      	ldr	r3, [pc, #88]	; (80054cc <gc_execute_line+0x1a48>)
 8005474:	2201      	movs	r2, #1
 8005476:	701a      	strb	r2, [r3, #0]
      gc_state.modal.plane_select = PLANE_SELECT_XY;
 8005478:	4b14      	ldr	r3, [pc, #80]	; (80054cc <gc_execute_line+0x1a48>)
 800547a:	2200      	movs	r2, #0
 800547c:	711a      	strb	r2, [r3, #4]
      gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
 800547e:	4b13      	ldr	r3, [pc, #76]	; (80054cc <gc_execute_line+0x1a48>)
 8005480:	2200      	movs	r2, #0
 8005482:	70da      	strb	r2, [r3, #3]
      gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
 8005484:	4b11      	ldr	r3, [pc, #68]	; (80054cc <gc_execute_line+0x1a48>)
 8005486:	2200      	movs	r2, #0
 8005488:	705a      	strb	r2, [r3, #1]
      // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
      gc_state.modal.coord_select = 0; // G54
 800548a:	4b10      	ldr	r3, [pc, #64]	; (80054cc <gc_execute_line+0x1a48>)
 800548c:	2200      	movs	r2, #0
 800548e:	719a      	strb	r2, [r3, #6]
      gc_state.modal.spindle = SPINDLE_DISABLE;
 8005490:	4b0e      	ldr	r3, [pc, #56]	; (80054cc <gc_execute_line+0x1a48>)
 8005492:	2200      	movs	r2, #0
 8005494:	725a      	strb	r2, [r3, #9]
      gc_state.modal.coolant = COOLANT_DISABLE;
 8005496:	4b0d      	ldr	r3, [pc, #52]	; (80054cc <gc_execute_line+0x1a48>)
 8005498:	2200      	movs	r2, #0
 800549a:	721a      	strb	r2, [r3, #8]
					gc_state.modal.override = OVERRIDE_PARKING_MOTION;
				#endif
			#endif
			
      #ifdef RESTORE_OVERRIDES_AFTER_PROGRAM_END
        sys.f_override = DEFAULT_FEED_OVERRIDE;
 800549c:	4b11      	ldr	r3, [pc, #68]	; (80054e4 <gc_execute_line+0x1a60>)
 800549e:	2264      	movs	r2, #100	; 0x64
 80054a0:	71da      	strb	r2, [r3, #7]
        sys.r_override = DEFAULT_RAPID_OVERRIDE;
 80054a2:	4b10      	ldr	r3, [pc, #64]	; (80054e4 <gc_execute_line+0x1a60>)
 80054a4:	2264      	movs	r2, #100	; 0x64
 80054a6:	721a      	strb	r2, [r3, #8]
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
 80054a8:	4b0e      	ldr	r3, [pc, #56]	; (80054e4 <gc_execute_line+0x1a60>)
 80054aa:	2264      	movs	r2, #100	; 0x64
 80054ac:	725a      	strb	r2, [r3, #9]
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
 80054ae:	4b0d      	ldr	r3, [pc, #52]	; (80054e4 <gc_execute_line+0x1a60>)
 80054b0:	781b      	ldrb	r3, [r3, #0]
 80054b2:	2b02      	cmp	r3, #2
 80054b4:	d024      	beq.n	8005500 <gc_execute_line+0x1a7c>
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
 80054b6:	4b05      	ldr	r3, [pc, #20]	; (80054cc <gc_execute_line+0x1a48>)
 80054b8:	799b      	ldrb	r3, [r3, #6]
 80054ba:	4a0b      	ldr	r2, [pc, #44]	; (80054e8 <gc_execute_line+0x1a64>)
 80054bc:	0011      	movs	r1, r2
 80054be:	0018      	movs	r0, r3
 80054c0:	f004 fa92 	bl	80099e8 <settings_read_coord_data>
 80054c4:	1e03      	subs	r3, r0, #0
 80054c6:	d111      	bne.n	80054ec <gc_execute_line+0x1a68>
 80054c8:	2307      	movs	r3, #7
 80054ca:	e020      	b.n	800550e <gc_execute_line+0x1a8a>
 80054cc:	200009c4 	.word	0x200009c4
 80054d0:	20000a14 	.word	0x20000a14
 80054d4:	20000a24 	.word	0x20000a24
 80054d8:	20000a48 	.word	0x20000a48
 80054dc:	200009e0 	.word	0x200009e0
 80054e0:	20000a00 	.word	0x20000a00
 80054e4:	20000bb4 	.word	0x20000bb4
 80054e8:	200009f0 	.word	0x200009f0
        system_flag_wco_change(); // Set to refresh immediately just in case something altered.
 80054ec:	f006 fcf2 	bl	800bed4 <system_flag_wco_change>
        spindle_set_state(SPINDLE_DISABLE,0.0f);
 80054f0:	2300      	movs	r3, #0
 80054f2:	1c19      	adds	r1, r3, #0
 80054f4:	2000      	movs	r0, #0
 80054f6:	f004 fe47 	bl	800a188 <spindle_set_state>
        coolant_set_state(COOLANT_DISABLE);
 80054fa:	2000      	movs	r0, #0
 80054fc:	f7fe f9b2 	bl	8003864 <coolant_set_state>
      }
      report_feedback_message(MESSAGE_PROGRAM_END);
 8005500:	2008      	movs	r0, #8
 8005502:	f003 f987 	bl	8008814 <report_feedback_message>
    }
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
 8005506:	4b04      	ldr	r3, [pc, #16]	; (8005518 <gc_execute_line+0x1a94>)
 8005508:	2200      	movs	r2, #0
 800550a:	71da      	strb	r2, [r3, #7]
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
 800550c:	2300      	movs	r3, #0
}
 800550e:	0018      	movs	r0, r3
 8005510:	46bd      	mov	sp, r7
 8005512:	b018      	add	sp, #96	; 0x60
 8005514:	bdb0      	pop	{r4, r5, r7, pc}
 8005516:	46c0      	nop			; (mov r8, r8)
 8005518:	200009c4 	.word	0x200009c4

0800551c <jog_execute>:
#include "grbl.h"


// Sets up valid jog motion received from g-code parser, checks for soft-limits, and executes the jog.
uint8_t jog_execute(plan_line_data_t *pl_data, parser_block_t *gc_block)
{
 800551c:	b580      	push	{r7, lr}
 800551e:	b082      	sub	sp, #8
 8005520:	af00      	add	r7, sp, #0
 8005522:	6078      	str	r0, [r7, #4]
 8005524:	6039      	str	r1, [r7, #0]
  // Initialize planner data struct for jogging motions.
  // NOTE: Spindle and coolant are allowed to fully function with overrides during a jog.
  pl_data->feed_rate = gc_block->values.f;
 8005526:	683b      	ldr	r3, [r7, #0]
 8005528:	68da      	ldr	r2, [r3, #12]
 800552a:	687b      	ldr	r3, [r7, #4]
 800552c:	601a      	str	r2, [r3, #0]
  pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
 800552e:	687b      	ldr	r3, [r7, #4]
 8005530:	7a1b      	ldrb	r3, [r3, #8]
 8005532:	2204      	movs	r2, #4
 8005534:	4313      	orrs	r3, r2
 8005536:	b2da      	uxtb	r2, r3
 8005538:	687b      	ldr	r3, [r7, #4]
 800553a:	721a      	strb	r2, [r3, #8]
#ifdef USE_LINE_NUMBERS
  pl_data->line_number = gc_block->values.n;
#endif

  if (bit_istrue(settings.flags, BITFLAG_SOFT_LIMIT_ENABLE)) {
 800553c:	4b15      	ldr	r3, [pc, #84]	; (8005594 <jog_execute+0x78>)
 800553e:	2258      	movs	r2, #88	; 0x58
 8005540:	5c9b      	ldrb	r3, [r3, r2]
 8005542:	001a      	movs	r2, r3
 8005544:	2320      	movs	r3, #32
 8005546:	4013      	ands	r3, r2
 8005548:	d008      	beq.n	800555c <jog_execute+0x40>
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
 800554a:	683b      	ldr	r3, [r7, #0]
 800554c:	3334      	adds	r3, #52	; 0x34
 800554e:	0018      	movs	r0, r3
 8005550:	f006 fd6a 	bl	800c028 <system_check_travel_limits>
 8005554:	1e03      	subs	r3, r0, #0
 8005556:	d001      	beq.n	800555c <jog_execute+0x40>
 8005558:	230f      	movs	r3, #15
 800555a:	e016      	b.n	800558a <jog_execute+0x6e>
  }

  // Valid jog command. Plan, set state, and execute.
  mc_line(gc_block->values.xyz, pl_data);
 800555c:	683b      	ldr	r3, [r7, #0]
 800555e:	3334      	adds	r3, #52	; 0x34
 8005560:	687a      	ldr	r2, [r7, #4]
 8005562:	0011      	movs	r1, r2
 8005564:	0018      	movs	r0, r3
 8005566:	f000 fc81 	bl	8005e6c <mc_line>
  if (sys.state == STATE_IDLE) {
 800556a:	4b0b      	ldr	r3, [pc, #44]	; (8005598 <jog_execute+0x7c>)
 800556c:	781b      	ldrb	r3, [r3, #0]
 800556e:	2b00      	cmp	r3, #0
 8005570:	d10a      	bne.n	8005588 <jog_execute+0x6c>
    if (plan_get_current_block() != NULL) { // Check if there is a block to execute.
 8005572:	f001 fc47 	bl	8006e04 <plan_get_current_block>
 8005576:	1e03      	subs	r3, r0, #0
 8005578:	d006      	beq.n	8005588 <jog_execute+0x6c>
      sys.state = STATE_JOG;
 800557a:	4b07      	ldr	r3, [pc, #28]	; (8005598 <jog_execute+0x7c>)
 800557c:	2220      	movs	r2, #32
 800557e:	701a      	strb	r2, [r3, #0]
      st_prep_buffer();
 8005580:	f005 fb20 	bl	800abc4 <st_prep_buffer>
      st_wake_up();  // NOTE: Manual start. No state machine required.
 8005584:	f004 fe94 	bl	800a2b0 <st_wake_up>
    }
  }

  return(STATUS_OK);
 8005588:	2300      	movs	r3, #0
}
 800558a:	0018      	movs	r0, r3
 800558c:	46bd      	mov	sp, r7
 800558e:	b002      	add	sp, #8
 8005590:	bd80      	pop	{r7, pc}
 8005592:	46c0      	nop			; (mov r8, r8)
 8005594:	20000b44 	.word	0x20000b44
 8005598:	20000bb4 	.word	0x20000bb4

0800559c <NVIC_DisableIRQ>:
    The function disables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
 800559c:	b580      	push	{r7, lr}
 800559e:	b082      	sub	sp, #8
 80055a0:	af00      	add	r7, sp, #0
 80055a2:	0002      	movs	r2, r0
 80055a4:	1dfb      	adds	r3, r7, #7
 80055a6:	701a      	strb	r2, [r3, #0]
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 80055a8:	4a07      	ldr	r2, [pc, #28]	; (80055c8 <NVIC_DisableIRQ+0x2c>)
 80055aa:	1dfb      	adds	r3, r7, #7
 80055ac:	781b      	ldrb	r3, [r3, #0]
 80055ae:	0019      	movs	r1, r3
 80055b0:	231f      	movs	r3, #31
 80055b2:	400b      	ands	r3, r1
 80055b4:	2101      	movs	r1, #1
 80055b6:	4099      	lsls	r1, r3
 80055b8:	000b      	movs	r3, r1
 80055ba:	0019      	movs	r1, r3
 80055bc:	2380      	movs	r3, #128	; 0x80
 80055be:	50d1      	str	r1, [r2, r3]
}
 80055c0:	46c0      	nop			; (mov r8, r8)
 80055c2:	46bd      	mov	sp, r7
 80055c4:	b002      	add	sp, #8
 80055c6:	bd80      	pop	{r7, pc}
 80055c8:	e000e100 	.word	0xe000e100

080055cc <NVIC_ClearPendingIRQ>:
    The function clears the pending bit of an external interrupt.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 80055cc:	b580      	push	{r7, lr}
 80055ce:	b082      	sub	sp, #8
 80055d0:	af00      	add	r7, sp, #0
 80055d2:	0002      	movs	r2, r0
 80055d4:	1dfb      	adds	r3, r7, #7
 80055d6:	701a      	strb	r2, [r3, #0]
  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
 80055d8:	4a08      	ldr	r2, [pc, #32]	; (80055fc <NVIC_ClearPendingIRQ+0x30>)
 80055da:	1dfb      	adds	r3, r7, #7
 80055dc:	781b      	ldrb	r3, [r3, #0]
 80055de:	0019      	movs	r1, r3
 80055e0:	231f      	movs	r3, #31
 80055e2:	400b      	ands	r3, r1
 80055e4:	2101      	movs	r1, #1
 80055e6:	4099      	lsls	r1, r3
 80055e8:	000b      	movs	r3, r1
 80055ea:	0019      	movs	r1, r3
 80055ec:	23c0      	movs	r3, #192	; 0xc0
 80055ee:	005b      	lsls	r3, r3, #1
 80055f0:	50d1      	str	r1, [r2, r3]
}
 80055f2:	46c0      	nop			; (mov r8, r8)
 80055f4:	46bd      	mov	sp, r7
 80055f6:	b002      	add	sp, #8
 80055f8:	bd80      	pop	{r7, pc}
 80055fa:	46c0      	nop			; (mov r8, r8)
 80055fc:	e000e100 	.word	0xe000e100

08005600 <limits_init>:
#ifndef HOMING_AXIS_LOCATE_SCALAR
  #define HOMING_AXIS_LOCATE_SCALAR  5.0f // Must be > 1 to ensure limit switch is cleared.
#endif

void limits_init()
{
 8005600:	b580      	push	{r7, lr}
 8005602:	b086      	sub	sp, #24
 8005604:	af00      	add	r7, sp, #0
	}
#endif
#ifdef STM32F0DISCOVERY
	GPIO_InitTypeDef GPIO_InitStructure;
	//RCC_APB2PeriphClockCmd(RCC_LIMIT_PORT | RCC_APB2Periph_AFIO, ENABLE);
	RCC_AHBPeriphClockCmd(RCC_LIMIT_PORT, ENABLE);
 8005606:	2380      	movs	r3, #128	; 0x80
 8005608:	02db      	lsls	r3, r3, #11
 800560a:	2101      	movs	r1, #1
 800560c:	0018      	movs	r0, r3
 800560e:	f7fd fd4b 	bl	80030a8 <RCC_AHBPeriphClockCmd>
	/* Enable SYSCFG's APB interface clock */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 8005612:	2101      	movs	r1, #1
 8005614:	2001      	movs	r0, #1
 8005616:	f7fd fd67 	bl	80030e8 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800561a:	2310      	movs	r3, #16
 800561c:	18fb      	adds	r3, r7, r3
 800561e:	2203      	movs	r2, #3
 8005620:	715a      	strb	r2, [r3, #5]
	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; // From STM32F103C8 Input Pull-Up
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8005622:	2310      	movs	r3, #16
 8005624:	18fb      	adds	r3, r7, r3
 8005626:	2200      	movs	r2, #0
 8005628:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 800562a:	2310      	movs	r3, #16
 800562c:	18fb      	adds	r3, r7, r3
 800562e:	2201      	movs	r2, #1
 8005630:	71da      	strb	r2, [r3, #7]
	GPIO_InitStructure.GPIO_Pin = LIMIT_MASK;
 8005632:	2310      	movs	r3, #16
 8005634:	18fb      	adds	r3, r7, r3
 8005636:	22f0      	movs	r2, #240	; 0xf0
 8005638:	0192      	lsls	r2, r2, #6
 800563a:	601a      	str	r2, [r3, #0]
	GPIO_Init(LIMIT_PORT, &GPIO_InitStructure);
 800563c:	2310      	movs	r3, #16
 800563e:	18fb      	adds	r3, r7, r3
 8005640:	4a22      	ldr	r2, [pc, #136]	; (80056cc <limits_init+0xcc>)
 8005642:	0019      	movs	r1, r3
 8005644:	0010      	movs	r0, r2
 8005646:	f7fd f9d5 	bl	80029f4 <GPIO_Init>

	if (bit_istrue(settings.flags, BITFLAG_HARD_LIMIT_ENABLE))
 800564a:	4b21      	ldr	r3, [pc, #132]	; (80056d0 <limits_init+0xd0>)
 800564c:	2258      	movs	r2, #88	; 0x58
 800564e:	5c9b      	ldrb	r3, [r3, r2]
 8005650:	001a      	movs	r2, r3
 8005652:	2308      	movs	r3, #8
 8005654:	4013      	ands	r3, r2
 8005656:	d033      	beq.n	80056c0 <limits_init+0xc0>
	{
		SYSCFG_EXTILineConfig(GPIO_LIMIT_PORT, X_LIMIT_BIT);
 8005658:	210a      	movs	r1, #10
 800565a:	2001      	movs	r0, #1
 800565c:	f7fd fd64 	bl	8003128 <SYSCFG_EXTILineConfig>
		SYSCFG_EXTILineConfig(GPIO_LIMIT_PORT, Y_LIMIT_BIT);
 8005660:	210b      	movs	r1, #11
 8005662:	2001      	movs	r0, #1
 8005664:	f7fd fd60 	bl	8003128 <SYSCFG_EXTILineConfig>
		SYSCFG_EXTILineConfig(GPIO_LIMIT_PORT, Z_LIMIT_BIT);
 8005668:	210c      	movs	r1, #12
 800566a:	2001      	movs	r0, #1
 800566c:	f7fd fd5c 	bl	8003128 <SYSCFG_EXTILineConfig>
		SYSCFG_EXTILineConfig(GPIO_LIMIT_PORT, A_LIMIT_BIT);
 8005670:	210d      	movs	r1, #13
 8005672:	2001      	movs	r0, #1
 8005674:	f7fd fd58 	bl	8003128 <SYSCFG_EXTILineConfig>

		EXTI_InitTypeDef EXTI_InitStructure;
		EXTI_InitStructure.EXTI_Line = LIMIT_MASK;    //
 8005678:	2308      	movs	r3, #8
 800567a:	18fb      	adds	r3, r7, r3
 800567c:	22f0      	movs	r2, #240	; 0xf0
 800567e:	0192      	lsls	r2, r2, #6
 8005680:	601a      	str	r2, [r3, #0]
		EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; //Interrupt mode, optional values for the interrupt EXTI_Mode_Interrupt and event EXTI_Mode_Event.
 8005682:	2308      	movs	r3, #8
 8005684:	18fb      	adds	r3, r7, r3
 8005686:	2200      	movs	r2, #0
 8005688:	711a      	strb	r2, [r3, #4]
		EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; //Trigger mode, can be a falling edge trigger EXTI_Trigger_Falling, the rising edge triggered EXTI_Trigger_Rising, or any level (rising edge and falling edge trigger EXTI_Trigger_Rising_Falling)
 800568a:	2308      	movs	r3, #8
 800568c:	18fb      	adds	r3, r7, r3
 800568e:	220c      	movs	r2, #12
 8005690:	715a      	strb	r2, [r3, #5]
		EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 8005692:	2308      	movs	r3, #8
 8005694:	18fb      	adds	r3, r7, r3
 8005696:	2201      	movs	r2, #1
 8005698:	719a      	strb	r2, [r3, #6]
		EXTI_Init(&EXTI_InitStructure);
 800569a:	2308      	movs	r3, #8
 800569c:	18fb      	adds	r3, r7, r3
 800569e:	0018      	movs	r0, r3
 80056a0:	f7fd f90a 	bl	80028b8 <EXTI_Init>

		NVIC_InitTypeDef NVIC_InitStructure;
		NVIC_InitStructure.NVIC_IRQChannel = EXTI4_15_IRQn; //Enable keypad external interrupt channel
 80056a4:	1d3b      	adds	r3, r7, #4
 80056a6:	2207      	movs	r2, #7
 80056a8:	701a      	strb	r2, [r3, #0]
		//NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //Priority 2,
		//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //Sub priority 2
		NVIC_InitStructure.NVIC_IRQChannelPriority = 0x02; // Priority 2
 80056aa:	1d3b      	adds	r3, r7, #4
 80056ac:	2202      	movs	r2, #2
 80056ae:	705a      	strb	r2, [r3, #1]
		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //Enable external interrupt channel
 80056b0:	1d3b      	adds	r3, r7, #4
 80056b2:	2201      	movs	r2, #1
 80056b4:	709a      	strb	r2, [r3, #2]
		NVIC_Init(&NVIC_InitStructure);
 80056b6:	1d3b      	adds	r3, r7, #4
 80056b8:	0018      	movs	r0, r3
 80056ba:	f7fd fae1 	bl	8002c80 <NVIC_Init>
	else
	{
		limits_disable();
	}
#endif
}
 80056be:	e001      	b.n	80056c4 <limits_init+0xc4>
		limits_disable();
 80056c0:	f000 f808 	bl	80056d4 <limits_disable>
}
 80056c4:	46c0      	nop			; (mov r8, r8)
 80056c6:	46bd      	mov	sp, r7
 80056c8:	b006      	add	sp, #24
 80056ca:	bd80      	pop	{r7, pc}
 80056cc:	48000400 	.word	0x48000400
 80056d0:	20000b44 	.word	0x20000b44

080056d4 <limits_disable>:


// Disables hard limits.
void limits_disable()
{
 80056d4:	b580      	push	{r7, lr}
 80056d6:	af00      	add	r7, sp, #0
#endif
#ifdef STM32F103C8
  NVIC_DisableIRQ(EXTI15_10_IRQn);
#endif
#ifdef STM32F0DISCOVERY
  NVIC_DisableIRQ(EXTI4_15_IRQn);
 80056d8:	2007      	movs	r0, #7
 80056da:	f7ff ff5f 	bl	800559c <NVIC_DisableIRQ>
#endif
}
 80056de:	46c0      	nop			; (mov r8, r8)
 80056e0:	46bd      	mov	sp, r7
 80056e2:	bd80      	pop	{r7, pc}

080056e4 <limits_get_state>:

// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
 80056e4:	b590      	push	{r4, r7, lr}
 80056e6:	b083      	sub	sp, #12
 80056e8:	af00      	add	r7, sp, #0
  uint8_t limit_state = 0;
 80056ea:	1dfb      	adds	r3, r7, #7
 80056ec:	2200      	movs	r2, #0
 80056ee:	701a      	strb	r2, [r3, #0]
#endif
#if defined(STM32F103C8)
  uint16_t pin = GPIO_ReadInputData(LIMIT_PIN);
#endif
#if defined(STM32F0DISCOVERY)
  uint16_t pin = GPIO_ReadInputData(LIMIT_PIN);
 80056f0:	1d3c      	adds	r4, r7, #4
 80056f2:	4b21      	ldr	r3, [pc, #132]	; (8005778 <limits_get_state+0x94>)
 80056f4:	0018      	movs	r0, r3
 80056f6:	f7fd fa10 	bl	8002b1a <GPIO_ReadInputData>
 80056fa:	0003      	movs	r3, r0
 80056fc:	8023      	strh	r3, [r4, #0]
#endif
  #ifdef INVERT_LIMIT_PIN_MASK
    pin ^= INVERT_LIMIT_PIN_MASK;
  #endif
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
 80056fe:	4b1f      	ldr	r3, [pc, #124]	; (800577c <limits_get_state+0x98>)
 8005700:	2258      	movs	r2, #88	; 0x58
 8005702:	5c9b      	ldrb	r3, [r3, r2]
 8005704:	001a      	movs	r2, r3
 8005706:	2340      	movs	r3, #64	; 0x40
 8005708:	4013      	ands	r3, r2
 800570a:	d106      	bne.n	800571a <limits_get_state+0x36>
 800570c:	1d3b      	adds	r3, r7, #4
 800570e:	1d3a      	adds	r2, r7, #4
 8005710:	8812      	ldrh	r2, [r2, #0]
 8005712:	21f0      	movs	r1, #240	; 0xf0
 8005714:	0189      	lsls	r1, r1, #6
 8005716:	404a      	eors	r2, r1
 8005718:	801a      	strh	r2, [r3, #0]
  if (pin) {
 800571a:	1d3b      	adds	r3, r7, #4
 800571c:	881b      	ldrh	r3, [r3, #0]
 800571e:	2b00      	cmp	r3, #0
 8005720:	d024      	beq.n	800576c <limits_get_state+0x88>
    uint8_t idx;
    for (idx=0; idx<N_AXIS; idx++) {
 8005722:	1cfb      	adds	r3, r7, #3
 8005724:	2200      	movs	r2, #0
 8005726:	701a      	strb	r2, [r3, #0]
 8005728:	e01c      	b.n	8005764 <limits_get_state+0x80>
      if (pin & limit_pin_mask[idx]) { limit_state |= (1 << idx); }
 800572a:	1cfb      	adds	r3, r7, #3
 800572c:	781a      	ldrb	r2, [r3, #0]
 800572e:	4b14      	ldr	r3, [pc, #80]	; (8005780 <limits_get_state+0x9c>)
 8005730:	0052      	lsls	r2, r2, #1
 8005732:	5ad3      	ldrh	r3, [r2, r3]
 8005734:	1d3a      	adds	r2, r7, #4
 8005736:	8812      	ldrh	r2, [r2, #0]
 8005738:	4013      	ands	r3, r2
 800573a:	b29b      	uxth	r3, r3
 800573c:	2b00      	cmp	r3, #0
 800573e:	d00c      	beq.n	800575a <limits_get_state+0x76>
 8005740:	1cfb      	adds	r3, r7, #3
 8005742:	781b      	ldrb	r3, [r3, #0]
 8005744:	2201      	movs	r2, #1
 8005746:	409a      	lsls	r2, r3
 8005748:	0013      	movs	r3, r2
 800574a:	b25a      	sxtb	r2, r3
 800574c:	1dfb      	adds	r3, r7, #7
 800574e:	781b      	ldrb	r3, [r3, #0]
 8005750:	b25b      	sxtb	r3, r3
 8005752:	4313      	orrs	r3, r2
 8005754:	b25a      	sxtb	r2, r3
 8005756:	1dfb      	adds	r3, r7, #7
 8005758:	701a      	strb	r2, [r3, #0]
    for (idx=0; idx<N_AXIS; idx++) {
 800575a:	1cfb      	adds	r3, r7, #3
 800575c:	781a      	ldrb	r2, [r3, #0]
 800575e:	1cfb      	adds	r3, r7, #3
 8005760:	3201      	adds	r2, #1
 8005762:	701a      	strb	r2, [r3, #0]
 8005764:	1cfb      	adds	r3, r7, #3
 8005766:	781b      	ldrb	r3, [r3, #0]
 8005768:	2b03      	cmp	r3, #3
 800576a:	d9de      	bls.n	800572a <limits_get_state+0x46>
    }
  }
#endif
  return(limit_state);
 800576c:	1dfb      	adds	r3, r7, #7
 800576e:	781b      	ldrb	r3, [r3, #0]
}
 8005770:	0018      	movs	r0, r3
 8005772:	46bd      	mov	sp, r7
 8005774:	b003      	add	sp, #12
 8005776:	bd90      	pop	{r4, r7, pc}
 8005778:	48000400 	.word	0x48000400
 800577c:	20000b44 	.word	0x20000b44
 8005780:	0800e0bc 	.word	0x0800e0bc

08005784 <EXTI4_15_IRQHandler>:
#if defined(AVRTARGET) 
ISR(LIMIT_INT_vect) // DEFAULT: Limit pin change interrupt process.
#else
void EXTI4_15_IRQHandler(void)
#endif
{
 8005784:	b580      	push	{r7, lr}
 8005786:	af00      	add	r7, sp, #0
		EXTI_ClearITPendingBit(1 << Z_LIMIT_BIT);
	}
	NVIC_ClearPendingIRQ(EXTI15_10_IRQn);
#endif
#if defined (STM32F0DISCOVERY)
	if (EXTI_GetITStatus(1 << X_LIMIT_BIT) != RESET)
 8005788:	2380      	movs	r3, #128	; 0x80
 800578a:	00db      	lsls	r3, r3, #3
 800578c:	0018      	movs	r0, r3
 800578e:	f7fd f903 	bl	8002998 <EXTI_GetITStatus>
 8005792:	1e03      	subs	r3, r0, #0
 8005794:	d004      	beq.n	80057a0 <EXTI4_15_IRQHandler+0x1c>
	{
		EXTI_ClearITPendingBit(1 << X_LIMIT_BIT);
 8005796:	2380      	movs	r3, #128	; 0x80
 8005798:	00db      	lsls	r3, r3, #3
 800579a:	0018      	movs	r0, r3
 800579c:	f7fd f91c 	bl	80029d8 <EXTI_ClearITPendingBit>
	}
	if (EXTI_GetITStatus(1 << Y_LIMIT_BIT) != RESET)
 80057a0:	2380      	movs	r3, #128	; 0x80
 80057a2:	011b      	lsls	r3, r3, #4
 80057a4:	0018      	movs	r0, r3
 80057a6:	f7fd f8f7 	bl	8002998 <EXTI_GetITStatus>
 80057aa:	1e03      	subs	r3, r0, #0
 80057ac:	d004      	beq.n	80057b8 <EXTI4_15_IRQHandler+0x34>
	{
		EXTI_ClearITPendingBit(1 << Y_LIMIT_BIT);
 80057ae:	2380      	movs	r3, #128	; 0x80
 80057b0:	011b      	lsls	r3, r3, #4
 80057b2:	0018      	movs	r0, r3
 80057b4:	f7fd f910 	bl	80029d8 <EXTI_ClearITPendingBit>
	}
	if (EXTI_GetITStatus(1 << Z_LIMIT_BIT) != RESET)
 80057b8:	2380      	movs	r3, #128	; 0x80
 80057ba:	015b      	lsls	r3, r3, #5
 80057bc:	0018      	movs	r0, r3
 80057be:	f7fd f8eb 	bl	8002998 <EXTI_GetITStatus>
 80057c2:	1e03      	subs	r3, r0, #0
 80057c4:	d004      	beq.n	80057d0 <EXTI4_15_IRQHandler+0x4c>
	{
		EXTI_ClearITPendingBit(1 << Z_LIMIT_BIT);
 80057c6:	2380      	movs	r3, #128	; 0x80
 80057c8:	015b      	lsls	r3, r3, #5
 80057ca:	0018      	movs	r0, r3
 80057cc:	f7fd f904 	bl	80029d8 <EXTI_ClearITPendingBit>
	}
	if (EXTI_GetITStatus(1 << A_LIMIT_BIT) != RESET)
 80057d0:	2380      	movs	r3, #128	; 0x80
 80057d2:	019b      	lsls	r3, r3, #6
 80057d4:	0018      	movs	r0, r3
 80057d6:	f7fd f8df 	bl	8002998 <EXTI_GetITStatus>
 80057da:	1e03      	subs	r3, r0, #0
 80057dc:	d004      	beq.n	80057e8 <EXTI4_15_IRQHandler+0x64>
	{
		EXTI_ClearITPendingBit(1 << A_LIMIT_BIT);
 80057de:	2380      	movs	r3, #128	; 0x80
 80057e0:	019b      	lsls	r3, r3, #6
 80057e2:	0018      	movs	r0, r3
 80057e4:	f7fd f8f8 	bl	80029d8 <EXTI_ClearITPendingBit>
	}
	NVIC_ClearPendingIRQ(EXTI4_15_IRQn);
 80057e8:	2007      	movs	r0, #7
 80057ea:	f7ff feef 	bl	80055cc <NVIC_ClearPendingIRQ>
  // Ignore limit switches if already in an alarm state or in-process of executing an alarm.
  // When in the alarm state, Grbl should have been reset or will force a reset, so any pending
  // moves in the planner and serial buffers are all cleared and newly sent blocks will be
  // locked out until a homing cycle or a kill lock command. Allows the user to disable the hard
  // limit setting if their limits are constantly triggering after a reset and move their axes.
  if (sys.state != STATE_ALARM) {
 80057ee:	4b08      	ldr	r3, [pc, #32]	; (8005810 <EXTI4_15_IRQHandler+0x8c>)
 80057f0:	781b      	ldrb	r3, [r3, #0]
 80057f2:	2b01      	cmp	r3, #1
 80057f4:	d009      	beq.n	800580a <EXTI4_15_IRQHandler+0x86>
    if (!(sys_rt_exec_alarm)) {
 80057f6:	4b07      	ldr	r3, [pc, #28]	; (8005814 <EXTI4_15_IRQHandler+0x90>)
 80057f8:	781b      	ldrb	r3, [r3, #0]
 80057fa:	b2db      	uxtb	r3, r3
 80057fc:	2b00      	cmp	r3, #0
 80057fe:	d104      	bne.n	800580a <EXTI4_15_IRQHandler+0x86>
      if (limits_get_state()) {
        mc_reset(); // Initiate system kill.
        system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT); // Indicate hard limit critical event
      }
#else
      mc_reset(); // Initiate system kill.
 8005800:	f000 feb8 	bl	8006574 <mc_reset>
      system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT); // Indicate hard limit critical event
 8005804:	2001      	movs	r0, #1
 8005806:	f006 fc81 	bl	800c10c <system_set_exec_alarm>
#endif
    }
  }
}
 800580a:	46c0      	nop			; (mov r8, r8)
 800580c:	46bd      	mov	sp, r7
 800580e:	bd80      	pop	{r7, pc}
 8005810:	20000bb4 	.word	0x20000bb4
 8005814:	20000bec 	.word	0x20000bec

08005818 <limits_go_home>:
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask)
{
 8005818:	b590      	push	{r4, r7, lr}
 800581a:	b097      	sub	sp, #92	; 0x5c
 800581c:	af00      	add	r7, sp, #0
 800581e:	0002      	movs	r2, r0
 8005820:	1dfb      	adds	r3, r7, #7
 8005822:	701a      	strb	r2, [r3, #0]
  if (sys.abort) { return; } // Block if system reset has been issued.
 8005824:	4bd0      	ldr	r3, [pc, #832]	; (8005b68 <limits_go_home+0x350>)
 8005826:	785b      	ldrb	r3, [r3, #1]
 8005828:	2b00      	cmp	r3, #0
 800582a:	d000      	beq.n	800582e <limits_go_home+0x16>
 800582c:	e2e0      	b.n	8005df0 <limits_go_home+0x5d8>

  // Initialize plan data struct for homing motion. Spindle and coolant are disabled.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
 800582e:	2320      	movs	r3, #32
 8005830:	18fb      	adds	r3, r7, r3
 8005832:	64bb      	str	r3, [r7, #72]	; 0x48
  memset(pl_data,0,sizeof(plan_line_data_t));
 8005834:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8005836:	220c      	movs	r2, #12
 8005838:	2100      	movs	r1, #0
 800583a:	0018      	movs	r0, r3
 800583c:	f006 ff62 	bl	800c704 <memset>
  pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
 8005840:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8005842:	2206      	movs	r2, #6
 8005844:	721a      	strb	r2, [r3, #8]

  // Initialize variables used for homing computations.
  //uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0f;
 8005846:	2300      	movs	r3, #0
 8005848:	657b      	str	r3, [r7, #84]	; 0x54
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 800584a:	2353      	movs	r3, #83	; 0x53
 800584c:	18fb      	adds	r3, r7, r3
 800584e:	2200      	movs	r2, #0
 8005850:	701a      	strb	r2, [r3, #0]
 8005852:	e056      	b.n	8005902 <limits_go_home+0xea>
    // Initialize step pin masks
    step_pin[idx] = step_pin_mask[idx];
 8005854:	2353      	movs	r3, #83	; 0x53
 8005856:	18fb      	adds	r3, r7, r3
 8005858:	781b      	ldrb	r3, [r3, #0]
 800585a:	2253      	movs	r2, #83	; 0x53
 800585c:	18ba      	adds	r2, r7, r2
 800585e:	7811      	ldrb	r1, [r2, #0]
 8005860:	4ac2      	ldr	r2, [pc, #776]	; (8005b6c <limits_go_home+0x354>)
 8005862:	0049      	lsls	r1, r1, #1
 8005864:	5a8a      	ldrh	r2, [r1, r2]
 8005866:	b2d1      	uxtb	r1, r2
 8005868:	221c      	movs	r2, #28
 800586a:	18ba      	adds	r2, r7, r2
 800586c:	54d1      	strb	r1, [r2, r3]
    #ifdef COREXY
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (step_pin_mask[X_AXIS]| step_pin_mask[Y_AXIS]); }
 800586e:	2353      	movs	r3, #83	; 0x53
 8005870:	18fb      	adds	r3, r7, r3
 8005872:	781b      	ldrb	r3, [r3, #0]
 8005874:	2b00      	cmp	r3, #0
 8005876:	d004      	beq.n	8005882 <limits_go_home+0x6a>
 8005878:	2353      	movs	r3, #83	; 0x53
 800587a:	18fb      	adds	r3, r7, r3
 800587c:	781b      	ldrb	r3, [r3, #0]
 800587e:	2b01      	cmp	r3, #1
 8005880:	d10d      	bne.n	800589e <limits_go_home+0x86>
 8005882:	2353      	movs	r3, #83	; 0x53
 8005884:	18fb      	adds	r3, r7, r3
 8005886:	781b      	ldrb	r3, [r3, #0]
 8005888:	4ab8      	ldr	r2, [pc, #736]	; (8005b6c <limits_go_home+0x354>)
 800588a:	8812      	ldrh	r2, [r2, #0]
 800588c:	b2d1      	uxtb	r1, r2
 800588e:	4ab7      	ldr	r2, [pc, #732]	; (8005b6c <limits_go_home+0x354>)
 8005890:	8852      	ldrh	r2, [r2, #2]
 8005892:	b2d2      	uxtb	r2, r2
 8005894:	430a      	orrs	r2, r1
 8005896:	b2d1      	uxtb	r1, r2
 8005898:	221c      	movs	r2, #28
 800589a:	18ba      	adds	r2, r7, r2
 800589c:	54d1      	strb	r1, [r2, r3]
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) {
 800589e:	1dfb      	adds	r3, r7, #7
 80058a0:	781a      	ldrb	r2, [r3, #0]
 80058a2:	2353      	movs	r3, #83	; 0x53
 80058a4:	18fb      	adds	r3, r7, r3
 80058a6:	781b      	ldrb	r3, [r3, #0]
 80058a8:	411a      	asrs	r2, r3
 80058aa:	0013      	movs	r3, r2
 80058ac:	2201      	movs	r2, #1
 80058ae:	4013      	ands	r3, r2
 80058b0:	d020      	beq.n	80058f4 <limits_go_home+0xdc>
      // Set target based on max_travel setting. Ensure homing switches engaged with search scalar.
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
 80058b2:	2353      	movs	r3, #83	; 0x53
 80058b4:	18fb      	adds	r3, r7, r3
 80058b6:	781a      	ldrb	r2, [r3, #0]
 80058b8:	4bad      	ldr	r3, [pc, #692]	; (8005b70 <limits_go_home+0x358>)
 80058ba:	320c      	adds	r2, #12
 80058bc:	0092      	lsls	r2, r2, #2
 80058be:	58d3      	ldr	r3, [r2, r3]
 80058c0:	49ac      	ldr	r1, [pc, #688]	; (8005b74 <limits_go_home+0x35c>)
 80058c2:	1c18      	adds	r0, r3, #0
 80058c4:	f7fb f8e6 	bl	8000a94 <__aeabi_fmul>
 80058c8:	1c03      	adds	r3, r0, #0
 80058ca:	6d79      	ldr	r1, [r7, #84]	; 0x54
 80058cc:	1c18      	adds	r0, r3, #0
 80058ce:	f7fa fd01 	bl	80002d4 <__aeabi_fcmplt>
 80058d2:	1e03      	subs	r3, r0, #0
 80058d4:	d001      	beq.n	80058da <limits_go_home+0xc2>
 80058d6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80058d8:	e00b      	b.n	80058f2 <limits_go_home+0xda>
 80058da:	2353      	movs	r3, #83	; 0x53
 80058dc:	18fb      	adds	r3, r7, r3
 80058de:	781a      	ldrb	r2, [r3, #0]
 80058e0:	4ba3      	ldr	r3, [pc, #652]	; (8005b70 <limits_go_home+0x358>)
 80058e2:	320c      	adds	r2, #12
 80058e4:	0092      	lsls	r2, r2, #2
 80058e6:	58d3      	ldr	r3, [r2, r3]
 80058e8:	49a2      	ldr	r1, [pc, #648]	; (8005b74 <limits_go_home+0x35c>)
 80058ea:	1c18      	adds	r0, r3, #0
 80058ec:	f7fb f8d2 	bl	8000a94 <__aeabi_fmul>
 80058f0:	1c03      	adds	r3, r0, #0
 80058f2:	657b      	str	r3, [r7, #84]	; 0x54
  for (idx=0; idx<N_AXIS; idx++) {
 80058f4:	2353      	movs	r3, #83	; 0x53
 80058f6:	18fb      	adds	r3, r7, r3
 80058f8:	781a      	ldrb	r2, [r3, #0]
 80058fa:	2353      	movs	r3, #83	; 0x53
 80058fc:	18fb      	adds	r3, r7, r3
 80058fe:	3201      	adds	r2, #1
 8005900:	701a      	strb	r2, [r3, #0]
 8005902:	2353      	movs	r3, #83	; 0x53
 8005904:	18fb      	adds	r3, r7, r3
 8005906:	781b      	ldrb	r3, [r3, #0]
 8005908:	2b03      	cmp	r3, #3
 800590a:	d9a3      	bls.n	8005854 <limits_go_home+0x3c>
    }
  }

  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
 800590c:	2301      	movs	r3, #1
 800590e:	647b      	str	r3, [r7, #68]	; 0x44
  float homing_rate = settings.homing_seek_rate;
 8005910:	4b97      	ldr	r3, [pc, #604]	; (8005b70 <limits_go_home+0x358>)
 8005912:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005914:	643b      	str	r3, [r7, #64]	; 0x40

  uint8_t limit_state, axislock, n_active_axis;
  //do {

    system_convert_array_steps_to_mpos(target,sys_position);
 8005916:	4a98      	ldr	r2, [pc, #608]	; (8005b78 <limits_go_home+0x360>)
 8005918:	230c      	movs	r3, #12
 800591a:	18fb      	adds	r3, r7, r3
 800591c:	0011      	movs	r1, r2
 800591e:	0018      	movs	r0, r3
 8005920:	f006 fb34 	bl	800bf8c <system_convert_array_steps_to_mpos>

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
 8005924:	2352      	movs	r3, #82	; 0x52
 8005926:	18fb      	adds	r3, r7, r3
 8005928:	2200      	movs	r2, #0
 800592a:	701a      	strb	r2, [r3, #0]
    n_active_axis = 0;
 800592c:	2351      	movs	r3, #81	; 0x51
 800592e:	18fb      	adds	r3, r7, r3
 8005930:	2200      	movs	r2, #0
 8005932:	701a      	strb	r2, [r3, #0]
    for (idx=0; idx<N_AXIS; idx++) {
 8005934:	2353      	movs	r3, #83	; 0x53
 8005936:	18fb      	adds	r3, r7, r3
 8005938:	2200      	movs	r2, #0
 800593a:	701a      	strb	r2, [r3, #0]
 800593c:	e08c      	b.n	8005a58 <limits_go_home+0x240>
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) {
 800593e:	1dfb      	adds	r3, r7, #7
 8005940:	781a      	ldrb	r2, [r3, #0]
 8005942:	2353      	movs	r3, #83	; 0x53
 8005944:	18fb      	adds	r3, r7, r3
 8005946:	781b      	ldrb	r3, [r3, #0]
 8005948:	411a      	asrs	r2, r3
 800594a:	0013      	movs	r3, r2
 800594c:	2201      	movs	r2, #1
 800594e:	4013      	ands	r3, r2
 8005950:	d100      	bne.n	8005954 <limits_go_home+0x13c>
 8005952:	e07a      	b.n	8005a4a <limits_go_home+0x232>
        n_active_axis++;
 8005954:	2351      	movs	r3, #81	; 0x51
 8005956:	18fb      	adds	r3, r7, r3
 8005958:	781a      	ldrb	r2, [r3, #0]
 800595a:	2351      	movs	r3, #81	; 0x51
 800595c:	18fb      	adds	r3, r7, r3
 800595e:	3201      	adds	r2, #1
 8005960:	701a      	strb	r2, [r3, #0]
        #ifdef COREXY
          if (idx == X_AXIS) {
 8005962:	2353      	movs	r3, #83	; 0x53
 8005964:	18fb      	adds	r3, r7, r3
 8005966:	781b      	ldrb	r3, [r3, #0]
 8005968:	2b00      	cmp	r3, #0
 800596a:	d10d      	bne.n	8005988 <limits_go_home+0x170>
            int32_t axis_position = system_convert_corexy_to_y_axis_steps(sys_position);
 800596c:	4b82      	ldr	r3, [pc, #520]	; (8005b78 <limits_go_home+0x360>)
 800596e:	0018      	movs	r0, r3
 8005970:	f006 fb48 	bl	800c004 <system_convert_corexy_to_y_axis_steps>
 8005974:	0003      	movs	r3, r0
 8005976:	63fb      	str	r3, [r7, #60]	; 0x3c
            sys_position[A_MOTOR] = axis_position;
 8005978:	4b7f      	ldr	r3, [pc, #508]	; (8005b78 <limits_go_home+0x360>)
 800597a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800597c:	601a      	str	r2, [r3, #0]
            sys_position[B_MOTOR] = -axis_position;
 800597e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8005980:	425a      	negs	r2, r3
 8005982:	4b7d      	ldr	r3, [pc, #500]	; (8005b78 <limits_go_home+0x360>)
 8005984:	605a      	str	r2, [r3, #4]
 8005986:	e018      	b.n	80059ba <limits_go_home+0x1a2>
          } else if (idx == Y_AXIS) {
 8005988:	2353      	movs	r3, #83	; 0x53
 800598a:	18fb      	adds	r3, r7, r3
 800598c:	781b      	ldrb	r3, [r3, #0]
 800598e:	2b01      	cmp	r3, #1
 8005990:	d10d      	bne.n	80059ae <limits_go_home+0x196>
            int32_t axis_position = system_convert_corexy_to_x_axis_steps(sys_position);
 8005992:	4b79      	ldr	r3, [pc, #484]	; (8005b78 <limits_go_home+0x360>)
 8005994:	0018      	movs	r0, r3
 8005996:	f006 fb23 	bl	800bfe0 <system_convert_corexy_to_x_axis_steps>
 800599a:	0003      	movs	r3, r0
 800599c:	63bb      	str	r3, [r7, #56]	; 0x38
            sys_position[A_MOTOR] = sys_position[B_MOTOR] = axis_position;
 800599e:	4b76      	ldr	r3, [pc, #472]	; (8005b78 <limits_go_home+0x360>)
 80059a0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80059a2:	605a      	str	r2, [r3, #4]
 80059a4:	4b74      	ldr	r3, [pc, #464]	; (8005b78 <limits_go_home+0x360>)
 80059a6:	685a      	ldr	r2, [r3, #4]
 80059a8:	4b73      	ldr	r3, [pc, #460]	; (8005b78 <limits_go_home+0x360>)
 80059aa:	601a      	str	r2, [r3, #0]
 80059ac:	e005      	b.n	80059ba <limits_go_home+0x1a2>
          } else {
            sys_position[Z_AXIS] = 0;
 80059ae:	4b72      	ldr	r3, [pc, #456]	; (8005b78 <limits_go_home+0x360>)
 80059b0:	2200      	movs	r2, #0
 80059b2:	609a      	str	r2, [r3, #8]
            sys_position[A_AXIS] = 0;          }
 80059b4:	4b70      	ldr	r3, [pc, #448]	; (8005b78 <limits_go_home+0x360>)
 80059b6:	2200      	movs	r2, #0
 80059b8:	60da      	str	r2, [r3, #12]
        #else
          sys_position[idx] = 0;
        #endif
        // Set target direction based on cycle mask and homing cycle approach state.
        // NOTE: This happens to compile smaller than any other implementation tried.
        if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
 80059ba:	4b6d      	ldr	r3, [pc, #436]	; (8005b70 <limits_go_home+0x358>)
 80059bc:	2259      	movs	r2, #89	; 0x59
 80059be:	5c9b      	ldrb	r3, [r3, r2]
 80059c0:	001a      	movs	r2, r3
 80059c2:	2353      	movs	r3, #83	; 0x53
 80059c4:	18fb      	adds	r3, r7, r3
 80059c6:	781b      	ldrb	r3, [r3, #0]
 80059c8:	411a      	asrs	r2, r3
 80059ca:	0013      	movs	r3, r2
 80059cc:	2201      	movs	r2, #1
 80059ce:	4013      	ands	r3, r2
 80059d0:	d017      	beq.n	8005a02 <limits_go_home+0x1ea>
          if (approach) { target[idx] = -max_travel; }
 80059d2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80059d4:	2b00      	cmp	r3, #0
 80059d6:	d00b      	beq.n	80059f0 <limits_go_home+0x1d8>
 80059d8:	2353      	movs	r3, #83	; 0x53
 80059da:	18fb      	adds	r3, r7, r3
 80059dc:	781a      	ldrb	r2, [r3, #0]
 80059de:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80059e0:	2180      	movs	r1, #128	; 0x80
 80059e2:	0609      	lsls	r1, r1, #24
 80059e4:	4059      	eors	r1, r3
 80059e6:	230c      	movs	r3, #12
 80059e8:	18fb      	adds	r3, r7, r3
 80059ea:	0092      	lsls	r2, r2, #2
 80059ec:	50d1      	str	r1, [r2, r3]
 80059ee:	e01f      	b.n	8005a30 <limits_go_home+0x218>
          else { target[idx] = max_travel; }
 80059f0:	2353      	movs	r3, #83	; 0x53
 80059f2:	18fb      	adds	r3, r7, r3
 80059f4:	781a      	ldrb	r2, [r3, #0]
 80059f6:	230c      	movs	r3, #12
 80059f8:	18fb      	adds	r3, r7, r3
 80059fa:	0092      	lsls	r2, r2, #2
 80059fc:	6d79      	ldr	r1, [r7, #84]	; 0x54
 80059fe:	50d1      	str	r1, [r2, r3]
 8005a00:	e016      	b.n	8005a30 <limits_go_home+0x218>
        } else {
          if (approach) { target[idx] = max_travel; }
 8005a02:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8005a04:	2b00      	cmp	r3, #0
 8005a06:	d008      	beq.n	8005a1a <limits_go_home+0x202>
 8005a08:	2353      	movs	r3, #83	; 0x53
 8005a0a:	18fb      	adds	r3, r7, r3
 8005a0c:	781a      	ldrb	r2, [r3, #0]
 8005a0e:	230c      	movs	r3, #12
 8005a10:	18fb      	adds	r3, r7, r3
 8005a12:	0092      	lsls	r2, r2, #2
 8005a14:	6d79      	ldr	r1, [r7, #84]	; 0x54
 8005a16:	50d1      	str	r1, [r2, r3]
 8005a18:	e00a      	b.n	8005a30 <limits_go_home+0x218>
          else { target[idx] = -max_travel; }
 8005a1a:	2353      	movs	r3, #83	; 0x53
 8005a1c:	18fb      	adds	r3, r7, r3
 8005a1e:	781a      	ldrb	r2, [r3, #0]
 8005a20:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8005a22:	2180      	movs	r1, #128	; 0x80
 8005a24:	0609      	lsls	r1, r1, #24
 8005a26:	4059      	eors	r1, r3
 8005a28:	230c      	movs	r3, #12
 8005a2a:	18fb      	adds	r3, r7, r3
 8005a2c:	0092      	lsls	r2, r2, #2
 8005a2e:	50d1      	str	r1, [r2, r3]
        }
        // Apply axislock to the step port pins active in this cycle.
        axislock |= step_pin[idx];
 8005a30:	2353      	movs	r3, #83	; 0x53
 8005a32:	18fb      	adds	r3, r7, r3
 8005a34:	781b      	ldrb	r3, [r3, #0]
 8005a36:	221c      	movs	r2, #28
 8005a38:	18ba      	adds	r2, r7, r2
 8005a3a:	5cd1      	ldrb	r1, [r2, r3]
 8005a3c:	2352      	movs	r3, #82	; 0x52
 8005a3e:	18fb      	adds	r3, r7, r3
 8005a40:	2252      	movs	r2, #82	; 0x52
 8005a42:	18ba      	adds	r2, r7, r2
 8005a44:	7812      	ldrb	r2, [r2, #0]
 8005a46:	430a      	orrs	r2, r1
 8005a48:	701a      	strb	r2, [r3, #0]
    for (idx=0; idx<N_AXIS; idx++) {
 8005a4a:	2353      	movs	r3, #83	; 0x53
 8005a4c:	18fb      	adds	r3, r7, r3
 8005a4e:	781a      	ldrb	r2, [r3, #0]
 8005a50:	2353      	movs	r3, #83	; 0x53
 8005a52:	18fb      	adds	r3, r7, r3
 8005a54:	3201      	adds	r2, #1
 8005a56:	701a      	strb	r2, [r3, #0]
 8005a58:	2353      	movs	r3, #83	; 0x53
 8005a5a:	18fb      	adds	r3, r7, r3
 8005a5c:	781b      	ldrb	r3, [r3, #0]
 8005a5e:	2b03      	cmp	r3, #3
 8005a60:	d800      	bhi.n	8005a64 <limits_go_home+0x24c>
 8005a62:	e76c      	b.n	800593e <limits_go_home+0x126>
      }

    }
    homing_rate *= sqrtf(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
 8005a64:	2351      	movs	r3, #81	; 0x51
 8005a66:	18fb      	adds	r3, r7, r3
 8005a68:	781b      	ldrb	r3, [r3, #0]
 8005a6a:	0018      	movs	r0, r3
 8005a6c:	f7fb fb56 	bl	800111c <__aeabi_ui2f>
 8005a70:	1c03      	adds	r3, r0, #0
 8005a72:	1c18      	adds	r0, r3, #0
 8005a74:	f006 ffde 	bl	800ca34 <sqrtf>
 8005a78:	1c03      	adds	r3, r0, #0
 8005a7a:	1c19      	adds	r1, r3, #0
 8005a7c:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8005a7e:	f7fb f809 	bl	8000a94 <__aeabi_fmul>
 8005a82:	1c03      	adds	r3, r0, #0
 8005a84:	643b      	str	r3, [r7, #64]	; 0x40
    sys.homing_axis_lock = axislock;
 8005a86:	4b38      	ldr	r3, [pc, #224]	; (8005b68 <limits_go_home+0x350>)
 8005a88:	2252      	movs	r2, #82	; 0x52
 8005a8a:	18ba      	adds	r2, r7, r2
 8005a8c:	7812      	ldrb	r2, [r2, #0]
 8005a8e:	719a      	strb	r2, [r3, #6]

    // Perform homing cycle. Planner buffer should be empty, as required to initiate the homing cycle.
    pl_data->feed_rate = homing_rate; // Set current homing rate.
 8005a90:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8005a92:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8005a94:	601a      	str	r2, [r3, #0]
    plan_buffer_line(target, pl_data); // Bypass mc_line(). Directly plan homing motion.
 8005a96:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8005a98:	230c      	movs	r3, #12
 8005a9a:	18fb      	adds	r3, r7, r3
 8005a9c:	0011      	movs	r1, r2
 8005a9e:	0018      	movs	r0, r3
 8005aa0:	f001 fad0 	bl	8007044 <plan_buffer_line>

    sys.step_control = STEP_CONTROL_EXECUTE_SYS_MOTION; // Set to execute homing motion and clear existing flags.
 8005aa4:	4b30      	ldr	r3, [pc, #192]	; (8005b68 <limits_go_home+0x350>)
 8005aa6:	2204      	movs	r2, #4
 8005aa8:	711a      	strb	r2, [r3, #4]
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
 8005aaa:	f005 f88b 	bl	800abc4 <st_prep_buffer>
    st_wake_up(); // Initiate motion
 8005aae:	f004 fbff 	bl	800a2b0 <st_wake_up>
    do {
      if (approach) {
 8005ab2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8005ab4:	2b00      	cmp	r3, #0
 8005ab6:	d100      	bne.n	8005aba <limits_go_home+0x2a2>
 8005ab8:	e085      	b.n	8005bc6 <limits_go_home+0x3ae>
        // Check limit state. Lock out cycle axes when they change.
        limit_state = limits_get_state();
 8005aba:	2337      	movs	r3, #55	; 0x37
 8005abc:	18fc      	adds	r4, r7, r3
 8005abe:	f7ff fe11 	bl	80056e4 <limits_get_state>
 8005ac2:	0003      	movs	r3, r0
 8005ac4:	7023      	strb	r3, [r4, #0]
        for (idx=0; idx<N_AXIS; idx++) {
 8005ac6:	2353      	movs	r3, #83	; 0x53
 8005ac8:	18fb      	adds	r3, r7, r3
 8005aca:	2200      	movs	r2, #0
 8005acc:	701a      	strb	r2, [r3, #0]
 8005ace:	e070      	b.n	8005bb2 <limits_go_home+0x39a>
          if (bit_istrue(cycle_mask,bit(idx))) {
 8005ad0:	1dfb      	adds	r3, r7, #7
 8005ad2:	781a      	ldrb	r2, [r3, #0]
 8005ad4:	2353      	movs	r3, #83	; 0x53
 8005ad6:	18fb      	adds	r3, r7, r3
 8005ad8:	781b      	ldrb	r3, [r3, #0]
 8005ada:	411a      	asrs	r2, r3
 8005adc:	0013      	movs	r3, r2
 8005ade:	2201      	movs	r2, #1
 8005ae0:	4013      	ands	r3, r2
 8005ae2:	d05f      	beq.n	8005ba4 <limits_go_home+0x38c>
            if (axislock & step_pin[idx]) {
 8005ae4:	2353      	movs	r3, #83	; 0x53
 8005ae6:	18fb      	adds	r3, r7, r3
 8005ae8:	781b      	ldrb	r3, [r3, #0]
 8005aea:	221c      	movs	r2, #28
 8005aec:	18ba      	adds	r2, r7, r2
 8005aee:	5cd3      	ldrb	r3, [r2, r3]
 8005af0:	2252      	movs	r2, #82	; 0x52
 8005af2:	18ba      	adds	r2, r7, r2
 8005af4:	7812      	ldrb	r2, [r2, #0]
 8005af6:	4013      	ands	r3, r2
 8005af8:	b2db      	uxtb	r3, r3
 8005afa:	2b00      	cmp	r3, #0
 8005afc:	d052      	beq.n	8005ba4 <limits_go_home+0x38c>
              if (limit_state & (1 << idx)) {
 8005afe:	2337      	movs	r3, #55	; 0x37
 8005b00:	18fb      	adds	r3, r7, r3
 8005b02:	781a      	ldrb	r2, [r3, #0]
 8005b04:	2353      	movs	r3, #83	; 0x53
 8005b06:	18fb      	adds	r3, r7, r3
 8005b08:	781b      	ldrb	r3, [r3, #0]
 8005b0a:	411a      	asrs	r2, r3
 8005b0c:	0013      	movs	r3, r2
 8005b0e:	2201      	movs	r2, #1
 8005b10:	4013      	ands	r3, r2
 8005b12:	d047      	beq.n	8005ba4 <limits_go_home+0x38c>
                #ifdef COREXY
                  if (idx==Z_AXIS) { axislock &= ~(step_pin[Z_AXIS]); }
 8005b14:	2353      	movs	r3, #83	; 0x53
 8005b16:	18fb      	adds	r3, r7, r3
 8005b18:	781b      	ldrb	r3, [r3, #0]
 8005b1a:	2b02      	cmp	r3, #2
 8005b1c:	d10f      	bne.n	8005b3e <limits_go_home+0x326>
 8005b1e:	231c      	movs	r3, #28
 8005b20:	18fb      	adds	r3, r7, r3
 8005b22:	789b      	ldrb	r3, [r3, #2]
 8005b24:	b25b      	sxtb	r3, r3
 8005b26:	43db      	mvns	r3, r3
 8005b28:	b25b      	sxtb	r3, r3
 8005b2a:	2252      	movs	r2, #82	; 0x52
 8005b2c:	18ba      	adds	r2, r7, r2
 8005b2e:	7812      	ldrb	r2, [r2, #0]
 8005b30:	b252      	sxtb	r2, r2
 8005b32:	4013      	ands	r3, r2
 8005b34:	b25a      	sxtb	r2, r3
 8005b36:	2352      	movs	r3, #82	; 0x52
 8005b38:	18fb      	adds	r3, r7, r3
 8005b3a:	701a      	strb	r2, [r3, #0]
 8005b3c:	e032      	b.n	8005ba4 <limits_go_home+0x38c>
                  else if (idx==A_AXIS) { axislock &= ~(step_pin[A_AXIS]); }
 8005b3e:	2353      	movs	r3, #83	; 0x53
 8005b40:	18fb      	adds	r3, r7, r3
 8005b42:	781b      	ldrb	r3, [r3, #0]
 8005b44:	2b03      	cmp	r3, #3
 8005b46:	d119      	bne.n	8005b7c <limits_go_home+0x364>
 8005b48:	231c      	movs	r3, #28
 8005b4a:	18fb      	adds	r3, r7, r3
 8005b4c:	78db      	ldrb	r3, [r3, #3]
 8005b4e:	b25b      	sxtb	r3, r3
 8005b50:	43db      	mvns	r3, r3
 8005b52:	b25b      	sxtb	r3, r3
 8005b54:	2252      	movs	r2, #82	; 0x52
 8005b56:	18ba      	adds	r2, r7, r2
 8005b58:	7812      	ldrb	r2, [r2, #0]
 8005b5a:	b252      	sxtb	r2, r2
 8005b5c:	4013      	ands	r3, r2
 8005b5e:	b25a      	sxtb	r2, r3
 8005b60:	2352      	movs	r3, #82	; 0x52
 8005b62:	18fb      	adds	r3, r7, r3
 8005b64:	701a      	strb	r2, [r3, #0]
 8005b66:	e01d      	b.n	8005ba4 <limits_go_home+0x38c>
 8005b68:	20000bb4 	.word	0x20000bb4
 8005b6c:	0800e0ac 	.word	0x0800e0ac
 8005b70:	20000b44 	.word	0x20000b44
 8005b74:	bfc00000 	.word	0xbfc00000
 8005b78:	20000bdc 	.word	0x20000bdc
                  else { axislock &= ~(step_pin[A_MOTOR]|step_pin[B_MOTOR]); }
 8005b7c:	231c      	movs	r3, #28
 8005b7e:	18fb      	adds	r3, r7, r3
 8005b80:	781a      	ldrb	r2, [r3, #0]
 8005b82:	231c      	movs	r3, #28
 8005b84:	18fb      	adds	r3, r7, r3
 8005b86:	785b      	ldrb	r3, [r3, #1]
 8005b88:	4313      	orrs	r3, r2
 8005b8a:	b2db      	uxtb	r3, r3
 8005b8c:	b25b      	sxtb	r3, r3
 8005b8e:	43db      	mvns	r3, r3
 8005b90:	b25b      	sxtb	r3, r3
 8005b92:	2252      	movs	r2, #82	; 0x52
 8005b94:	18ba      	adds	r2, r7, r2
 8005b96:	7812      	ldrb	r2, [r2, #0]
 8005b98:	b252      	sxtb	r2, r2
 8005b9a:	4013      	ands	r3, r2
 8005b9c:	b25a      	sxtb	r2, r3
 8005b9e:	2352      	movs	r3, #82	; 0x52
 8005ba0:	18fb      	adds	r3, r7, r3
 8005ba2:	701a      	strb	r2, [r3, #0]
        for (idx=0; idx<N_AXIS; idx++) {
 8005ba4:	2353      	movs	r3, #83	; 0x53
 8005ba6:	18fb      	adds	r3, r7, r3
 8005ba8:	781a      	ldrb	r2, [r3, #0]
 8005baa:	2353      	movs	r3, #83	; 0x53
 8005bac:	18fb      	adds	r3, r7, r3
 8005bae:	3201      	adds	r2, #1
 8005bb0:	701a      	strb	r2, [r3, #0]
 8005bb2:	2353      	movs	r3, #83	; 0x53
 8005bb4:	18fb      	adds	r3, r7, r3
 8005bb6:	781b      	ldrb	r3, [r3, #0]
 8005bb8:	2b03      	cmp	r3, #3
 8005bba:	d989      	bls.n	8005ad0 <limits_go_home+0x2b8>
                #endif
              }
            }
          }
        }
        sys.homing_axis_lock = axislock;
 8005bbc:	4b8e      	ldr	r3, [pc, #568]	; (8005df8 <limits_go_home+0x5e0>)
 8005bbe:	2252      	movs	r2, #82	; 0x52
 8005bc0:	18ba      	adds	r2, r7, r2
 8005bc2:	7812      	ldrb	r2, [r2, #0]
 8005bc4:	719a      	strb	r2, [r3, #6]
      }

      st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
 8005bc6:	f004 fffd 	bl	800abc4 <st_prep_buffer>
      //printPgmString(PSTR("Testing Exit Condition:")); // for debugging

      // Exit routines: No time to run protocol_execute_realtime() in this loop.
      if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
 8005bca:	4b8c      	ldr	r3, [pc, #560]	; (8005dfc <limits_go_home+0x5e4>)
 8005bcc:	781b      	ldrb	r3, [r3, #0]
 8005bce:	b2db      	uxtb	r3, r3
 8005bd0:	001a      	movs	r2, r3
 8005bd2:	2334      	movs	r3, #52	; 0x34
 8005bd4:	4013      	ands	r3, r2
 8005bd6:	d040      	beq.n	8005c5a <limits_go_home+0x442>
        uint8_t rt_exec = sys_rt_exec_state;
 8005bd8:	2336      	movs	r3, #54	; 0x36
 8005bda:	18fb      	adds	r3, r7, r3
 8005bdc:	4a87      	ldr	r2, [pc, #540]	; (8005dfc <limits_go_home+0x5e4>)
 8005bde:	7812      	ldrb	r2, [r2, #0]
 8005be0:	701a      	strb	r2, [r3, #0]
        // Homing failure condition: Reset issued during cycle.
        if (rt_exec & EXEC_RESET) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
 8005be2:	2336      	movs	r3, #54	; 0x36
 8005be4:	18fb      	adds	r3, r7, r3
 8005be6:	781b      	ldrb	r3, [r3, #0]
 8005be8:	2210      	movs	r2, #16
 8005bea:	4013      	ands	r3, r2
 8005bec:	d002      	beq.n	8005bf4 <limits_go_home+0x3dc>
 8005bee:	2006      	movs	r0, #6
 8005bf0:	f006 fa8c 	bl	800c10c <system_set_exec_alarm>
        // Homing failure condition: Safety door was opened.
        if (rt_exec & EXEC_SAFETY_DOOR) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_DOOR); }
 8005bf4:	2336      	movs	r3, #54	; 0x36
 8005bf6:	18fb      	adds	r3, r7, r3
 8005bf8:	781b      	ldrb	r3, [r3, #0]
 8005bfa:	2220      	movs	r2, #32
 8005bfc:	4013      	ands	r3, r2
 8005bfe:	d002      	beq.n	8005c06 <limits_go_home+0x3ee>
 8005c00:	2007      	movs	r0, #7
 8005c02:	f006 fa83 	bl	800c10c <system_set_exec_alarm>
        // Homing failure condition: Limit switch still engaged after pull-off motion
        if (!approach && (limits_get_state() & cycle_mask)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_PULLOFF); }
 8005c06:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8005c08:	2b00      	cmp	r3, #0
 8005c0a:	d10c      	bne.n	8005c26 <limits_go_home+0x40e>
 8005c0c:	f7ff fd6a 	bl	80056e4 <limits_get_state>
 8005c10:	0003      	movs	r3, r0
 8005c12:	001a      	movs	r2, r3
 8005c14:	1dfb      	adds	r3, r7, #7
 8005c16:	781b      	ldrb	r3, [r3, #0]
 8005c18:	4013      	ands	r3, r2
 8005c1a:	b2db      	uxtb	r3, r3
 8005c1c:	2b00      	cmp	r3, #0
 8005c1e:	d002      	beq.n	8005c26 <limits_go_home+0x40e>
 8005c20:	2008      	movs	r0, #8
 8005c22:	f006 fa73 	bl	800c10c <system_set_exec_alarm>
        // Homing failure condition: Limit switch not found during approach.
        if (approach && (rt_exec & EXEC_CYCLE_STOP)) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_APPROACH); }
 8005c26:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8005c28:	2b00      	cmp	r3, #0
 8005c2a:	d008      	beq.n	8005c3e <limits_go_home+0x426>
 8005c2c:	2336      	movs	r3, #54	; 0x36
 8005c2e:	18fb      	adds	r3, r7, r3
 8005c30:	781b      	ldrb	r3, [r3, #0]
 8005c32:	2204      	movs	r2, #4
 8005c34:	4013      	ands	r3, r2
 8005c36:	d002      	beq.n	8005c3e <limits_go_home+0x426>
 8005c38:	2009      	movs	r0, #9
 8005c3a:	f006 fa67 	bl	800c10c <system_set_exec_alarm>
        if (sys_rt_exec_alarm) {
 8005c3e:	4b70      	ldr	r3, [pc, #448]	; (8005e00 <limits_go_home+0x5e8>)
 8005c40:	781b      	ldrb	r3, [r3, #0]
 8005c42:	b2db      	uxtb	r3, r3
 8005c44:	2b00      	cmp	r3, #0
 8005c46:	d004      	beq.n	8005c52 <limits_go_home+0x43a>
          mc_reset(); // Stop motors, if they are running.
 8005c48:	f000 fc94 	bl	8006574 <mc_reset>
          protocol_execute_realtime();
 8005c4c:	f002 f898 	bl	8007d80 <protocol_execute_realtime>
          return;
 8005c50:	e0cf      	b.n	8005df2 <limits_go_home+0x5da>
        } else {
          // Pull-off motion complete. Disable CYCLE_STOP from executing.
          system_clear_exec_state_flag(EXEC_CYCLE_STOP);
 8005c52:	2004      	movs	r0, #4
 8005c54:	f006 fa3e 	bl	800c0d4 <system_clear_exec_state_flag>
          break;
 8005c58:	e008      	b.n	8005c6c <limits_go_home+0x454>
        }
      }

    } while ((STEP_MASK | 1) & axislock); // one for A axis since it has 4 pins on another port
 8005c5a:	2352      	movs	r3, #82	; 0x52
 8005c5c:	18fb      	adds	r3, r7, r3
 8005c5e:	781b      	ldrb	r3, [r3, #0]
 8005c60:	220f      	movs	r2, #15
 8005c62:	4013      	ands	r3, r2
 8005c64:	b2db      	uxtb	r3, r3
 8005c66:	2b00      	cmp	r3, #0
 8005c68:	d000      	beq.n	8005c6c <limits_go_home+0x454>
 8005c6a:	e722      	b.n	8005ab2 <limits_go_home+0x29a>

    st_reset(); // Immediately force kill steppers and reset step segment buffer.
 8005c6c:	f004 fe88 	bl	800a980 <st_reset>
    delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
 8005c70:	4b64      	ldr	r3, [pc, #400]	; (8005e04 <limits_go_home+0x5ec>)
 8005c72:	2264      	movs	r2, #100	; 0x64
 8005c74:	5a9b      	ldrh	r3, [r3, r2]
 8005c76:	0018      	movs	r0, r3
 8005c78:	f000 fdf0 	bl	800685c <delay_ms>

    // Reverse direction and reset homing rate for locate cycle(s).
    approach = !approach;
 8005c7c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8005c7e:	425a      	negs	r2, r3
 8005c80:	4153      	adcs	r3, r2
 8005c82:	b2db      	uxtb	r3, r3
 8005c84:	647b      	str	r3, [r7, #68]	; 0x44

    // After first cycle, homing enters locating phase. Shorten search to pull-off distance.
    if (approach) {
 8005c86:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8005c88:	2b00      	cmp	r3, #0
 8005c8a:	d00b      	beq.n	8005ca4 <limits_go_home+0x48c>
      max_travel = settings.homing_pulloff*HOMING_AXIS_LOCATE_SCALAR;
 8005c8c:	4b5d      	ldr	r3, [pc, #372]	; (8005e04 <limits_go_home+0x5ec>)
 8005c8e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8005c90:	495d      	ldr	r1, [pc, #372]	; (8005e08 <limits_go_home+0x5f0>)
 8005c92:	1c18      	adds	r0, r3, #0
 8005c94:	f7fa fefe 	bl	8000a94 <__aeabi_fmul>
 8005c98:	1c03      	adds	r3, r0, #0
 8005c9a:	657b      	str	r3, [r7, #84]	; 0x54
      homing_rate = settings.homing_feed_rate;
 8005c9c:	4b59      	ldr	r3, [pc, #356]	; (8005e04 <limits_go_home+0x5ec>)
 8005c9e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8005ca0:	643b      	str	r3, [r7, #64]	; 0x40
 8005ca2:	e005      	b.n	8005cb0 <limits_go_home+0x498>
    } else {
      max_travel = settings.homing_pulloff;
 8005ca4:	4b57      	ldr	r3, [pc, #348]	; (8005e04 <limits_go_home+0x5ec>)
 8005ca6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8005ca8:	657b      	str	r3, [r7, #84]	; 0x54
      homing_rate = settings.homing_seek_rate;
 8005caa:	4b56      	ldr	r3, [pc, #344]	; (8005e04 <limits_go_home+0x5ec>)
 8005cac:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005cae:	643b      	str	r3, [r7, #64]	; 0x40
  // set up pull-off maneuver from axes limit switches that have been homed. This provides
  // some initial clearance off the switches and should also help prevent them from falsely
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
 8005cb0:	2353      	movs	r3, #83	; 0x53
 8005cb2:	18fb      	adds	r3, r7, r3
 8005cb4:	2200      	movs	r2, #0
 8005cb6:	701a      	strb	r2, [r3, #0]
 8005cb8:	e090      	b.n	8005ddc <limits_go_home+0x5c4>
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
 8005cba:	1dfb      	adds	r3, r7, #7
 8005cbc:	781a      	ldrb	r2, [r3, #0]
 8005cbe:	2353      	movs	r3, #83	; 0x53
 8005cc0:	18fb      	adds	r3, r7, r3
 8005cc2:	781b      	ldrb	r3, [r3, #0]
 8005cc4:	411a      	asrs	r2, r3
 8005cc6:	0013      	movs	r3, r2
 8005cc8:	2201      	movs	r2, #1
 8005cca:	4013      	ands	r3, r2
 8005ccc:	d100      	bne.n	8005cd0 <limits_go_home+0x4b8>
 8005cce:	e07e      	b.n	8005dce <limits_go_home+0x5b6>
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
 8005cd0:	4b4c      	ldr	r3, [pc, #304]	; (8005e04 <limits_go_home+0x5ec>)
 8005cd2:	2259      	movs	r2, #89	; 0x59
 8005cd4:	5c9b      	ldrb	r3, [r3, r2]
 8005cd6:	001a      	movs	r2, r3
 8005cd8:	2353      	movs	r3, #83	; 0x53
 8005cda:	18fb      	adds	r3, r7, r3
 8005cdc:	781b      	ldrb	r3, [r3, #0]
 8005cde:	411a      	asrs	r2, r3
 8005ce0:	0013      	movs	r3, r2
 8005ce2:	2201      	movs	r2, #1
 8005ce4:	4013      	ands	r3, r2
 8005ce6:	d024      	beq.n	8005d32 <limits_go_home+0x51a>
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
 8005ce8:	2353      	movs	r3, #83	; 0x53
 8005cea:	18fb      	adds	r3, r7, r3
 8005cec:	781a      	ldrb	r2, [r3, #0]
 8005cee:	4b45      	ldr	r3, [pc, #276]	; (8005e04 <limits_go_home+0x5ec>)
 8005cf0:	320c      	adds	r2, #12
 8005cf2:	0092      	lsls	r2, r2, #2
 8005cf4:	58d2      	ldr	r2, [r2, r3]
 8005cf6:	4b43      	ldr	r3, [pc, #268]	; (8005e04 <limits_go_home+0x5ec>)
 8005cf8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8005cfa:	1c19      	adds	r1, r3, #0
 8005cfc:	1c10      	adds	r0, r2, #0
 8005cfe:	f7fa fb47 	bl	8000390 <__aeabi_fadd>
 8005d02:	1c03      	adds	r3, r0, #0
 8005d04:	1c18      	adds	r0, r3, #0
 8005d06:	2353      	movs	r3, #83	; 0x53
 8005d08:	18fb      	adds	r3, r7, r3
 8005d0a:	781a      	ldrb	r2, [r3, #0]
 8005d0c:	4b3d      	ldr	r3, [pc, #244]	; (8005e04 <limits_go_home+0x5ec>)
 8005d0e:	0092      	lsls	r2, r2, #2
 8005d10:	58d3      	ldr	r3, [r2, r3]
 8005d12:	1c19      	adds	r1, r3, #0
 8005d14:	f7fa febe 	bl	8000a94 <__aeabi_fmul>
 8005d18:	1c03      	adds	r3, r0, #0
 8005d1a:	1c18      	adds	r0, r3, #0
 8005d1c:	f7fc fcd2 	bl	80026c4 <__aeabi_f2d>
 8005d20:	0003      	movs	r3, r0
 8005d22:	000c      	movs	r4, r1
 8005d24:	0018      	movs	r0, r3
 8005d26:	0021      	movs	r1, r4
 8005d28:	f006 fcf4 	bl	800c714 <lround>
 8005d2c:	0003      	movs	r3, r0
 8005d2e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8005d30:	e01a      	b.n	8005d68 <limits_go_home+0x550>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
 8005d32:	4b34      	ldr	r3, [pc, #208]	; (8005e04 <limits_go_home+0x5ec>)
 8005d34:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8005d36:	2280      	movs	r2, #128	; 0x80
 8005d38:	0612      	lsls	r2, r2, #24
 8005d3a:	405a      	eors	r2, r3
 8005d3c:	0010      	movs	r0, r2
 8005d3e:	2353      	movs	r3, #83	; 0x53
 8005d40:	18fb      	adds	r3, r7, r3
 8005d42:	781a      	ldrb	r2, [r3, #0]
 8005d44:	4b2f      	ldr	r3, [pc, #188]	; (8005e04 <limits_go_home+0x5ec>)
 8005d46:	0092      	lsls	r2, r2, #2
 8005d48:	58d3      	ldr	r3, [r2, r3]
 8005d4a:	1c19      	adds	r1, r3, #0
 8005d4c:	f7fa fea2 	bl	8000a94 <__aeabi_fmul>
 8005d50:	1c03      	adds	r3, r0, #0
 8005d52:	1c18      	adds	r0, r3, #0
 8005d54:	f7fc fcb6 	bl	80026c4 <__aeabi_f2d>
 8005d58:	0003      	movs	r3, r0
 8005d5a:	000c      	movs	r4, r1
 8005d5c:	0018      	movs	r0, r3
 8005d5e:	0021      	movs	r1, r4
 8005d60:	f006 fcd8 	bl	800c714 <lround>
 8005d64:	0003      	movs	r3, r0
 8005d66:	64fb      	str	r3, [r7, #76]	; 0x4c
        }
      #endif

      #ifdef COREXY
        if (idx==X_AXIS) {
 8005d68:	2353      	movs	r3, #83	; 0x53
 8005d6a:	18fb      	adds	r3, r7, r3
 8005d6c:	781b      	ldrb	r3, [r3, #0]
 8005d6e:	2b00      	cmp	r3, #0
 8005d70:	d110      	bne.n	8005d94 <limits_go_home+0x57c>
          int32_t off_axis_position = system_convert_corexy_to_y_axis_steps(sys_position);
 8005d72:	4b26      	ldr	r3, [pc, #152]	; (8005e0c <limits_go_home+0x5f4>)
 8005d74:	0018      	movs	r0, r3
 8005d76:	f006 f945 	bl	800c004 <system_convert_corexy_to_y_axis_steps>
 8005d7a:	0003      	movs	r3, r0
 8005d7c:	633b      	str	r3, [r7, #48]	; 0x30
          sys_position[A_MOTOR] = set_axis_position + off_axis_position;
 8005d7e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8005d80:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005d82:	18d2      	adds	r2, r2, r3
 8005d84:	4b21      	ldr	r3, [pc, #132]	; (8005e0c <limits_go_home+0x5f4>)
 8005d86:	601a      	str	r2, [r3, #0]
          sys_position[B_MOTOR] = set_axis_position - off_axis_position;
 8005d88:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8005d8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005d8c:	1ad2      	subs	r2, r2, r3
 8005d8e:	4b1f      	ldr	r3, [pc, #124]	; (8005e0c <limits_go_home+0x5f4>)
 8005d90:	605a      	str	r2, [r3, #4]
 8005d92:	e01c      	b.n	8005dce <limits_go_home+0x5b6>
        } else if (idx==Y_AXIS) {
 8005d94:	2353      	movs	r3, #83	; 0x53
 8005d96:	18fb      	adds	r3, r7, r3
 8005d98:	781b      	ldrb	r3, [r3, #0]
 8005d9a:	2b01      	cmp	r3, #1
 8005d9c:	d110      	bne.n	8005dc0 <limits_go_home+0x5a8>
          int32_t off_axis_position = system_convert_corexy_to_x_axis_steps(sys_position);
 8005d9e:	4b1b      	ldr	r3, [pc, #108]	; (8005e0c <limits_go_home+0x5f4>)
 8005da0:	0018      	movs	r0, r3
 8005da2:	f006 f91d 	bl	800bfe0 <system_convert_corexy_to_x_axis_steps>
 8005da6:	0003      	movs	r3, r0
 8005da8:	62fb      	str	r3, [r7, #44]	; 0x2c
          sys_position[A_MOTOR] = off_axis_position + set_axis_position;
 8005daa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005dac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005dae:	18d2      	adds	r2, r2, r3
 8005db0:	4b16      	ldr	r3, [pc, #88]	; (8005e0c <limits_go_home+0x5f4>)
 8005db2:	601a      	str	r2, [r3, #0]
          sys_position[B_MOTOR] = off_axis_position - set_axis_position;
 8005db4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005db6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8005db8:	1ad2      	subs	r2, r2, r3
 8005dba:	4b14      	ldr	r3, [pc, #80]	; (8005e0c <limits_go_home+0x5f4>)
 8005dbc:	605a      	str	r2, [r3, #4]
 8005dbe:	e006      	b.n	8005dce <limits_go_home+0x5b6>
        } else {
          sys_position[idx] = set_axis_position;
 8005dc0:	2353      	movs	r3, #83	; 0x53
 8005dc2:	18fb      	adds	r3, r7, r3
 8005dc4:	781a      	ldrb	r2, [r3, #0]
 8005dc6:	4b11      	ldr	r3, [pc, #68]	; (8005e0c <limits_go_home+0x5f4>)
 8005dc8:	0092      	lsls	r2, r2, #2
 8005dca:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8005dcc:	50d1      	str	r1, [r2, r3]
  for (idx=0; idx<N_AXIS; idx++) {
 8005dce:	2353      	movs	r3, #83	; 0x53
 8005dd0:	18fb      	adds	r3, r7, r3
 8005dd2:	781a      	ldrb	r2, [r3, #0]
 8005dd4:	2353      	movs	r3, #83	; 0x53
 8005dd6:	18fb      	adds	r3, r7, r3
 8005dd8:	3201      	adds	r2, #1
 8005dda:	701a      	strb	r2, [r3, #0]
 8005ddc:	2353      	movs	r3, #83	; 0x53
 8005dde:	18fb      	adds	r3, r7, r3
 8005de0:	781b      	ldrb	r3, [r3, #0]
 8005de2:	2b03      	cmp	r3, #3
 8005de4:	d800      	bhi.n	8005de8 <limits_go_home+0x5d0>
 8005de6:	e768      	b.n	8005cba <limits_go_home+0x4a2>
        sys_position[idx] = set_axis_position;
      #endif

    }
  }
  sys.step_control = STEP_CONTROL_NORMAL_OP; // Return step control to normal operation.
 8005de8:	4b03      	ldr	r3, [pc, #12]	; (8005df8 <limits_go_home+0x5e0>)
 8005dea:	2200      	movs	r2, #0
 8005dec:	711a      	strb	r2, [r3, #4]
 8005dee:	e000      	b.n	8005df2 <limits_go_home+0x5da>
  if (sys.abort) { return; } // Block if system reset has been issued.
 8005df0:	46c0      	nop			; (mov r8, r8)
}
 8005df2:	46bd      	mov	sp, r7
 8005df4:	b017      	add	sp, #92	; 0x5c
 8005df6:	bd90      	pop	{r4, r7, pc}
 8005df8:	20000bb4 	.word	0x20000bb4
 8005dfc:	20000bc9 	.word	0x20000bc9
 8005e00:	20000bec 	.word	0x20000bec
 8005e04:	20000b44 	.word	0x20000b44
 8005e08:	40a00000 	.word	0x40a00000
 8005e0c:	20000bdc 	.word	0x20000bdc

08005e10 <limits_soft_check>:

// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
// NOTE: Used by jogging to limit travel within soft-limit volume.
void limits_soft_check(float *target)
{
 8005e10:	b580      	push	{r7, lr}
 8005e12:	b082      	sub	sp, #8
 8005e14:	af00      	add	r7, sp, #0
 8005e16:	6078      	str	r0, [r7, #4]
  if (system_check_travel_limits(target)) {
 8005e18:	687b      	ldr	r3, [r7, #4]
 8005e1a:	0018      	movs	r0, r3
 8005e1c:	f006 f904 	bl	800c028 <system_check_travel_limits>
 8005e20:	1e03      	subs	r3, r0, #0
 8005e22:	d01d      	beq.n	8005e60 <limits_soft_check+0x50>
    sys.soft_limit = true;
 8005e24:	4b10      	ldr	r3, [pc, #64]	; (8005e68 <limits_soft_check+0x58>)
 8005e26:	2201      	movs	r2, #1
 8005e28:	70da      	strb	r2, [r3, #3]
    // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
 8005e2a:	4b0f      	ldr	r3, [pc, #60]	; (8005e68 <limits_soft_check+0x58>)
 8005e2c:	781b      	ldrb	r3, [r3, #0]
 8005e2e:	2b08      	cmp	r3, #8
 8005e30:	d10c      	bne.n	8005e4c <limits_soft_check+0x3c>
      system_set_exec_state_flag(EXEC_FEED_HOLD);
 8005e32:	2008      	movs	r0, #8
 8005e34:	f006 f936 	bl	800c0a4 <system_set_exec_state_flag>
      do {
        protocol_execute_realtime();
 8005e38:	f001 ffa2 	bl	8007d80 <protocol_execute_realtime>
        if (sys.abort) { return; }
 8005e3c:	4b0a      	ldr	r3, [pc, #40]	; (8005e68 <limits_soft_check+0x58>)
 8005e3e:	785b      	ldrb	r3, [r3, #1]
 8005e40:	2b00      	cmp	r3, #0
 8005e42:	d10c      	bne.n	8005e5e <limits_soft_check+0x4e>
      } while ( sys.state != STATE_IDLE );
 8005e44:	4b08      	ldr	r3, [pc, #32]	; (8005e68 <limits_soft_check+0x58>)
 8005e46:	781b      	ldrb	r3, [r3, #0]
 8005e48:	2b00      	cmp	r3, #0
 8005e4a:	d1f5      	bne.n	8005e38 <limits_soft_check+0x28>
    }
    mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
 8005e4c:	f000 fb92 	bl	8006574 <mc_reset>
    system_set_exec_alarm(EXEC_ALARM_SOFT_LIMIT); // Indicate soft limit critical event
 8005e50:	2002      	movs	r0, #2
 8005e52:	f006 f95b 	bl	800c10c <system_set_exec_alarm>
    protocol_execute_realtime(); // Execute to enter critical event loop and system abort
 8005e56:	f001 ff93 	bl	8007d80 <protocol_execute_realtime>
    return;
 8005e5a:	46c0      	nop			; (mov r8, r8)
 8005e5c:	e000      	b.n	8005e60 <limits_soft_check+0x50>
        if (sys.abort) { return; }
 8005e5e:	46c0      	nop			; (mov r8, r8)
  }
}
 8005e60:	46bd      	mov	sp, r7
 8005e62:	b002      	add	sp, #8
 8005e64:	bd80      	pop	{r7, pc}
 8005e66:	46c0      	nop			; (mov r8, r8)
 8005e68:	20000bb4 	.word	0x20000bb4

08005e6c <mc_line>:
// NOTE: This is the primary gateway to the grbl planner. All line motions, including arc line
// segments, must pass through this routine before being passed to the planner. The seperation of
// mc_line and plan_buffer_line is done primarily to place non-planner-type functions from being
// in the planner and to let backlash compensation or canned cycle integration simple and direct.
void mc_line(float *target, plan_line_data_t *pl_data)
{
 8005e6c:	b580      	push	{r7, lr}
 8005e6e:	b082      	sub	sp, #8
 8005e70:	af00      	add	r7, sp, #0
 8005e72:	6078      	str	r0, [r7, #4]
 8005e74:	6039      	str	r1, [r7, #0]
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
 8005e76:	4b21      	ldr	r3, [pc, #132]	; (8005efc <mc_line+0x90>)
 8005e78:	2258      	movs	r2, #88	; 0x58
 8005e7a:	5c9b      	ldrb	r3, [r3, r2]
 8005e7c:	001a      	movs	r2, r3
 8005e7e:	2320      	movs	r3, #32
 8005e80:	4013      	ands	r3, r2
 8005e82:	d007      	beq.n	8005e94 <mc_line+0x28>
    // NOTE: Block jog state. Jogging is a special case and soft limits are handled independently.
    if (sys.state != STATE_JOG) { limits_soft_check(target); }
 8005e84:	4b1e      	ldr	r3, [pc, #120]	; (8005f00 <mc_line+0x94>)
 8005e86:	781b      	ldrb	r3, [r3, #0]
 8005e88:	2b20      	cmp	r3, #32
 8005e8a:	d003      	beq.n	8005e94 <mc_line+0x28>
 8005e8c:	687b      	ldr	r3, [r7, #4]
 8005e8e:	0018      	movs	r0, r3
 8005e90:	f7ff ffbe 	bl	8005e10 <limits_soft_check>
  }

  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
 8005e94:	4b1a      	ldr	r3, [pc, #104]	; (8005f00 <mc_line+0x94>)
 8005e96:	781b      	ldrb	r3, [r3, #0]
 8005e98:	2b02      	cmp	r3, #2
 8005e9a:	d029      	beq.n	8005ef0 <mc_line+0x84>
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot.
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
 8005e9c:	f001 ff70 	bl	8007d80 <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail, if system abort.
 8005ea0:	4b17      	ldr	r3, [pc, #92]	; (8005f00 <mc_line+0x94>)
 8005ea2:	785b      	ldrb	r3, [r3, #1]
 8005ea4:	2b00      	cmp	r3, #0
 8005ea6:	d125      	bne.n	8005ef4 <mc_line+0x88>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
 8005ea8:	f000 fff0 	bl	8006e8c <plan_check_full_buffer>
 8005eac:	1e03      	subs	r3, r0, #0
 8005eae:	d002      	beq.n	8005eb6 <mc_line+0x4a>
 8005eb0:	f001 ff5a 	bl	8007d68 <protocol_auto_cycle_start>
    protocol_execute_realtime(); // Check for any run-time commands
 8005eb4:	e7f2      	b.n	8005e9c <mc_line+0x30>
    else { break; }
 8005eb6:	46c0      	nop			; (mov r8, r8)
  } while (1);

  // Plan and queue motion into planner buffer
	if (plan_buffer_line(target, pl_data) == PLAN_EMPTY_BLOCK) {
 8005eb8:	683a      	ldr	r2, [r7, #0]
 8005eba:	687b      	ldr	r3, [r7, #4]
 8005ebc:	0011      	movs	r1, r2
 8005ebe:	0018      	movs	r0, r3
 8005ec0:	f001 f8c0 	bl	8007044 <plan_buffer_line>
 8005ec4:	1e03      	subs	r3, r0, #0
 8005ec6:	d116      	bne.n	8005ef6 <mc_line+0x8a>
		if (bit_istrue(settings.flags, BITFLAG_LASER_MODE)) {
 8005ec8:	4b0c      	ldr	r3, [pc, #48]	; (8005efc <mc_line+0x90>)
 8005eca:	2258      	movs	r2, #88	; 0x58
 8005ecc:	5c9b      	ldrb	r3, [r3, r2]
 8005ece:	001a      	movs	r2, r3
 8005ed0:	2302      	movs	r3, #2
 8005ed2:	4013      	ands	r3, r2
 8005ed4:	d00f      	beq.n	8005ef6 <mc_line+0x8a>
			// Correctly set spindle state, if there is a coincident position passed. Forces a buffer
			// sync while in M3 laser mode only.
			if (pl_data->condition & PL_COND_FLAG_SPINDLE_CW) {
 8005ed6:	683b      	ldr	r3, [r7, #0]
 8005ed8:	7a1b      	ldrb	r3, [r3, #8]
 8005eda:	001a      	movs	r2, r3
 8005edc:	2310      	movs	r3, #16
 8005ede:	4013      	ands	r3, r2
 8005ee0:	d009      	beq.n	8005ef6 <mc_line+0x8a>
				spindle_sync(PL_COND_FLAG_SPINDLE_CW, pl_data->spindle_speed);
 8005ee2:	683b      	ldr	r3, [r7, #0]
 8005ee4:	685b      	ldr	r3, [r3, #4]
 8005ee6:	1c19      	adds	r1, r3, #0
 8005ee8:	2010      	movs	r0, #16
 8005eea:	f004 f997 	bl	800a21c <spindle_sync>
 8005eee:	e002      	b.n	8005ef6 <mc_line+0x8a>
  if (sys.state == STATE_CHECK_MODE) { return; }
 8005ef0:	46c0      	nop			; (mov r8, r8)
 8005ef2:	e000      	b.n	8005ef6 <mc_line+0x8a>
    if (sys.abort) { return; } // Bail, if system abort.
 8005ef4:	46c0      	nop			; (mov r8, r8)
			}
		}
	}
}
 8005ef6:	46bd      	mov	sp, r7
 8005ef8:	b002      	add	sp, #8
 8005efa:	bd80      	pop	{r7, pc}
 8005efc:	20000b44 	.word	0x20000b44
 8005f00:	20000bb4 	.word	0x20000bb4

08005f04 <mc_arc>:
// The arc is approximated by generating a huge number of tiny, linear segments. The chordal tolerance
// of each segment is configured in settings.arc_tolerance, which is defined to be the maximum normal
// distance from segment to the circle when the end points both lie on the circle.
void mc_arc(float *target, plan_line_data_t *pl_data, float *position, float *offset, float radius,
  uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
{
 8005f04:	b5b0      	push	{r4, r5, r7, lr}
 8005f06:	b094      	sub	sp, #80	; 0x50
 8005f08:	af00      	add	r7, sp, #0
 8005f0a:	60f8      	str	r0, [r7, #12]
 8005f0c:	60b9      	str	r1, [r7, #8]
 8005f0e:	607a      	str	r2, [r7, #4]
 8005f10:	603b      	str	r3, [r7, #0]
  float center_axis0 = position[axis_0] + offset[axis_0];
 8005f12:	2364      	movs	r3, #100	; 0x64
 8005f14:	18fb      	adds	r3, r7, r3
 8005f16:	781b      	ldrb	r3, [r3, #0]
 8005f18:	009b      	lsls	r3, r3, #2
 8005f1a:	687a      	ldr	r2, [r7, #4]
 8005f1c:	18d3      	adds	r3, r2, r3
 8005f1e:	6818      	ldr	r0, [r3, #0]
 8005f20:	2364      	movs	r3, #100	; 0x64
 8005f22:	18fb      	adds	r3, r7, r3
 8005f24:	781b      	ldrb	r3, [r3, #0]
 8005f26:	009b      	lsls	r3, r3, #2
 8005f28:	683a      	ldr	r2, [r7, #0]
 8005f2a:	18d3      	adds	r3, r2, r3
 8005f2c:	681b      	ldr	r3, [r3, #0]
 8005f2e:	1c19      	adds	r1, r3, #0
 8005f30:	f7fa fa2e 	bl	8000390 <__aeabi_fadd>
 8005f34:	1c03      	adds	r3, r0, #0
 8005f36:	63fb      	str	r3, [r7, #60]	; 0x3c
  float center_axis1 = position[axis_1] + offset[axis_1];
 8005f38:	2368      	movs	r3, #104	; 0x68
 8005f3a:	18fb      	adds	r3, r7, r3
 8005f3c:	781b      	ldrb	r3, [r3, #0]
 8005f3e:	009b      	lsls	r3, r3, #2
 8005f40:	687a      	ldr	r2, [r7, #4]
 8005f42:	18d3      	adds	r3, r2, r3
 8005f44:	6818      	ldr	r0, [r3, #0]
 8005f46:	2368      	movs	r3, #104	; 0x68
 8005f48:	18fb      	adds	r3, r7, r3
 8005f4a:	781b      	ldrb	r3, [r3, #0]
 8005f4c:	009b      	lsls	r3, r3, #2
 8005f4e:	683a      	ldr	r2, [r7, #0]
 8005f50:	18d3      	adds	r3, r2, r3
 8005f52:	681b      	ldr	r3, [r3, #0]
 8005f54:	1c19      	adds	r1, r3, #0
 8005f56:	f7fa fa1b 	bl	8000390 <__aeabi_fadd>
 8005f5a:	1c03      	adds	r3, r0, #0
 8005f5c:	63bb      	str	r3, [r7, #56]	; 0x38
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
 8005f5e:	2364      	movs	r3, #100	; 0x64
 8005f60:	18fb      	adds	r3, r7, r3
 8005f62:	781b      	ldrb	r3, [r3, #0]
 8005f64:	009b      	lsls	r3, r3, #2
 8005f66:	683a      	ldr	r2, [r7, #0]
 8005f68:	18d3      	adds	r3, r2, r3
 8005f6a:	681b      	ldr	r3, [r3, #0]
 8005f6c:	2280      	movs	r2, #128	; 0x80
 8005f6e:	0612      	lsls	r2, r2, #24
 8005f70:	4053      	eors	r3, r2
 8005f72:	64fb      	str	r3, [r7, #76]	; 0x4c
  float r_axis1 = -offset[axis_1];
 8005f74:	2368      	movs	r3, #104	; 0x68
 8005f76:	18fb      	adds	r3, r7, r3
 8005f78:	781b      	ldrb	r3, [r3, #0]
 8005f7a:	009b      	lsls	r3, r3, #2
 8005f7c:	683a      	ldr	r2, [r7, #0]
 8005f7e:	18d3      	adds	r3, r2, r3
 8005f80:	681b      	ldr	r3, [r3, #0]
 8005f82:	2280      	movs	r2, #128	; 0x80
 8005f84:	0612      	lsls	r2, r2, #24
 8005f86:	4053      	eors	r3, r2
 8005f88:	64bb      	str	r3, [r7, #72]	; 0x48
  float rt_axis0 = target[axis_0] - center_axis0;
 8005f8a:	2364      	movs	r3, #100	; 0x64
 8005f8c:	18fb      	adds	r3, r7, r3
 8005f8e:	781b      	ldrb	r3, [r3, #0]
 8005f90:	009b      	lsls	r3, r3, #2
 8005f92:	68fa      	ldr	r2, [r7, #12]
 8005f94:	18d3      	adds	r3, r2, r3
 8005f96:	681b      	ldr	r3, [r3, #0]
 8005f98:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8005f9a:	1c18      	adds	r0, r3, #0
 8005f9c:	f7fa fe9a 	bl	8000cd4 <__aeabi_fsub>
 8005fa0:	1c03      	adds	r3, r0, #0
 8005fa2:	637b      	str	r3, [r7, #52]	; 0x34
  float rt_axis1 = target[axis_1] - center_axis1;
 8005fa4:	2368      	movs	r3, #104	; 0x68
 8005fa6:	18fb      	adds	r3, r7, r3
 8005fa8:	781b      	ldrb	r3, [r3, #0]
 8005faa:	009b      	lsls	r3, r3, #2
 8005fac:	68fa      	ldr	r2, [r7, #12]
 8005fae:	18d3      	adds	r3, r2, r3
 8005fb0:	681b      	ldr	r3, [r3, #0]
 8005fb2:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 8005fb4:	1c18      	adds	r0, r3, #0
 8005fb6:	f7fa fe8d 	bl	8000cd4 <__aeabi_fsub>
 8005fba:	1c03      	adds	r3, r0, #0
 8005fbc:	633b      	str	r3, [r7, #48]	; 0x30

  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2f(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
 8005fbe:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8005fc0:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8005fc2:	f7fa fd67 	bl	8000a94 <__aeabi_fmul>
 8005fc6:	1c03      	adds	r3, r0, #0
 8005fc8:	1c1c      	adds	r4, r3, #0
 8005fca:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8005fcc:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8005fce:	f7fa fd61 	bl	8000a94 <__aeabi_fmul>
 8005fd2:	1c03      	adds	r3, r0, #0
 8005fd4:	1c19      	adds	r1, r3, #0
 8005fd6:	1c20      	adds	r0, r4, #0
 8005fd8:	f7fa fe7c 	bl	8000cd4 <__aeabi_fsub>
 8005fdc:	1c03      	adds	r3, r0, #0
 8005fde:	1c1c      	adds	r4, r3, #0
 8005fe0:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8005fe2:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8005fe4:	f7fa fd56 	bl	8000a94 <__aeabi_fmul>
 8005fe8:	1c03      	adds	r3, r0, #0
 8005fea:	1c1d      	adds	r5, r3, #0
 8005fec:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8005fee:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8005ff0:	f7fa fd50 	bl	8000a94 <__aeabi_fmul>
 8005ff4:	1c03      	adds	r3, r0, #0
 8005ff6:	1c19      	adds	r1, r3, #0
 8005ff8:	1c28      	adds	r0, r5, #0
 8005ffa:	f7fa f9c9 	bl	8000390 <__aeabi_fadd>
 8005ffe:	1c03      	adds	r3, r0, #0
 8006000:	1c19      	adds	r1, r3, #0
 8006002:	1c20      	adds	r0, r4, #0
 8006004:	f006 fd12 	bl	800ca2c <atan2f>
 8006008:	1c03      	adds	r3, r0, #0
 800600a:	647b      	str	r3, [r7, #68]	; 0x44
  if (is_clockwise_arc) { // Correct atan2 output per direction
 800600c:	2370      	movs	r3, #112	; 0x70
 800600e:	18fb      	adds	r3, r7, r3
 8006010:	781b      	ldrb	r3, [r3, #0]
 8006012:	2b00      	cmp	r3, #0
 8006014:	d018      	beq.n	8006048 <mc_arc+0x144>
    if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel -= 2*M_PI; }
 8006016:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8006018:	f7fc fb54 	bl	80026c4 <__aeabi_f2d>
 800601c:	4ae4      	ldr	r2, [pc, #912]	; (80063b0 <mc_arc+0x4ac>)
 800601e:	4be5      	ldr	r3, [pc, #916]	; (80063b4 <mc_arc+0x4b0>)
 8006020:	f7fa f93c 	bl	800029c <__aeabi_dcmpge>
 8006024:	1e03      	subs	r3, r0, #0
 8006026:	d027      	beq.n	8006078 <mc_arc+0x174>
 8006028:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800602a:	f7fc fb4b 	bl	80026c4 <__aeabi_f2d>
 800602e:	4ae2      	ldr	r2, [pc, #904]	; (80063b8 <mc_arc+0x4b4>)
 8006030:	4be2      	ldr	r3, [pc, #904]	; (80063bc <mc_arc+0x4b8>)
 8006032:	f7fb fffd 	bl	8002030 <__aeabi_dsub>
 8006036:	0003      	movs	r3, r0
 8006038:	000c      	movs	r4, r1
 800603a:	0018      	movs	r0, r3
 800603c:	0021      	movs	r1, r4
 800603e:	f7fc fb93 	bl	8002768 <__aeabi_d2f>
 8006042:	1c03      	adds	r3, r0, #0
 8006044:	647b      	str	r3, [r7, #68]	; 0x44
 8006046:	e017      	b.n	8006078 <mc_arc+0x174>
  } else {
    if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel += 2*M_PI; }
 8006048:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800604a:	f7fc fb3b 	bl	80026c4 <__aeabi_f2d>
 800604e:	4ad8      	ldr	r2, [pc, #864]	; (80063b0 <mc_arc+0x4ac>)
 8006050:	4bdb      	ldr	r3, [pc, #876]	; (80063c0 <mc_arc+0x4bc>)
 8006052:	f7fa f90f 	bl	8000274 <__aeabi_dcmple>
 8006056:	1e03      	subs	r3, r0, #0
 8006058:	d00e      	beq.n	8006078 <mc_arc+0x174>
 800605a:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800605c:	f7fc fb32 	bl	80026c4 <__aeabi_f2d>
 8006060:	4ad5      	ldr	r2, [pc, #852]	; (80063b8 <mc_arc+0x4b4>)
 8006062:	4bd6      	ldr	r3, [pc, #856]	; (80063bc <mc_arc+0x4b8>)
 8006064:	f7fb f8a0 	bl	80011a8 <__aeabi_dadd>
 8006068:	0003      	movs	r3, r0
 800606a:	000c      	movs	r4, r1
 800606c:	0018      	movs	r0, r3
 800606e:	0021      	movs	r1, r4
 8006070:	f7fc fb7a 	bl	8002768 <__aeabi_d2f>
 8006074:	1c03      	adds	r3, r0, #0
 8006076:	647b      	str	r3, [r7, #68]	; 0x44

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = (uint16_t)floorf(fabsf(0.5f*angular_travel*radius) /
 8006078:	21fc      	movs	r1, #252	; 0xfc
 800607a:	0589      	lsls	r1, r1, #22
 800607c:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800607e:	f7fa fd09 	bl	8000a94 <__aeabi_fmul>
 8006082:	1c03      	adds	r3, r0, #0
 8006084:	6e39      	ldr	r1, [r7, #96]	; 0x60
 8006086:	1c18      	adds	r0, r3, #0
 8006088:	f7fa fd04 	bl	8000a94 <__aeabi_fmul>
 800608c:	1c03      	adds	r3, r0, #0
 800608e:	005b      	lsls	r3, r3, #1
 8006090:	085c      	lsrs	r4, r3, #1
                          sqrtf(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
 8006092:	4bcc      	ldr	r3, [pc, #816]	; (80063c4 <mc_arc+0x4c0>)
 8006094:	6cdd      	ldr	r5, [r3, #76]	; 0x4c
 8006096:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8006098:	1c19      	adds	r1, r3, #0
 800609a:	1c18      	adds	r0, r3, #0
 800609c:	f7fa f978 	bl	8000390 <__aeabi_fadd>
 80060a0:	1c03      	adds	r3, r0, #0
 80060a2:	1c1a      	adds	r2, r3, #0
 80060a4:	4bc7      	ldr	r3, [pc, #796]	; (80063c4 <mc_arc+0x4c0>)
 80060a6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80060a8:	1c19      	adds	r1, r3, #0
 80060aa:	1c10      	adds	r0, r2, #0
 80060ac:	f7fa fe12 	bl	8000cd4 <__aeabi_fsub>
 80060b0:	1c03      	adds	r3, r0, #0
 80060b2:	1c19      	adds	r1, r3, #0
 80060b4:	1c28      	adds	r0, r5, #0
 80060b6:	f7fa fced 	bl	8000a94 <__aeabi_fmul>
 80060ba:	1c03      	adds	r3, r0, #0
 80060bc:	1c18      	adds	r0, r3, #0
 80060be:	f006 fcb9 	bl	800ca34 <sqrtf>
 80060c2:	1c03      	adds	r3, r0, #0
  uint16_t segments = (uint16_t)floorf(fabsf(0.5f*angular_travel*radius) /
 80060c4:	1c19      	adds	r1, r3, #0
 80060c6:	1c20      	adds	r0, r4, #0
 80060c8:	f7fa faf4 	bl	80006b4 <__aeabi_fdiv>
 80060cc:	1c03      	adds	r3, r0, #0
 80060ce:	1c18      	adds	r0, r3, #0
 80060d0:	f006 fc12 	bl	800c8f8 <floorf>
 80060d4:	1c03      	adds	r3, r0, #0
 80060d6:	222e      	movs	r2, #46	; 0x2e
 80060d8:	18bc      	adds	r4, r7, r2
 80060da:	1c18      	adds	r0, r3, #0
 80060dc:	f7fa f922 	bl	8000324 <__aeabi_f2uiz>
 80060e0:	0003      	movs	r3, r0
 80060e2:	8023      	strh	r3, [r4, #0]

  if (segments) {
 80060e4:	232e      	movs	r3, #46	; 0x2e
 80060e6:	18fb      	adds	r3, r7, r3
 80060e8:	881b      	ldrh	r3, [r3, #0]
 80060ea:	2b00      	cmp	r3, #0
 80060ec:	d100      	bne.n	80060f0 <mc_arc+0x1ec>
 80060ee:	e158      	b.n	80063a2 <mc_arc+0x49e>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of
    // all segments.
    if (pl_data->condition & PL_COND_FLAG_INVERSE_TIME) { 
 80060f0:	68bb      	ldr	r3, [r7, #8]
 80060f2:	7a1b      	ldrb	r3, [r3, #8]
 80060f4:	001a      	movs	r2, r3
 80060f6:	2308      	movs	r3, #8
 80060f8:	4013      	ands	r3, r2
 80060fa:	d017      	beq.n	800612c <mc_arc+0x228>
      pl_data->feed_rate *= segments; 
 80060fc:	68bb      	ldr	r3, [r7, #8]
 80060fe:	681c      	ldr	r4, [r3, #0]
 8006100:	232e      	movs	r3, #46	; 0x2e
 8006102:	18fb      	adds	r3, r7, r3
 8006104:	881b      	ldrh	r3, [r3, #0]
 8006106:	0018      	movs	r0, r3
 8006108:	f7fa ffb8 	bl	800107c <__aeabi_i2f>
 800610c:	1c03      	adds	r3, r0, #0
 800610e:	1c19      	adds	r1, r3, #0
 8006110:	1c20      	adds	r0, r4, #0
 8006112:	f7fa fcbf 	bl	8000a94 <__aeabi_fmul>
 8006116:	1c03      	adds	r3, r0, #0
 8006118:	1c1a      	adds	r2, r3, #0
 800611a:	68bb      	ldr	r3, [r7, #8]
 800611c:	601a      	str	r2, [r3, #0]
      bit_false(pl_data->condition,PL_COND_FLAG_INVERSE_TIME); // Force as feed absolute mode over arc segments.
 800611e:	68bb      	ldr	r3, [r7, #8]
 8006120:	7a1b      	ldrb	r3, [r3, #8]
 8006122:	2208      	movs	r2, #8
 8006124:	4393      	bics	r3, r2
 8006126:	b2da      	uxtb	r2, r3
 8006128:	68bb      	ldr	r3, [r7, #8]
 800612a:	721a      	strb	r2, [r3, #8]
    }
    
    float theta_per_segment = angular_travel/segments;
 800612c:	232e      	movs	r3, #46	; 0x2e
 800612e:	18fb      	adds	r3, r7, r3
 8006130:	881b      	ldrh	r3, [r3, #0]
 8006132:	0018      	movs	r0, r3
 8006134:	f7fa ffa2 	bl	800107c <__aeabi_i2f>
 8006138:	1c03      	adds	r3, r0, #0
 800613a:	1c19      	adds	r1, r3, #0
 800613c:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800613e:	f7fa fab9 	bl	80006b4 <__aeabi_fdiv>
 8006142:	1c03      	adds	r3, r0, #0
 8006144:	62bb      	str	r3, [r7, #40]	; 0x28
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
 8006146:	236c      	movs	r3, #108	; 0x6c
 8006148:	18fb      	adds	r3, r7, r3
 800614a:	781b      	ldrb	r3, [r3, #0]
 800614c:	009b      	lsls	r3, r3, #2
 800614e:	68fa      	ldr	r2, [r7, #12]
 8006150:	18d3      	adds	r3, r2, r3
 8006152:	6818      	ldr	r0, [r3, #0]
 8006154:	236c      	movs	r3, #108	; 0x6c
 8006156:	18fb      	adds	r3, r7, r3
 8006158:	781b      	ldrb	r3, [r3, #0]
 800615a:	009b      	lsls	r3, r3, #2
 800615c:	687a      	ldr	r2, [r7, #4]
 800615e:	18d3      	adds	r3, r2, r3
 8006160:	681b      	ldr	r3, [r3, #0]
 8006162:	1c19      	adds	r1, r3, #0
 8006164:	f7fa fdb6 	bl	8000cd4 <__aeabi_fsub>
 8006168:	1c03      	adds	r3, r0, #0
 800616a:	1c1c      	adds	r4, r3, #0
 800616c:	232e      	movs	r3, #46	; 0x2e
 800616e:	18fb      	adds	r3, r7, r3
 8006170:	881b      	ldrh	r3, [r3, #0]
 8006172:	0018      	movs	r0, r3
 8006174:	f7fa ff82 	bl	800107c <__aeabi_i2f>
 8006178:	1c03      	adds	r3, r0, #0
 800617a:	1c19      	adds	r1, r3, #0
 800617c:	1c20      	adds	r0, r4, #0
 800617e:	f7fa fa99 	bl	80006b4 <__aeabi_fdiv>
 8006182:	1c03      	adds	r3, r0, #0
 8006184:	627b      	str	r3, [r7, #36]	; 0x24
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead.
       This is important when there are successive arc motions.
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0f - theta_per_segment*theta_per_segment;
 8006186:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8006188:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800618a:	f7fa fc83 	bl	8000a94 <__aeabi_fmul>
 800618e:	1c03      	adds	r3, r0, #0
 8006190:	1c19      	adds	r1, r3, #0
 8006192:	2080      	movs	r0, #128	; 0x80
 8006194:	05c0      	lsls	r0, r0, #23
 8006196:	f7fa fd9d 	bl	8000cd4 <__aeabi_fsub>
 800619a:	1c03      	adds	r3, r0, #0
 800619c:	623b      	str	r3, [r7, #32]
    float sin_T = theta_per_segment*0.16666667f*(cos_T + 4.0f);
 800619e:	498a      	ldr	r1, [pc, #552]	; (80063c8 <mc_arc+0x4c4>)
 80061a0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80061a2:	f7fa fc77 	bl	8000a94 <__aeabi_fmul>
 80061a6:	1c03      	adds	r3, r0, #0
 80061a8:	1c1c      	adds	r4, r3, #0
 80061aa:	2181      	movs	r1, #129	; 0x81
 80061ac:	05c9      	lsls	r1, r1, #23
 80061ae:	6a38      	ldr	r0, [r7, #32]
 80061b0:	f7fa f8ee 	bl	8000390 <__aeabi_fadd>
 80061b4:	1c03      	adds	r3, r0, #0
 80061b6:	1c19      	adds	r1, r3, #0
 80061b8:	1c20      	adds	r0, r4, #0
 80061ba:	f7fa fc6b 	bl	8000a94 <__aeabi_fmul>
 80061be:	1c03      	adds	r3, r0, #0
 80061c0:	61fb      	str	r3, [r7, #28]
    cos_T *= 0.5;
 80061c2:	21fc      	movs	r1, #252	; 0xfc
 80061c4:	0589      	lsls	r1, r1, #22
 80061c6:	6a38      	ldr	r0, [r7, #32]
 80061c8:	f7fa fc64 	bl	8000a94 <__aeabi_fmul>
 80061cc:	1c03      	adds	r3, r0, #0
 80061ce:	623b      	str	r3, [r7, #32]

    float sin_Ti;
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
 80061d0:	2341      	movs	r3, #65	; 0x41
 80061d2:	18fb      	adds	r3, r7, r3
 80061d4:	2200      	movs	r2, #0
 80061d6:	701a      	strb	r2, [r3, #0]

    for (i = 1; i<segments; i++) { // Increment (segments-1).
 80061d8:	2342      	movs	r3, #66	; 0x42
 80061da:	18fb      	adds	r3, r7, r3
 80061dc:	2201      	movs	r2, #1
 80061de:	801a      	strh	r2, [r3, #0]
 80061e0:	e0d6      	b.n	8006390 <mc_arc+0x48c>

      if (count < N_ARC_CORRECTION) {
 80061e2:	2341      	movs	r3, #65	; 0x41
 80061e4:	18fb      	adds	r3, r7, r3
 80061e6:	781b      	ldrb	r3, [r3, #0]
 80061e8:	2b0b      	cmp	r3, #11
 80061ea:	d82b      	bhi.n	8006244 <mc_arc+0x340>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
 80061ec:	69f9      	ldr	r1, [r7, #28]
 80061ee:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 80061f0:	f7fa fc50 	bl	8000a94 <__aeabi_fmul>
 80061f4:	1c03      	adds	r3, r0, #0
 80061f6:	1c1c      	adds	r4, r3, #0
 80061f8:	6a39      	ldr	r1, [r7, #32]
 80061fa:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 80061fc:	f7fa fc4a 	bl	8000a94 <__aeabi_fmul>
 8006200:	1c03      	adds	r3, r0, #0
 8006202:	1c19      	adds	r1, r3, #0
 8006204:	1c20      	adds	r0, r4, #0
 8006206:	f7fa f8c3 	bl	8000390 <__aeabi_fadd>
 800620a:	1c03      	adds	r3, r0, #0
 800620c:	61bb      	str	r3, [r7, #24]
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
 800620e:	6a39      	ldr	r1, [r7, #32]
 8006210:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8006212:	f7fa fc3f 	bl	8000a94 <__aeabi_fmul>
 8006216:	1c03      	adds	r3, r0, #0
 8006218:	1c1c      	adds	r4, r3, #0
 800621a:	69f9      	ldr	r1, [r7, #28]
 800621c:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 800621e:	f7fa fc39 	bl	8000a94 <__aeabi_fmul>
 8006222:	1c03      	adds	r3, r0, #0
 8006224:	1c19      	adds	r1, r3, #0
 8006226:	1c20      	adds	r0, r4, #0
 8006228:	f7fa fd54 	bl	8000cd4 <__aeabi_fsub>
 800622c:	1c03      	adds	r3, r0, #0
 800622e:	64fb      	str	r3, [r7, #76]	; 0x4c
        r_axis1 = r_axisi;
 8006230:	69bb      	ldr	r3, [r7, #24]
 8006232:	64bb      	str	r3, [r7, #72]	; 0x48
        count++;
 8006234:	2341      	movs	r3, #65	; 0x41
 8006236:	18fb      	adds	r3, r7, r3
 8006238:	781a      	ldrb	r2, [r3, #0]
 800623a:	2341      	movs	r3, #65	; 0x41
 800623c:	18fb      	adds	r3, r7, r3
 800623e:	3201      	adds	r2, #1
 8006240:	701a      	strb	r2, [r3, #0]
 8006242:	e069      	b.n	8006318 <mc_arc+0x414>
      } else {
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cosf(i*theta_per_segment);
 8006244:	2342      	movs	r3, #66	; 0x42
 8006246:	18fb      	adds	r3, r7, r3
 8006248:	881b      	ldrh	r3, [r3, #0]
 800624a:	0018      	movs	r0, r3
 800624c:	f7fa ff16 	bl	800107c <__aeabi_i2f>
 8006250:	1c03      	adds	r3, r0, #0
 8006252:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8006254:	1c18      	adds	r0, r3, #0
 8006256:	f7fa fc1d 	bl	8000a94 <__aeabi_fmul>
 800625a:	1c03      	adds	r3, r0, #0
 800625c:	1c18      	adds	r0, r3, #0
 800625e:	f006 fb15 	bl	800c88c <cosf>
 8006262:	1c03      	adds	r3, r0, #0
 8006264:	617b      	str	r3, [r7, #20]
        sin_Ti = sinf(i*theta_per_segment);
 8006266:	2342      	movs	r3, #66	; 0x42
 8006268:	18fb      	adds	r3, r7, r3
 800626a:	881b      	ldrh	r3, [r3, #0]
 800626c:	0018      	movs	r0, r3
 800626e:	f7fa ff05 	bl	800107c <__aeabi_i2f>
 8006272:	1c03      	adds	r3, r0, #0
 8006274:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8006276:	1c18      	adds	r0, r3, #0
 8006278:	f7fa fc0c 	bl	8000a94 <__aeabi_fmul>
 800627c:	1c03      	adds	r3, r0, #0
 800627e:	1c18      	adds	r0, r3, #0
 8006280:	f006 fb9c 	bl	800c9bc <sinf>
 8006284:	1c03      	adds	r3, r0, #0
 8006286:	613b      	str	r3, [r7, #16]
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
 8006288:	2364      	movs	r3, #100	; 0x64
 800628a:	18fb      	adds	r3, r7, r3
 800628c:	781b      	ldrb	r3, [r3, #0]
 800628e:	009b      	lsls	r3, r3, #2
 8006290:	683a      	ldr	r2, [r7, #0]
 8006292:	18d3      	adds	r3, r2, r3
 8006294:	681b      	ldr	r3, [r3, #0]
 8006296:	2280      	movs	r2, #128	; 0x80
 8006298:	0612      	lsls	r2, r2, #24
 800629a:	4053      	eors	r3, r2
 800629c:	6979      	ldr	r1, [r7, #20]
 800629e:	1c18      	adds	r0, r3, #0
 80062a0:	f7fa fbf8 	bl	8000a94 <__aeabi_fmul>
 80062a4:	1c03      	adds	r3, r0, #0
 80062a6:	1c1c      	adds	r4, r3, #0
 80062a8:	2368      	movs	r3, #104	; 0x68
 80062aa:	18fb      	adds	r3, r7, r3
 80062ac:	781b      	ldrb	r3, [r3, #0]
 80062ae:	009b      	lsls	r3, r3, #2
 80062b0:	683a      	ldr	r2, [r7, #0]
 80062b2:	18d3      	adds	r3, r2, r3
 80062b4:	681b      	ldr	r3, [r3, #0]
 80062b6:	6939      	ldr	r1, [r7, #16]
 80062b8:	1c18      	adds	r0, r3, #0
 80062ba:	f7fa fbeb 	bl	8000a94 <__aeabi_fmul>
 80062be:	1c03      	adds	r3, r0, #0
 80062c0:	1c19      	adds	r1, r3, #0
 80062c2:	1c20      	adds	r0, r4, #0
 80062c4:	f7fa f864 	bl	8000390 <__aeabi_fadd>
 80062c8:	1c03      	adds	r3, r0, #0
 80062ca:	64fb      	str	r3, [r7, #76]	; 0x4c
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
 80062cc:	2364      	movs	r3, #100	; 0x64
 80062ce:	18fb      	adds	r3, r7, r3
 80062d0:	781b      	ldrb	r3, [r3, #0]
 80062d2:	009b      	lsls	r3, r3, #2
 80062d4:	683a      	ldr	r2, [r7, #0]
 80062d6:	18d3      	adds	r3, r2, r3
 80062d8:	681b      	ldr	r3, [r3, #0]
 80062da:	2280      	movs	r2, #128	; 0x80
 80062dc:	0612      	lsls	r2, r2, #24
 80062de:	4053      	eors	r3, r2
 80062e0:	6939      	ldr	r1, [r7, #16]
 80062e2:	1c18      	adds	r0, r3, #0
 80062e4:	f7fa fbd6 	bl	8000a94 <__aeabi_fmul>
 80062e8:	1c03      	adds	r3, r0, #0
 80062ea:	1c1c      	adds	r4, r3, #0
 80062ec:	2368      	movs	r3, #104	; 0x68
 80062ee:	18fb      	adds	r3, r7, r3
 80062f0:	781b      	ldrb	r3, [r3, #0]
 80062f2:	009b      	lsls	r3, r3, #2
 80062f4:	683a      	ldr	r2, [r7, #0]
 80062f6:	18d3      	adds	r3, r2, r3
 80062f8:	681b      	ldr	r3, [r3, #0]
 80062fa:	6979      	ldr	r1, [r7, #20]
 80062fc:	1c18      	adds	r0, r3, #0
 80062fe:	f7fa fbc9 	bl	8000a94 <__aeabi_fmul>
 8006302:	1c03      	adds	r3, r0, #0
 8006304:	1c19      	adds	r1, r3, #0
 8006306:	1c20      	adds	r0, r4, #0
 8006308:	f7fa fce4 	bl	8000cd4 <__aeabi_fsub>
 800630c:	1c03      	adds	r3, r0, #0
 800630e:	64bb      	str	r3, [r7, #72]	; 0x48
        count = 0;
 8006310:	2341      	movs	r3, #65	; 0x41
 8006312:	18fb      	adds	r3, r7, r3
 8006314:	2200      	movs	r2, #0
 8006316:	701a      	strb	r2, [r3, #0]
      }

      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
 8006318:	2364      	movs	r3, #100	; 0x64
 800631a:	18fb      	adds	r3, r7, r3
 800631c:	781b      	ldrb	r3, [r3, #0]
 800631e:	009b      	lsls	r3, r3, #2
 8006320:	687a      	ldr	r2, [r7, #4]
 8006322:	18d4      	adds	r4, r2, r3
 8006324:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8006326:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8006328:	f7fa f832 	bl	8000390 <__aeabi_fadd>
 800632c:	1c03      	adds	r3, r0, #0
 800632e:	6023      	str	r3, [r4, #0]
      position[axis_1] = center_axis1 + r_axis1;
 8006330:	2368      	movs	r3, #104	; 0x68
 8006332:	18fb      	adds	r3, r7, r3
 8006334:	781b      	ldrb	r3, [r3, #0]
 8006336:	009b      	lsls	r3, r3, #2
 8006338:	687a      	ldr	r2, [r7, #4]
 800633a:	18d4      	adds	r4, r2, r3
 800633c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800633e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8006340:	f7fa f826 	bl	8000390 <__aeabi_fadd>
 8006344:	1c03      	adds	r3, r0, #0
 8006346:	6023      	str	r3, [r4, #0]
      position[axis_linear] += linear_per_segment;
 8006348:	236c      	movs	r3, #108	; 0x6c
 800634a:	18fb      	adds	r3, r7, r3
 800634c:	781b      	ldrb	r3, [r3, #0]
 800634e:	009b      	lsls	r3, r3, #2
 8006350:	687a      	ldr	r2, [r7, #4]
 8006352:	18d4      	adds	r4, r2, r3
 8006354:	236c      	movs	r3, #108	; 0x6c
 8006356:	18fb      	adds	r3, r7, r3
 8006358:	781b      	ldrb	r3, [r3, #0]
 800635a:	009b      	lsls	r3, r3, #2
 800635c:	687a      	ldr	r2, [r7, #4]
 800635e:	18d3      	adds	r3, r2, r3
 8006360:	681b      	ldr	r3, [r3, #0]
 8006362:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8006364:	1c18      	adds	r0, r3, #0
 8006366:	f7fa f813 	bl	8000390 <__aeabi_fadd>
 800636a:	1c03      	adds	r3, r0, #0
 800636c:	6023      	str	r3, [r4, #0]

      mc_line(position, pl_data);
 800636e:	68ba      	ldr	r2, [r7, #8]
 8006370:	687b      	ldr	r3, [r7, #4]
 8006372:	0011      	movs	r1, r2
 8006374:	0018      	movs	r0, r3
 8006376:	f7ff fd79 	bl	8005e6c <mc_line>

      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
 800637a:	4b14      	ldr	r3, [pc, #80]	; (80063cc <mc_arc+0x4c8>)
 800637c:	785b      	ldrb	r3, [r3, #1]
 800637e:	2b00      	cmp	r3, #0
 8006380:	d126      	bne.n	80063d0 <mc_arc+0x4cc>
    for (i = 1; i<segments; i++) { // Increment (segments-1).
 8006382:	2342      	movs	r3, #66	; 0x42
 8006384:	18fb      	adds	r3, r7, r3
 8006386:	881a      	ldrh	r2, [r3, #0]
 8006388:	2342      	movs	r3, #66	; 0x42
 800638a:	18fb      	adds	r3, r7, r3
 800638c:	3201      	adds	r2, #1
 800638e:	801a      	strh	r2, [r3, #0]
 8006390:	2342      	movs	r3, #66	; 0x42
 8006392:	18fa      	adds	r2, r7, r3
 8006394:	232e      	movs	r3, #46	; 0x2e
 8006396:	18fb      	adds	r3, r7, r3
 8006398:	8812      	ldrh	r2, [r2, #0]
 800639a:	881b      	ldrh	r3, [r3, #0]
 800639c:	429a      	cmp	r2, r3
 800639e:	d200      	bcs.n	80063a2 <mc_arc+0x49e>
 80063a0:	e71f      	b.n	80061e2 <mc_arc+0x2de>
    }
  }
  // Ensure last segment arrives at target location.
  mc_line(target, pl_data);
 80063a2:	68ba      	ldr	r2, [r7, #8]
 80063a4:	68fb      	ldr	r3, [r7, #12]
 80063a6:	0011      	movs	r1, r2
 80063a8:	0018      	movs	r0, r3
 80063aa:	f7ff fd5f 	bl	8005e6c <mc_line>
 80063ae:	e010      	b.n	80063d2 <mc_arc+0x4ce>
 80063b0:	a0b5ed8d 	.word	0xa0b5ed8d
 80063b4:	bea0c6f7 	.word	0xbea0c6f7
 80063b8:	54442d18 	.word	0x54442d18
 80063bc:	401921fb 	.word	0x401921fb
 80063c0:	3ea0c6f7 	.word	0x3ea0c6f7
 80063c4:	20000b44 	.word	0x20000b44
 80063c8:	3e2aaaab 	.word	0x3e2aaaab
 80063cc:	20000bb4 	.word	0x20000bb4
      if (sys.abort) { return; }
 80063d0:	46c0      	nop			; (mov r8, r8)
}
 80063d2:	46bd      	mov	sp, r7
 80063d4:	b014      	add	sp, #80	; 0x50
 80063d6:	bdb0      	pop	{r4, r5, r7, pc}

080063d8 <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds)
{
 80063d8:	b580      	push	{r7, lr}
 80063da:	b082      	sub	sp, #8
 80063dc:	af00      	add	r7, sp, #0
 80063de:	6078      	str	r0, [r7, #4]
  if (sys.state == STATE_CHECK_MODE) { return; }
 80063e0:	4b07      	ldr	r3, [pc, #28]	; (8006400 <mc_dwell+0x28>)
 80063e2:	781b      	ldrb	r3, [r3, #0]
 80063e4:	2b02      	cmp	r3, #2
 80063e6:	d007      	beq.n	80063f8 <mc_dwell+0x20>
  protocol_buffer_synchronize();
 80063e8:	f001 fca6 	bl	8007d38 <protocol_buffer_synchronize>
  delay_sec(seconds, DELAY_MODE_DWELL);
 80063ec:	687b      	ldr	r3, [r7, #4]
 80063ee:	2100      	movs	r1, #0
 80063f0:	1c18      	adds	r0, r3, #0
 80063f2:	f000 f9f1 	bl	80067d8 <delay_sec>
 80063f6:	e000      	b.n	80063fa <mc_dwell+0x22>
  if (sys.state == STATE_CHECK_MODE) { return; }
 80063f8:	46c0      	nop			; (mov r8, r8)
}
 80063fa:	46bd      	mov	sp, r7
 80063fc:	b002      	add	sp, #8
 80063fe:	bd80      	pop	{r7, pc}
 8006400:	20000bb4 	.word	0x20000bb4

08006404 <mc_homing_cycle>:

// Perform homing cycle to locate and set machine zero. Only '$H' executes this command.
// NOTE: There should be no motions in the buffer and Grbl must be in an idle state before
// executing the homing cycle. This prevents incorrect buffered plans after homing.
void mc_homing_cycle(uint8_t cycle_mask)
{
 8006404:	b580      	push	{r7, lr}
 8006406:	b082      	sub	sp, #8
 8006408:	af00      	add	r7, sp, #0
 800640a:	0002      	movs	r2, r0
 800640c:	1dfb      	adds	r3, r7, #7
 800640e:	701a      	strb	r2, [r3, #0]
      system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT);
      return;
    }
  #endif

  limits_disable(); // Disable hard limits pin change register for cycle duration
 8006410:	f7ff f960 	bl	80056d4 <limits_disable>
  #endif
  {
    // Search to engage all axes limit switches at faster homing seek rate.
    //limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
    #ifdef HOMING_CYCLE_1
      limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
 8006414:	2001      	movs	r0, #1
 8006416:	f7ff f9ff 	bl	8005818 <limits_go_home>
    #endif
    #ifdef HOMING_CYCLE_2
      limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
 800641a:	2002      	movs	r0, #2
 800641c:	f7ff f9fc 	bl	8005818 <limits_go_home>
    #endif
	#ifdef HOMING_CYCLE_3
      limits_go_home(HOMING_CYCLE_3); // Homing cycle 3
 8006420:	2008      	movs	r0, #8
 8006422:	f7ff f9f9 	bl	8005818 <limits_go_home>
	#endif
  }

  protocol_execute_realtime(); // Check for reset and set system abort.
 8006426:	f001 fcab 	bl	8007d80 <protocol_execute_realtime>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
 800642a:	4b07      	ldr	r3, [pc, #28]	; (8006448 <mc_homing_cycle+0x44>)
 800642c:	785b      	ldrb	r3, [r3, #1]
 800642e:	2b00      	cmp	r3, #0
 8006430:	d106      	bne.n	8006440 <mc_homing_cycle+0x3c>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Sync gcode parser and planner positions to homed position.
  gc_sync_position();
 8006432:	f7fd fb17 	bl	8003a64 <gc_sync_position>
  plan_sync_position();
 8006436:	f001 f8f1 	bl	800761c <plan_sync_position>

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
 800643a:	f7ff f8e1 	bl	8005600 <limits_init>
 800643e:	e000      	b.n	8006442 <mc_homing_cycle+0x3e>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
 8006440:	46c0      	nop			; (mov r8, r8)
}
 8006442:	46bd      	mov	sp, r7
 8006444:	b002      	add	sp, #8
 8006446:	bd80      	pop	{r7, pc}
 8006448:	20000bb4 	.word	0x20000bb4

0800644c <mc_probe_cycle>:


// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
 800644c:	b590      	push	{r4, r7, lr}
 800644e:	b087      	sub	sp, #28
 8006450:	af00      	add	r7, sp, #0
 8006452:	60f8      	str	r0, [r7, #12]
 8006454:	60b9      	str	r1, [r7, #8]
 8006456:	1dfb      	adds	r3, r7, #7
 8006458:	701a      	strb	r2, [r3, #0]
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
 800645a:	4b42      	ldr	r3, [pc, #264]	; (8006564 <mc_probe_cycle+0x118>)
 800645c:	781b      	ldrb	r3, [r3, #0]
 800645e:	2b02      	cmp	r3, #2
 8006460:	d101      	bne.n	8006466 <mc_probe_cycle+0x1a>
 8006462:	2300      	movs	r3, #0
 8006464:	e079      	b.n	800655a <mc_probe_cycle+0x10e>

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
 8006466:	f001 fc67 	bl	8007d38 <protocol_buffer_synchronize>
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
 800646a:	4b3e      	ldr	r3, [pc, #248]	; (8006564 <mc_probe_cycle+0x118>)
 800646c:	785b      	ldrb	r3, [r3, #1]
 800646e:	2b00      	cmp	r3, #0
 8006470:	d001      	beq.n	8006476 <mc_probe_cycle+0x2a>
 8006472:	2302      	movs	r3, #2
 8006474:	e071      	b.n	800655a <mc_probe_cycle+0x10e>

  // Initialize probing control variables
  uint8_t is_probe_away = bit_istrue(parser_flags, GC_PARSER_PROBE_IS_AWAY);
 8006476:	1dfb      	adds	r3, r7, #7
 8006478:	781b      	ldrb	r3, [r3, #0]
 800647a:	2208      	movs	r2, #8
 800647c:	4013      	ands	r3, r2
 800647e:	1e5a      	subs	r2, r3, #1
 8006480:	4193      	sbcs	r3, r2
 8006482:	b2da      	uxtb	r2, r3
 8006484:	2317      	movs	r3, #23
 8006486:	18fb      	adds	r3, r7, r3
 8006488:	701a      	strb	r2, [r3, #0]
  uint8_t is_no_error = bit_istrue(parser_flags, GC_PARSER_PROBE_IS_NO_ERROR);
 800648a:	1dfb      	adds	r3, r7, #7
 800648c:	781b      	ldrb	r3, [r3, #0]
 800648e:	2210      	movs	r2, #16
 8006490:	4013      	ands	r3, r2
 8006492:	1e5a      	subs	r2, r3, #1
 8006494:	4193      	sbcs	r3, r2
 8006496:	b2da      	uxtb	r2, r3
 8006498:	2316      	movs	r3, #22
 800649a:	18fb      	adds	r3, r7, r3
 800649c:	701a      	strb	r2, [r3, #0]
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.
 800649e:	4b31      	ldr	r3, [pc, #196]	; (8006564 <mc_probe_cycle+0x118>)
 80064a0:	2200      	movs	r2, #0
 80064a2:	715a      	strb	r2, [r3, #5]
  probe_configure_invert_mask(is_probe_away);
 80064a4:	2317      	movs	r3, #23
 80064a6:	18fb      	adds	r3, r7, r3
 80064a8:	781b      	ldrb	r3, [r3, #0]
 80064aa:	0018      	movs	r0, r3
 80064ac:	f001 fab8 	bl	8007a20 <probe_configure_invert_mask>

  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
 80064b0:	f001 fada 	bl	8007a68 <probe_get_state>
 80064b4:	1e03      	subs	r3, r0, #0
 80064b6:	d009      	beq.n	80064cc <mc_probe_cycle+0x80>
    system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_INITIAL);
 80064b8:	2004      	movs	r0, #4
 80064ba:	f005 fe27 	bl	800c10c <system_set_exec_alarm>
    protocol_execute_realtime();
 80064be:	f001 fc5f 	bl	8007d80 <protocol_execute_realtime>
    probe_configure_invert_mask(false); // Re-initialize invert mask before returning.
 80064c2:	2000      	movs	r0, #0
 80064c4:	f001 faac 	bl	8007a20 <probe_configure_invert_mask>
    return(GC_PROBE_FAIL_INIT); // Nothing else to do but bail.
 80064c8:	2302      	movs	r3, #2
 80064ca:	e046      	b.n	800655a <mc_probe_cycle+0x10e>
  }

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  mc_line(target, pl_data);
 80064cc:	68ba      	ldr	r2, [r7, #8]
 80064ce:	68fb      	ldr	r3, [r7, #12]
 80064d0:	0011      	movs	r1, r2
 80064d2:	0018      	movs	r0, r3
 80064d4:	f7ff fcca 	bl	8005e6c <mc_line>

  // Activate the probing state monitor in the stepper module.
  sys_probe_state = PROBE_ACTIVE;
 80064d8:	4b23      	ldr	r3, [pc, #140]	; (8006568 <mc_probe_cycle+0x11c>)
 80064da:	2201      	movs	r2, #1
 80064dc:	701a      	strb	r2, [r3, #0]

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
 80064de:	2002      	movs	r0, #2
 80064e0:	f005 fde0 	bl	800c0a4 <system_set_exec_state_flag>
  do {
    protocol_execute_realtime();
 80064e4:	f001 fc4c 	bl	8007d80 <protocol_execute_realtime>
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
 80064e8:	4b1e      	ldr	r3, [pc, #120]	; (8006564 <mc_probe_cycle+0x118>)
 80064ea:	785b      	ldrb	r3, [r3, #1]
 80064ec:	2b00      	cmp	r3, #0
 80064ee:	d001      	beq.n	80064f4 <mc_probe_cycle+0xa8>
 80064f0:	2302      	movs	r3, #2
 80064f2:	e032      	b.n	800655a <mc_probe_cycle+0x10e>
  } while (sys.state != STATE_IDLE);
 80064f4:	4b1b      	ldr	r3, [pc, #108]	; (8006564 <mc_probe_cycle+0x118>)
 80064f6:	781b      	ldrb	r3, [r3, #0]
 80064f8:	2b00      	cmp	r3, #0
 80064fa:	d1f3      	bne.n	80064e4 <mc_probe_cycle+0x98>

  // Probing cycle complete!

  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys_probe_state == PROBE_ACTIVE) {
 80064fc:	4b1a      	ldr	r3, [pc, #104]	; (8006568 <mc_probe_cycle+0x11c>)
 80064fe:	781b      	ldrb	r3, [r3, #0]
 8006500:	b2db      	uxtb	r3, r3
 8006502:	2b01      	cmp	r3, #1
 8006504:	d10f      	bne.n	8006526 <mc_probe_cycle+0xda>
    if (is_no_error) { memcpy(sys_probe_position, sys_position, sizeof(sys_position)); }
 8006506:	2316      	movs	r3, #22
 8006508:	18fb      	adds	r3, r7, r3
 800650a:	781b      	ldrb	r3, [r3, #0]
 800650c:	2b00      	cmp	r3, #0
 800650e:	d006      	beq.n	800651e <mc_probe_cycle+0xd2>
 8006510:	4b16      	ldr	r3, [pc, #88]	; (800656c <mc_probe_cycle+0x120>)
 8006512:	4a17      	ldr	r2, [pc, #92]	; (8006570 <mc_probe_cycle+0x124>)
 8006514:	ca13      	ldmia	r2!, {r0, r1, r4}
 8006516:	c313      	stmia	r3!, {r0, r1, r4}
 8006518:	6812      	ldr	r2, [r2, #0]
 800651a:	601a      	str	r2, [r3, #0]
 800651c:	e006      	b.n	800652c <mc_probe_cycle+0xe0>
    else { system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_CONTACT); }
 800651e:	2005      	movs	r0, #5
 8006520:	f005 fdf4 	bl	800c10c <system_set_exec_alarm>
 8006524:	e002      	b.n	800652c <mc_probe_cycle+0xe0>
  } else {
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
 8006526:	4b0f      	ldr	r3, [pc, #60]	; (8006564 <mc_probe_cycle+0x118>)
 8006528:	2201      	movs	r2, #1
 800652a:	715a      	strb	r2, [r3, #5]
  }
  sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
 800652c:	4b0e      	ldr	r3, [pc, #56]	; (8006568 <mc_probe_cycle+0x11c>)
 800652e:	2200      	movs	r2, #0
 8006530:	701a      	strb	r2, [r3, #0]
  probe_configure_invert_mask(false); // Re-initialize invert mask.
 8006532:	2000      	movs	r0, #0
 8006534:	f001 fa74 	bl	8007a20 <probe_configure_invert_mask>
  protocol_execute_realtime();   // Check and execute run-time commands
 8006538:	f001 fc22 	bl	8007d80 <protocol_execute_realtime>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reset step segment buffer.
 800653c:	f004 fa20 	bl	800a980 <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
 8006540:	f000 fbfa 	bl	8006d38 <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
 8006544:	f001 f86a 	bl	800761c <plan_sync_position>

  #ifdef MESSAGE_PROBE_COORDINATES
    // All done! Output the probe position as message.
    report_probe_parameters();
 8006548:	f002 fb34 	bl	8008bb4 <report_probe_parameters>
  #endif

  if (sys.probe_succeeded) { return(GC_PROBE_FOUND); } // Successful probe cycle.
 800654c:	4b05      	ldr	r3, [pc, #20]	; (8006564 <mc_probe_cycle+0x118>)
 800654e:	795b      	ldrb	r3, [r3, #5]
 8006550:	2b00      	cmp	r3, #0
 8006552:	d001      	beq.n	8006558 <mc_probe_cycle+0x10c>
 8006554:	2301      	movs	r3, #1
 8006556:	e000      	b.n	800655a <mc_probe_cycle+0x10e>
  else { return(GC_PROBE_FAIL_END); } // Failed to trigger probe within travel. With or without error.
 8006558:	2300      	movs	r3, #0
}
 800655a:	0018      	movs	r0, r3
 800655c:	46bd      	mov	sp, r7
 800655e:	b007      	add	sp, #28
 8006560:	bd90      	pop	{r4, r7, pc}
 8006562:	46c0      	nop			; (mov r8, r8)
 8006564:	20000bb4 	.word	0x20000bb4
 8006568:	20000bca 	.word	0x20000bca
 800656c:	20000bcc 	.word	0x20000bcc
 8006570:	20000bdc 	.word	0x20000bdc

08006574 <mc_reset>:
// active processes in the system. This also checks if a system reset is issued while Grbl
// is in a motion state. If so, kills the steppers and sets the system alarm to flag position
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
 8006574:	b580      	push	{r7, lr}
 8006576:	af00      	add	r7, sp, #0
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
 8006578:	4b17      	ldr	r3, [pc, #92]	; (80065d8 <mc_reset+0x64>)
 800657a:	781b      	ldrb	r3, [r3, #0]
 800657c:	b2db      	uxtb	r3, r3
 800657e:	001a      	movs	r2, r3
 8006580:	2310      	movs	r3, #16
 8006582:	4013      	ands	r3, r2
 8006584:	d124      	bne.n	80065d0 <mc_reset+0x5c>
    system_set_exec_state_flag(EXEC_RESET);
 8006586:	2010      	movs	r0, #16
 8006588:	f005 fd8c 	bl	800c0a4 <system_set_exec_state_flag>

    // Kill spindle and coolant.
    spindle_stop();
 800658c:	f003 fd52 	bl	800a034 <spindle_stop>
    coolant_stop();
 8006590:	f7fd f963 	bl	800385a <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)) ||
 8006594:	4b11      	ldr	r3, [pc, #68]	; (80065dc <mc_reset+0x68>)
 8006596:	781b      	ldrb	r3, [r3, #0]
 8006598:	001a      	movs	r2, r3
 800659a:	232c      	movs	r3, #44	; 0x2c
 800659c:	4013      	ands	r3, r2
 800659e:	d105      	bne.n	80065ac <mc_reset+0x38>
    		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
 80065a0:	4b0e      	ldr	r3, [pc, #56]	; (80065dc <mc_reset+0x68>)
 80065a2:	791b      	ldrb	r3, [r3, #4]
 80065a4:	001a      	movs	r2, r3
 80065a6:	2306      	movs	r3, #6
 80065a8:	4013      	ands	r3, r2
    if ((sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)) ||
 80065aa:	d011      	beq.n	80065d0 <mc_reset+0x5c>
      if (sys.state == STATE_HOMING) {
 80065ac:	4b0b      	ldr	r3, [pc, #44]	; (80065dc <mc_reset+0x68>)
 80065ae:	781b      	ldrb	r3, [r3, #0]
 80065b0:	2b04      	cmp	r3, #4
 80065b2:	d108      	bne.n	80065c6 <mc_reset+0x52>
        if (!sys_rt_exec_alarm) { system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
 80065b4:	4b0a      	ldr	r3, [pc, #40]	; (80065e0 <mc_reset+0x6c>)
 80065b6:	781b      	ldrb	r3, [r3, #0]
 80065b8:	b2db      	uxtb	r3, r3
 80065ba:	2b00      	cmp	r3, #0
 80065bc:	d106      	bne.n	80065cc <mc_reset+0x58>
 80065be:	2006      	movs	r0, #6
 80065c0:	f005 fda4 	bl	800c10c <system_set_exec_alarm>
 80065c4:	e002      	b.n	80065cc <mc_reset+0x58>
      }
      else { system_set_exec_alarm(EXEC_ALARM_ABORT_CYCLE); }
 80065c6:	2003      	movs	r0, #3
 80065c8:	f005 fda0 	bl	800c10c <system_set_exec_alarm>
      st_go_idle(); // Force kill steppers. Position has likely been lost.
 80065cc:	f003 fec4 	bl	800a358 <st_go_idle>
    }
  }
}
 80065d0:	46c0      	nop			; (mov r8, r8)
 80065d2:	46bd      	mov	sp, r7
 80065d4:	bd80      	pop	{r7, pc}
 80065d6:	46c0      	nop			; (mov r8, r8)
 80065d8:	20000bc9 	.word	0x20000bc9
 80065dc:	20000bb4 	.word	0x20000bb4
 80065e0:	20000bec 	.word	0x20000bec

080065e4 <read_float>:
// CNC applications, the typical decimal value is expected to be in the range of E0 to E-4.
// Scientific notation is officially not supported by g-code, and the 'E' character may
// be a g-code word on some CNC systems. So, 'E' notation will not be recognized.
// NOTE: Thanks to Radu-Eosif Mihailescu for identifying the issues with using strtod().
uint8_t read_float(char *line, uint8_t *char_counter, float *float_ptr)
{
 80065e4:	b580      	push	{r7, lr}
 80065e6:	b08c      	sub	sp, #48	; 0x30
 80065e8:	af00      	add	r7, sp, #0
 80065ea:	60f8      	str	r0, [r7, #12]
 80065ec:	60b9      	str	r1, [r7, #8]
 80065ee:	607a      	str	r2, [r7, #4]
  char *ptr = line + *char_counter;
 80065f0:	68bb      	ldr	r3, [r7, #8]
 80065f2:	781b      	ldrb	r3, [r3, #0]
 80065f4:	001a      	movs	r2, r3
 80065f6:	68fb      	ldr	r3, [r7, #12]
 80065f8:	189b      	adds	r3, r3, r2
 80065fa:	62fb      	str	r3, [r7, #44]	; 0x2c
  unsigned char c;

  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
 80065fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80065fe:	1c5a      	adds	r2, r3, #1
 8006600:	62fa      	str	r2, [r7, #44]	; 0x2c
 8006602:	222b      	movs	r2, #43	; 0x2b
 8006604:	18ba      	adds	r2, r7, r2
 8006606:	781b      	ldrb	r3, [r3, #0]
 8006608:	7013      	strb	r3, [r2, #0]

  // Capture initial positive/minus character
  bool isnegative = false;
 800660a:	2300      	movs	r3, #0
 800660c:	627b      	str	r3, [r7, #36]	; 0x24
  if (c == '-') {
 800660e:	232b      	movs	r3, #43	; 0x2b
 8006610:	18fb      	adds	r3, r7, r3
 8006612:	781b      	ldrb	r3, [r3, #0]
 8006614:	2b2d      	cmp	r3, #45	; 0x2d
 8006616:	d109      	bne.n	800662c <read_float+0x48>
    isnegative = true;
 8006618:	2301      	movs	r3, #1
 800661a:	627b      	str	r3, [r7, #36]	; 0x24
    c = *ptr++;
 800661c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800661e:	1c5a      	adds	r2, r3, #1
 8006620:	62fa      	str	r2, [r7, #44]	; 0x2c
 8006622:	222b      	movs	r2, #43	; 0x2b
 8006624:	18ba      	adds	r2, r7, r2
 8006626:	781b      	ldrb	r3, [r3, #0]
 8006628:	7013      	strb	r3, [r2, #0]
 800662a:	e00b      	b.n	8006644 <read_float+0x60>
  } else if (c == '+') {
 800662c:	232b      	movs	r3, #43	; 0x2b
 800662e:	18fb      	adds	r3, r7, r3
 8006630:	781b      	ldrb	r3, [r3, #0]
 8006632:	2b2b      	cmp	r3, #43	; 0x2b
 8006634:	d106      	bne.n	8006644 <read_float+0x60>
    c = *ptr++;
 8006636:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006638:	1c5a      	adds	r2, r3, #1
 800663a:	62fa      	str	r2, [r7, #44]	; 0x2c
 800663c:	222b      	movs	r2, #43	; 0x2b
 800663e:	18ba      	adds	r2, r7, r2
 8006640:	781b      	ldrb	r3, [r3, #0]
 8006642:	7013      	strb	r3, [r2, #0]
  }

  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
 8006644:	2300      	movs	r3, #0
 8006646:	623b      	str	r3, [r7, #32]
  int8_t exp = 0;
 8006648:	231f      	movs	r3, #31
 800664a:	18fb      	adds	r3, r7, r3
 800664c:	2200      	movs	r2, #0
 800664e:	701a      	strb	r2, [r3, #0]
  uint8_t ndigit = 0;
 8006650:	231e      	movs	r3, #30
 8006652:	18fb      	adds	r3, r7, r3
 8006654:	2200      	movs	r2, #0
 8006656:	701a      	strb	r2, [r3, #0]
  bool isdecimal = false;
 8006658:	2300      	movs	r3, #0
 800665a:	61bb      	str	r3, [r7, #24]
  while(1) {
    c -= '0';
 800665c:	232b      	movs	r3, #43	; 0x2b
 800665e:	18fb      	adds	r3, r7, r3
 8006660:	222b      	movs	r2, #43	; 0x2b
 8006662:	18ba      	adds	r2, r7, r2
 8006664:	7812      	ldrb	r2, [r2, #0]
 8006666:	3a30      	subs	r2, #48	; 0x30
 8006668:	701a      	strb	r2, [r3, #0]
    if (c <= 9) {
 800666a:	232b      	movs	r3, #43	; 0x2b
 800666c:	18fb      	adds	r3, r7, r3
 800666e:	781b      	ldrb	r3, [r3, #0]
 8006670:	2b09      	cmp	r3, #9
 8006672:	d831      	bhi.n	80066d8 <read_float+0xf4>
      ndigit++;
 8006674:	231e      	movs	r3, #30
 8006676:	18fb      	adds	r3, r7, r3
 8006678:	781a      	ldrb	r2, [r3, #0]
 800667a:	231e      	movs	r3, #30
 800667c:	18fb      	adds	r3, r7, r3
 800667e:	3201      	adds	r2, #1
 8006680:	701a      	strb	r2, [r3, #0]
      if (ndigit <= MAX_INT_DIGITS) {
 8006682:	231e      	movs	r3, #30
 8006684:	18fb      	adds	r3, r7, r3
 8006686:	781b      	ldrb	r3, [r3, #0]
 8006688:	2b08      	cmp	r3, #8
 800668a:	d817      	bhi.n	80066bc <read_float+0xd8>
        if (isdecimal) { exp--; }
 800668c:	69bb      	ldr	r3, [r7, #24]
 800668e:	2b00      	cmp	r3, #0
 8006690:	d009      	beq.n	80066a6 <read_float+0xc2>
 8006692:	231f      	movs	r3, #31
 8006694:	18fb      	adds	r3, r7, r3
 8006696:	781b      	ldrb	r3, [r3, #0]
 8006698:	b25b      	sxtb	r3, r3
 800669a:	b2db      	uxtb	r3, r3
 800669c:	3b01      	subs	r3, #1
 800669e:	b2da      	uxtb	r2, r3
 80066a0:	231f      	movs	r3, #31
 80066a2:	18fb      	adds	r3, r7, r3
 80066a4:	701a      	strb	r2, [r3, #0]
        intval = (((intval << 2) + intval) << 1) + c; // intval*10 + c
 80066a6:	6a3b      	ldr	r3, [r7, #32]
 80066a8:	009a      	lsls	r2, r3, #2
 80066aa:	6a3b      	ldr	r3, [r7, #32]
 80066ac:	18d3      	adds	r3, r2, r3
 80066ae:	005a      	lsls	r2, r3, #1
 80066b0:	232b      	movs	r3, #43	; 0x2b
 80066b2:	18fb      	adds	r3, r7, r3
 80066b4:	781b      	ldrb	r3, [r3, #0]
 80066b6:	18d3      	adds	r3, r2, r3
 80066b8:	623b      	str	r3, [r7, #32]
 80066ba:	e017      	b.n	80066ec <read_float+0x108>
      } else {
        if (!(isdecimal)) { exp++; }  // Drop overflow digits
 80066bc:	69bb      	ldr	r3, [r7, #24]
 80066be:	2b00      	cmp	r3, #0
 80066c0:	d114      	bne.n	80066ec <read_float+0x108>
 80066c2:	231f      	movs	r3, #31
 80066c4:	18fb      	adds	r3, r7, r3
 80066c6:	781b      	ldrb	r3, [r3, #0]
 80066c8:	b25b      	sxtb	r3, r3
 80066ca:	b2db      	uxtb	r3, r3
 80066cc:	3301      	adds	r3, #1
 80066ce:	b2da      	uxtb	r2, r3
 80066d0:	231f      	movs	r3, #31
 80066d2:	18fb      	adds	r3, r7, r3
 80066d4:	701a      	strb	r2, [r3, #0]
 80066d6:	e009      	b.n	80066ec <read_float+0x108>
      }
    } else if (c == (('.'-'0') & 0xff)  &&  !(isdecimal)) {
 80066d8:	232b      	movs	r3, #43	; 0x2b
 80066da:	18fb      	adds	r3, r7, r3
 80066dc:	781b      	ldrb	r3, [r3, #0]
 80066de:	2bfe      	cmp	r3, #254	; 0xfe
 80066e0:	d10c      	bne.n	80066fc <read_float+0x118>
 80066e2:	69bb      	ldr	r3, [r7, #24]
 80066e4:	2b00      	cmp	r3, #0
 80066e6:	d109      	bne.n	80066fc <read_float+0x118>
      isdecimal = true;
 80066e8:	2301      	movs	r3, #1
 80066ea:	61bb      	str	r3, [r7, #24]
    } else {
      break;
    }
    c = *ptr++;
 80066ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80066ee:	1c5a      	adds	r2, r3, #1
 80066f0:	62fa      	str	r2, [r7, #44]	; 0x2c
 80066f2:	222b      	movs	r2, #43	; 0x2b
 80066f4:	18ba      	adds	r2, r7, r2
 80066f6:	781b      	ldrb	r3, [r3, #0]
 80066f8:	7013      	strb	r3, [r2, #0]
    c -= '0';
 80066fa:	e7af      	b.n	800665c <read_float+0x78>
  }

  // Return if no digits have been read.
  if (!ndigit) { return(false); };
 80066fc:	231e      	movs	r3, #30
 80066fe:	18fb      	adds	r3, r7, r3
 8006700:	781b      	ldrb	r3, [r3, #0]
 8006702:	2b00      	cmp	r3, #0
 8006704:	d101      	bne.n	800670a <read_float+0x126>
 8006706:	2300      	movs	r3, #0
 8006708:	e05b      	b.n	80067c2 <read_float+0x1de>

  // Convert integer into floating point.
  float fval;
  fval = (float)intval;
 800670a:	6a38      	ldr	r0, [r7, #32]
 800670c:	f7fa fd06 	bl	800111c <__aeabi_ui2f>
 8006710:	1c03      	adds	r3, r0, #0
 8006712:	617b      	str	r3, [r7, #20]

  // Apply decimal. Should perform no more than two floating point multiplications for the
  // expected range of E0 to E-4.
  if (fval != 0) {
 8006714:	2100      	movs	r1, #0
 8006716:	6978      	ldr	r0, [r7, #20]
 8006718:	f7f9 fdd6 	bl	80002c8 <__aeabi_fcmpeq>
 800671c:	1e03      	subs	r3, r0, #0
 800671e:	d13a      	bne.n	8006796 <read_float+0x1b2>
    while (exp <= -2) {
 8006720:	e00d      	b.n	800673e <read_float+0x15a>
      fval *= 0.01f;
 8006722:	492a      	ldr	r1, [pc, #168]	; (80067cc <read_float+0x1e8>)
 8006724:	6978      	ldr	r0, [r7, #20]
 8006726:	f7fa f9b5 	bl	8000a94 <__aeabi_fmul>
 800672a:	1c03      	adds	r3, r0, #0
 800672c:	617b      	str	r3, [r7, #20]
      exp += 2;
 800672e:	231f      	movs	r3, #31
 8006730:	18fb      	adds	r3, r7, r3
 8006732:	781b      	ldrb	r3, [r3, #0]
 8006734:	3302      	adds	r3, #2
 8006736:	b2da      	uxtb	r2, r3
 8006738:	231f      	movs	r3, #31
 800673a:	18fb      	adds	r3, r7, r3
 800673c:	701a      	strb	r2, [r3, #0]
    while (exp <= -2) {
 800673e:	231f      	movs	r3, #31
 8006740:	18fb      	adds	r3, r7, r3
 8006742:	781b      	ldrb	r3, [r3, #0]
 8006744:	b25b      	sxtb	r3, r3
 8006746:	3301      	adds	r3, #1
 8006748:	dbeb      	blt.n	8006722 <read_float+0x13e>
    }
    if (exp < 0) {
 800674a:	231f      	movs	r3, #31
 800674c:	18fb      	adds	r3, r7, r3
 800674e:	781b      	ldrb	r3, [r3, #0]
 8006750:	2b7f      	cmp	r3, #127	; 0x7f
 8006752:	d906      	bls.n	8006762 <read_float+0x17e>
      fval *= 0.1f;
 8006754:	491e      	ldr	r1, [pc, #120]	; (80067d0 <read_float+0x1ec>)
 8006756:	6978      	ldr	r0, [r7, #20]
 8006758:	f7fa f99c 	bl	8000a94 <__aeabi_fmul>
 800675c:	1c03      	adds	r3, r0, #0
 800675e:	617b      	str	r3, [r7, #20]
 8006760:	e019      	b.n	8006796 <read_float+0x1b2>
    } else if (exp > 0) {
 8006762:	231f      	movs	r3, #31
 8006764:	18fb      	adds	r3, r7, r3
 8006766:	781b      	ldrb	r3, [r3, #0]
 8006768:	b25b      	sxtb	r3, r3
 800676a:	2b00      	cmp	r3, #0
 800676c:	dd13      	ble.n	8006796 <read_float+0x1b2>
      do {
        fval *= 10.0f;
 800676e:	4919      	ldr	r1, [pc, #100]	; (80067d4 <read_float+0x1f0>)
 8006770:	6978      	ldr	r0, [r7, #20]
 8006772:	f7fa f98f 	bl	8000a94 <__aeabi_fmul>
 8006776:	1c03      	adds	r3, r0, #0
 8006778:	617b      	str	r3, [r7, #20]
      } while (--exp > 0);
 800677a:	231f      	movs	r3, #31
 800677c:	18fb      	adds	r3, r7, r3
 800677e:	781b      	ldrb	r3, [r3, #0]
 8006780:	3b01      	subs	r3, #1
 8006782:	b2da      	uxtb	r2, r3
 8006784:	231f      	movs	r3, #31
 8006786:	18fb      	adds	r3, r7, r3
 8006788:	701a      	strb	r2, [r3, #0]
 800678a:	231f      	movs	r3, #31
 800678c:	18fb      	adds	r3, r7, r3
 800678e:	781b      	ldrb	r3, [r3, #0]
 8006790:	b25b      	sxtb	r3, r3
 8006792:	2b00      	cmp	r3, #0
 8006794:	dceb      	bgt.n	800676e <read_float+0x18a>
    }
  }

  // Assign floating point value with correct sign.
  if (isnegative) {
 8006796:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006798:	2b00      	cmp	r3, #0
 800679a:	d006      	beq.n	80067aa <read_float+0x1c6>
    *float_ptr = -fval;
 800679c:	697b      	ldr	r3, [r7, #20]
 800679e:	2280      	movs	r2, #128	; 0x80
 80067a0:	0612      	lsls	r2, r2, #24
 80067a2:	405a      	eors	r2, r3
 80067a4:	687b      	ldr	r3, [r7, #4]
 80067a6:	601a      	str	r2, [r3, #0]
 80067a8:	e002      	b.n	80067b0 <read_float+0x1cc>
  } else {
    *float_ptr = fval;
 80067aa:	687b      	ldr	r3, [r7, #4]
 80067ac:	697a      	ldr	r2, [r7, #20]
 80067ae:	601a      	str	r2, [r3, #0]
  }

  *char_counter = ptr - line - 1; // Set char_counter to next statement
 80067b0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80067b2:	68fb      	ldr	r3, [r7, #12]
 80067b4:	1ad3      	subs	r3, r2, r3
 80067b6:	b2db      	uxtb	r3, r3
 80067b8:	3b01      	subs	r3, #1
 80067ba:	b2da      	uxtb	r2, r3
 80067bc:	68bb      	ldr	r3, [r7, #8]
 80067be:	701a      	strb	r2, [r3, #0]

  return(true);
 80067c0:	2301      	movs	r3, #1
}
 80067c2:	0018      	movs	r0, r3
 80067c4:	46bd      	mov	sp, r7
 80067c6:	b00c      	add	sp, #48	; 0x30
 80067c8:	bd80      	pop	{r7, pc}
 80067ca:	46c0      	nop			; (mov r8, r8)
 80067cc:	3c23d70a 	.word	0x3c23d70a
 80067d0:	3dcccccd 	.word	0x3dcccccd
 80067d4:	41200000 	.word	0x41200000

080067d8 <delay_sec>:


// Non-blocking delay function used for general operation and suspend features.
void delay_sec(float seconds, uint8_t mode)
{
 80067d8:	b590      	push	{r4, r7, lr}
 80067da:	b085      	sub	sp, #20
 80067dc:	af00      	add	r7, sp, #0
 80067de:	6078      	str	r0, [r7, #4]
 80067e0:	000a      	movs	r2, r1
 80067e2:	1cfb      	adds	r3, r7, #3
 80067e4:	701a      	strb	r2, [r3, #0]
	uint16_t i = (uint16_t)ceilf(1000 / DWELL_TIME_STEP*seconds);
 80067e6:	491b      	ldr	r1, [pc, #108]	; (8006854 <delay_sec+0x7c>)
 80067e8:	6878      	ldr	r0, [r7, #4]
 80067ea:	f7fa f953 	bl	8000a94 <__aeabi_fmul>
 80067ee:	1c03      	adds	r3, r0, #0
 80067f0:	1c18      	adds	r0, r3, #0
 80067f2:	f006 f80d 	bl	800c810 <ceilf>
 80067f6:	1c03      	adds	r3, r0, #0
 80067f8:	220e      	movs	r2, #14
 80067fa:	18bc      	adds	r4, r7, r2
 80067fc:	1c18      	adds	r0, r3, #0
 80067fe:	f7f9 fd91 	bl	8000324 <__aeabi_f2uiz>
 8006802:	0003      	movs	r3, r0
 8006804:	8023      	strh	r3, [r4, #0]
	while (i-- > 0) {
 8006806:	e015      	b.n	8006834 <delay_sec+0x5c>
		if (sys.abort) { return; }
 8006808:	4b13      	ldr	r3, [pc, #76]	; (8006858 <delay_sec+0x80>)
 800680a:	785b      	ldrb	r3, [r3, #1]
 800680c:	2b00      	cmp	r3, #0
 800680e:	d11b      	bne.n	8006848 <delay_sec+0x70>
		if (mode == DELAY_MODE_DWELL) {
 8006810:	1cfb      	adds	r3, r7, #3
 8006812:	781b      	ldrb	r3, [r3, #0]
 8006814:	2b00      	cmp	r3, #0
 8006816:	d102      	bne.n	800681e <delay_sec+0x46>
			protocol_execute_realtime();
 8006818:	f001 fab2 	bl	8007d80 <protocol_execute_realtime>
 800681c:	e007      	b.n	800682e <delay_sec+0x56>
		} else { // DELAY_MODE_SYS_SUSPEND
		  // Execute rt_system() only to avoid nesting suspend loops.
		  protocol_exec_rt_system();
 800681e:	f001 fabf 	bl	8007da0 <protocol_exec_rt_system>
		  if (sys.suspend & SUSPEND_RESTART_RETRACT) { return; } // Bail, if safety door reopens.
 8006822:	4b0d      	ldr	r3, [pc, #52]	; (8006858 <delay_sec+0x80>)
 8006824:	789b      	ldrb	r3, [r3, #2]
 8006826:	001a      	movs	r2, r3
 8006828:	2302      	movs	r3, #2
 800682a:	4013      	ands	r3, r2
 800682c:	d10e      	bne.n	800684c <delay_sec+0x74>
		}
		_delay_ms(DWELL_TIME_STEP); // Delay DWELL_TIME_STEP increment
 800682e:	2032      	movs	r0, #50	; 0x32
 8006830:	f005 fdfe 	bl	800c430 <_delay_ms>
	while (i-- > 0) {
 8006834:	230e      	movs	r3, #14
 8006836:	18fb      	adds	r3, r7, r3
 8006838:	881b      	ldrh	r3, [r3, #0]
 800683a:	220e      	movs	r2, #14
 800683c:	18ba      	adds	r2, r7, r2
 800683e:	1e59      	subs	r1, r3, #1
 8006840:	8011      	strh	r1, [r2, #0]
 8006842:	2b00      	cmp	r3, #0
 8006844:	d1e0      	bne.n	8006808 <delay_sec+0x30>
 8006846:	e002      	b.n	800684e <delay_sec+0x76>
		if (sys.abort) { return; }
 8006848:	46c0      	nop			; (mov r8, r8)
 800684a:	e000      	b.n	800684e <delay_sec+0x76>
		  if (sys.suspend & SUSPEND_RESTART_RETRACT) { return; } // Bail, if safety door reopens.
 800684c:	46c0      	nop			; (mov r8, r8)
	}
}
 800684e:	46bd      	mov	sp, r7
 8006850:	b005      	add	sp, #20
 8006852:	bd90      	pop	{r4, r7, pc}
 8006854:	41a00000 	.word	0x41a00000
 8006858:	20000bb4 	.word	0x20000bb4

0800685c <delay_ms>:


// Delays variable defined milliseconds. Compiler compatibility fix for _delay_ms(),
// which only accepts constants in future compiler releases.
void delay_ms(uint16_t ms)
{
 800685c:	b580      	push	{r7, lr}
 800685e:	b082      	sub	sp, #8
 8006860:	af00      	add	r7, sp, #0
 8006862:	0002      	movs	r2, r0
 8006864:	1dbb      	adds	r3, r7, #6
 8006866:	801a      	strh	r2, [r3, #0]
  while ( ms-- ) { _delay_ms(1); }
 8006868:	e002      	b.n	8006870 <delay_ms+0x14>
 800686a:	2001      	movs	r0, #1
 800686c:	f005 fde0 	bl	800c430 <_delay_ms>
 8006870:	1dbb      	adds	r3, r7, #6
 8006872:	881b      	ldrh	r3, [r3, #0]
 8006874:	1dba      	adds	r2, r7, #6
 8006876:	1e59      	subs	r1, r3, #1
 8006878:	8011      	strh	r1, [r2, #0]
 800687a:	2b00      	cmp	r3, #0
 800687c:	d1f5      	bne.n	800686a <delay_ms+0xe>
}
 800687e:	46c0      	nop			; (mov r8, r8)
 8006880:	46bd      	mov	sp, r7
 8006882:	b002      	add	sp, #8
 8006884:	bd80      	pop	{r7, pc}

08006886 <hypot_f>:


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrtf(x*x + y*y)); }
 8006886:	b590      	push	{r4, r7, lr}
 8006888:	b083      	sub	sp, #12
 800688a:	af00      	add	r7, sp, #0
 800688c:	6078      	str	r0, [r7, #4]
 800688e:	6039      	str	r1, [r7, #0]
 8006890:	6879      	ldr	r1, [r7, #4]
 8006892:	6878      	ldr	r0, [r7, #4]
 8006894:	f7fa f8fe 	bl	8000a94 <__aeabi_fmul>
 8006898:	1c03      	adds	r3, r0, #0
 800689a:	1c1c      	adds	r4, r3, #0
 800689c:	6839      	ldr	r1, [r7, #0]
 800689e:	6838      	ldr	r0, [r7, #0]
 80068a0:	f7fa f8f8 	bl	8000a94 <__aeabi_fmul>
 80068a4:	1c03      	adds	r3, r0, #0
 80068a6:	1c19      	adds	r1, r3, #0
 80068a8:	1c20      	adds	r0, r4, #0
 80068aa:	f7f9 fd71 	bl	8000390 <__aeabi_fadd>
 80068ae:	1c03      	adds	r3, r0, #0
 80068b0:	1c18      	adds	r0, r3, #0
 80068b2:	f006 f8bf 	bl	800ca34 <sqrtf>
 80068b6:	1c03      	adds	r3, r0, #0
 80068b8:	1c18      	adds	r0, r3, #0
 80068ba:	46bd      	mov	sp, r7
 80068bc:	b003      	add	sp, #12
 80068be:	bd90      	pop	{r4, r7, pc}

080068c0 <convert_delta_vector_to_unit_vector>:


float convert_delta_vector_to_unit_vector(float *vector)
{
 80068c0:	b590      	push	{r4, r7, lr}
 80068c2:	b087      	sub	sp, #28
 80068c4:	af00      	add	r7, sp, #0
 80068c6:	6078      	str	r0, [r7, #4]
  uint8_t idx;
  float magnitude = 0.0f;
 80068c8:	2300      	movs	r3, #0
 80068ca:	613b      	str	r3, [r7, #16]
  for (idx=0; idx<N_AXIS; idx++) {
 80068cc:	2317      	movs	r3, #23
 80068ce:	18fb      	adds	r3, r7, r3
 80068d0:	2200      	movs	r2, #0
 80068d2:	701a      	strb	r2, [r3, #0]
 80068d4:	e02b      	b.n	800692e <convert_delta_vector_to_unit_vector+0x6e>
    if (vector[idx] != 0.0f) {
 80068d6:	2317      	movs	r3, #23
 80068d8:	18fb      	adds	r3, r7, r3
 80068da:	781b      	ldrb	r3, [r3, #0]
 80068dc:	009b      	lsls	r3, r3, #2
 80068de:	687a      	ldr	r2, [r7, #4]
 80068e0:	18d3      	adds	r3, r2, r3
 80068e2:	681b      	ldr	r3, [r3, #0]
 80068e4:	2100      	movs	r1, #0
 80068e6:	1c18      	adds	r0, r3, #0
 80068e8:	f7f9 fcee 	bl	80002c8 <__aeabi_fcmpeq>
 80068ec:	1e03      	subs	r3, r0, #0
 80068ee:	d117      	bne.n	8006920 <convert_delta_vector_to_unit_vector+0x60>
      magnitude += vector[idx]*vector[idx];
 80068f0:	2317      	movs	r3, #23
 80068f2:	18fb      	adds	r3, r7, r3
 80068f4:	781b      	ldrb	r3, [r3, #0]
 80068f6:	009b      	lsls	r3, r3, #2
 80068f8:	687a      	ldr	r2, [r7, #4]
 80068fa:	18d3      	adds	r3, r2, r3
 80068fc:	6818      	ldr	r0, [r3, #0]
 80068fe:	2317      	movs	r3, #23
 8006900:	18fb      	adds	r3, r7, r3
 8006902:	781b      	ldrb	r3, [r3, #0]
 8006904:	009b      	lsls	r3, r3, #2
 8006906:	687a      	ldr	r2, [r7, #4]
 8006908:	18d3      	adds	r3, r2, r3
 800690a:	681b      	ldr	r3, [r3, #0]
 800690c:	1c19      	adds	r1, r3, #0
 800690e:	f7fa f8c1 	bl	8000a94 <__aeabi_fmul>
 8006912:	1c03      	adds	r3, r0, #0
 8006914:	1c19      	adds	r1, r3, #0
 8006916:	6938      	ldr	r0, [r7, #16]
 8006918:	f7f9 fd3a 	bl	8000390 <__aeabi_fadd>
 800691c:	1c03      	adds	r3, r0, #0
 800691e:	613b      	str	r3, [r7, #16]
  for (idx=0; idx<N_AXIS; idx++) {
 8006920:	2317      	movs	r3, #23
 8006922:	18fb      	adds	r3, r7, r3
 8006924:	781a      	ldrb	r2, [r3, #0]
 8006926:	2317      	movs	r3, #23
 8006928:	18fb      	adds	r3, r7, r3
 800692a:	3201      	adds	r2, #1
 800692c:	701a      	strb	r2, [r3, #0]
 800692e:	2317      	movs	r3, #23
 8006930:	18fb      	adds	r3, r7, r3
 8006932:	781b      	ldrb	r3, [r3, #0]
 8006934:	2b03      	cmp	r3, #3
 8006936:	d9ce      	bls.n	80068d6 <convert_delta_vector_to_unit_vector+0x16>
    }
  }
  magnitude = sqrtf(magnitude);
 8006938:	693b      	ldr	r3, [r7, #16]
 800693a:	1c18      	adds	r0, r3, #0
 800693c:	f006 f87a 	bl	800ca34 <sqrtf>
 8006940:	1c03      	adds	r3, r0, #0
 8006942:	613b      	str	r3, [r7, #16]
  float inv_magnitude = 1.0f/magnitude;
 8006944:	6939      	ldr	r1, [r7, #16]
 8006946:	20fe      	movs	r0, #254	; 0xfe
 8006948:	0580      	lsls	r0, r0, #22
 800694a:	f7f9 feb3 	bl	80006b4 <__aeabi_fdiv>
 800694e:	1c03      	adds	r3, r0, #0
 8006950:	60fb      	str	r3, [r7, #12]
  for (idx=0; idx<N_AXIS; idx++) { vector[idx] *= inv_magnitude; }
 8006952:	2317      	movs	r3, #23
 8006954:	18fb      	adds	r3, r7, r3
 8006956:	2200      	movs	r2, #0
 8006958:	701a      	strb	r2, [r3, #0]
 800695a:	e019      	b.n	8006990 <convert_delta_vector_to_unit_vector+0xd0>
 800695c:	2317      	movs	r3, #23
 800695e:	18fb      	adds	r3, r7, r3
 8006960:	781b      	ldrb	r3, [r3, #0]
 8006962:	009b      	lsls	r3, r3, #2
 8006964:	687a      	ldr	r2, [r7, #4]
 8006966:	18d4      	adds	r4, r2, r3
 8006968:	2317      	movs	r3, #23
 800696a:	18fb      	adds	r3, r7, r3
 800696c:	781b      	ldrb	r3, [r3, #0]
 800696e:	009b      	lsls	r3, r3, #2
 8006970:	687a      	ldr	r2, [r7, #4]
 8006972:	18d3      	adds	r3, r2, r3
 8006974:	681b      	ldr	r3, [r3, #0]
 8006976:	68f9      	ldr	r1, [r7, #12]
 8006978:	1c18      	adds	r0, r3, #0
 800697a:	f7fa f88b 	bl	8000a94 <__aeabi_fmul>
 800697e:	1c03      	adds	r3, r0, #0
 8006980:	6023      	str	r3, [r4, #0]
 8006982:	2317      	movs	r3, #23
 8006984:	18fb      	adds	r3, r7, r3
 8006986:	781a      	ldrb	r2, [r3, #0]
 8006988:	2317      	movs	r3, #23
 800698a:	18fb      	adds	r3, r7, r3
 800698c:	3201      	adds	r2, #1
 800698e:	701a      	strb	r2, [r3, #0]
 8006990:	2317      	movs	r3, #23
 8006992:	18fb      	adds	r3, r7, r3
 8006994:	781b      	ldrb	r3, [r3, #0]
 8006996:	2b03      	cmp	r3, #3
 8006998:	d9e0      	bls.n	800695c <convert_delta_vector_to_unit_vector+0x9c>
  return(magnitude);
 800699a:	693b      	ldr	r3, [r7, #16]
}
 800699c:	1c18      	adds	r0, r3, #0
 800699e:	46bd      	mov	sp, r7
 80069a0:	b007      	add	sp, #28
 80069a2:	bd90      	pop	{r4, r7, pc}

080069a4 <limit_value_by_axis_maximum>:


float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
 80069a4:	b580      	push	{r7, lr}
 80069a6:	b084      	sub	sp, #16
 80069a8:	af00      	add	r7, sp, #0
 80069aa:	6078      	str	r0, [r7, #4]
 80069ac:	6039      	str	r1, [r7, #0]
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
 80069ae:	4b2b      	ldr	r3, [pc, #172]	; (8006a5c <limit_value_by_axis_maximum+0xb8>)
 80069b0:	60bb      	str	r3, [r7, #8]
  for (idx=0; idx<N_AXIS; idx++) {
 80069b2:	230f      	movs	r3, #15
 80069b4:	18fb      	adds	r3, r7, r3
 80069b6:	2200      	movs	r2, #0
 80069b8:	701a      	strb	r2, [r3, #0]
 80069ba:	e044      	b.n	8006a46 <limit_value_by_axis_maximum+0xa2>
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
 80069bc:	230f      	movs	r3, #15
 80069be:	18fb      	adds	r3, r7, r3
 80069c0:	781b      	ldrb	r3, [r3, #0]
 80069c2:	009b      	lsls	r3, r3, #2
 80069c4:	683a      	ldr	r2, [r7, #0]
 80069c6:	18d3      	adds	r3, r2, r3
 80069c8:	681b      	ldr	r3, [r3, #0]
 80069ca:	2100      	movs	r1, #0
 80069cc:	1c18      	adds	r0, r3, #0
 80069ce:	f7f9 fc7b 	bl	80002c8 <__aeabi_fcmpeq>
 80069d2:	1e03      	subs	r3, r0, #0
 80069d4:	d130      	bne.n	8006a38 <limit_value_by_axis_maximum+0x94>
      limit_value = min(limit_value,fabsf(max_value[idx]/unit_vec[idx]));
 80069d6:	230f      	movs	r3, #15
 80069d8:	18fb      	adds	r3, r7, r3
 80069da:	781b      	ldrb	r3, [r3, #0]
 80069dc:	009b      	lsls	r3, r3, #2
 80069de:	687a      	ldr	r2, [r7, #4]
 80069e0:	18d3      	adds	r3, r2, r3
 80069e2:	6818      	ldr	r0, [r3, #0]
 80069e4:	230f      	movs	r3, #15
 80069e6:	18fb      	adds	r3, r7, r3
 80069e8:	781b      	ldrb	r3, [r3, #0]
 80069ea:	009b      	lsls	r3, r3, #2
 80069ec:	683a      	ldr	r2, [r7, #0]
 80069ee:	18d3      	adds	r3, r2, r3
 80069f0:	681b      	ldr	r3, [r3, #0]
 80069f2:	1c19      	adds	r1, r3, #0
 80069f4:	f7f9 fe5e 	bl	80006b4 <__aeabi_fdiv>
 80069f8:	1c03      	adds	r3, r0, #0
 80069fa:	005b      	lsls	r3, r3, #1
 80069fc:	085b      	lsrs	r3, r3, #1
 80069fe:	68b9      	ldr	r1, [r7, #8]
 8006a00:	1c18      	adds	r0, r3, #0
 8006a02:	f7f9 fc7b 	bl	80002fc <__aeabi_fcmpgt>
 8006a06:	1e03      	subs	r3, r0, #0
 8006a08:	d001      	beq.n	8006a0e <limit_value_by_axis_maximum+0x6a>
 8006a0a:	68bb      	ldr	r3, [r7, #8]
 8006a0c:	e013      	b.n	8006a36 <limit_value_by_axis_maximum+0x92>
 8006a0e:	230f      	movs	r3, #15
 8006a10:	18fb      	adds	r3, r7, r3
 8006a12:	781b      	ldrb	r3, [r3, #0]
 8006a14:	009b      	lsls	r3, r3, #2
 8006a16:	687a      	ldr	r2, [r7, #4]
 8006a18:	18d3      	adds	r3, r2, r3
 8006a1a:	6818      	ldr	r0, [r3, #0]
 8006a1c:	230f      	movs	r3, #15
 8006a1e:	18fb      	adds	r3, r7, r3
 8006a20:	781b      	ldrb	r3, [r3, #0]
 8006a22:	009b      	lsls	r3, r3, #2
 8006a24:	683a      	ldr	r2, [r7, #0]
 8006a26:	18d3      	adds	r3, r2, r3
 8006a28:	681b      	ldr	r3, [r3, #0]
 8006a2a:	1c19      	adds	r1, r3, #0
 8006a2c:	f7f9 fe42 	bl	80006b4 <__aeabi_fdiv>
 8006a30:	1c03      	adds	r3, r0, #0
 8006a32:	005b      	lsls	r3, r3, #1
 8006a34:	085b      	lsrs	r3, r3, #1
 8006a36:	60bb      	str	r3, [r7, #8]
  for (idx=0; idx<N_AXIS; idx++) {
 8006a38:	230f      	movs	r3, #15
 8006a3a:	18fb      	adds	r3, r7, r3
 8006a3c:	781a      	ldrb	r2, [r3, #0]
 8006a3e:	230f      	movs	r3, #15
 8006a40:	18fb      	adds	r3, r7, r3
 8006a42:	3201      	adds	r2, #1
 8006a44:	701a      	strb	r2, [r3, #0]
 8006a46:	230f      	movs	r3, #15
 8006a48:	18fb      	adds	r3, r7, r3
 8006a4a:	781b      	ldrb	r3, [r3, #0]
 8006a4c:	2b03      	cmp	r3, #3
 8006a4e:	d9b5      	bls.n	80069bc <limit_value_by_axis_maximum+0x18>
    }
  }
  return(limit_value);
 8006a50:	68bb      	ldr	r3, [r7, #8]
}
 8006a52:	1c18      	adds	r0, r3, #0
 8006a54:	46bd      	mov	sp, r7
 8006a56:	b004      	add	sp, #16
 8006a58:	bd80      	pop	{r7, pc}
 8006a5a:	46c0      	nop			; (mov r8, r8)
 8006a5c:	7f7fffff 	.word	0x7f7fffff

08006a60 <plan_next_block_index>:
static planner_t pl;


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index)
{
 8006a60:	b580      	push	{r7, lr}
 8006a62:	b082      	sub	sp, #8
 8006a64:	af00      	add	r7, sp, #0
 8006a66:	0002      	movs	r2, r0
 8006a68:	1dfb      	adds	r3, r7, #7
 8006a6a:	701a      	strb	r2, [r3, #0]
  block_index++;
 8006a6c:	1dfb      	adds	r3, r7, #7
 8006a6e:	781a      	ldrb	r2, [r3, #0]
 8006a70:	1dfb      	adds	r3, r7, #7
 8006a72:	3201      	adds	r2, #1
 8006a74:	701a      	strb	r2, [r3, #0]
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
 8006a76:	1dfb      	adds	r3, r7, #7
 8006a78:	781b      	ldrb	r3, [r3, #0]
 8006a7a:	2b10      	cmp	r3, #16
 8006a7c:	d102      	bne.n	8006a84 <plan_next_block_index+0x24>
 8006a7e:	1dfb      	adds	r3, r7, #7
 8006a80:	2200      	movs	r2, #0
 8006a82:	701a      	strb	r2, [r3, #0]
  return(block_index);
 8006a84:	1dfb      	adds	r3, r7, #7
 8006a86:	781b      	ldrb	r3, [r3, #0]
}
 8006a88:	0018      	movs	r0, r3
 8006a8a:	46bd      	mov	sp, r7
 8006a8c:	b002      	add	sp, #8
 8006a8e:	bd80      	pop	{r7, pc}

08006a90 <plan_prev_block_index>:


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index)
{
 8006a90:	b580      	push	{r7, lr}
 8006a92:	b082      	sub	sp, #8
 8006a94:	af00      	add	r7, sp, #0
 8006a96:	0002      	movs	r2, r0
 8006a98:	1dfb      	adds	r3, r7, #7
 8006a9a:	701a      	strb	r2, [r3, #0]
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
 8006a9c:	1dfb      	adds	r3, r7, #7
 8006a9e:	781b      	ldrb	r3, [r3, #0]
 8006aa0:	2b00      	cmp	r3, #0
 8006aa2:	d102      	bne.n	8006aaa <plan_prev_block_index+0x1a>
 8006aa4:	1dfb      	adds	r3, r7, #7
 8006aa6:	2210      	movs	r2, #16
 8006aa8:	701a      	strb	r2, [r3, #0]
  block_index--;
 8006aaa:	1dfb      	adds	r3, r7, #7
 8006aac:	781a      	ldrb	r2, [r3, #0]
 8006aae:	1dfb      	adds	r3, r7, #7
 8006ab0:	3a01      	subs	r2, #1
 8006ab2:	701a      	strb	r2, [r3, #0]
  return(block_index);
 8006ab4:	1dfb      	adds	r3, r7, #7
 8006ab6:	781b      	ldrb	r3, [r3, #0]
}
 8006ab8:	0018      	movs	r0, r3
 8006aba:	46bd      	mov	sp, r7
 8006abc:	b002      	add	sp, #8
 8006abe:	bd80      	pop	{r7, pc}

08006ac0 <planner_recalculate>:
  to compute an optimal plan, so select carefully. The Arduino 328p memory is already maxed out, but future
  ARM versions should have enough memory and speed for look-ahead blocks numbering up to a hundred or more.

*/
static void planner_recalculate()
{
 8006ac0:	b590      	push	{r4, r7, lr}
 8006ac2:	b085      	sub	sp, #20
 8006ac4:	af00      	add	r7, sp, #0
  // Initialize block index to the last block in the planner buffer.
  uint8_t block_index = plan_prev_block_index(block_buffer_head);
 8006ac6:	4b98      	ldr	r3, [pc, #608]	; (8006d28 <planner_recalculate+0x268>)
 8006ac8:	781b      	ldrb	r3, [r3, #0]
 8006aca:	220f      	movs	r2, #15
 8006acc:	18bc      	adds	r4, r7, r2
 8006ace:	0018      	movs	r0, r3
 8006ad0:	f7ff ffde 	bl	8006a90 <plan_prev_block_index>
 8006ad4:	0003      	movs	r3, r0
 8006ad6:	7023      	strb	r3, [r4, #0]

  // Bail. Can't do anything with one only one plan-able block.
  if (block_index == block_buffer_planned) { return; }
 8006ad8:	4b94      	ldr	r3, [pc, #592]	; (8006d2c <planner_recalculate+0x26c>)
 8006ada:	781b      	ldrb	r3, [r3, #0]
 8006adc:	220f      	movs	r2, #15
 8006ade:	18ba      	adds	r2, r7, r2
 8006ae0:	7812      	ldrb	r2, [r2, #0]
 8006ae2:	429a      	cmp	r2, r3
 8006ae4:	d100      	bne.n	8006ae8 <planner_recalculate+0x28>
 8006ae6:	e11a      	b.n	8006d1e <planner_recalculate+0x25e>
  // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
  // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
  // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
  float entry_speed_sqr;
  plan_block_t *next;
  plan_block_t *current = &block_buffer[block_index];
 8006ae8:	230f      	movs	r3, #15
 8006aea:	18fb      	adds	r3, r7, r3
 8006aec:	781a      	ldrb	r2, [r3, #0]
 8006aee:	0013      	movs	r3, r2
 8006af0:	00db      	lsls	r3, r3, #3
 8006af2:	1a9b      	subs	r3, r3, r2
 8006af4:	00db      	lsls	r3, r3, #3
 8006af6:	4a8e      	ldr	r2, [pc, #568]	; (8006d30 <planner_recalculate+0x270>)
 8006af8:	189b      	adds	r3, r3, r2
 8006afa:	607b      	str	r3, [r7, #4]

  // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
 8006afc:	687b      	ldr	r3, [r7, #4]
 8006afe:	69dc      	ldr	r4, [r3, #28]
 8006b00:	687b      	ldr	r3, [r7, #4]
 8006b02:	6a1b      	ldr	r3, [r3, #32]
 8006b04:	1c19      	adds	r1, r3, #0
 8006b06:	1c18      	adds	r0, r3, #0
 8006b08:	f7f9 fc42 	bl	8000390 <__aeabi_fadd>
 8006b0c:	1c03      	adds	r3, r0, #0
 8006b0e:	1c1a      	adds	r2, r3, #0
 8006b10:	687b      	ldr	r3, [r7, #4]
 8006b12:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006b14:	1c19      	adds	r1, r3, #0
 8006b16:	1c10      	adds	r0, r2, #0
 8006b18:	f7f9 ffbc 	bl	8000a94 <__aeabi_fmul>
 8006b1c:	1c03      	adds	r3, r0, #0
 8006b1e:	1c19      	adds	r1, r3, #0
 8006b20:	1c20      	adds	r0, r4, #0
 8006b22:	f7f9 fbd7 	bl	80002d4 <__aeabi_fcmplt>
 8006b26:	1e03      	subs	r3, r0, #0
 8006b28:	d002      	beq.n	8006b30 <planner_recalculate+0x70>
 8006b2a:	687b      	ldr	r3, [r7, #4]
 8006b2c:	69da      	ldr	r2, [r3, #28]
 8006b2e:	e00f      	b.n	8006b50 <planner_recalculate+0x90>
 8006b30:	687b      	ldr	r3, [r7, #4]
 8006b32:	6a1b      	ldr	r3, [r3, #32]
 8006b34:	1c19      	adds	r1, r3, #0
 8006b36:	1c18      	adds	r0, r3, #0
 8006b38:	f7f9 fc2a 	bl	8000390 <__aeabi_fadd>
 8006b3c:	1c03      	adds	r3, r0, #0
 8006b3e:	1c1a      	adds	r2, r3, #0
 8006b40:	687b      	ldr	r3, [r7, #4]
 8006b42:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006b44:	1c19      	adds	r1, r3, #0
 8006b46:	1c10      	adds	r0, r2, #0
 8006b48:	f7f9 ffa4 	bl	8000a94 <__aeabi_fmul>
 8006b4c:	1c03      	adds	r3, r0, #0
 8006b4e:	1c1a      	adds	r2, r3, #0
 8006b50:	687b      	ldr	r3, [r7, #4]
 8006b52:	619a      	str	r2, [r3, #24]

  block_index = plan_prev_block_index(block_index);
 8006b54:	230f      	movs	r3, #15
 8006b56:	18fc      	adds	r4, r7, r3
 8006b58:	230f      	movs	r3, #15
 8006b5a:	18fb      	adds	r3, r7, r3
 8006b5c:	781b      	ldrb	r3, [r3, #0]
 8006b5e:	0018      	movs	r0, r3
 8006b60:	f7ff ff96 	bl	8006a90 <plan_prev_block_index>
 8006b64:	0003      	movs	r3, r0
 8006b66:	7023      	strb	r3, [r4, #0]
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
 8006b68:	4b70      	ldr	r3, [pc, #448]	; (8006d2c <planner_recalculate+0x26c>)
 8006b6a:	781b      	ldrb	r3, [r3, #0]
 8006b6c:	220f      	movs	r2, #15
 8006b6e:	18ba      	adds	r2, r7, r2
 8006b70:	7812      	ldrb	r2, [r2, #0]
 8006b72:	429a      	cmp	r2, r3
 8006b74:	d15a      	bne.n	8006c2c <planner_recalculate+0x16c>
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
 8006b76:	4b6f      	ldr	r3, [pc, #444]	; (8006d34 <planner_recalculate+0x274>)
 8006b78:	781b      	ldrb	r3, [r3, #0]
 8006b7a:	220f      	movs	r2, #15
 8006b7c:	18ba      	adds	r2, r7, r2
 8006b7e:	7812      	ldrb	r2, [r2, #0]
 8006b80:	429a      	cmp	r2, r3
 8006b82:	d15a      	bne.n	8006c3a <planner_recalculate+0x17a>
 8006b84:	f003 ffe2 	bl	800ab4c <st_update_plan_block_parameters>
 8006b88:	e057      	b.n	8006c3a <planner_recalculate+0x17a>
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) {
      next = current;
 8006b8a:	687b      	ldr	r3, [r7, #4]
 8006b8c:	60bb      	str	r3, [r7, #8]
      current = &block_buffer[block_index];
 8006b8e:	230f      	movs	r3, #15
 8006b90:	18fb      	adds	r3, r7, r3
 8006b92:	781a      	ldrb	r2, [r3, #0]
 8006b94:	0013      	movs	r3, r2
 8006b96:	00db      	lsls	r3, r3, #3
 8006b98:	1a9b      	subs	r3, r3, r2
 8006b9a:	00db      	lsls	r3, r3, #3
 8006b9c:	4a64      	ldr	r2, [pc, #400]	; (8006d30 <planner_recalculate+0x270>)
 8006b9e:	189b      	adds	r3, r3, r2
 8006ba0:	607b      	str	r3, [r7, #4]
      block_index = plan_prev_block_index(block_index);
 8006ba2:	230f      	movs	r3, #15
 8006ba4:	18fc      	adds	r4, r7, r3
 8006ba6:	230f      	movs	r3, #15
 8006ba8:	18fb      	adds	r3, r7, r3
 8006baa:	781b      	ldrb	r3, [r3, #0]
 8006bac:	0018      	movs	r0, r3
 8006bae:	f7ff ff6f 	bl	8006a90 <plan_prev_block_index>
 8006bb2:	0003      	movs	r3, r0
 8006bb4:	7023      	strb	r3, [r4, #0]

      // Check if next block is the tail block(=planned block). If so, update current stepper parameters.
      if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
 8006bb6:	4b5f      	ldr	r3, [pc, #380]	; (8006d34 <planner_recalculate+0x274>)
 8006bb8:	781b      	ldrb	r3, [r3, #0]
 8006bba:	220f      	movs	r2, #15
 8006bbc:	18ba      	adds	r2, r7, r2
 8006bbe:	7812      	ldrb	r2, [r2, #0]
 8006bc0:	429a      	cmp	r2, r3
 8006bc2:	d101      	bne.n	8006bc8 <planner_recalculate+0x108>
 8006bc4:	f003 ffc2 	bl	800ab4c <st_update_plan_block_parameters>

      // Compute maximum entry speed decelerating over the current block from its exit speed.
      if (current->entry_speed_sqr != current->max_entry_speed_sqr) {
 8006bc8:	687b      	ldr	r3, [r7, #4]
 8006bca:	699a      	ldr	r2, [r3, #24]
 8006bcc:	687b      	ldr	r3, [r7, #4]
 8006bce:	69db      	ldr	r3, [r3, #28]
 8006bd0:	1c19      	adds	r1, r3, #0
 8006bd2:	1c10      	adds	r0, r2, #0
 8006bd4:	f7f9 fb78 	bl	80002c8 <__aeabi_fcmpeq>
 8006bd8:	1e03      	subs	r3, r0, #0
 8006bda:	d000      	beq.n	8006bde <planner_recalculate+0x11e>
 8006bdc:	e026      	b.n	8006c2c <planner_recalculate+0x16c>
        entry_speed_sqr = next->entry_speed_sqr + 2*current->acceleration*current->millimeters;
 8006bde:	68bb      	ldr	r3, [r7, #8]
 8006be0:	699c      	ldr	r4, [r3, #24]
 8006be2:	687b      	ldr	r3, [r7, #4]
 8006be4:	6a1b      	ldr	r3, [r3, #32]
 8006be6:	1c19      	adds	r1, r3, #0
 8006be8:	1c18      	adds	r0, r3, #0
 8006bea:	f7f9 fbd1 	bl	8000390 <__aeabi_fadd>
 8006bee:	1c03      	adds	r3, r0, #0
 8006bf0:	1c1a      	adds	r2, r3, #0
 8006bf2:	687b      	ldr	r3, [r7, #4]
 8006bf4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006bf6:	1c19      	adds	r1, r3, #0
 8006bf8:	1c10      	adds	r0, r2, #0
 8006bfa:	f7f9 ff4b 	bl	8000a94 <__aeabi_fmul>
 8006bfe:	1c03      	adds	r3, r0, #0
 8006c00:	1c19      	adds	r1, r3, #0
 8006c02:	1c20      	adds	r0, r4, #0
 8006c04:	f7f9 fbc4 	bl	8000390 <__aeabi_fadd>
 8006c08:	1c03      	adds	r3, r0, #0
 8006c0a:	603b      	str	r3, [r7, #0]
        if (entry_speed_sqr < current->max_entry_speed_sqr) {
 8006c0c:	687b      	ldr	r3, [r7, #4]
 8006c0e:	69db      	ldr	r3, [r3, #28]
 8006c10:	6839      	ldr	r1, [r7, #0]
 8006c12:	1c18      	adds	r0, r3, #0
 8006c14:	f7f9 fb72 	bl	80002fc <__aeabi_fcmpgt>
 8006c18:	1e03      	subs	r3, r0, #0
 8006c1a:	d003      	beq.n	8006c24 <planner_recalculate+0x164>
          current->entry_speed_sqr = entry_speed_sqr;
 8006c1c:	687b      	ldr	r3, [r7, #4]
 8006c1e:	683a      	ldr	r2, [r7, #0]
 8006c20:	619a      	str	r2, [r3, #24]
 8006c22:	e003      	b.n	8006c2c <planner_recalculate+0x16c>
        } else {
          current->entry_speed_sqr = current->max_entry_speed_sqr;
 8006c24:	687b      	ldr	r3, [r7, #4]
 8006c26:	69da      	ldr	r2, [r3, #28]
 8006c28:	687b      	ldr	r3, [r7, #4]
 8006c2a:	619a      	str	r2, [r3, #24]
    while (block_index != block_buffer_planned) {
 8006c2c:	4b3f      	ldr	r3, [pc, #252]	; (8006d2c <planner_recalculate+0x26c>)
 8006c2e:	781b      	ldrb	r3, [r3, #0]
 8006c30:	220f      	movs	r2, #15
 8006c32:	18ba      	adds	r2, r7, r2
 8006c34:	7812      	ldrb	r2, [r2, #0]
 8006c36:	429a      	cmp	r2, r3
 8006c38:	d1a7      	bne.n	8006b8a <planner_recalculate+0xca>
    }
  }

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
 8006c3a:	4b3c      	ldr	r3, [pc, #240]	; (8006d2c <planner_recalculate+0x26c>)
 8006c3c:	781b      	ldrb	r3, [r3, #0]
 8006c3e:	001a      	movs	r2, r3
 8006c40:	0013      	movs	r3, r2
 8006c42:	00db      	lsls	r3, r3, #3
 8006c44:	1a9b      	subs	r3, r3, r2
 8006c46:	00db      	lsls	r3, r3, #3
 8006c48:	4a39      	ldr	r2, [pc, #228]	; (8006d30 <planner_recalculate+0x270>)
 8006c4a:	189b      	adds	r3, r3, r2
 8006c4c:	60bb      	str	r3, [r7, #8]
  block_index = plan_next_block_index(block_buffer_planned);
 8006c4e:	4b37      	ldr	r3, [pc, #220]	; (8006d2c <planner_recalculate+0x26c>)
 8006c50:	781b      	ldrb	r3, [r3, #0]
 8006c52:	220f      	movs	r2, #15
 8006c54:	18bc      	adds	r4, r7, r2
 8006c56:	0018      	movs	r0, r3
 8006c58:	f7ff ff02 	bl	8006a60 <plan_next_block_index>
 8006c5c:	0003      	movs	r3, r0
 8006c5e:	7023      	strb	r3, [r4, #0]
  while (block_index != block_buffer_head) {
 8006c60:	e055      	b.n	8006d0e <planner_recalculate+0x24e>
    current = next;
 8006c62:	68bb      	ldr	r3, [r7, #8]
 8006c64:	607b      	str	r3, [r7, #4]
    next = &block_buffer[block_index];
 8006c66:	230f      	movs	r3, #15
 8006c68:	18fb      	adds	r3, r7, r3
 8006c6a:	781a      	ldrb	r2, [r3, #0]
 8006c6c:	0013      	movs	r3, r2
 8006c6e:	00db      	lsls	r3, r3, #3
 8006c70:	1a9b      	subs	r3, r3, r2
 8006c72:	00db      	lsls	r3, r3, #3
 8006c74:	4a2e      	ldr	r2, [pc, #184]	; (8006d30 <planner_recalculate+0x270>)
 8006c76:	189b      	adds	r3, r3, r2
 8006c78:	60bb      	str	r3, [r7, #8]

    // Any acceleration detected in the forward pass automatically moves the optimal planned
    // pointer forward, since everything before this is all optimal. In other words, nothing
    // can improve the plan from the buffer tail to the planned pointer by logic.
    if (current->entry_speed_sqr < next->entry_speed_sqr) {
 8006c7a:	687b      	ldr	r3, [r7, #4]
 8006c7c:	699a      	ldr	r2, [r3, #24]
 8006c7e:	68bb      	ldr	r3, [r7, #8]
 8006c80:	699b      	ldr	r3, [r3, #24]
 8006c82:	1c19      	adds	r1, r3, #0
 8006c84:	1c10      	adds	r0, r2, #0
 8006c86:	f7f9 fb25 	bl	80002d4 <__aeabi_fcmplt>
 8006c8a:	1e03      	subs	r3, r0, #0
 8006c8c:	d026      	beq.n	8006cdc <planner_recalculate+0x21c>
      entry_speed_sqr = current->entry_speed_sqr + 2*current->acceleration*current->millimeters;
 8006c8e:	687b      	ldr	r3, [r7, #4]
 8006c90:	699c      	ldr	r4, [r3, #24]
 8006c92:	687b      	ldr	r3, [r7, #4]
 8006c94:	6a1b      	ldr	r3, [r3, #32]
 8006c96:	1c19      	adds	r1, r3, #0
 8006c98:	1c18      	adds	r0, r3, #0
 8006c9a:	f7f9 fb79 	bl	8000390 <__aeabi_fadd>
 8006c9e:	1c03      	adds	r3, r0, #0
 8006ca0:	1c1a      	adds	r2, r3, #0
 8006ca2:	687b      	ldr	r3, [r7, #4]
 8006ca4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006ca6:	1c19      	adds	r1, r3, #0
 8006ca8:	1c10      	adds	r0, r2, #0
 8006caa:	f7f9 fef3 	bl	8000a94 <__aeabi_fmul>
 8006cae:	1c03      	adds	r3, r0, #0
 8006cb0:	1c19      	adds	r1, r3, #0
 8006cb2:	1c20      	adds	r0, r4, #0
 8006cb4:	f7f9 fb6c 	bl	8000390 <__aeabi_fadd>
 8006cb8:	1c03      	adds	r3, r0, #0
 8006cba:	603b      	str	r3, [r7, #0]
      // If true, current block is full-acceleration and we can move the planned pointer forward.
      if (entry_speed_sqr < next->entry_speed_sqr) {
 8006cbc:	68bb      	ldr	r3, [r7, #8]
 8006cbe:	699b      	ldr	r3, [r3, #24]
 8006cc0:	6839      	ldr	r1, [r7, #0]
 8006cc2:	1c18      	adds	r0, r3, #0
 8006cc4:	f7f9 fb1a 	bl	80002fc <__aeabi_fcmpgt>
 8006cc8:	1e03      	subs	r3, r0, #0
 8006cca:	d007      	beq.n	8006cdc <planner_recalculate+0x21c>
        next->entry_speed_sqr = entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
 8006ccc:	68bb      	ldr	r3, [r7, #8]
 8006cce:	683a      	ldr	r2, [r7, #0]
 8006cd0:	619a      	str	r2, [r3, #24]
        block_buffer_planned = block_index; // Set optimal plan pointer.
 8006cd2:	4b16      	ldr	r3, [pc, #88]	; (8006d2c <planner_recalculate+0x26c>)
 8006cd4:	220f      	movs	r2, #15
 8006cd6:	18ba      	adds	r2, r7, r2
 8006cd8:	7812      	ldrb	r2, [r2, #0]
 8006cda:	701a      	strb	r2, [r3, #0]

    // Any block set at its maximum entry speed also creates an optimal plan up to this
    // point in the buffer. When the plan is bracketed by either the beginning of the
    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
    if (next->entry_speed_sqr == next->max_entry_speed_sqr) { block_buffer_planned = block_index; }
 8006cdc:	68bb      	ldr	r3, [r7, #8]
 8006cde:	699a      	ldr	r2, [r3, #24]
 8006ce0:	68bb      	ldr	r3, [r7, #8]
 8006ce2:	69db      	ldr	r3, [r3, #28]
 8006ce4:	1c19      	adds	r1, r3, #0
 8006ce6:	1c10      	adds	r0, r2, #0
 8006ce8:	f7f9 faee 	bl	80002c8 <__aeabi_fcmpeq>
 8006cec:	1e03      	subs	r3, r0, #0
 8006cee:	d004      	beq.n	8006cfa <planner_recalculate+0x23a>
 8006cf0:	4b0e      	ldr	r3, [pc, #56]	; (8006d2c <planner_recalculate+0x26c>)
 8006cf2:	220f      	movs	r2, #15
 8006cf4:	18ba      	adds	r2, r7, r2
 8006cf6:	7812      	ldrb	r2, [r2, #0]
 8006cf8:	701a      	strb	r2, [r3, #0]
    block_index = plan_next_block_index( block_index );
 8006cfa:	230f      	movs	r3, #15
 8006cfc:	18fc      	adds	r4, r7, r3
 8006cfe:	230f      	movs	r3, #15
 8006d00:	18fb      	adds	r3, r7, r3
 8006d02:	781b      	ldrb	r3, [r3, #0]
 8006d04:	0018      	movs	r0, r3
 8006d06:	f7ff feab 	bl	8006a60 <plan_next_block_index>
 8006d0a:	0003      	movs	r3, r0
 8006d0c:	7023      	strb	r3, [r4, #0]
  while (block_index != block_buffer_head) {
 8006d0e:	4b06      	ldr	r3, [pc, #24]	; (8006d28 <planner_recalculate+0x268>)
 8006d10:	781b      	ldrb	r3, [r3, #0]
 8006d12:	220f      	movs	r2, #15
 8006d14:	18ba      	adds	r2, r7, r2
 8006d16:	7812      	ldrb	r2, [r2, #0]
 8006d18:	429a      	cmp	r2, r3
 8006d1a:	d1a2      	bne.n	8006c62 <planner_recalculate+0x1a2>
 8006d1c:	e000      	b.n	8006d20 <planner_recalculate+0x260>
  if (block_index == block_buffer_planned) { return; }
 8006d1e:	46c0      	nop			; (mov r8, r8)
  }
}
 8006d20:	46bd      	mov	sp, r7
 8006d22:	b005      	add	sp, #20
 8006d24:	bd90      	pop	{r4, r7, pc}
 8006d26:	46c0      	nop			; (mov r8, r8)
 8006d28:	20000419 	.word	0x20000419
 8006d2c:	2000041b 	.word	0x2000041b
 8006d30:	20000098 	.word	0x20000098
 8006d34:	20000418 	.word	0x20000418

08006d38 <plan_reset>:


void plan_reset()
{
 8006d38:	b580      	push	{r7, lr}
 8006d3a:	af00      	add	r7, sp, #0
  memset(&pl, 0, sizeof(planner_t)); // Clear planner struct
 8006d3c:	4b05      	ldr	r3, [pc, #20]	; (8006d54 <plan_reset+0x1c>)
 8006d3e:	2224      	movs	r2, #36	; 0x24
 8006d40:	2100      	movs	r1, #0
 8006d42:	0018      	movs	r0, r3
 8006d44:	f005 fcde 	bl	800c704 <memset>
  plan_reset_buffer();
 8006d48:	f000 f806 	bl	8006d58 <plan_reset_buffer>
}
 8006d4c:	46c0      	nop			; (mov r8, r8)
 8006d4e:	46bd      	mov	sp, r7
 8006d50:	bd80      	pop	{r7, pc}
 8006d52:	46c0      	nop			; (mov r8, r8)
 8006d54:	2000041c 	.word	0x2000041c

08006d58 <plan_reset_buffer>:


void plan_reset_buffer()
{
 8006d58:	b580      	push	{r7, lr}
 8006d5a:	af00      	add	r7, sp, #0
  block_buffer_tail = 0;
 8006d5c:	4b07      	ldr	r3, [pc, #28]	; (8006d7c <plan_reset_buffer+0x24>)
 8006d5e:	2200      	movs	r2, #0
 8006d60:	701a      	strb	r2, [r3, #0]
  block_buffer_head = 0; // Empty = tail
 8006d62:	4b07      	ldr	r3, [pc, #28]	; (8006d80 <plan_reset_buffer+0x28>)
 8006d64:	2200      	movs	r2, #0
 8006d66:	701a      	strb	r2, [r3, #0]
  next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
 8006d68:	4b06      	ldr	r3, [pc, #24]	; (8006d84 <plan_reset_buffer+0x2c>)
 8006d6a:	2201      	movs	r2, #1
 8006d6c:	701a      	strb	r2, [r3, #0]
  block_buffer_planned = 0; // = block_buffer_tail;
 8006d6e:	4b06      	ldr	r3, [pc, #24]	; (8006d88 <plan_reset_buffer+0x30>)
 8006d70:	2200      	movs	r2, #0
 8006d72:	701a      	strb	r2, [r3, #0]
}
 8006d74:	46c0      	nop			; (mov r8, r8)
 8006d76:	46bd      	mov	sp, r7
 8006d78:	bd80      	pop	{r7, pc}
 8006d7a:	46c0      	nop			; (mov r8, r8)
 8006d7c:	20000418 	.word	0x20000418
 8006d80:	20000419 	.word	0x20000419
 8006d84:	2000041a 	.word	0x2000041a
 8006d88:	2000041b 	.word	0x2000041b

08006d8c <plan_discard_current_block>:


void plan_discard_current_block()
{
 8006d8c:	b590      	push	{r4, r7, lr}
 8006d8e:	b083      	sub	sp, #12
 8006d90:	af00      	add	r7, sp, #0
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
 8006d92:	4b10      	ldr	r3, [pc, #64]	; (8006dd4 <plan_discard_current_block+0x48>)
 8006d94:	781a      	ldrb	r2, [r3, #0]
 8006d96:	4b10      	ldr	r3, [pc, #64]	; (8006dd8 <plan_discard_current_block+0x4c>)
 8006d98:	781b      	ldrb	r3, [r3, #0]
 8006d9a:	429a      	cmp	r2, r3
 8006d9c:	d015      	beq.n	8006dca <plan_discard_current_block+0x3e>
    uint8_t block_index = plan_next_block_index( block_buffer_tail );
 8006d9e:	4b0e      	ldr	r3, [pc, #56]	; (8006dd8 <plan_discard_current_block+0x4c>)
 8006da0:	781b      	ldrb	r3, [r3, #0]
 8006da2:	1dfc      	adds	r4, r7, #7
 8006da4:	0018      	movs	r0, r3
 8006da6:	f7ff fe5b 	bl	8006a60 <plan_next_block_index>
 8006daa:	0003      	movs	r3, r0
 8006dac:	7023      	strb	r3, [r4, #0]
    // Push block_buffer_planned pointer, if encountered.
    if (block_buffer_tail == block_buffer_planned) { block_buffer_planned = block_index; }
 8006dae:	4b0a      	ldr	r3, [pc, #40]	; (8006dd8 <plan_discard_current_block+0x4c>)
 8006db0:	781a      	ldrb	r2, [r3, #0]
 8006db2:	4b0a      	ldr	r3, [pc, #40]	; (8006ddc <plan_discard_current_block+0x50>)
 8006db4:	781b      	ldrb	r3, [r3, #0]
 8006db6:	429a      	cmp	r2, r3
 8006db8:	d103      	bne.n	8006dc2 <plan_discard_current_block+0x36>
 8006dba:	4b08      	ldr	r3, [pc, #32]	; (8006ddc <plan_discard_current_block+0x50>)
 8006dbc:	1dfa      	adds	r2, r7, #7
 8006dbe:	7812      	ldrb	r2, [r2, #0]
 8006dc0:	701a      	strb	r2, [r3, #0]
    block_buffer_tail = block_index;
 8006dc2:	4b05      	ldr	r3, [pc, #20]	; (8006dd8 <plan_discard_current_block+0x4c>)
 8006dc4:	1dfa      	adds	r2, r7, #7
 8006dc6:	7812      	ldrb	r2, [r2, #0]
 8006dc8:	701a      	strb	r2, [r3, #0]
  }
}
 8006dca:	46c0      	nop			; (mov r8, r8)
 8006dcc:	46bd      	mov	sp, r7
 8006dce:	b003      	add	sp, #12
 8006dd0:	bd90      	pop	{r4, r7, pc}
 8006dd2:	46c0      	nop			; (mov r8, r8)
 8006dd4:	20000419 	.word	0x20000419
 8006dd8:	20000418 	.word	0x20000418
 8006ddc:	2000041b 	.word	0x2000041b

08006de0 <plan_get_system_motion_block>:


// Returns address of planner buffer block used by system motions. Called by segment generator.
plan_block_t *plan_get_system_motion_block()
{
 8006de0:	b580      	push	{r7, lr}
 8006de2:	af00      	add	r7, sp, #0
  return(&block_buffer[block_buffer_head]);
 8006de4:	4b05      	ldr	r3, [pc, #20]	; (8006dfc <plan_get_system_motion_block+0x1c>)
 8006de6:	781b      	ldrb	r3, [r3, #0]
 8006de8:	001a      	movs	r2, r3
 8006dea:	0013      	movs	r3, r2
 8006dec:	00db      	lsls	r3, r3, #3
 8006dee:	1a9b      	subs	r3, r3, r2
 8006df0:	00db      	lsls	r3, r3, #3
 8006df2:	4a03      	ldr	r2, [pc, #12]	; (8006e00 <plan_get_system_motion_block+0x20>)
 8006df4:	189b      	adds	r3, r3, r2
}
 8006df6:	0018      	movs	r0, r3
 8006df8:	46bd      	mov	sp, r7
 8006dfa:	bd80      	pop	{r7, pc}
 8006dfc:	20000419 	.word	0x20000419
 8006e00:	20000098 	.word	0x20000098

08006e04 <plan_get_current_block>:


// Returns address of first planner block, if available. Called by various main program functions.
plan_block_t *plan_get_current_block()
{
 8006e04:	b580      	push	{r7, lr}
 8006e06:	af00      	add	r7, sp, #0
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty
 8006e08:	4b09      	ldr	r3, [pc, #36]	; (8006e30 <plan_get_current_block+0x2c>)
 8006e0a:	781a      	ldrb	r2, [r3, #0]
 8006e0c:	4b09      	ldr	r3, [pc, #36]	; (8006e34 <plan_get_current_block+0x30>)
 8006e0e:	781b      	ldrb	r3, [r3, #0]
 8006e10:	429a      	cmp	r2, r3
 8006e12:	d101      	bne.n	8006e18 <plan_get_current_block+0x14>
 8006e14:	2300      	movs	r3, #0
 8006e16:	e008      	b.n	8006e2a <plan_get_current_block+0x26>
  return(&block_buffer[block_buffer_tail]);
 8006e18:	4b06      	ldr	r3, [pc, #24]	; (8006e34 <plan_get_current_block+0x30>)
 8006e1a:	781b      	ldrb	r3, [r3, #0]
 8006e1c:	001a      	movs	r2, r3
 8006e1e:	0013      	movs	r3, r2
 8006e20:	00db      	lsls	r3, r3, #3
 8006e22:	1a9b      	subs	r3, r3, r2
 8006e24:	00db      	lsls	r3, r3, #3
 8006e26:	4a04      	ldr	r2, [pc, #16]	; (8006e38 <plan_get_current_block+0x34>)
 8006e28:	189b      	adds	r3, r3, r2
}
 8006e2a:	0018      	movs	r0, r3
 8006e2c:	46bd      	mov	sp, r7
 8006e2e:	bd80      	pop	{r7, pc}
 8006e30:	20000419 	.word	0x20000419
 8006e34:	20000418 	.word	0x20000418
 8006e38:	20000098 	.word	0x20000098

08006e3c <plan_get_exec_block_exit_speed_sqr>:


float plan_get_exec_block_exit_speed_sqr()
{
 8006e3c:	b590      	push	{r4, r7, lr}
 8006e3e:	b083      	sub	sp, #12
 8006e40:	af00      	add	r7, sp, #0
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
 8006e42:	4b0f      	ldr	r3, [pc, #60]	; (8006e80 <plan_get_exec_block_exit_speed_sqr+0x44>)
 8006e44:	781b      	ldrb	r3, [r3, #0]
 8006e46:	1dfc      	adds	r4, r7, #7
 8006e48:	0018      	movs	r0, r3
 8006e4a:	f7ff fe09 	bl	8006a60 <plan_next_block_index>
 8006e4e:	0003      	movs	r3, r0
 8006e50:	7023      	strb	r3, [r4, #0]
  if (block_index == block_buffer_head) { return( 0.0 ); }
 8006e52:	4b0c      	ldr	r3, [pc, #48]	; (8006e84 <plan_get_exec_block_exit_speed_sqr+0x48>)
 8006e54:	781b      	ldrb	r3, [r3, #0]
 8006e56:	1dfa      	adds	r2, r7, #7
 8006e58:	7812      	ldrb	r2, [r2, #0]
 8006e5a:	429a      	cmp	r2, r3
 8006e5c:	d101      	bne.n	8006e62 <plan_get_exec_block_exit_speed_sqr+0x26>
 8006e5e:	2300      	movs	r3, #0
 8006e60:	e009      	b.n	8006e76 <plan_get_exec_block_exit_speed_sqr+0x3a>
  return( block_buffer[block_index].entry_speed_sqr );
 8006e62:	1dfb      	adds	r3, r7, #7
 8006e64:	781a      	ldrb	r2, [r3, #0]
 8006e66:	4908      	ldr	r1, [pc, #32]	; (8006e88 <plan_get_exec_block_exit_speed_sqr+0x4c>)
 8006e68:	0013      	movs	r3, r2
 8006e6a:	00db      	lsls	r3, r3, #3
 8006e6c:	1a9b      	subs	r3, r3, r2
 8006e6e:	00db      	lsls	r3, r3, #3
 8006e70:	18cb      	adds	r3, r1, r3
 8006e72:	3318      	adds	r3, #24
 8006e74:	681b      	ldr	r3, [r3, #0]
}
 8006e76:	1c18      	adds	r0, r3, #0
 8006e78:	46bd      	mov	sp, r7
 8006e7a:	b003      	add	sp, #12
 8006e7c:	bd90      	pop	{r4, r7, pc}
 8006e7e:	46c0      	nop			; (mov r8, r8)
 8006e80:	20000418 	.word	0x20000418
 8006e84:	20000419 	.word	0x20000419
 8006e88:	20000098 	.word	0x20000098

08006e8c <plan_check_full_buffer>:


// Returns the availability status of the block ring buffer. True, if full.
uint8_t plan_check_full_buffer()
{
 8006e8c:	b580      	push	{r7, lr}
 8006e8e:	af00      	add	r7, sp, #0
  if (block_buffer_tail == next_buffer_head) { return(true); }
 8006e90:	4b05      	ldr	r3, [pc, #20]	; (8006ea8 <plan_check_full_buffer+0x1c>)
 8006e92:	781a      	ldrb	r2, [r3, #0]
 8006e94:	4b05      	ldr	r3, [pc, #20]	; (8006eac <plan_check_full_buffer+0x20>)
 8006e96:	781b      	ldrb	r3, [r3, #0]
 8006e98:	429a      	cmp	r2, r3
 8006e9a:	d101      	bne.n	8006ea0 <plan_check_full_buffer+0x14>
 8006e9c:	2301      	movs	r3, #1
 8006e9e:	e000      	b.n	8006ea2 <plan_check_full_buffer+0x16>
  return(false);
 8006ea0:	2300      	movs	r3, #0
}
 8006ea2:	0018      	movs	r0, r3
 8006ea4:	46bd      	mov	sp, r7
 8006ea6:	bd80      	pop	{r7, pc}
 8006ea8:	20000418 	.word	0x20000418
 8006eac:	2000041a 	.word	0x2000041a

08006eb0 <plan_compute_profile_nominal_speed>:


// Computes and returns block nominal speed based on running condition and override values.
// NOTE: All system motion commands, such as homing/parking, are not subject to overrides.
float plan_compute_profile_nominal_speed(plan_block_t *block)
{
 8006eb0:	b580      	push	{r7, lr}
 8006eb2:	b084      	sub	sp, #16
 8006eb4:	af00      	add	r7, sp, #0
 8006eb6:	6078      	str	r0, [r7, #4]
  float nominal_speed = block->programmed_rate;
 8006eb8:	687b      	ldr	r3, [r7, #4]
 8006eba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006ebc:	60fb      	str	r3, [r7, #12]
  if (block->condition & PL_COND_FLAG_RAPID_MOTION) { nominal_speed *= (0.01f*sys.r_override); }
 8006ebe:	687b      	ldr	r3, [r7, #4]
 8006ec0:	7d5b      	ldrb	r3, [r3, #21]
 8006ec2:	001a      	movs	r2, r3
 8006ec4:	2301      	movs	r3, #1
 8006ec6:	4013      	ands	r3, r2
 8006ec8:	d011      	beq.n	8006eee <plan_compute_profile_nominal_speed+0x3e>
 8006eca:	4b21      	ldr	r3, [pc, #132]	; (8006f50 <plan_compute_profile_nominal_speed+0xa0>)
 8006ecc:	7a1b      	ldrb	r3, [r3, #8]
 8006ece:	0018      	movs	r0, r3
 8006ed0:	f7fa f8d4 	bl	800107c <__aeabi_i2f>
 8006ed4:	1c03      	adds	r3, r0, #0
 8006ed6:	491f      	ldr	r1, [pc, #124]	; (8006f54 <plan_compute_profile_nominal_speed+0xa4>)
 8006ed8:	1c18      	adds	r0, r3, #0
 8006eda:	f7f9 fddb 	bl	8000a94 <__aeabi_fmul>
 8006ede:	1c03      	adds	r3, r0, #0
 8006ee0:	1c19      	adds	r1, r3, #0
 8006ee2:	68f8      	ldr	r0, [r7, #12]
 8006ee4:	f7f9 fdd6 	bl	8000a94 <__aeabi_fmul>
 8006ee8:	1c03      	adds	r3, r0, #0
 8006eea:	60fb      	str	r3, [r7, #12]
 8006eec:	e021      	b.n	8006f32 <plan_compute_profile_nominal_speed+0x82>
  else {
    if (!(block->condition & PL_COND_FLAG_NO_FEED_OVERRIDE)) { nominal_speed *= (0.01f*sys.f_override); }
 8006eee:	687b      	ldr	r3, [r7, #4]
 8006ef0:	7d5b      	ldrb	r3, [r3, #21]
 8006ef2:	001a      	movs	r2, r3
 8006ef4:	2304      	movs	r3, #4
 8006ef6:	4013      	ands	r3, r2
 8006ef8:	d110      	bne.n	8006f1c <plan_compute_profile_nominal_speed+0x6c>
 8006efa:	4b15      	ldr	r3, [pc, #84]	; (8006f50 <plan_compute_profile_nominal_speed+0xa0>)
 8006efc:	79db      	ldrb	r3, [r3, #7]
 8006efe:	0018      	movs	r0, r3
 8006f00:	f7fa f8bc 	bl	800107c <__aeabi_i2f>
 8006f04:	1c03      	adds	r3, r0, #0
 8006f06:	4913      	ldr	r1, [pc, #76]	; (8006f54 <plan_compute_profile_nominal_speed+0xa4>)
 8006f08:	1c18      	adds	r0, r3, #0
 8006f0a:	f7f9 fdc3 	bl	8000a94 <__aeabi_fmul>
 8006f0e:	1c03      	adds	r3, r0, #0
 8006f10:	1c19      	adds	r1, r3, #0
 8006f12:	68f8      	ldr	r0, [r7, #12]
 8006f14:	f7f9 fdbe 	bl	8000a94 <__aeabi_fmul>
 8006f18:	1c03      	adds	r3, r0, #0
 8006f1a:	60fb      	str	r3, [r7, #12]
    if (nominal_speed > block->rapid_rate) { nominal_speed = block->rapid_rate; }
 8006f1c:	687b      	ldr	r3, [r7, #4]
 8006f1e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006f20:	68f9      	ldr	r1, [r7, #12]
 8006f22:	1c18      	adds	r0, r3, #0
 8006f24:	f7f9 f9d6 	bl	80002d4 <__aeabi_fcmplt>
 8006f28:	1e03      	subs	r3, r0, #0
 8006f2a:	d002      	beq.n	8006f32 <plan_compute_profile_nominal_speed+0x82>
 8006f2c:	687b      	ldr	r3, [r7, #4]
 8006f2e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006f30:	60fb      	str	r3, [r7, #12]
  }
  if (nominal_speed > MINIMUM_FEED_RATE) { return(nominal_speed); }
 8006f32:	21fe      	movs	r1, #254	; 0xfe
 8006f34:	0589      	lsls	r1, r1, #22
 8006f36:	68f8      	ldr	r0, [r7, #12]
 8006f38:	f7f9 f9e0 	bl	80002fc <__aeabi_fcmpgt>
 8006f3c:	1e03      	subs	r3, r0, #0
 8006f3e:	d001      	beq.n	8006f44 <plan_compute_profile_nominal_speed+0x94>
 8006f40:	68fb      	ldr	r3, [r7, #12]
 8006f42:	e001      	b.n	8006f48 <plan_compute_profile_nominal_speed+0x98>
  return(MINIMUM_FEED_RATE);
 8006f44:	23fe      	movs	r3, #254	; 0xfe
 8006f46:	059b      	lsls	r3, r3, #22
}
 8006f48:	1c18      	adds	r0, r3, #0
 8006f4a:	46bd      	mov	sp, r7
 8006f4c:	b004      	add	sp, #16
 8006f4e:	bd80      	pop	{r7, pc}
 8006f50:	20000bb4 	.word	0x20000bb4
 8006f54:	3c23d70a 	.word	0x3c23d70a

08006f58 <plan_compute_profile_parameters>:


// Computes and updates the max entry speed (sqr) of the block, based on the minimum of the junction's
// previous and current nominal speeds and max junction speed.
static void plan_compute_profile_parameters(plan_block_t *block, float nominal_speed, float prev_nominal_speed)
{
 8006f58:	b580      	push	{r7, lr}
 8006f5a:	b084      	sub	sp, #16
 8006f5c:	af00      	add	r7, sp, #0
 8006f5e:	60f8      	str	r0, [r7, #12]
 8006f60:	60b9      	str	r1, [r7, #8]
 8006f62:	607a      	str	r2, [r7, #4]
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  if (nominal_speed > prev_nominal_speed) { block->max_entry_speed_sqr = prev_nominal_speed*prev_nominal_speed; }
 8006f64:	6879      	ldr	r1, [r7, #4]
 8006f66:	68b8      	ldr	r0, [r7, #8]
 8006f68:	f7f9 f9c8 	bl	80002fc <__aeabi_fcmpgt>
 8006f6c:	1e03      	subs	r3, r0, #0
 8006f6e:	d008      	beq.n	8006f82 <plan_compute_profile_parameters+0x2a>
 8006f70:	6879      	ldr	r1, [r7, #4]
 8006f72:	6878      	ldr	r0, [r7, #4]
 8006f74:	f7f9 fd8e 	bl	8000a94 <__aeabi_fmul>
 8006f78:	1c03      	adds	r3, r0, #0
 8006f7a:	1c1a      	adds	r2, r3, #0
 8006f7c:	68fb      	ldr	r3, [r7, #12]
 8006f7e:	61da      	str	r2, [r3, #28]
 8006f80:	e007      	b.n	8006f92 <plan_compute_profile_parameters+0x3a>
  else { block->max_entry_speed_sqr = nominal_speed*nominal_speed; }
 8006f82:	68b9      	ldr	r1, [r7, #8]
 8006f84:	68b8      	ldr	r0, [r7, #8]
 8006f86:	f7f9 fd85 	bl	8000a94 <__aeabi_fmul>
 8006f8a:	1c03      	adds	r3, r0, #0
 8006f8c:	1c1a      	adds	r2, r3, #0
 8006f8e:	68fb      	ldr	r3, [r7, #12]
 8006f90:	61da      	str	r2, [r3, #28]
  if (block->max_entry_speed_sqr > block->max_junction_speed_sqr) { block->max_entry_speed_sqr = block->max_junction_speed_sqr; }
 8006f92:	68fb      	ldr	r3, [r7, #12]
 8006f94:	69da      	ldr	r2, [r3, #28]
 8006f96:	68fb      	ldr	r3, [r7, #12]
 8006f98:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006f9a:	1c19      	adds	r1, r3, #0
 8006f9c:	1c10      	adds	r0, r2, #0
 8006f9e:	f7f9 f9ad 	bl	80002fc <__aeabi_fcmpgt>
 8006fa2:	1e03      	subs	r3, r0, #0
 8006fa4:	d100      	bne.n	8006fa8 <plan_compute_profile_parameters+0x50>
}
 8006fa6:	e003      	b.n	8006fb0 <plan_compute_profile_parameters+0x58>
  if (block->max_entry_speed_sqr > block->max_junction_speed_sqr) { block->max_entry_speed_sqr = block->max_junction_speed_sqr; }
 8006fa8:	68fb      	ldr	r3, [r7, #12]
 8006faa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8006fac:	68fb      	ldr	r3, [r7, #12]
 8006fae:	61da      	str	r2, [r3, #28]
}
 8006fb0:	46c0      	nop			; (mov r8, r8)
 8006fb2:	46bd      	mov	sp, r7
 8006fb4:	b004      	add	sp, #16
 8006fb6:	bd80      	pop	{r7, pc}

08006fb8 <plan_update_velocity_profile_parameters>:


// Re-calculates buffered motions profile parameters upon a motion-based override change.
void plan_update_velocity_profile_parameters()
{
 8006fb8:	b590      	push	{r4, r7, lr}
 8006fba:	b085      	sub	sp, #20
 8006fbc:	af00      	add	r7, sp, #0
  uint8_t block_index = block_buffer_tail;
 8006fbe:	230f      	movs	r3, #15
 8006fc0:	18fb      	adds	r3, r7, r3
 8006fc2:	4a1b      	ldr	r2, [pc, #108]	; (8007030 <plan_update_velocity_profile_parameters+0x78>)
 8006fc4:	7812      	ldrb	r2, [r2, #0]
 8006fc6:	701a      	strb	r2, [r3, #0]
  plan_block_t *block;
  float nominal_speed;
  float prev_nominal_speed = SOME_LARGE_VALUE; // Set high for first block nominal speed calculation.
 8006fc8:	4b1a      	ldr	r3, [pc, #104]	; (8007034 <plan_update_velocity_profile_parameters+0x7c>)
 8006fca:	60bb      	str	r3, [r7, #8]
  while (block_index != block_buffer_head) {
 8006fcc:	e021      	b.n	8007012 <plan_update_velocity_profile_parameters+0x5a>
    block = &block_buffer[block_index];
 8006fce:	230f      	movs	r3, #15
 8006fd0:	18fb      	adds	r3, r7, r3
 8006fd2:	781a      	ldrb	r2, [r3, #0]
 8006fd4:	0013      	movs	r3, r2
 8006fd6:	00db      	lsls	r3, r3, #3
 8006fd8:	1a9b      	subs	r3, r3, r2
 8006fda:	00db      	lsls	r3, r3, #3
 8006fdc:	4a16      	ldr	r2, [pc, #88]	; (8007038 <plan_update_velocity_profile_parameters+0x80>)
 8006fde:	189b      	adds	r3, r3, r2
 8006fe0:	607b      	str	r3, [r7, #4]
    nominal_speed = plan_compute_profile_nominal_speed(block);
 8006fe2:	687b      	ldr	r3, [r7, #4]
 8006fe4:	0018      	movs	r0, r3
 8006fe6:	f7ff ff63 	bl	8006eb0 <plan_compute_profile_nominal_speed>
 8006fea:	1c03      	adds	r3, r0, #0
 8006fec:	603b      	str	r3, [r7, #0]
    plan_compute_profile_parameters(block, nominal_speed, prev_nominal_speed);
 8006fee:	68ba      	ldr	r2, [r7, #8]
 8006ff0:	6839      	ldr	r1, [r7, #0]
 8006ff2:	687b      	ldr	r3, [r7, #4]
 8006ff4:	0018      	movs	r0, r3
 8006ff6:	f7ff ffaf 	bl	8006f58 <plan_compute_profile_parameters>
    prev_nominal_speed = nominal_speed;
 8006ffa:	683b      	ldr	r3, [r7, #0]
 8006ffc:	60bb      	str	r3, [r7, #8]
    block_index = plan_next_block_index(block_index);
 8006ffe:	230f      	movs	r3, #15
 8007000:	18fc      	adds	r4, r7, r3
 8007002:	230f      	movs	r3, #15
 8007004:	18fb      	adds	r3, r7, r3
 8007006:	781b      	ldrb	r3, [r3, #0]
 8007008:	0018      	movs	r0, r3
 800700a:	f7ff fd29 	bl	8006a60 <plan_next_block_index>
 800700e:	0003      	movs	r3, r0
 8007010:	7023      	strb	r3, [r4, #0]
  while (block_index != block_buffer_head) {
 8007012:	4b0a      	ldr	r3, [pc, #40]	; (800703c <plan_update_velocity_profile_parameters+0x84>)
 8007014:	781b      	ldrb	r3, [r3, #0]
 8007016:	220f      	movs	r2, #15
 8007018:	18ba      	adds	r2, r7, r2
 800701a:	7812      	ldrb	r2, [r2, #0]
 800701c:	429a      	cmp	r2, r3
 800701e:	d1d6      	bne.n	8006fce <plan_update_velocity_profile_parameters+0x16>
  }
  pl.previous_nominal_speed = prev_nominal_speed; // Update prev nominal speed for next incoming block.
 8007020:	4b07      	ldr	r3, [pc, #28]	; (8007040 <plan_update_velocity_profile_parameters+0x88>)
 8007022:	68ba      	ldr	r2, [r7, #8]
 8007024:	621a      	str	r2, [r3, #32]
}
 8007026:	46c0      	nop			; (mov r8, r8)
 8007028:	46bd      	mov	sp, r7
 800702a:	b005      	add	sp, #20
 800702c:	bd90      	pop	{r4, r7, pc}
 800702e:	46c0      	nop			; (mov r8, r8)
 8007030:	20000418 	.word	0x20000418
 8007034:	7f7fffff 	.word	0x7f7fffff
 8007038:	20000098 	.word	0x20000098
 800703c:	20000419 	.word	0x20000419
 8007040:	2000041c 	.word	0x2000041c

08007044 <plan_buffer_line>:
   The system motion condition tells the planner to plan a motion in the always unused block buffer
   head. It avoids changing the planner state and preserves the buffer to ensure subsequent gcode
   motions are still planned correctly, while the stepper module only points to the block buffer head
   to execute the special system motion. */
uint8_t plan_buffer_line(float *target, plan_line_data_t *pl_data)
{
 8007044:	b590      	push	{r4, r7, lr}
 8007046:	b09b      	sub	sp, #108	; 0x6c
 8007048:	af00      	add	r7, sp, #0
 800704a:	6078      	str	r0, [r7, #4]
 800704c:	6039      	str	r1, [r7, #0]
  // Prepare and initialize new block. Copy relevant pl_data for block execution.
  plan_block_t *block = &block_buffer[block_buffer_head];
 800704e:	4bd6      	ldr	r3, [pc, #856]	; (80073a8 <plan_buffer_line+0x364>)
 8007050:	781b      	ldrb	r3, [r3, #0]
 8007052:	001a      	movs	r2, r3
 8007054:	0013      	movs	r3, r2
 8007056:	00db      	lsls	r3, r3, #3
 8007058:	1a9b      	subs	r3, r3, r2
 800705a:	00db      	lsls	r3, r3, #3
 800705c:	4ad3      	ldr	r2, [pc, #844]	; (80073ac <plan_buffer_line+0x368>)
 800705e:	189b      	adds	r3, r3, r2
 8007060:	65bb      	str	r3, [r7, #88]	; 0x58
  memset(block,0,sizeof(plan_block_t)); // Zero all block values.
 8007062:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007064:	2238      	movs	r2, #56	; 0x38
 8007066:	2100      	movs	r1, #0
 8007068:	0018      	movs	r0, r3
 800706a:	f005 fb4b 	bl	800c704 <memset>
  block->condition = pl_data->condition;
 800706e:	683b      	ldr	r3, [r7, #0]
 8007070:	7a1a      	ldrb	r2, [r3, #8]
 8007072:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007074:	755a      	strb	r2, [r3, #21]
  #ifdef VARIABLE_SPINDLE
    block->spindle_speed = pl_data->spindle_speed;
 8007076:	683b      	ldr	r3, [r7, #0]
 8007078:	685a      	ldr	r2, [r3, #4]
 800707a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800707c:	635a      	str	r2, [r3, #52]	; 0x34
  int32_t target_steps[N_AXIS], position_steps[N_AXIS];
  float unit_vec[N_AXIS], delta_mm;
  uint8_t idx;

  // Copy position data based on type of motion being planned.
  if (block->condition & PL_COND_FLAG_SYSTEM_MOTION) {
 800707e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007080:	7d5b      	ldrb	r3, [r3, #21]
 8007082:	001a      	movs	r2, r3
 8007084:	2302      	movs	r3, #2
 8007086:	4013      	ands	r3, r2
 8007088:	d015      	beq.n	80070b6 <plan_buffer_line+0x72>
#ifdef COREXY
    position_steps[X_AXIS] = system_convert_corexy_to_x_axis_steps(sys_position);
 800708a:	4bc9      	ldr	r3, [pc, #804]	; (80073b0 <plan_buffer_line+0x36c>)
 800708c:	0018      	movs	r0, r3
 800708e:	f004 ffa7 	bl	800bfe0 <system_convert_corexy_to_x_axis_steps>
 8007092:	0002      	movs	r2, r0
 8007094:	232c      	movs	r3, #44	; 0x2c
 8007096:	18fb      	adds	r3, r7, r3
 8007098:	601a      	str	r2, [r3, #0]
    position_steps[Y_AXIS] = system_convert_corexy_to_y_axis_steps(sys_position);
 800709a:	4bc5      	ldr	r3, [pc, #788]	; (80073b0 <plan_buffer_line+0x36c>)
 800709c:	0018      	movs	r0, r3
 800709e:	f004 ffb1 	bl	800c004 <system_convert_corexy_to_y_axis_steps>
 80070a2:	0002      	movs	r2, r0
 80070a4:	232c      	movs	r3, #44	; 0x2c
 80070a6:	18fb      	adds	r3, r7, r3
 80070a8:	605a      	str	r2, [r3, #4]
    position_steps[Z_AXIS] = sys_position[Z_AXIS];
 80070aa:	4bc1      	ldr	r3, [pc, #772]	; (80073b0 <plan_buffer_line+0x36c>)
 80070ac:	689a      	ldr	r2, [r3, #8]
 80070ae:	232c      	movs	r3, #44	; 0x2c
 80070b0:	18fb      	adds	r3, r7, r3
 80070b2:	609a      	str	r2, [r3, #8]
 80070b4:	e006      	b.n	80070c4 <plan_buffer_line+0x80>
#else
    memcpy(position_steps, sys_position, sizeof(sys_position));
#endif
  }
  else { memcpy(position_steps, pl.position, sizeof(pl.position)); }
 80070b6:	232c      	movs	r3, #44	; 0x2c
 80070b8:	18fb      	adds	r3, r7, r3
 80070ba:	4abe      	ldr	r2, [pc, #760]	; (80073b4 <plan_buffer_line+0x370>)
 80070bc:	ca13      	ldmia	r2!, {r0, r1, r4}
 80070be:	c313      	stmia	r3!, {r0, r1, r4}
 80070c0:	6812      	ldr	r2, [r2, #0]
 80070c2:	601a      	str	r2, [r3, #0]

  #ifdef COREXY
    target_steps[A_MOTOR] = lround(target[A_MOTOR]*settings.steps_per_mm[A_MOTOR]);
 80070c4:	687b      	ldr	r3, [r7, #4]
 80070c6:	681a      	ldr	r2, [r3, #0]
 80070c8:	4bbb      	ldr	r3, [pc, #748]	; (80073b8 <plan_buffer_line+0x374>)
 80070ca:	681b      	ldr	r3, [r3, #0]
 80070cc:	1c19      	adds	r1, r3, #0
 80070ce:	1c10      	adds	r0, r2, #0
 80070d0:	f7f9 fce0 	bl	8000a94 <__aeabi_fmul>
 80070d4:	1c03      	adds	r3, r0, #0
 80070d6:	1c18      	adds	r0, r3, #0
 80070d8:	f7fb faf4 	bl	80026c4 <__aeabi_f2d>
 80070dc:	0003      	movs	r3, r0
 80070de:	000c      	movs	r4, r1
 80070e0:	0018      	movs	r0, r3
 80070e2:	0021      	movs	r1, r4
 80070e4:	f005 fb16 	bl	800c714 <lround>
 80070e8:	0002      	movs	r2, r0
 80070ea:	233c      	movs	r3, #60	; 0x3c
 80070ec:	18fb      	adds	r3, r7, r3
 80070ee:	601a      	str	r2, [r3, #0]
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
 80070f0:	687b      	ldr	r3, [r7, #4]
 80070f2:	3304      	adds	r3, #4
 80070f4:	681a      	ldr	r2, [r3, #0]
 80070f6:	4bb0      	ldr	r3, [pc, #704]	; (80073b8 <plan_buffer_line+0x374>)
 80070f8:	685b      	ldr	r3, [r3, #4]
 80070fa:	1c19      	adds	r1, r3, #0
 80070fc:	1c10      	adds	r0, r2, #0
 80070fe:	f7f9 fcc9 	bl	8000a94 <__aeabi_fmul>
 8007102:	1c03      	adds	r3, r0, #0
 8007104:	1c18      	adds	r0, r3, #0
 8007106:	f7fb fadd 	bl	80026c4 <__aeabi_f2d>
 800710a:	0003      	movs	r3, r0
 800710c:	000c      	movs	r4, r1
 800710e:	0018      	movs	r0, r3
 8007110:	0021      	movs	r1, r4
 8007112:	f005 faff 	bl	800c714 <lround>
 8007116:	0002      	movs	r2, r0
 8007118:	233c      	movs	r3, #60	; 0x3c
 800711a:	18fb      	adds	r3, r7, r3
 800711c:	605a      	str	r2, [r3, #4]
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-position_steps[X_AXIS]) + (target_steps[Y_AXIS]-position_steps[Y_AXIS]));
 800711e:	233c      	movs	r3, #60	; 0x3c
 8007120:	18fb      	adds	r3, r7, r3
 8007122:	681a      	ldr	r2, [r3, #0]
 8007124:	232c      	movs	r3, #44	; 0x2c
 8007126:	18fb      	adds	r3, r7, r3
 8007128:	681b      	ldr	r3, [r3, #0]
 800712a:	1ad2      	subs	r2, r2, r3
 800712c:	233c      	movs	r3, #60	; 0x3c
 800712e:	18fb      	adds	r3, r7, r3
 8007130:	6859      	ldr	r1, [r3, #4]
 8007132:	232c      	movs	r3, #44	; 0x2c
 8007134:	18fb      	adds	r3, r7, r3
 8007136:	685b      	ldr	r3, [r3, #4]
 8007138:	1acb      	subs	r3, r1, r3
 800713a:	18d3      	adds	r3, r2, r3
 800713c:	17da      	asrs	r2, r3, #31
 800713e:	189b      	adds	r3, r3, r2
 8007140:	4053      	eors	r3, r2
 8007142:	001a      	movs	r2, r3
 8007144:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007146:	601a      	str	r2, [r3, #0]
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-position_steps[X_AXIS]) - (target_steps[Y_AXIS]-position_steps[Y_AXIS]));
 8007148:	233c      	movs	r3, #60	; 0x3c
 800714a:	18fb      	adds	r3, r7, r3
 800714c:	681a      	ldr	r2, [r3, #0]
 800714e:	232c      	movs	r3, #44	; 0x2c
 8007150:	18fb      	adds	r3, r7, r3
 8007152:	681b      	ldr	r3, [r3, #0]
 8007154:	1ad2      	subs	r2, r2, r3
 8007156:	233c      	movs	r3, #60	; 0x3c
 8007158:	18fb      	adds	r3, r7, r3
 800715a:	6859      	ldr	r1, [r3, #4]
 800715c:	232c      	movs	r3, #44	; 0x2c
 800715e:	18fb      	adds	r3, r7, r3
 8007160:	685b      	ldr	r3, [r3, #4]
 8007162:	1acb      	subs	r3, r1, r3
 8007164:	1ad3      	subs	r3, r2, r3
 8007166:	17da      	asrs	r2, r3, #31
 8007168:	189b      	adds	r3, r3, r2
 800716a:	4053      	eors	r3, r2
 800716c:	001a      	movs	r2, r3
 800716e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007170:	605a      	str	r2, [r3, #4]
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
 8007172:	2363      	movs	r3, #99	; 0x63
 8007174:	18fb      	adds	r3, r7, r3
 8007176:	2200      	movs	r2, #0
 8007178:	701a      	strb	r2, [r3, #0]
 800717a:	e0e2      	b.n	8007342 <plan_buffer_line+0x2fe>
    // Calculate target position in absolute steps, number of steps for each axis, and determine max step events.
    // Also, compute individual axes distance for move and prep unit vector calculations.
    // NOTE: Computes true distance from converted step values.
    #ifdef COREXY
      if ( !(idx == A_MOTOR) && !(idx == B_MOTOR) ) {
 800717c:	2363      	movs	r3, #99	; 0x63
 800717e:	18fb      	adds	r3, r7, r3
 8007180:	781b      	ldrb	r3, [r3, #0]
 8007182:	2b00      	cmp	r3, #0
 8007184:	d03f      	beq.n	8007206 <plan_buffer_line+0x1c2>
 8007186:	2363      	movs	r3, #99	; 0x63
 8007188:	18fb      	adds	r3, r7, r3
 800718a:	781b      	ldrb	r3, [r3, #0]
 800718c:	2b01      	cmp	r3, #1
 800718e:	d03a      	beq.n	8007206 <plan_buffer_line+0x1c2>
        target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
 8007190:	2363      	movs	r3, #99	; 0x63
 8007192:	18fb      	adds	r3, r7, r3
 8007194:	781c      	ldrb	r4, [r3, #0]
 8007196:	2363      	movs	r3, #99	; 0x63
 8007198:	18fb      	adds	r3, r7, r3
 800719a:	781b      	ldrb	r3, [r3, #0]
 800719c:	009b      	lsls	r3, r3, #2
 800719e:	687a      	ldr	r2, [r7, #4]
 80071a0:	18d3      	adds	r3, r2, r3
 80071a2:	6818      	ldr	r0, [r3, #0]
 80071a4:	2363      	movs	r3, #99	; 0x63
 80071a6:	18fb      	adds	r3, r7, r3
 80071a8:	781a      	ldrb	r2, [r3, #0]
 80071aa:	4b83      	ldr	r3, [pc, #524]	; (80073b8 <plan_buffer_line+0x374>)
 80071ac:	0092      	lsls	r2, r2, #2
 80071ae:	58d3      	ldr	r3, [r2, r3]
 80071b0:	1c19      	adds	r1, r3, #0
 80071b2:	f7f9 fc6f 	bl	8000a94 <__aeabi_fmul>
 80071b6:	1c03      	adds	r3, r0, #0
 80071b8:	1c18      	adds	r0, r3, #0
 80071ba:	f7fb fa83 	bl	80026c4 <__aeabi_f2d>
 80071be:	0002      	movs	r2, r0
 80071c0:	000b      	movs	r3, r1
 80071c2:	0010      	movs	r0, r2
 80071c4:	0019      	movs	r1, r3
 80071c6:	f005 faa5 	bl	800c714 <lround>
 80071ca:	0001      	movs	r1, r0
 80071cc:	233c      	movs	r3, #60	; 0x3c
 80071ce:	18fb      	adds	r3, r7, r3
 80071d0:	00a2      	lsls	r2, r4, #2
 80071d2:	50d1      	str	r1, [r2, r3]
        block->steps[idx] = labs(target_steps[idx]-position_steps[idx]);
 80071d4:	2363      	movs	r3, #99	; 0x63
 80071d6:	18fb      	adds	r3, r7, r3
 80071d8:	781a      	ldrb	r2, [r3, #0]
 80071da:	2363      	movs	r3, #99	; 0x63
 80071dc:	18fb      	adds	r3, r7, r3
 80071de:	7819      	ldrb	r1, [r3, #0]
 80071e0:	233c      	movs	r3, #60	; 0x3c
 80071e2:	18fb      	adds	r3, r7, r3
 80071e4:	0089      	lsls	r1, r1, #2
 80071e6:	58c9      	ldr	r1, [r1, r3]
 80071e8:	2363      	movs	r3, #99	; 0x63
 80071ea:	18fb      	adds	r3, r7, r3
 80071ec:	7818      	ldrb	r0, [r3, #0]
 80071ee:	232c      	movs	r3, #44	; 0x2c
 80071f0:	18fb      	adds	r3, r7, r3
 80071f2:	0080      	lsls	r0, r0, #2
 80071f4:	58c3      	ldr	r3, [r0, r3]
 80071f6:	1acb      	subs	r3, r1, r3
 80071f8:	17d9      	asrs	r1, r3, #31
 80071fa:	185b      	adds	r3, r3, r1
 80071fc:	404b      	eors	r3, r1
 80071fe:	0019      	movs	r1, r3
 8007200:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007202:	0092      	lsls	r2, r2, #2
 8007204:	50d1      	str	r1, [r2, r3]
      }
      block->step_event_count = max(block->step_event_count, block->steps[idx]);
 8007206:	2363      	movs	r3, #99	; 0x63
 8007208:	18fb      	adds	r3, r7, r3
 800720a:	781a      	ldrb	r2, [r3, #0]
 800720c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800720e:	0092      	lsls	r2, r2, #2
 8007210:	58d1      	ldr	r1, [r2, r3]
 8007212:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007214:	691a      	ldr	r2, [r3, #16]
 8007216:	000b      	movs	r3, r1
 8007218:	4293      	cmp	r3, r2
 800721a:	d200      	bcs.n	800721e <plan_buffer_line+0x1da>
 800721c:	0013      	movs	r3, r2
 800721e:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8007220:	6113      	str	r3, [r2, #16]
      if (idx == A_MOTOR) {
 8007222:	2363      	movs	r3, #99	; 0x63
 8007224:	18fb      	adds	r3, r7, r3
 8007226:	781b      	ldrb	r3, [r3, #0]
 8007228:	2b00      	cmp	r3, #0
 800722a:	d11d      	bne.n	8007268 <plan_buffer_line+0x224>
        delta_mm = (target_steps[X_AXIS]-position_steps[X_AXIS] + target_steps[Y_AXIS]-position_steps[Y_AXIS])/settings.steps_per_mm[idx];
 800722c:	233c      	movs	r3, #60	; 0x3c
 800722e:	18fb      	adds	r3, r7, r3
 8007230:	681a      	ldr	r2, [r3, #0]
 8007232:	232c      	movs	r3, #44	; 0x2c
 8007234:	18fb      	adds	r3, r7, r3
 8007236:	681b      	ldr	r3, [r3, #0]
 8007238:	1ad2      	subs	r2, r2, r3
 800723a:	233c      	movs	r3, #60	; 0x3c
 800723c:	18fb      	adds	r3, r7, r3
 800723e:	685b      	ldr	r3, [r3, #4]
 8007240:	18d2      	adds	r2, r2, r3
 8007242:	232c      	movs	r3, #44	; 0x2c
 8007244:	18fb      	adds	r3, r7, r3
 8007246:	685b      	ldr	r3, [r3, #4]
 8007248:	1ad3      	subs	r3, r2, r3
 800724a:	0018      	movs	r0, r3
 800724c:	f7f9 ff16 	bl	800107c <__aeabi_i2f>
 8007250:	2363      	movs	r3, #99	; 0x63
 8007252:	18fb      	adds	r3, r7, r3
 8007254:	781a      	ldrb	r2, [r3, #0]
 8007256:	4b58      	ldr	r3, [pc, #352]	; (80073b8 <plan_buffer_line+0x374>)
 8007258:	0092      	lsls	r2, r2, #2
 800725a:	58d3      	ldr	r3, [r2, r3]
 800725c:	1c19      	adds	r1, r3, #0
 800725e:	f7f9 fa29 	bl	80006b4 <__aeabi_fdiv>
 8007262:	1c03      	adds	r3, r0, #0
 8007264:	667b      	str	r3, [r7, #100]	; 0x64
 8007266:	e03f      	b.n	80072e8 <plan_buffer_line+0x2a4>
      } else if (idx == B_MOTOR) {
 8007268:	2363      	movs	r3, #99	; 0x63
 800726a:	18fb      	adds	r3, r7, r3
 800726c:	781b      	ldrb	r3, [r3, #0]
 800726e:	2b01      	cmp	r3, #1
 8007270:	d11d      	bne.n	80072ae <plan_buffer_line+0x26a>
        delta_mm = (target_steps[X_AXIS]-position_steps[X_AXIS] - target_steps[Y_AXIS]+position_steps[Y_AXIS])/settings.steps_per_mm[idx];
 8007272:	233c      	movs	r3, #60	; 0x3c
 8007274:	18fb      	adds	r3, r7, r3
 8007276:	681a      	ldr	r2, [r3, #0]
 8007278:	232c      	movs	r3, #44	; 0x2c
 800727a:	18fb      	adds	r3, r7, r3
 800727c:	681b      	ldr	r3, [r3, #0]
 800727e:	1ad2      	subs	r2, r2, r3
 8007280:	233c      	movs	r3, #60	; 0x3c
 8007282:	18fb      	adds	r3, r7, r3
 8007284:	685b      	ldr	r3, [r3, #4]
 8007286:	1ad2      	subs	r2, r2, r3
 8007288:	232c      	movs	r3, #44	; 0x2c
 800728a:	18fb      	adds	r3, r7, r3
 800728c:	685b      	ldr	r3, [r3, #4]
 800728e:	18d3      	adds	r3, r2, r3
 8007290:	0018      	movs	r0, r3
 8007292:	f7f9 fef3 	bl	800107c <__aeabi_i2f>
 8007296:	2363      	movs	r3, #99	; 0x63
 8007298:	18fb      	adds	r3, r7, r3
 800729a:	781a      	ldrb	r2, [r3, #0]
 800729c:	4b46      	ldr	r3, [pc, #280]	; (80073b8 <plan_buffer_line+0x374>)
 800729e:	0092      	lsls	r2, r2, #2
 80072a0:	58d3      	ldr	r3, [r2, r3]
 80072a2:	1c19      	adds	r1, r3, #0
 80072a4:	f7f9 fa06 	bl	80006b4 <__aeabi_fdiv>
 80072a8:	1c03      	adds	r3, r0, #0
 80072aa:	667b      	str	r3, [r7, #100]	; 0x64
 80072ac:	e01c      	b.n	80072e8 <plan_buffer_line+0x2a4>
      } else {
        delta_mm = (target_steps[idx] - position_steps[idx])/settings.steps_per_mm[idx];
 80072ae:	2363      	movs	r3, #99	; 0x63
 80072b0:	18fb      	adds	r3, r7, r3
 80072b2:	781a      	ldrb	r2, [r3, #0]
 80072b4:	233c      	movs	r3, #60	; 0x3c
 80072b6:	18fb      	adds	r3, r7, r3
 80072b8:	0092      	lsls	r2, r2, #2
 80072ba:	58d2      	ldr	r2, [r2, r3]
 80072bc:	2363      	movs	r3, #99	; 0x63
 80072be:	18fb      	adds	r3, r7, r3
 80072c0:	7819      	ldrb	r1, [r3, #0]
 80072c2:	232c      	movs	r3, #44	; 0x2c
 80072c4:	18fb      	adds	r3, r7, r3
 80072c6:	0089      	lsls	r1, r1, #2
 80072c8:	58cb      	ldr	r3, [r1, r3]
 80072ca:	1ad3      	subs	r3, r2, r3
 80072cc:	0018      	movs	r0, r3
 80072ce:	f7f9 fed5 	bl	800107c <__aeabi_i2f>
 80072d2:	2363      	movs	r3, #99	; 0x63
 80072d4:	18fb      	adds	r3, r7, r3
 80072d6:	781a      	ldrb	r2, [r3, #0]
 80072d8:	4b37      	ldr	r3, [pc, #220]	; (80073b8 <plan_buffer_line+0x374>)
 80072da:	0092      	lsls	r2, r2, #2
 80072dc:	58d3      	ldr	r3, [r2, r3]
 80072de:	1c19      	adds	r1, r3, #0
 80072e0:	f7f9 f9e8 	bl	80006b4 <__aeabi_fdiv>
 80072e4:	1c03      	adds	r3, r0, #0
 80072e6:	667b      	str	r3, [r7, #100]	; 0x64
      target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
      block->steps[idx] = labs(target_steps[idx]-position_steps[idx]);
      block->step_event_count = max(block->step_event_count, block->steps[idx]);
      delta_mm = (target_steps[idx] - position_steps[idx])/settings.steps_per_mm[idx];
	  #endif
    unit_vec[idx] = delta_mm; // Store unit vector numerator
 80072e8:	2363      	movs	r3, #99	; 0x63
 80072ea:	18fb      	adds	r3, r7, r3
 80072ec:	781a      	ldrb	r2, [r3, #0]
 80072ee:	231c      	movs	r3, #28
 80072f0:	18fb      	adds	r3, r7, r3
 80072f2:	0092      	lsls	r2, r2, #2
 80072f4:	6e79      	ldr	r1, [r7, #100]	; 0x64
 80072f6:	50d1      	str	r1, [r2, r3]

    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0.0f ) { block->direction_bits |= direction_pin_mask[idx]; }
 80072f8:	2100      	movs	r1, #0
 80072fa:	6e78      	ldr	r0, [r7, #100]	; 0x64
 80072fc:	f7f8 ffea 	bl	80002d4 <__aeabi_fcmplt>
 8007300:	1e03      	subs	r3, r0, #0
 8007302:	d00c      	beq.n	800731e <plan_buffer_line+0x2da>
 8007304:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007306:	7d1a      	ldrb	r2, [r3, #20]
 8007308:	2363      	movs	r3, #99	; 0x63
 800730a:	18fb      	adds	r3, r7, r3
 800730c:	7819      	ldrb	r1, [r3, #0]
 800730e:	4b2b      	ldr	r3, [pc, #172]	; (80073bc <plan_buffer_line+0x378>)
 8007310:	0049      	lsls	r1, r1, #1
 8007312:	5acb      	ldrh	r3, [r1, r3]
 8007314:	b2db      	uxtb	r3, r3
 8007316:	4313      	orrs	r3, r2
 8007318:	b2da      	uxtb	r2, r3
 800731a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800731c:	751a      	strb	r2, [r3, #20]
    if (sys.state == STATE_HOMING) {
 800731e:	4b28      	ldr	r3, [pc, #160]	; (80073c0 <plan_buffer_line+0x37c>)
 8007320:	781b      	ldrb	r3, [r3, #0]
 8007322:	2b04      	cmp	r3, #4
 8007324:	d106      	bne.n	8007334 <plan_buffer_line+0x2f0>
    	block->direction_bits ^= 0x1;
 8007326:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007328:	7d1b      	ldrb	r3, [r3, #20]
 800732a:	2201      	movs	r2, #1
 800732c:	4053      	eors	r3, r2
 800732e:	b2da      	uxtb	r2, r3
 8007330:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007332:	751a      	strb	r2, [r3, #20]
  for (idx=0; idx<N_AXIS; idx++) {
 8007334:	2363      	movs	r3, #99	; 0x63
 8007336:	18fb      	adds	r3, r7, r3
 8007338:	781a      	ldrb	r2, [r3, #0]
 800733a:	2363      	movs	r3, #99	; 0x63
 800733c:	18fb      	adds	r3, r7, r3
 800733e:	3201      	adds	r2, #1
 8007340:	701a      	strb	r2, [r3, #0]
 8007342:	2363      	movs	r3, #99	; 0x63
 8007344:	18fb      	adds	r3, r7, r3
 8007346:	781b      	ldrb	r3, [r3, #0]
 8007348:	2b03      	cmp	r3, #3
 800734a:	d800      	bhi.n	800734e <plan_buffer_line+0x30a>
 800734c:	e716      	b.n	800717c <plan_buffer_line+0x138>
    }
  }

  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return(PLAN_EMPTY_BLOCK); }
 800734e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007350:	691b      	ldr	r3, [r3, #16]
 8007352:	2b00      	cmp	r3, #0
 8007354:	d101      	bne.n	800735a <plan_buffer_line+0x316>
 8007356:	2300      	movs	r3, #0
 8007358:	e149      	b.n	80075ee <plan_buffer_line+0x5aa>

  // Calculate the unit vector of the line move and the block maximum feed rate and acceleration scaled
  // down such that no individual axes maximum values are exceeded with respect to the line direction.
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  block->millimeters = convert_delta_vector_to_unit_vector(unit_vec);
 800735a:	231c      	movs	r3, #28
 800735c:	18fb      	adds	r3, r7, r3
 800735e:	0018      	movs	r0, r3
 8007360:	f7ff faae 	bl	80068c0 <convert_delta_vector_to_unit_vector>
 8007364:	1c02      	adds	r2, r0, #0
 8007366:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007368:	625a      	str	r2, [r3, #36]	; 0x24
  block->acceleration = limit_value_by_axis_maximum(settings.acceleration, unit_vec);
 800736a:	231c      	movs	r3, #28
 800736c:	18fa      	adds	r2, r7, r3
 800736e:	4b15      	ldr	r3, [pc, #84]	; (80073c4 <plan_buffer_line+0x380>)
 8007370:	0011      	movs	r1, r2
 8007372:	0018      	movs	r0, r3
 8007374:	f7ff fb16 	bl	80069a4 <limit_value_by_axis_maximum>
 8007378:	1c02      	adds	r2, r0, #0
 800737a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800737c:	621a      	str	r2, [r3, #32]
  block->rapid_rate = limit_value_by_axis_maximum(settings.max_rate, unit_vec);
 800737e:	231c      	movs	r3, #28
 8007380:	18fa      	adds	r2, r7, r3
 8007382:	4b11      	ldr	r3, [pc, #68]	; (80073c8 <plan_buffer_line+0x384>)
 8007384:	0011      	movs	r1, r2
 8007386:	0018      	movs	r0, r3
 8007388:	f7ff fb0c 	bl	80069a4 <limit_value_by_axis_maximum>
 800738c:	1c02      	adds	r2, r0, #0
 800738e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007390:	62da      	str	r2, [r3, #44]	; 0x2c

  // Store programmed rate.
  if (block->condition & PL_COND_FLAG_RAPID_MOTION) { block->programmed_rate = block->rapid_rate; }
 8007392:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007394:	7d5b      	ldrb	r3, [r3, #21]
 8007396:	001a      	movs	r2, r3
 8007398:	2301      	movs	r3, #1
 800739a:	4013      	ands	r3, r2
 800739c:	d016      	beq.n	80073cc <plan_buffer_line+0x388>
 800739e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80073a0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80073a2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80073a4:	631a      	str	r2, [r3, #48]	; 0x30
 80073a6:	e027      	b.n	80073f8 <plan_buffer_line+0x3b4>
 80073a8:	20000419 	.word	0x20000419
 80073ac:	20000098 	.word	0x20000098
 80073b0:	20000bdc 	.word	0x20000bdc
 80073b4:	2000041c 	.word	0x2000041c
 80073b8:	20000b44 	.word	0x20000b44
 80073bc:	0800e0b4 	.word	0x0800e0b4
 80073c0:	20000bb4 	.word	0x20000bb4
 80073c4:	20000b64 	.word	0x20000b64
 80073c8:	20000b54 	.word	0x20000b54
  else { 
    block->programmed_rate = pl_data->feed_rate;
 80073cc:	683b      	ldr	r3, [r7, #0]
 80073ce:	681a      	ldr	r2, [r3, #0]
 80073d0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80073d2:	631a      	str	r2, [r3, #48]	; 0x30
    if (block->condition & PL_COND_FLAG_INVERSE_TIME) { block->programmed_rate *= block->millimeters; }
 80073d4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80073d6:	7d5b      	ldrb	r3, [r3, #21]
 80073d8:	001a      	movs	r2, r3
 80073da:	2308      	movs	r3, #8
 80073dc:	4013      	ands	r3, r2
 80073de:	d00b      	beq.n	80073f8 <plan_buffer_line+0x3b4>
 80073e0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80073e2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80073e4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80073e6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80073e8:	1c19      	adds	r1, r3, #0
 80073ea:	1c10      	adds	r0, r2, #0
 80073ec:	f7f9 fb52 	bl	8000a94 <__aeabi_fmul>
 80073f0:	1c03      	adds	r3, r0, #0
 80073f2:	1c1a      	adds	r2, r3, #0
 80073f4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80073f6:	631a      	str	r2, [r3, #48]	; 0x30
  }

  // TODO: Need to check this method handling zero junction speeds when starting from rest.
  if ((block_buffer_head == block_buffer_tail) || (block->condition & PL_COND_FLAG_SYSTEM_MOTION)) {
 80073f8:	4b7f      	ldr	r3, [pc, #508]	; (80075f8 <plan_buffer_line+0x5b4>)
 80073fa:	781a      	ldrb	r2, [r3, #0]
 80073fc:	4b7f      	ldr	r3, [pc, #508]	; (80075fc <plan_buffer_line+0x5b8>)
 80073fe:	781b      	ldrb	r3, [r3, #0]
 8007400:	429a      	cmp	r2, r3
 8007402:	d005      	beq.n	8007410 <plan_buffer_line+0x3cc>
 8007404:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007406:	7d5b      	ldrb	r3, [r3, #21]
 8007408:	001a      	movs	r2, r3
 800740a:	2302      	movs	r3, #2
 800740c:	4013      	ands	r3, r2
 800740e:	d006      	beq.n	800741e <plan_buffer_line+0x3da>

    // Initialize block entry speed as zero. Assume it will be starting from rest. Planner will correct this later.
    // If system motion, the system motion block always is assumed to start from rest and end at a complete stop.
    block->entry_speed_sqr = 0.0f;
 8007410:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007412:	2200      	movs	r2, #0
 8007414:	619a      	str	r2, [r3, #24]
    block->max_junction_speed_sqr = 0.0f; // Starting from rest. Enforce start from zero velocity.
 8007416:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007418:	2200      	movs	r2, #0
 800741a:	629a      	str	r2, [r3, #40]	; 0x28
 800741c:	e0b2      	b.n	8007584 <plan_buffer_line+0x540>
    // changed dynamically during operation nor can the line move geometry. This must be kept in
    // memory in the event of a feedrate override changing the nominal speeds of blocks, which can
    // change the overall maximum entry speed conditions of all blocks.

    float junction_unit_vec[N_AXIS];
    float junction_cos_theta = 0.0f;
 800741e:	2300      	movs	r3, #0
 8007420:	65fb      	str	r3, [r7, #92]	; 0x5c
    for (idx=0; idx<N_AXIS; idx++) {
 8007422:	2363      	movs	r3, #99	; 0x63
 8007424:	18fb      	adds	r3, r7, r3
 8007426:	2200      	movs	r2, #0
 8007428:	701a      	strb	r2, [r3, #0]
 800742a:	e038      	b.n	800749e <plan_buffer_line+0x45a>
      junction_cos_theta -= pl.previous_unit_vec[idx]*unit_vec[idx];
 800742c:	2363      	movs	r3, #99	; 0x63
 800742e:	18fb      	adds	r3, r7, r3
 8007430:	781a      	ldrb	r2, [r3, #0]
 8007432:	4b73      	ldr	r3, [pc, #460]	; (8007600 <plan_buffer_line+0x5bc>)
 8007434:	3204      	adds	r2, #4
 8007436:	0092      	lsls	r2, r2, #2
 8007438:	58d0      	ldr	r0, [r2, r3]
 800743a:	2363      	movs	r3, #99	; 0x63
 800743c:	18fb      	adds	r3, r7, r3
 800743e:	781a      	ldrb	r2, [r3, #0]
 8007440:	231c      	movs	r3, #28
 8007442:	18fb      	adds	r3, r7, r3
 8007444:	0092      	lsls	r2, r2, #2
 8007446:	58d3      	ldr	r3, [r2, r3]
 8007448:	1c19      	adds	r1, r3, #0
 800744a:	f7f9 fb23 	bl	8000a94 <__aeabi_fmul>
 800744e:	1c03      	adds	r3, r0, #0
 8007450:	1c19      	adds	r1, r3, #0
 8007452:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 8007454:	f7f9 fc3e 	bl	8000cd4 <__aeabi_fsub>
 8007458:	1c03      	adds	r3, r0, #0
 800745a:	65fb      	str	r3, [r7, #92]	; 0x5c
      junction_unit_vec[idx] = unit_vec[idx]-pl.previous_unit_vec[idx];
 800745c:	2363      	movs	r3, #99	; 0x63
 800745e:	18fb      	adds	r3, r7, r3
 8007460:	781c      	ldrb	r4, [r3, #0]
 8007462:	2363      	movs	r3, #99	; 0x63
 8007464:	18fb      	adds	r3, r7, r3
 8007466:	781a      	ldrb	r2, [r3, #0]
 8007468:	231c      	movs	r3, #28
 800746a:	18fb      	adds	r3, r7, r3
 800746c:	0092      	lsls	r2, r2, #2
 800746e:	58d0      	ldr	r0, [r2, r3]
 8007470:	2363      	movs	r3, #99	; 0x63
 8007472:	18fb      	adds	r3, r7, r3
 8007474:	781a      	ldrb	r2, [r3, #0]
 8007476:	4b62      	ldr	r3, [pc, #392]	; (8007600 <plan_buffer_line+0x5bc>)
 8007478:	3204      	adds	r2, #4
 800747a:	0092      	lsls	r2, r2, #2
 800747c:	58d3      	ldr	r3, [r2, r3]
 800747e:	1c19      	adds	r1, r3, #0
 8007480:	f7f9 fc28 	bl	8000cd4 <__aeabi_fsub>
 8007484:	1c03      	adds	r3, r0, #0
 8007486:	1c19      	adds	r1, r3, #0
 8007488:	230c      	movs	r3, #12
 800748a:	18fb      	adds	r3, r7, r3
 800748c:	00a2      	lsls	r2, r4, #2
 800748e:	50d1      	str	r1, [r2, r3]
    for (idx=0; idx<N_AXIS; idx++) {
 8007490:	2363      	movs	r3, #99	; 0x63
 8007492:	18fb      	adds	r3, r7, r3
 8007494:	781a      	ldrb	r2, [r3, #0]
 8007496:	2363      	movs	r3, #99	; 0x63
 8007498:	18fb      	adds	r3, r7, r3
 800749a:	3201      	adds	r2, #1
 800749c:	701a      	strb	r2, [r3, #0]
 800749e:	2363      	movs	r3, #99	; 0x63
 80074a0:	18fb      	adds	r3, r7, r3
 80074a2:	781b      	ldrb	r3, [r3, #0]
 80074a4:	2b03      	cmp	r3, #3
 80074a6:	d9c1      	bls.n	800742c <plan_buffer_line+0x3e8>
    }

    // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
    if (junction_cos_theta > 0.999999f) {
 80074a8:	4956      	ldr	r1, [pc, #344]	; (8007604 <plan_buffer_line+0x5c0>)
 80074aa:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 80074ac:	f7f8 ff26 	bl	80002fc <__aeabi_fcmpgt>
 80074b0:	1e03      	subs	r3, r0, #0
 80074b2:	d003      	beq.n	80074bc <plan_buffer_line+0x478>
      //  For a 0 degree acute junction, just set minimum junction speed.
      block->max_junction_speed_sqr = MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED;
 80074b4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80074b6:	2200      	movs	r2, #0
 80074b8:	629a      	str	r2, [r3, #40]	; 0x28
 80074ba:	e063      	b.n	8007584 <plan_buffer_line+0x540>
    } else {
      if (junction_cos_theta < -0.999999f) {
 80074bc:	4952      	ldr	r1, [pc, #328]	; (8007608 <plan_buffer_line+0x5c4>)
 80074be:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 80074c0:	f7f8 ff08 	bl	80002d4 <__aeabi_fcmplt>
 80074c4:	1e03      	subs	r3, r0, #0
 80074c6:	d003      	beq.n	80074d0 <plan_buffer_line+0x48c>
        // Junction is a straight line or 180 degrees. Junction speed is infinite.
        block->max_junction_speed_sqr = SOME_LARGE_VALUE;
 80074c8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80074ca:	4a50      	ldr	r2, [pc, #320]	; (800760c <plan_buffer_line+0x5c8>)
 80074cc:	629a      	str	r2, [r3, #40]	; 0x28
 80074ce:	e059      	b.n	8007584 <plan_buffer_line+0x540>
      } else {
        convert_delta_vector_to_unit_vector(junction_unit_vec);
 80074d0:	230c      	movs	r3, #12
 80074d2:	18fb      	adds	r3, r7, r3
 80074d4:	0018      	movs	r0, r3
 80074d6:	f7ff f9f3 	bl	80068c0 <convert_delta_vector_to_unit_vector>
        float junction_acceleration = limit_value_by_axis_maximum(settings.acceleration, junction_unit_vec);
 80074da:	230c      	movs	r3, #12
 80074dc:	18fa      	adds	r2, r7, r3
 80074de:	4b4c      	ldr	r3, [pc, #304]	; (8007610 <plan_buffer_line+0x5cc>)
 80074e0:	0011      	movs	r1, r2
 80074e2:	0018      	movs	r0, r3
 80074e4:	f7ff fa5e 	bl	80069a4 <limit_value_by_axis_maximum>
 80074e8:	1c03      	adds	r3, r0, #0
 80074ea:	657b      	str	r3, [r7, #84]	; 0x54
        float sin_theta_d2 = sqrtf(0.5f*(1.0f-junction_cos_theta)); // Trig half angle identity. Always positive.
 80074ec:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 80074ee:	20fe      	movs	r0, #254	; 0xfe
 80074f0:	0580      	lsls	r0, r0, #22
 80074f2:	f7f9 fbef 	bl	8000cd4 <__aeabi_fsub>
 80074f6:	1c03      	adds	r3, r0, #0
 80074f8:	21fc      	movs	r1, #252	; 0xfc
 80074fa:	0589      	lsls	r1, r1, #22
 80074fc:	1c18      	adds	r0, r3, #0
 80074fe:	f7f9 fac9 	bl	8000a94 <__aeabi_fmul>
 8007502:	1c03      	adds	r3, r0, #0
 8007504:	1c18      	adds	r0, r3, #0
 8007506:	f005 fa95 	bl	800ca34 <sqrtf>
 800750a:	1c03      	adds	r3, r0, #0
 800750c:	653b      	str	r3, [r7, #80]	; 0x50
        block->max_junction_speed_sqr = max( MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED,
 800750e:	4b41      	ldr	r3, [pc, #260]	; (8007614 <plan_buffer_line+0x5d0>)
 8007510:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8007512:	6d79      	ldr	r1, [r7, #84]	; 0x54
 8007514:	1c18      	adds	r0, r3, #0
 8007516:	f7f9 fabd 	bl	8000a94 <__aeabi_fmul>
 800751a:	1c03      	adds	r3, r0, #0
 800751c:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800751e:	1c18      	adds	r0, r3, #0
 8007520:	f7f9 fab8 	bl	8000a94 <__aeabi_fmul>
 8007524:	1c03      	adds	r3, r0, #0
 8007526:	1c1c      	adds	r4, r3, #0
 8007528:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800752a:	20fe      	movs	r0, #254	; 0xfe
 800752c:	0580      	lsls	r0, r0, #22
 800752e:	f7f9 fbd1 	bl	8000cd4 <__aeabi_fsub>
 8007532:	1c03      	adds	r3, r0, #0
 8007534:	1c19      	adds	r1, r3, #0
 8007536:	1c20      	adds	r0, r4, #0
 8007538:	f7f9 f8bc 	bl	80006b4 <__aeabi_fdiv>
 800753c:	1c03      	adds	r3, r0, #0
 800753e:	2100      	movs	r1, #0
 8007540:	1c18      	adds	r0, r3, #0
 8007542:	f7f8 fec7 	bl	80002d4 <__aeabi_fcmplt>
 8007546:	1e03      	subs	r3, r0, #0
 8007548:	d001      	beq.n	800754e <plan_buffer_line+0x50a>
 800754a:	2200      	movs	r2, #0
 800754c:	e018      	b.n	8007580 <plan_buffer_line+0x53c>
 800754e:	4b31      	ldr	r3, [pc, #196]	; (8007614 <plan_buffer_line+0x5d0>)
 8007550:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8007552:	6d79      	ldr	r1, [r7, #84]	; 0x54
 8007554:	1c18      	adds	r0, r3, #0
 8007556:	f7f9 fa9d 	bl	8000a94 <__aeabi_fmul>
 800755a:	1c03      	adds	r3, r0, #0
 800755c:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800755e:	1c18      	adds	r0, r3, #0
 8007560:	f7f9 fa98 	bl	8000a94 <__aeabi_fmul>
 8007564:	1c03      	adds	r3, r0, #0
 8007566:	1c1c      	adds	r4, r3, #0
 8007568:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800756a:	20fe      	movs	r0, #254	; 0xfe
 800756c:	0580      	lsls	r0, r0, #22
 800756e:	f7f9 fbb1 	bl	8000cd4 <__aeabi_fsub>
 8007572:	1c03      	adds	r3, r0, #0
 8007574:	1c19      	adds	r1, r3, #0
 8007576:	1c20      	adds	r0, r4, #0
 8007578:	f7f9 f89c 	bl	80006b4 <__aeabi_fdiv>
 800757c:	1c03      	adds	r3, r0, #0
 800757e:	1c1a      	adds	r2, r3, #0
 8007580:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007582:	629a      	str	r2, [r3, #40]	; 0x28
      }
    }
  }

  // Block system motion from updating this data to ensure next g-code motion is computed correctly.
  if (!(block->condition & PL_COND_FLAG_SYSTEM_MOTION)) {
 8007584:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007586:	7d5b      	ldrb	r3, [r3, #21]
 8007588:	001a      	movs	r2, r3
 800758a:	2302      	movs	r3, #2
 800758c:	4013      	ands	r3, r2
 800758e:	d12d      	bne.n	80075ec <plan_buffer_line+0x5a8>
    float nominal_speed = plan_compute_profile_nominal_speed(block);
 8007590:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007592:	0018      	movs	r0, r3
 8007594:	f7ff fc8c 	bl	8006eb0 <plan_compute_profile_nominal_speed>
 8007598:	1c03      	adds	r3, r0, #0
 800759a:	64fb      	str	r3, [r7, #76]	; 0x4c
    plan_compute_profile_parameters(block, nominal_speed, pl.previous_nominal_speed);
 800759c:	4b18      	ldr	r3, [pc, #96]	; (8007600 <plan_buffer_line+0x5bc>)
 800759e:	6a1a      	ldr	r2, [r3, #32]
 80075a0:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80075a2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80075a4:	0018      	movs	r0, r3
 80075a6:	f7ff fcd7 	bl	8006f58 <plan_compute_profile_parameters>
    pl.previous_nominal_speed = nominal_speed;
 80075aa:	4b15      	ldr	r3, [pc, #84]	; (8007600 <plan_buffer_line+0x5bc>)
 80075ac:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80075ae:	621a      	str	r2, [r3, #32]

    // Update previous path unit_vector and planner position.
    memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[]
 80075b0:	4b13      	ldr	r3, [pc, #76]	; (8007600 <plan_buffer_line+0x5bc>)
 80075b2:	221c      	movs	r2, #28
 80075b4:	18ba      	adds	r2, r7, r2
 80075b6:	3310      	adds	r3, #16
 80075b8:	ca13      	ldmia	r2!, {r0, r1, r4}
 80075ba:	c313      	stmia	r3!, {r0, r1, r4}
 80075bc:	6812      	ldr	r2, [r2, #0]
 80075be:	601a      	str	r2, [r3, #0]
    memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
 80075c0:	4b0f      	ldr	r3, [pc, #60]	; (8007600 <plan_buffer_line+0x5bc>)
 80075c2:	223c      	movs	r2, #60	; 0x3c
 80075c4:	18ba      	adds	r2, r7, r2
 80075c6:	ca13      	ldmia	r2!, {r0, r1, r4}
 80075c8:	c313      	stmia	r3!, {r0, r1, r4}
 80075ca:	6812      	ldr	r2, [r2, #0]
 80075cc:	601a      	str	r2, [r3, #0]

    // New block is all set. Update buffer head and next buffer head indices.
    block_buffer_head = next_buffer_head;
 80075ce:	4b12      	ldr	r3, [pc, #72]	; (8007618 <plan_buffer_line+0x5d4>)
 80075d0:	781a      	ldrb	r2, [r3, #0]
 80075d2:	4b09      	ldr	r3, [pc, #36]	; (80075f8 <plan_buffer_line+0x5b4>)
 80075d4:	701a      	strb	r2, [r3, #0]
    next_buffer_head = plan_next_block_index(block_buffer_head);
 80075d6:	4b08      	ldr	r3, [pc, #32]	; (80075f8 <plan_buffer_line+0x5b4>)
 80075d8:	781b      	ldrb	r3, [r3, #0]
 80075da:	0018      	movs	r0, r3
 80075dc:	f7ff fa40 	bl	8006a60 <plan_next_block_index>
 80075e0:	0003      	movs	r3, r0
 80075e2:	001a      	movs	r2, r3
 80075e4:	4b0c      	ldr	r3, [pc, #48]	; (8007618 <plan_buffer_line+0x5d4>)
 80075e6:	701a      	strb	r2, [r3, #0]

    // Finish up by recalculating the plan with the new block.
    planner_recalculate();
 80075e8:	f7ff fa6a 	bl	8006ac0 <planner_recalculate>
  }
  return(PLAN_OK);
 80075ec:	2301      	movs	r3, #1
}
 80075ee:	0018      	movs	r0, r3
 80075f0:	46bd      	mov	sp, r7
 80075f2:	b01b      	add	sp, #108	; 0x6c
 80075f4:	bd90      	pop	{r4, r7, pc}
 80075f6:	46c0      	nop			; (mov r8, r8)
 80075f8:	20000419 	.word	0x20000419
 80075fc:	20000418 	.word	0x20000418
 8007600:	2000041c 	.word	0x2000041c
 8007604:	3f7fffef 	.word	0x3f7fffef
 8007608:	bf7fffef 	.word	0xbf7fffef
 800760c:	7f7fffff 	.word	0x7f7fffff
 8007610:	20000b64 	.word	0x20000b64
 8007614:	20000b44 	.word	0x20000b44
 8007618:	2000041a 	.word	0x2000041a

0800761c <plan_sync_position>:


// Reset the planner position vectors. Called by the system abort/initialization routine.
void plan_sync_position()
{
 800761c:	b580      	push	{r7, lr}
 800761e:	b082      	sub	sp, #8
 8007620:	af00      	add	r7, sp, #0
  // TODO: For motor configurations not in the same coordinate frame as the machine position,
  // this function needs to be updated to accomodate the difference.
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 8007622:	1dfb      	adds	r3, r7, #7
 8007624:	2200      	movs	r2, #0
 8007626:	701a      	strb	r2, [r3, #0]
 8007628:	e026      	b.n	8007678 <plan_sync_position+0x5c>
    #ifdef COREXY
      if (idx==X_AXIS) {
 800762a:	1dfb      	adds	r3, r7, #7
 800762c:	781b      	ldrb	r3, [r3, #0]
 800762e:	2b00      	cmp	r3, #0
 8007630:	d107      	bne.n	8007642 <plan_sync_position+0x26>
        pl.position[X_AXIS] = system_convert_corexy_to_x_axis_steps(sys_position);
 8007632:	4b15      	ldr	r3, [pc, #84]	; (8007688 <plan_sync_position+0x6c>)
 8007634:	0018      	movs	r0, r3
 8007636:	f004 fcd3 	bl	800bfe0 <system_convert_corexy_to_x_axis_steps>
 800763a:	0002      	movs	r2, r0
 800763c:	4b13      	ldr	r3, [pc, #76]	; (800768c <plan_sync_position+0x70>)
 800763e:	601a      	str	r2, [r3, #0]
 8007640:	e015      	b.n	800766e <plan_sync_position+0x52>
      } else if (idx==Y_AXIS) {
 8007642:	1dfb      	adds	r3, r7, #7
 8007644:	781b      	ldrb	r3, [r3, #0]
 8007646:	2b01      	cmp	r3, #1
 8007648:	d107      	bne.n	800765a <plan_sync_position+0x3e>
        pl.position[Y_AXIS] = system_convert_corexy_to_y_axis_steps(sys_position);
 800764a:	4b0f      	ldr	r3, [pc, #60]	; (8007688 <plan_sync_position+0x6c>)
 800764c:	0018      	movs	r0, r3
 800764e:	f004 fcd9 	bl	800c004 <system_convert_corexy_to_y_axis_steps>
 8007652:	0002      	movs	r2, r0
 8007654:	4b0d      	ldr	r3, [pc, #52]	; (800768c <plan_sync_position+0x70>)
 8007656:	605a      	str	r2, [r3, #4]
 8007658:	e009      	b.n	800766e <plan_sync_position+0x52>
      } else {
        pl.position[idx] = sys_position[idx];
 800765a:	1dfb      	adds	r3, r7, #7
 800765c:	781a      	ldrb	r2, [r3, #0]
 800765e:	1dfb      	adds	r3, r7, #7
 8007660:	7819      	ldrb	r1, [r3, #0]
 8007662:	4b09      	ldr	r3, [pc, #36]	; (8007688 <plan_sync_position+0x6c>)
 8007664:	0089      	lsls	r1, r1, #2
 8007666:	58c9      	ldr	r1, [r1, r3]
 8007668:	4b08      	ldr	r3, [pc, #32]	; (800768c <plan_sync_position+0x70>)
 800766a:	0092      	lsls	r2, r2, #2
 800766c:	50d1      	str	r1, [r2, r3]
  for (idx=0; idx<N_AXIS; idx++) {
 800766e:	1dfb      	adds	r3, r7, #7
 8007670:	781a      	ldrb	r2, [r3, #0]
 8007672:	1dfb      	adds	r3, r7, #7
 8007674:	3201      	adds	r2, #1
 8007676:	701a      	strb	r2, [r3, #0]
 8007678:	1dfb      	adds	r3, r7, #7
 800767a:	781b      	ldrb	r3, [r3, #0]
 800767c:	2b03      	cmp	r3, #3
 800767e:	d9d4      	bls.n	800762a <plan_sync_position+0xe>
      }
    #else
      pl.position[idx] = sys_position[idx];
    #endif
  }
}
 8007680:	46c0      	nop			; (mov r8, r8)
 8007682:	46bd      	mov	sp, r7
 8007684:	b002      	add	sp, #8
 8007686:	bd80      	pop	{r7, pc}
 8007688:	20000bdc 	.word	0x20000bdc
 800768c:	2000041c 	.word	0x2000041c

08007690 <plan_get_block_buffer_available>:


// Returns the number of available blocks are in the planner buffer.
uint8_t plan_get_block_buffer_available()
{
 8007690:	b580      	push	{r7, lr}
 8007692:	af00      	add	r7, sp, #0
  if (block_buffer_head >= block_buffer_tail) { return((BLOCK_BUFFER_SIZE-1)-(block_buffer_head-block_buffer_tail)); }
 8007694:	4b0c      	ldr	r3, [pc, #48]	; (80076c8 <plan_get_block_buffer_available+0x38>)
 8007696:	781a      	ldrb	r2, [r3, #0]
 8007698:	4b0c      	ldr	r3, [pc, #48]	; (80076cc <plan_get_block_buffer_available+0x3c>)
 800769a:	781b      	ldrb	r3, [r3, #0]
 800769c:	429a      	cmp	r2, r3
 800769e:	d308      	bcc.n	80076b2 <plan_get_block_buffer_available+0x22>
 80076a0:	4b0a      	ldr	r3, [pc, #40]	; (80076cc <plan_get_block_buffer_available+0x3c>)
 80076a2:	781a      	ldrb	r2, [r3, #0]
 80076a4:	4b08      	ldr	r3, [pc, #32]	; (80076c8 <plan_get_block_buffer_available+0x38>)
 80076a6:	781b      	ldrb	r3, [r3, #0]
 80076a8:	1ad3      	subs	r3, r2, r3
 80076aa:	b2db      	uxtb	r3, r3
 80076ac:	330f      	adds	r3, #15
 80076ae:	b2db      	uxtb	r3, r3
 80076b0:	e007      	b.n	80076c2 <plan_get_block_buffer_available+0x32>
  return((block_buffer_tail-block_buffer_head-1));
 80076b2:	4b06      	ldr	r3, [pc, #24]	; (80076cc <plan_get_block_buffer_available+0x3c>)
 80076b4:	781a      	ldrb	r2, [r3, #0]
 80076b6:	4b04      	ldr	r3, [pc, #16]	; (80076c8 <plan_get_block_buffer_available+0x38>)
 80076b8:	781b      	ldrb	r3, [r3, #0]
 80076ba:	1ad3      	subs	r3, r2, r3
 80076bc:	b2db      	uxtb	r3, r3
 80076be:	3b01      	subs	r3, #1
 80076c0:	b2db      	uxtb	r3, r3
}
 80076c2:	0018      	movs	r0, r3
 80076c4:	46bd      	mov	sp, r7
 80076c6:	bd80      	pop	{r7, pc}
 80076c8:	20000419 	.word	0x20000419
 80076cc:	20000418 	.word	0x20000418

080076d0 <plan_cycle_reinitialize>:


// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
 80076d0:	b580      	push	{r7, lr}
 80076d2:	af00      	add	r7, sp, #0
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
 80076d4:	f003 fa3a 	bl	800ab4c <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
 80076d8:	4b04      	ldr	r3, [pc, #16]	; (80076ec <plan_cycle_reinitialize+0x1c>)
 80076da:	781a      	ldrb	r2, [r3, #0]
 80076dc:	4b04      	ldr	r3, [pc, #16]	; (80076f0 <plan_cycle_reinitialize+0x20>)
 80076de:	701a      	strb	r2, [r3, #0]
  planner_recalculate();
 80076e0:	f7ff f9ee 	bl	8006ac0 <planner_recalculate>
}
 80076e4:	46c0      	nop			; (mov r8, r8)
 80076e6:	46bd      	mov	sp, r7
 80076e8:	bd80      	pop	{r7, pc}
 80076ea:	46c0      	nop			; (mov r8, r8)
 80076ec:	20000418 	.word	0x20000418
 80076f0:	2000041b 	.word	0x2000041b

080076f4 <printString>:

#include "grbl.h"


void printString(const char *s)
{
 80076f4:	b580      	push	{r7, lr}
 80076f6:	b082      	sub	sp, #8
 80076f8:	af00      	add	r7, sp, #0
 80076fa:	6078      	str	r0, [r7, #4]
  while (*s)
 80076fc:	e006      	b.n	800770c <printString+0x18>
    serial_write(*s++);
 80076fe:	687b      	ldr	r3, [r7, #4]
 8007700:	1c5a      	adds	r2, r3, #1
 8007702:	607a      	str	r2, [r7, #4]
 8007704:	781b      	ldrb	r3, [r3, #0]
 8007706:	0018      	movs	r0, r3
 8007708:	f001 fea8 	bl	800945c <serial_write>
  while (*s)
 800770c:	687b      	ldr	r3, [r7, #4]
 800770e:	781b      	ldrb	r3, [r3, #0]
 8007710:	2b00      	cmp	r3, #0
 8007712:	d1f4      	bne.n	80076fe <printString+0xa>
}
 8007714:	46c0      	nop			; (mov r8, r8)
 8007716:	46bd      	mov	sp, r7
 8007718:	b002      	add	sp, #8
 800771a:	bd80      	pop	{r7, pc}

0800771c <print_uint8_base10>:
// }


// Prints an uint8 variable in base 10.
void print_uint8_base10(uint8_t n)
{
 800771c:	b590      	push	{r4, r7, lr}
 800771e:	b085      	sub	sp, #20
 8007720:	af00      	add	r7, sp, #0
 8007722:	0002      	movs	r2, r0
 8007724:	1dfb      	adds	r3, r7, #7
 8007726:	701a      	strb	r2, [r3, #0]
  uint8_t digit_a = 0;
 8007728:	230f      	movs	r3, #15
 800772a:	18fb      	adds	r3, r7, r3
 800772c:	2200      	movs	r2, #0
 800772e:	701a      	strb	r2, [r3, #0]
  uint8_t digit_b = 0;
 8007730:	230e      	movs	r3, #14
 8007732:	18fb      	adds	r3, r7, r3
 8007734:	2200      	movs	r2, #0
 8007736:	701a      	strb	r2, [r3, #0]
  if (n >= 100) { // 100-255
 8007738:	1dfb      	adds	r3, r7, #7
 800773a:	781b      	ldrb	r3, [r3, #0]
 800773c:	2b63      	cmp	r3, #99	; 0x63
 800773e:	d914      	bls.n	800776a <print_uint8_base10+0x4e>
    digit_a = '0' + n % 10;
 8007740:	1dfb      	adds	r3, r7, #7
 8007742:	781b      	ldrb	r3, [r3, #0]
 8007744:	210a      	movs	r1, #10
 8007746:	0018      	movs	r0, r3
 8007748:	f7f8 fd6e 	bl	8000228 <__aeabi_uidivmod>
 800774c:	000b      	movs	r3, r1
 800774e:	b2da      	uxtb	r2, r3
 8007750:	230f      	movs	r3, #15
 8007752:	18fb      	adds	r3, r7, r3
 8007754:	3230      	adds	r2, #48	; 0x30
 8007756:	701a      	strb	r2, [r3, #0]
    n /= 10;
 8007758:	1dfc      	adds	r4, r7, #7
 800775a:	1dfb      	adds	r3, r7, #7
 800775c:	781b      	ldrb	r3, [r3, #0]
 800775e:	210a      	movs	r1, #10
 8007760:	0018      	movs	r0, r3
 8007762:	f7f8 fcdb 	bl	800011c <__udivsi3>
 8007766:	0003      	movs	r3, r0
 8007768:	7023      	strb	r3, [r4, #0]
  }
  if (n >= 10) { // 10-99
 800776a:	1dfb      	adds	r3, r7, #7
 800776c:	781b      	ldrb	r3, [r3, #0]
 800776e:	2b09      	cmp	r3, #9
 8007770:	d914      	bls.n	800779c <print_uint8_base10+0x80>
    digit_b = '0' + n % 10;
 8007772:	1dfb      	adds	r3, r7, #7
 8007774:	781b      	ldrb	r3, [r3, #0]
 8007776:	210a      	movs	r1, #10
 8007778:	0018      	movs	r0, r3
 800777a:	f7f8 fd55 	bl	8000228 <__aeabi_uidivmod>
 800777e:	000b      	movs	r3, r1
 8007780:	b2da      	uxtb	r2, r3
 8007782:	230e      	movs	r3, #14
 8007784:	18fb      	adds	r3, r7, r3
 8007786:	3230      	adds	r2, #48	; 0x30
 8007788:	701a      	strb	r2, [r3, #0]
    n /= 10;
 800778a:	1dfc      	adds	r4, r7, #7
 800778c:	1dfb      	adds	r3, r7, #7
 800778e:	781b      	ldrb	r3, [r3, #0]
 8007790:	210a      	movs	r1, #10
 8007792:	0018      	movs	r0, r3
 8007794:	f7f8 fcc2 	bl	800011c <__udivsi3>
 8007798:	0003      	movs	r3, r0
 800779a:	7023      	strb	r3, [r4, #0]
  }
  serial_write('0' + n);
 800779c:	1dfb      	adds	r3, r7, #7
 800779e:	781b      	ldrb	r3, [r3, #0]
 80077a0:	3330      	adds	r3, #48	; 0x30
 80077a2:	b2db      	uxtb	r3, r3
 80077a4:	0018      	movs	r0, r3
 80077a6:	f001 fe59 	bl	800945c <serial_write>
  if (digit_b) { serial_write(digit_b); }
 80077aa:	230e      	movs	r3, #14
 80077ac:	18fb      	adds	r3, r7, r3
 80077ae:	781b      	ldrb	r3, [r3, #0]
 80077b0:	2b00      	cmp	r3, #0
 80077b2:	d005      	beq.n	80077c0 <print_uint8_base10+0xa4>
 80077b4:	230e      	movs	r3, #14
 80077b6:	18fb      	adds	r3, r7, r3
 80077b8:	781b      	ldrb	r3, [r3, #0]
 80077ba:	0018      	movs	r0, r3
 80077bc:	f001 fe4e 	bl	800945c <serial_write>
  if (digit_a) { serial_write(digit_a); }
 80077c0:	230f      	movs	r3, #15
 80077c2:	18fb      	adds	r3, r7, r3
 80077c4:	781b      	ldrb	r3, [r3, #0]
 80077c6:	2b00      	cmp	r3, #0
 80077c8:	d005      	beq.n	80077d6 <print_uint8_base10+0xba>
 80077ca:	230f      	movs	r3, #15
 80077cc:	18fb      	adds	r3, r7, r3
 80077ce:	781b      	ldrb	r3, [r3, #0]
 80077d0:	0018      	movs	r0, r3
 80077d2:	f001 fe43 	bl	800945c <serial_write>
}
 80077d6:	46c0      	nop			; (mov r8, r8)
 80077d8:	46bd      	mov	sp, r7
 80077da:	b005      	add	sp, #20
 80077dc:	bd90      	pop	{r4, r7, pc}
	...

080077e0 <printFloat>:
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
 80077e0:	b590      	push	{r4, r7, lr}
 80077e2:	b089      	sub	sp, #36	; 0x24
 80077e4:	af00      	add	r7, sp, #0
 80077e6:	6078      	str	r0, [r7, #4]
 80077e8:	000a      	movs	r2, r1
 80077ea:	1cfb      	adds	r3, r7, #3
 80077ec:	701a      	strb	r2, [r3, #0]
  if (n < 0) {
 80077ee:	2100      	movs	r1, #0
 80077f0:	6878      	ldr	r0, [r7, #4]
 80077f2:	f7f8 fd6f 	bl	80002d4 <__aeabi_fcmplt>
 80077f6:	1e03      	subs	r3, r0, #0
 80077f8:	d007      	beq.n	800780a <printFloat+0x2a>
    serial_write('-');
 80077fa:	202d      	movs	r0, #45	; 0x2d
 80077fc:	f001 fe2e 	bl	800945c <serial_write>
    n = -n;
 8007800:	687b      	ldr	r3, [r7, #4]
 8007802:	2280      	movs	r2, #128	; 0x80
 8007804:	0612      	lsls	r2, r2, #24
 8007806:	4053      	eors	r3, r2
 8007808:	607b      	str	r3, [r7, #4]
  }

  uint8_t decimals = decimal_places;
 800780a:	231f      	movs	r3, #31
 800780c:	18fb      	adds	r3, r7, r3
 800780e:	1cfa      	adds	r2, r7, #3
 8007810:	7812      	ldrb	r2, [r2, #0]
 8007812:	701a      	strb	r2, [r3, #0]
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
 8007814:	e00c      	b.n	8007830 <printFloat+0x50>
    n *= 100;
 8007816:	494c      	ldr	r1, [pc, #304]	; (8007948 <printFloat+0x168>)
 8007818:	6878      	ldr	r0, [r7, #4]
 800781a:	f7f9 f93b 	bl	8000a94 <__aeabi_fmul>
 800781e:	1c03      	adds	r3, r0, #0
 8007820:	607b      	str	r3, [r7, #4]
    decimals -= 2;
 8007822:	231f      	movs	r3, #31
 8007824:	18fb      	adds	r3, r7, r3
 8007826:	221f      	movs	r2, #31
 8007828:	18ba      	adds	r2, r7, r2
 800782a:	7812      	ldrb	r2, [r2, #0]
 800782c:	3a02      	subs	r2, #2
 800782e:	701a      	strb	r2, [r3, #0]
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
 8007830:	231f      	movs	r3, #31
 8007832:	18fb      	adds	r3, r7, r3
 8007834:	781b      	ldrb	r3, [r3, #0]
 8007836:	2b01      	cmp	r3, #1
 8007838:	d8ed      	bhi.n	8007816 <printFloat+0x36>
  }
  if (decimals) { n *= 10; }
 800783a:	231f      	movs	r3, #31
 800783c:	18fb      	adds	r3, r7, r3
 800783e:	781b      	ldrb	r3, [r3, #0]
 8007840:	2b00      	cmp	r3, #0
 8007842:	d005      	beq.n	8007850 <printFloat+0x70>
 8007844:	4941      	ldr	r1, [pc, #260]	; (800794c <printFloat+0x16c>)
 8007846:	6878      	ldr	r0, [r7, #4]
 8007848:	f7f9 f924 	bl	8000a94 <__aeabi_fmul>
 800784c:	1c03      	adds	r3, r0, #0
 800784e:	607b      	str	r3, [r7, #4]
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
 8007850:	21fc      	movs	r1, #252	; 0xfc
 8007852:	0589      	lsls	r1, r1, #22
 8007854:	6878      	ldr	r0, [r7, #4]
 8007856:	f7f8 fd9b 	bl	8000390 <__aeabi_fadd>
 800785a:	1c03      	adds	r3, r0, #0
 800785c:	607b      	str	r3, [r7, #4]

  // Generate digits backwards and store in string.
  unsigned char buf[13];
  uint8_t i = 0;
 800785e:	231e      	movs	r3, #30
 8007860:	18fb      	adds	r3, r7, r3
 8007862:	2200      	movs	r2, #0
 8007864:	701a      	strb	r2, [r3, #0]
  uint32_t a = (long)n;
 8007866:	6878      	ldr	r0, [r7, #4]
 8007868:	f7f9 fbe8 	bl	800103c <__aeabi_f2iz>
 800786c:	0003      	movs	r3, r0
 800786e:	61bb      	str	r3, [r7, #24]
  while(a > 0) {
 8007870:	e01a      	b.n	80078a8 <printFloat+0xc8>
    buf[i++] = (a % 10) + '0'; // Get digit
 8007872:	231e      	movs	r3, #30
 8007874:	18fb      	adds	r3, r7, r3
 8007876:	781b      	ldrb	r3, [r3, #0]
 8007878:	221e      	movs	r2, #30
 800787a:	18ba      	adds	r2, r7, r2
 800787c:	1c59      	adds	r1, r3, #1
 800787e:	7011      	strb	r1, [r2, #0]
 8007880:	001c      	movs	r4, r3
 8007882:	69bb      	ldr	r3, [r7, #24]
 8007884:	210a      	movs	r1, #10
 8007886:	0018      	movs	r0, r3
 8007888:	f7f8 fcce 	bl	8000228 <__aeabi_uidivmod>
 800788c:	000b      	movs	r3, r1
 800788e:	b2db      	uxtb	r3, r3
 8007890:	3330      	adds	r3, #48	; 0x30
 8007892:	b2da      	uxtb	r2, r3
 8007894:	2308      	movs	r3, #8
 8007896:	18fb      	adds	r3, r7, r3
 8007898:	551a      	strb	r2, [r3, r4]
    a /= 10;
 800789a:	69bb      	ldr	r3, [r7, #24]
 800789c:	210a      	movs	r1, #10
 800789e:	0018      	movs	r0, r3
 80078a0:	f7f8 fc3c 	bl	800011c <__udivsi3>
 80078a4:	0003      	movs	r3, r0
 80078a6:	61bb      	str	r3, [r7, #24]
  while(a > 0) {
 80078a8:	69bb      	ldr	r3, [r7, #24]
 80078aa:	2b00      	cmp	r3, #0
 80078ac:	d1e1      	bne.n	8007872 <printFloat+0x92>
  }
  while (i < decimal_places) {
 80078ae:	e00b      	b.n	80078c8 <printFloat+0xe8>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
 80078b0:	231e      	movs	r3, #30
 80078b2:	18fb      	adds	r3, r7, r3
 80078b4:	781b      	ldrb	r3, [r3, #0]
 80078b6:	221e      	movs	r2, #30
 80078b8:	18ba      	adds	r2, r7, r2
 80078ba:	1c59      	adds	r1, r3, #1
 80078bc:	7011      	strb	r1, [r2, #0]
 80078be:	001a      	movs	r2, r3
 80078c0:	2308      	movs	r3, #8
 80078c2:	18fb      	adds	r3, r7, r3
 80078c4:	2130      	movs	r1, #48	; 0x30
 80078c6:	5499      	strb	r1, [r3, r2]
  while (i < decimal_places) {
 80078c8:	231e      	movs	r3, #30
 80078ca:	18fa      	adds	r2, r7, r3
 80078cc:	1cfb      	adds	r3, r7, #3
 80078ce:	7812      	ldrb	r2, [r2, #0]
 80078d0:	781b      	ldrb	r3, [r3, #0]
 80078d2:	429a      	cmp	r2, r3
 80078d4:	d3ec      	bcc.n	80078b0 <printFloat+0xd0>
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
 80078d6:	231e      	movs	r3, #30
 80078d8:	18fa      	adds	r2, r7, r3
 80078da:	1cfb      	adds	r3, r7, #3
 80078dc:	7812      	ldrb	r2, [r2, #0]
 80078de:	781b      	ldrb	r3, [r3, #0]
 80078e0:	429a      	cmp	r2, r3
 80078e2:	d127      	bne.n	8007934 <printFloat+0x154>
    buf[i++] = '0';
 80078e4:	231e      	movs	r3, #30
 80078e6:	18fb      	adds	r3, r7, r3
 80078e8:	781b      	ldrb	r3, [r3, #0]
 80078ea:	221e      	movs	r2, #30
 80078ec:	18ba      	adds	r2, r7, r2
 80078ee:	1c59      	adds	r1, r3, #1
 80078f0:	7011      	strb	r1, [r2, #0]
 80078f2:	001a      	movs	r2, r3
 80078f4:	2308      	movs	r3, #8
 80078f6:	18fb      	adds	r3, r7, r3
 80078f8:	2130      	movs	r1, #48	; 0x30
 80078fa:	5499      	strb	r1, [r3, r2]
  }

  // Print the generated string.
  for (; i > 0; i--) {
 80078fc:	e01a      	b.n	8007934 <printFloat+0x154>
    if (i == decimal_places) { serial_write('.'); } // Insert decimal point in right place.
 80078fe:	231e      	movs	r3, #30
 8007900:	18fa      	adds	r2, r7, r3
 8007902:	1cfb      	adds	r3, r7, #3
 8007904:	7812      	ldrb	r2, [r2, #0]
 8007906:	781b      	ldrb	r3, [r3, #0]
 8007908:	429a      	cmp	r2, r3
 800790a:	d102      	bne.n	8007912 <printFloat+0x132>
 800790c:	202e      	movs	r0, #46	; 0x2e
 800790e:	f001 fda5 	bl	800945c <serial_write>
    serial_write(buf[i-1]);
 8007912:	231e      	movs	r3, #30
 8007914:	18fb      	adds	r3, r7, r3
 8007916:	781b      	ldrb	r3, [r3, #0]
 8007918:	3b01      	subs	r3, #1
 800791a:	2208      	movs	r2, #8
 800791c:	18ba      	adds	r2, r7, r2
 800791e:	5cd3      	ldrb	r3, [r2, r3]
 8007920:	0018      	movs	r0, r3
 8007922:	f001 fd9b 	bl	800945c <serial_write>
  for (; i > 0; i--) {
 8007926:	231e      	movs	r3, #30
 8007928:	18fb      	adds	r3, r7, r3
 800792a:	781a      	ldrb	r2, [r3, #0]
 800792c:	231e      	movs	r3, #30
 800792e:	18fb      	adds	r3, r7, r3
 8007930:	3a01      	subs	r2, #1
 8007932:	701a      	strb	r2, [r3, #0]
 8007934:	231e      	movs	r3, #30
 8007936:	18fb      	adds	r3, r7, r3
 8007938:	781b      	ldrb	r3, [r3, #0]
 800793a:	2b00      	cmp	r3, #0
 800793c:	d1df      	bne.n	80078fe <printFloat+0x11e>
  }
}
 800793e:	46c0      	nop			; (mov r8, r8)
 8007940:	46bd      	mov	sp, r7
 8007942:	b009      	add	sp, #36	; 0x24
 8007944:	bd90      	pop	{r4, r7, pc}
 8007946:	46c0      	nop			; (mov r8, r8)
 8007948:	42c80000 	.word	0x42c80000
 800794c:	41200000 	.word	0x41200000

08007950 <printFloat_CoordValue>:

// Floating value printing handlers for special variables types used in Grbl and are defined
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
void printFloat_CoordValue(float n) {
 8007950:	b580      	push	{r7, lr}
 8007952:	b082      	sub	sp, #8
 8007954:	af00      	add	r7, sp, #0
 8007956:	6078      	str	r0, [r7, #4]
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
 8007958:	4b0c      	ldr	r3, [pc, #48]	; (800798c <printFloat_CoordValue+0x3c>)
 800795a:	2258      	movs	r2, #88	; 0x58
 800795c:	5c9b      	ldrb	r3, [r3, r2]
 800795e:	001a      	movs	r2, r3
 8007960:	2301      	movs	r3, #1
 8007962:	4013      	ands	r3, r2
 8007964:	d009      	beq.n	800797a <printFloat_CoordValue+0x2a>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
 8007966:	490a      	ldr	r1, [pc, #40]	; (8007990 <printFloat_CoordValue+0x40>)
 8007968:	6878      	ldr	r0, [r7, #4]
 800796a:	f7f9 f893 	bl	8000a94 <__aeabi_fmul>
 800796e:	1c03      	adds	r3, r0, #0
 8007970:	2104      	movs	r1, #4
 8007972:	1c18      	adds	r0, r3, #0
 8007974:	f7ff ff34 	bl	80077e0 <printFloat>
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
  }
}
 8007978:	e004      	b.n	8007984 <printFloat_CoordValue+0x34>
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
 800797a:	687b      	ldr	r3, [r7, #4]
 800797c:	2103      	movs	r1, #3
 800797e:	1c18      	adds	r0, r3, #0
 8007980:	f7ff ff2e 	bl	80077e0 <printFloat>
}
 8007984:	46c0      	nop			; (mov r8, r8)
 8007986:	46bd      	mov	sp, r7
 8007988:	b002      	add	sp, #8
 800798a:	bd80      	pop	{r7, pc}
 800798c:	20000b44 	.word	0x20000b44
 8007990:	3d21428b 	.word	0x3d21428b

08007994 <printFloat_RateValue>:

void printFloat_RateValue(float n) {
 8007994:	b580      	push	{r7, lr}
 8007996:	b082      	sub	sp, #8
 8007998:	af00      	add	r7, sp, #0
 800799a:	6078      	str	r0, [r7, #4]
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
 800799c:	4b0c      	ldr	r3, [pc, #48]	; (80079d0 <printFloat_RateValue+0x3c>)
 800799e:	2258      	movs	r2, #88	; 0x58
 80079a0:	5c9b      	ldrb	r3, [r3, r2]
 80079a2:	001a      	movs	r2, r3
 80079a4:	2301      	movs	r3, #1
 80079a6:	4013      	ands	r3, r2
 80079a8:	d009      	beq.n	80079be <printFloat_RateValue+0x2a>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
 80079aa:	490a      	ldr	r1, [pc, #40]	; (80079d4 <printFloat_RateValue+0x40>)
 80079ac:	6878      	ldr	r0, [r7, #4]
 80079ae:	f7f9 f871 	bl	8000a94 <__aeabi_fmul>
 80079b2:	1c03      	adds	r3, r0, #0
 80079b4:	2101      	movs	r1, #1
 80079b6:	1c18      	adds	r0, r3, #0
 80079b8:	f7ff ff12 	bl	80077e0 <printFloat>
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
  }
}
 80079bc:	e004      	b.n	80079c8 <printFloat_RateValue+0x34>
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
 80079be:	687b      	ldr	r3, [r7, #4]
 80079c0:	2100      	movs	r1, #0
 80079c2:	1c18      	adds	r0, r3, #0
 80079c4:	f7ff ff0c 	bl	80077e0 <printFloat>
}
 80079c8:	46c0      	nop			; (mov r8, r8)
 80079ca:	46bd      	mov	sp, r7
 80079cc:	b002      	add	sp, #8
 80079ce:	bd80      	pop	{r7, pc}
 80079d0:	20000b44 	.word	0x20000b44
 80079d4:	3d21428b 	.word	0x3d21428b

080079d8 <probe_init>:
uint8_t probe_invert_mask;


// Probe pin initialization routine.
void probe_init()
{
 80079d8:	b580      	push	{r7, lr}
 80079da:	b082      	sub	sp, #8
 80079dc:	af00      	add	r7, sp, #0
	GPIO_InitStructure.GPIO_Pin = PROBE_MASK;
	GPIO_Init(PROBE_PORT, &GPIO_InitStructure);
#endif
#ifdef STM32F0DISCOVERY
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_PROBE_PORT, ENABLE);
 80079de:	2380      	movs	r3, #128	; 0x80
 80079e0:	029b      	lsls	r3, r3, #10
 80079e2:	2101      	movs	r1, #1
 80079e4:	0018      	movs	r0, r3
 80079e6:	f7fb fb7f 	bl	80030e8 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80079ea:	003b      	movs	r3, r7
 80079ec:	2203      	movs	r2, #3
 80079ee:	715a      	strb	r2, [r3, #5]
#ifdef DISABLE_PROBE_PIN_PULL_UP
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
#else
	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 80079f0:	003b      	movs	r3, r7
 80079f2:	2200      	movs	r2, #0
 80079f4:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 80079f6:	003b      	movs	r3, r7
 80079f8:	2201      	movs	r2, #1
 80079fa:	71da      	strb	r2, [r3, #7]
#endif
	GPIO_InitStructure.GPIO_Pin = PROBE_MASK;
 80079fc:	003b      	movs	r3, r7
 80079fe:	2280      	movs	r2, #128	; 0x80
 8007a00:	0212      	lsls	r2, r2, #8
 8007a02:	601a      	str	r2, [r3, #0]
	GPIO_Init(PROBE_PORT, &GPIO_InitStructure);
 8007a04:	003a      	movs	r2, r7
 8007a06:	2390      	movs	r3, #144	; 0x90
 8007a08:	05db      	lsls	r3, r3, #23
 8007a0a:	0011      	movs	r1, r2
 8007a0c:	0018      	movs	r0, r3
 8007a0e:	f7fa fff1 	bl	80029f4 <GPIO_Init>
#endif
  probe_configure_invert_mask(false); // Initialize invert mask.
 8007a12:	2000      	movs	r0, #0
 8007a14:	f000 f804 	bl	8007a20 <probe_configure_invert_mask>
}
 8007a18:	46c0      	nop			; (mov r8, r8)
 8007a1a:	46bd      	mov	sp, r7
 8007a1c:	b002      	add	sp, #8
 8007a1e:	bd80      	pop	{r7, pc}

08007a20 <probe_configure_invert_mask>:

// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to
// appropriately set the pin logic according to setting for normal-high/normal-low operation
// and the probing cycle modes for toward-workpiece/away-from-workpiece.
void probe_configure_invert_mask(uint8_t is_probe_away)
{
 8007a20:	b580      	push	{r7, lr}
 8007a22:	b082      	sub	sp, #8
 8007a24:	af00      	add	r7, sp, #0
 8007a26:	0002      	movs	r2, r0
 8007a28:	1dfb      	adds	r3, r7, #7
 8007a2a:	701a      	strb	r2, [r3, #0]
  probe_invert_mask = 0; // Initialize as zero.
 8007a2c:	4b0c      	ldr	r3, [pc, #48]	; (8007a60 <probe_configure_invert_mask+0x40>)
 8007a2e:	2200      	movs	r2, #0
 8007a30:	701a      	strb	r2, [r3, #0]
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
 8007a32:	4b0c      	ldr	r3, [pc, #48]	; (8007a64 <probe_configure_invert_mask+0x44>)
 8007a34:	2258      	movs	r2, #88	; 0x58
 8007a36:	5c9b      	ldrb	r3, [r3, r2]
 8007a38:	b25b      	sxtb	r3, r3
 8007a3a:	2b00      	cmp	r3, #0
 8007a3c:	db03      	blt.n	8007a46 <probe_configure_invert_mask+0x26>
 8007a3e:	4b08      	ldr	r3, [pc, #32]	; (8007a60 <probe_configure_invert_mask+0x40>)
 8007a40:	781a      	ldrb	r2, [r3, #0]
 8007a42:	4b07      	ldr	r3, [pc, #28]	; (8007a60 <probe_configure_invert_mask+0x40>)
 8007a44:	701a      	strb	r2, [r3, #0]
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
 8007a46:	1dfb      	adds	r3, r7, #7
 8007a48:	781b      	ldrb	r3, [r3, #0]
 8007a4a:	2b00      	cmp	r3, #0
 8007a4c:	d003      	beq.n	8007a56 <probe_configure_invert_mask+0x36>
 8007a4e:	4b04      	ldr	r3, [pc, #16]	; (8007a60 <probe_configure_invert_mask+0x40>)
 8007a50:	781a      	ldrb	r2, [r3, #0]
 8007a52:	4b03      	ldr	r3, [pc, #12]	; (8007a60 <probe_configure_invert_mask+0x40>)
 8007a54:	701a      	strb	r2, [r3, #0]
}
 8007a56:	46c0      	nop			; (mov r8, r8)
 8007a58:	46bd      	mov	sp, r7
 8007a5a:	b002      	add	sp, #8
 8007a5c:	bd80      	pop	{r7, pc}
 8007a5e:	46c0      	nop			; (mov r8, r8)
 8007a60:	20000a58 	.word	0x20000a58
 8007a64:	20000b44 	.word	0x20000b44

08007a68 <probe_get_state>:


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() 
{ 
 8007a68:	b580      	push	{r7, lr}
 8007a6a:	af00      	add	r7, sp, #0
#endif
#ifdef STM32F103C8
	return ((GPIO_ReadInputData(PROBE_PORT) & PROBE_MASK) ^ probe_invert_mask) != 0;
#endif
#ifdef STM32F0DISCOVERY
	return ((GPIO_ReadInputData(PROBE_PORT) & PROBE_MASK) ^ probe_invert_mask) != 0;
 8007a6c:	2390      	movs	r3, #144	; 0x90
 8007a6e:	05db      	lsls	r3, r3, #23
 8007a70:	0018      	movs	r0, r3
 8007a72:	f7fb f852 	bl	8002b1a <GPIO_ReadInputData>
 8007a76:	0003      	movs	r3, r0
 8007a78:	001a      	movs	r2, r3
 8007a7a:	2380      	movs	r3, #128	; 0x80
 8007a7c:	021b      	lsls	r3, r3, #8
 8007a7e:	4013      	ands	r3, r2
 8007a80:	4a04      	ldr	r2, [pc, #16]	; (8007a94 <probe_get_state+0x2c>)
 8007a82:	7812      	ldrb	r2, [r2, #0]
 8007a84:	1a9b      	subs	r3, r3, r2
 8007a86:	1e5a      	subs	r2, r3, #1
 8007a88:	4193      	sbcs	r3, r2
 8007a8a:	b2db      	uxtb	r3, r3
#endif
}
 8007a8c:	0018      	movs	r0, r3
 8007a8e:	46bd      	mov	sp, r7
 8007a90:	bd80      	pop	{r7, pc}
 8007a92:	46c0      	nop			; (mov r8, r8)
 8007a94:	20000a58 	.word	0x20000a58

08007a98 <probe_state_monitor>:

// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
 8007a98:	b5b0      	push	{r4, r5, r7, lr}
 8007a9a:	af00      	add	r7, sp, #0
  if (probe_get_state()) {
 8007a9c:	f7ff ffe4 	bl	8007a68 <probe_get_state>
 8007aa0:	1e03      	subs	r3, r0, #0
 8007aa2:	d010      	beq.n	8007ac6 <probe_state_monitor+0x2e>
    sys_probe_state = PROBE_OFF;
 8007aa4:	4b09      	ldr	r3, [pc, #36]	; (8007acc <probe_state_monitor+0x34>)
 8007aa6:	2200      	movs	r2, #0
 8007aa8:	701a      	strb	r2, [r3, #0]
    memcpy(sys_probe_position, sys_position, sizeof(sys_position));
 8007aaa:	4b09      	ldr	r3, [pc, #36]	; (8007ad0 <probe_state_monitor+0x38>)
 8007aac:	4a09      	ldr	r2, [pc, #36]	; (8007ad4 <probe_state_monitor+0x3c>)
 8007aae:	ca13      	ldmia	r2!, {r0, r1, r4}
 8007ab0:	c313      	stmia	r3!, {r0, r1, r4}
 8007ab2:	6812      	ldr	r2, [r2, #0]
 8007ab4:	601a      	str	r2, [r3, #0]
    bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
 8007ab6:	4b08      	ldr	r3, [pc, #32]	; (8007ad8 <probe_state_monitor+0x40>)
 8007ab8:	781b      	ldrb	r3, [r3, #0]
 8007aba:	b2db      	uxtb	r3, r3
 8007abc:	2240      	movs	r2, #64	; 0x40
 8007abe:	4313      	orrs	r3, r2
 8007ac0:	b2da      	uxtb	r2, r3
 8007ac2:	4b05      	ldr	r3, [pc, #20]	; (8007ad8 <probe_state_monitor+0x40>)
 8007ac4:	701a      	strb	r2, [r3, #0]
  }
}
 8007ac6:	46c0      	nop			; (mov r8, r8)
 8007ac8:	46bd      	mov	sp, r7
 8007aca:	bdb0      	pop	{r4, r5, r7, pc}
 8007acc:	20000bca 	.word	0x20000bca
 8007ad0:	20000bcc 	.word	0x20000bcc
 8007ad4:	20000bdc 	.word	0x20000bdc
 8007ad8:	20000bc9 	.word	0x20000bc9

08007adc <protocol_main_loop>:

/*
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
 8007adc:	b590      	push	{r4, r7, lr}
 8007ade:	b083      	sub	sp, #12
 8007ae0:	af00      	add	r7, sp, #0
  // Perform some machine checks to make sure everything is good to go.
  #ifdef CHECK_LIMITS_AT_INIT
    if (bit_istrue(settings.flags, BITFLAG_HARD_LIMIT_ENABLE)) {
 8007ae2:	4b91      	ldr	r3, [pc, #580]	; (8007d28 <protocol_main_loop+0x24c>)
 8007ae4:	2258      	movs	r2, #88	; 0x58
 8007ae6:	5c9b      	ldrb	r3, [r3, r2]
 8007ae8:	001a      	movs	r2, r3
 8007aea:	2308      	movs	r3, #8
 8007aec:	4013      	ands	r3, r2
 8007aee:	d009      	beq.n	8007b04 <protocol_main_loop+0x28>
      if (limits_get_state()) {
 8007af0:	f7fd fdf8 	bl	80056e4 <limits_get_state>
 8007af4:	1e03      	subs	r3, r0, #0
 8007af6:	d005      	beq.n	8007b04 <protocol_main_loop+0x28>
        sys.state = STATE_ALARM; // Ensure alarm state is active.
 8007af8:	4b8c      	ldr	r3, [pc, #560]	; (8007d2c <protocol_main_loop+0x250>)
 8007afa:	2201      	movs	r2, #1
 8007afc:	701a      	strb	r2, [r3, #0]
        report_feedback_message(MESSAGE_CHECK_LIMITS);
 8007afe:	2007      	movs	r0, #7
 8007b00:	f000 fe88 	bl	8008814 <report_feedback_message>
    }
  #endif
  // Check for and report alarm state after a reset, error, or an initial power up.
  // NOTE: Sleep mode disables the stepper drivers and position can't be guaranteed.
  // Re-initialize the sleep state as an ALARM mode to ensure user homes or acknowledges.
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
 8007b04:	4b89      	ldr	r3, [pc, #548]	; (8007d2c <protocol_main_loop+0x250>)
 8007b06:	781b      	ldrb	r3, [r3, #0]
 8007b08:	001a      	movs	r2, r3
 8007b0a:	2381      	movs	r3, #129	; 0x81
 8007b0c:	4013      	ands	r3, r2
 8007b0e:	d006      	beq.n	8007b1e <protocol_main_loop+0x42>
    report_feedback_message(MESSAGE_ALARM_LOCK);
 8007b10:	2002      	movs	r0, #2
 8007b12:	f000 fe7f 	bl	8008814 <report_feedback_message>
    sys.state = STATE_ALARM; // Ensure alarm state is set.
 8007b16:	4b85      	ldr	r3, [pc, #532]	; (8007d2c <protocol_main_loop+0x250>)
 8007b18:	2201      	movs	r2, #1
 8007b1a:	701a      	strb	r2, [r3, #0]
 8007b1c:	e014      	b.n	8007b48 <protocol_main_loop+0x6c>
  } else {
    // Check if the safety door is open.
    sys.state = STATE_IDLE;
 8007b1e:	4b83      	ldr	r3, [pc, #524]	; (8007d2c <protocol_main_loop+0x250>)
 8007b20:	2200      	movs	r2, #0
 8007b22:	701a      	strb	r2, [r3, #0]
    if (system_check_safety_door_ajar()) {
 8007b24:	f003 ff22 	bl	800b96c <system_check_safety_door_ajar>
 8007b28:	1e03      	subs	r3, r0, #0
 8007b2a:	d009      	beq.n	8007b40 <protocol_main_loop+0x64>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
 8007b2c:	4b80      	ldr	r3, [pc, #512]	; (8007d30 <protocol_main_loop+0x254>)
 8007b2e:	781b      	ldrb	r3, [r3, #0]
 8007b30:	b2db      	uxtb	r3, r3
 8007b32:	2220      	movs	r2, #32
 8007b34:	4313      	orrs	r3, r2
 8007b36:	b2da      	uxtb	r2, r3
 8007b38:	4b7d      	ldr	r3, [pc, #500]	; (8007d30 <protocol_main_loop+0x254>)
 8007b3a:	701a      	strb	r2, [r3, #0]
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
 8007b3c:	f000 f920 	bl	8007d80 <protocol_execute_realtime>
    }
    // All systems go!
    system_execute_startup(line); // Execute startup script.
 8007b40:	4b7c      	ldr	r3, [pc, #496]	; (8007d34 <protocol_main_loop+0x258>)
 8007b42:	0018      	movs	r0, r3
 8007b44:	f003 ff18 	bl	800b978 <system_execute_startup>
  // ---------------------------------------------------------------------------------
  // Primary loop! Upon a system abort, this exits back to main() to reset the system.
  // This is also where Grbl idles while waiting for something to do.
  // ---------------------------------------------------------------------------------

  uint8_t line_flags = 0;
 8007b48:	1dfb      	adds	r3, r7, #7
 8007b4a:	2200      	movs	r2, #0
 8007b4c:	701a      	strb	r2, [r3, #0]
  uint8_t char_counter = 0;
 8007b4e:	1dbb      	adds	r3, r7, #6
 8007b50:	2200      	movs	r2, #0
 8007b52:	701a      	strb	r2, [r3, #0]
  uint8_t c;
  for (;;) {

    // Process one line of incoming serial data, as the data becomes available. Performs an
    // initial filtering by removing spaces and comments and capitalizing all letters.
    while((c = serial_read()) != SERIAL_NO_DATA) {
 8007b54:	e0ce      	b.n	8007cf4 <protocol_main_loop+0x218>
      if ((c == '\n') || (c == '\r')) { // End of line reached
 8007b56:	1d7b      	adds	r3, r7, #5
 8007b58:	781b      	ldrb	r3, [r3, #0]
 8007b5a:	2b0a      	cmp	r3, #10
 8007b5c:	d003      	beq.n	8007b66 <protocol_main_loop+0x8a>
 8007b5e:	1d7b      	adds	r3, r7, #5
 8007b60:	781b      	ldrb	r3, [r3, #0]
 8007b62:	2b0d      	cmp	r3, #13
 8007b64:	d142      	bne.n	8007bec <protocol_main_loop+0x110>

        protocol_execute_realtime(); // Runtime command check point.
 8007b66:	f000 f90b 	bl	8007d80 <protocol_execute_realtime>
        if (sys.abort) { return; } // Bail to calling function upon system abort
 8007b6a:	4b70      	ldr	r3, [pc, #448]	; (8007d2c <protocol_main_loop+0x250>)
 8007b6c:	785b      	ldrb	r3, [r3, #1]
 8007b6e:	2b00      	cmp	r3, #0
 8007b70:	d000      	beq.n	8007b74 <protocol_main_loop+0x98>
 8007b72:	e0d2      	b.n	8007d1a <protocol_main_loop+0x23e>

        line[char_counter] = 0; // Set string termination character.
 8007b74:	1dbb      	adds	r3, r7, #6
 8007b76:	781b      	ldrb	r3, [r3, #0]
 8007b78:	4a6e      	ldr	r2, [pc, #440]	; (8007d34 <protocol_main_loop+0x258>)
 8007b7a:	2100      	movs	r1, #0
 8007b7c:	54d1      	strb	r1, [r2, r3]
				#ifdef REPORT_ECHO_LINE_RECEIVED
          report_echo_line_received(line);
        #endif

        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) {
 8007b7e:	1dfb      	adds	r3, r7, #7
 8007b80:	781b      	ldrb	r3, [r3, #0]
 8007b82:	2201      	movs	r2, #1
 8007b84:	4013      	ands	r3, r2
 8007b86:	d003      	beq.n	8007b90 <protocol_main_loop+0xb4>
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
 8007b88:	200b      	movs	r0, #11
 8007b8a:	f000 fe05 	bl	8008798 <report_status_message>
 8007b8e:	e026      	b.n	8007bde <protocol_main_loop+0x102>
        } else if (line[0] == 0) {
 8007b90:	4b68      	ldr	r3, [pc, #416]	; (8007d34 <protocol_main_loop+0x258>)
 8007b92:	781b      	ldrb	r3, [r3, #0]
 8007b94:	2b00      	cmp	r3, #0
 8007b96:	d103      	bne.n	8007ba0 <protocol_main_loop+0xc4>
          // Empty or comment line. For syncing purposes.
          report_status_message(STATUS_OK);
 8007b98:	2000      	movs	r0, #0
 8007b9a:	f000 fdfd 	bl	8008798 <report_status_message>
 8007b9e:	e01e      	b.n	8007bde <protocol_main_loop+0x102>
        } else if (line[0] == '$') {
 8007ba0:	4b64      	ldr	r3, [pc, #400]	; (8007d34 <protocol_main_loop+0x258>)
 8007ba2:	781b      	ldrb	r3, [r3, #0]
 8007ba4:	2b24      	cmp	r3, #36	; 0x24
 8007ba6:	d108      	bne.n	8007bba <protocol_main_loop+0xde>
          // Grbl '$' system command
          report_status_message(system_execute_line(line));
 8007ba8:	4b62      	ldr	r3, [pc, #392]	; (8007d34 <protocol_main_loop+0x258>)
 8007baa:	0018      	movs	r0, r3
 8007bac:	f003 ff24 	bl	800b9f8 <system_execute_line>
 8007bb0:	0003      	movs	r3, r0
 8007bb2:	0018      	movs	r0, r3
 8007bb4:	f000 fdf0 	bl	8008798 <report_status_message>
 8007bb8:	e011      	b.n	8007bde <protocol_main_loop+0x102>
        } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
 8007bba:	4b5c      	ldr	r3, [pc, #368]	; (8007d2c <protocol_main_loop+0x250>)
 8007bbc:	781b      	ldrb	r3, [r3, #0]
 8007bbe:	001a      	movs	r2, r3
 8007bc0:	2321      	movs	r3, #33	; 0x21
 8007bc2:	4013      	ands	r3, r2
 8007bc4:	d003      	beq.n	8007bce <protocol_main_loop+0xf2>
          // Everything else is gcode. Block if in alarm or jog mode.
          report_status_message(STATUS_SYSTEM_GC_LOCK);
 8007bc6:	2009      	movs	r0, #9
 8007bc8:	f000 fde6 	bl	8008798 <report_status_message>
 8007bcc:	e007      	b.n	8007bde <protocol_main_loop+0x102>
        } else {
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
 8007bce:	4b59      	ldr	r3, [pc, #356]	; (8007d34 <protocol_main_loop+0x258>)
 8007bd0:	0018      	movs	r0, r3
 8007bd2:	f7fb ff57 	bl	8003a84 <gc_execute_line>
 8007bd6:	0003      	movs	r3, r0
 8007bd8:	0018      	movs	r0, r3
 8007bda:	f000 fddd 	bl	8008798 <report_status_message>
        }

        // Reset tracking data for next line.
        line_flags = 0;
 8007bde:	1dfb      	adds	r3, r7, #7
 8007be0:	2200      	movs	r2, #0
 8007be2:	701a      	strb	r2, [r3, #0]
        char_counter = 0;
 8007be4:	1dbb      	adds	r3, r7, #6
 8007be6:	2200      	movs	r2, #0
 8007be8:	701a      	strb	r2, [r3, #0]
 8007bea:	e083      	b.n	8007cf4 <protocol_main_loop+0x218>

      } else {

        if (line_flags) {
 8007bec:	1dfb      	adds	r3, r7, #7
 8007bee:	781b      	ldrb	r3, [r3, #0]
 8007bf0:	2b00      	cmp	r3, #0
 8007bf2:	d013      	beq.n	8007c1c <protocol_main_loop+0x140>
          // Throw away all (except EOL) comment characters and overflow characters.
          if (c == ')') {
 8007bf4:	1d7b      	adds	r3, r7, #5
 8007bf6:	781b      	ldrb	r3, [r3, #0]
 8007bf8:	2b29      	cmp	r3, #41	; 0x29
 8007bfa:	d10a      	bne.n	8007c12 <protocol_main_loop+0x136>
            // End of '()' comment. Resume line allowed.
            if (line_flags & LINE_FLAG_COMMENT_PARENTHESES) { line_flags &= ~(LINE_FLAG_COMMENT_PARENTHESES); }
 8007bfc:	1dfb      	adds	r3, r7, #7
 8007bfe:	781b      	ldrb	r3, [r3, #0]
 8007c00:	2202      	movs	r2, #2
 8007c02:	4013      	ands	r3, r2
 8007c04:	d005      	beq.n	8007c12 <protocol_main_loop+0x136>
 8007c06:	1dfb      	adds	r3, r7, #7
 8007c08:	1dfa      	adds	r2, r7, #7
 8007c0a:	7812      	ldrb	r2, [r2, #0]
 8007c0c:	2102      	movs	r1, #2
 8007c0e:	438a      	bics	r2, r1
 8007c10:	701a      	strb	r2, [r3, #0]
 8007c12:	1dbb      	adds	r3, r7, #6
 8007c14:	1dba      	adds	r2, r7, #6
 8007c16:	7812      	ldrb	r2, [r2, #0]
 8007c18:	701a      	strb	r2, [r3, #0]
 8007c1a:	e06b      	b.n	8007cf4 <protocol_main_loop+0x218>
 8007c1c:	1dfb      	adds	r3, r7, #7
 8007c1e:	1dfa      	adds	r2, r7, #7
 8007c20:	7812      	ldrb	r2, [r2, #0]
 8007c22:	701a      	strb	r2, [r3, #0]
 8007c24:	1dbb      	adds	r3, r7, #6
 8007c26:	1dba      	adds	r2, r7, #6
 8007c28:	7812      	ldrb	r2, [r2, #0]
 8007c2a:	701a      	strb	r2, [r3, #0]
          }
        } else {
          if (c <= ' ') {
 8007c2c:	1d7b      	adds	r3, r7, #5
 8007c2e:	781b      	ldrb	r3, [r3, #0]
 8007c30:	2b20      	cmp	r3, #32
 8007c32:	d95f      	bls.n	8007cf4 <protocol_main_loop+0x218>
 8007c34:	1dfb      	adds	r3, r7, #7
 8007c36:	1dfa      	adds	r2, r7, #7
 8007c38:	7812      	ldrb	r2, [r2, #0]
 8007c3a:	701a      	strb	r2, [r3, #0]
 8007c3c:	1dbb      	adds	r3, r7, #6
 8007c3e:	1dba      	adds	r2, r7, #6
 8007c40:	7812      	ldrb	r2, [r2, #0]
 8007c42:	701a      	strb	r2, [r3, #0]
            // Throw away whitepace and control characters
          } else if (c == '/') {
 8007c44:	1d7b      	adds	r3, r7, #5
 8007c46:	781b      	ldrb	r3, [r3, #0]
 8007c48:	2b2f      	cmp	r3, #47	; 0x2f
 8007c4a:	d053      	beq.n	8007cf4 <protocol_main_loop+0x218>
            // Block delete NOT SUPPORTED. Ignore character.
            // NOTE: If supported, would simply need to check the system if block delete is enabled.
          } else if (c == '(') {
 8007c4c:	1d7b      	adds	r3, r7, #5
 8007c4e:	781b      	ldrb	r3, [r3, #0]
 8007c50:	2b28      	cmp	r3, #40	; 0x28
 8007c52:	d10a      	bne.n	8007c6a <protocol_main_loop+0x18e>
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
 8007c54:	1dfb      	adds	r3, r7, #7
 8007c56:	1dfa      	adds	r2, r7, #7
 8007c58:	7812      	ldrb	r2, [r2, #0]
 8007c5a:	2102      	movs	r1, #2
 8007c5c:	430a      	orrs	r2, r1
 8007c5e:	701a      	strb	r2, [r3, #0]
 8007c60:	1dbb      	adds	r3, r7, #6
 8007c62:	1dba      	adds	r2, r7, #6
 8007c64:	7812      	ldrb	r2, [r2, #0]
 8007c66:	701a      	strb	r2, [r3, #0]
 8007c68:	e044      	b.n	8007cf4 <protocol_main_loop+0x218>
          } else if (c == ';') {
 8007c6a:	1d7b      	adds	r3, r7, #5
 8007c6c:	781b      	ldrb	r3, [r3, #0]
 8007c6e:	2b3b      	cmp	r3, #59	; 0x3b
 8007c70:	d10a      	bne.n	8007c88 <protocol_main_loop+0x1ac>
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            line_flags |= LINE_FLAG_COMMENT_SEMICOLON;
 8007c72:	1dfb      	adds	r3, r7, #7
 8007c74:	1dfa      	adds	r2, r7, #7
 8007c76:	7812      	ldrb	r2, [r2, #0]
 8007c78:	2104      	movs	r1, #4
 8007c7a:	430a      	orrs	r2, r1
 8007c7c:	701a      	strb	r2, [r3, #0]
 8007c7e:	1dbb      	adds	r3, r7, #6
 8007c80:	1dba      	adds	r2, r7, #6
 8007c82:	7812      	ldrb	r2, [r2, #0]
 8007c84:	701a      	strb	r2, [r3, #0]
 8007c86:	e035      	b.n	8007cf4 <protocol_main_loop+0x218>
            // Program start-end percent sign NOT SUPPORTED.
            // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
            // where, during a program, the system auto-cycle start will continue to execute
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.
          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
 8007c88:	1dbb      	adds	r3, r7, #6
 8007c8a:	781b      	ldrb	r3, [r3, #0]
 8007c8c:	2b4e      	cmp	r3, #78	; 0x4e
 8007c8e:	d90a      	bls.n	8007ca6 <protocol_main_loop+0x1ca>
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
 8007c90:	1dfb      	adds	r3, r7, #7
 8007c92:	1dfa      	adds	r2, r7, #7
 8007c94:	7812      	ldrb	r2, [r2, #0]
 8007c96:	2101      	movs	r1, #1
 8007c98:	430a      	orrs	r2, r1
 8007c9a:	701a      	strb	r2, [r3, #0]
 8007c9c:	1dbb      	adds	r3, r7, #6
 8007c9e:	1dba      	adds	r2, r7, #6
 8007ca0:	7812      	ldrb	r2, [r2, #0]
 8007ca2:	701a      	strb	r2, [r3, #0]
 8007ca4:	e026      	b.n	8007cf4 <protocol_main_loop+0x218>
          } else if (c >= 'a' && c <= 'z') { // Upcase lowercase
 8007ca6:	1d7b      	adds	r3, r7, #5
 8007ca8:	781b      	ldrb	r3, [r3, #0]
 8007caa:	2b60      	cmp	r3, #96	; 0x60
 8007cac:	d914      	bls.n	8007cd8 <protocol_main_loop+0x1fc>
 8007cae:	1d7b      	adds	r3, r7, #5
 8007cb0:	781b      	ldrb	r3, [r3, #0]
 8007cb2:	2b7a      	cmp	r3, #122	; 0x7a
 8007cb4:	d810      	bhi.n	8007cd8 <protocol_main_loop+0x1fc>
            line[char_counter++] = c-'a'+'A';
 8007cb6:	1dbb      	adds	r3, r7, #6
 8007cb8:	781b      	ldrb	r3, [r3, #0]
 8007cba:	1dba      	adds	r2, r7, #6
 8007cbc:	1c59      	adds	r1, r3, #1
 8007cbe:	7011      	strb	r1, [r2, #0]
 8007cc0:	001a      	movs	r2, r3
 8007cc2:	1d7b      	adds	r3, r7, #5
 8007cc4:	781b      	ldrb	r3, [r3, #0]
 8007cc6:	3b20      	subs	r3, #32
 8007cc8:	b2d9      	uxtb	r1, r3
 8007cca:	4b1a      	ldr	r3, [pc, #104]	; (8007d34 <protocol_main_loop+0x258>)
 8007ccc:	5499      	strb	r1, [r3, r2]
 8007cce:	1dfb      	adds	r3, r7, #7
 8007cd0:	1dfa      	adds	r2, r7, #7
 8007cd2:	7812      	ldrb	r2, [r2, #0]
 8007cd4:	701a      	strb	r2, [r3, #0]
 8007cd6:	e00d      	b.n	8007cf4 <protocol_main_loop+0x218>
          } else {
            line[char_counter++] = c;
 8007cd8:	1dbb      	adds	r3, r7, #6
 8007cda:	781b      	ldrb	r3, [r3, #0]
 8007cdc:	1dba      	adds	r2, r7, #6
 8007cde:	1c59      	adds	r1, r3, #1
 8007ce0:	7011      	strb	r1, [r2, #0]
 8007ce2:	0019      	movs	r1, r3
 8007ce4:	4b13      	ldr	r3, [pc, #76]	; (8007d34 <protocol_main_loop+0x258>)
 8007ce6:	1d7a      	adds	r2, r7, #5
 8007ce8:	7812      	ldrb	r2, [r2, #0]
 8007cea:	545a      	strb	r2, [r3, r1]
 8007cec:	1dfb      	adds	r3, r7, #7
 8007cee:	1dfa      	adds	r2, r7, #7
 8007cf0:	7812      	ldrb	r2, [r2, #0]
 8007cf2:	701a      	strb	r2, [r3, #0]
    while((c = serial_read()) != SERIAL_NO_DATA) {
 8007cf4:	1d7c      	adds	r4, r7, #5
 8007cf6:	f001 fbd3 	bl	80094a0 <serial_read>
 8007cfa:	0003      	movs	r3, r0
 8007cfc:	7023      	strb	r3, [r4, #0]
 8007cfe:	1d7b      	adds	r3, r7, #5
 8007d00:	781b      	ldrb	r3, [r3, #0]
 8007d02:	2bff      	cmp	r3, #255	; 0xff
 8007d04:	d000      	beq.n	8007d08 <protocol_main_loop+0x22c>
 8007d06:	e726      	b.n	8007b56 <protocol_main_loop+0x7a>
    }

    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
 8007d08:	f000 f82e 	bl	8007d68 <protocol_auto_cycle_start>

    protocol_execute_realtime();  // Runtime command check point.
 8007d0c:	f000 f838 	bl	8007d80 <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
 8007d10:	4b06      	ldr	r3, [pc, #24]	; (8007d2c <protocol_main_loop+0x250>)
 8007d12:	785b      	ldrb	r3, [r3, #1]
 8007d14:	2b00      	cmp	r3, #0
 8007d16:	d102      	bne.n	8007d1e <protocol_main_loop+0x242>
    while((c = serial_read()) != SERIAL_NO_DATA) {
 8007d18:	e7ec      	b.n	8007cf4 <protocol_main_loop+0x218>
        if (sys.abort) { return; } // Bail to calling function upon system abort
 8007d1a:	46c0      	nop			; (mov r8, r8)
 8007d1c:	e000      	b.n	8007d20 <protocol_main_loop+0x244>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
 8007d1e:	46c0      	nop			; (mov r8, r8)
  }

  return; /* Never reached */
}
 8007d20:	46bd      	mov	sp, r7
 8007d22:	b003      	add	sp, #12
 8007d24:	bd90      	pop	{r4, r7, pc}
 8007d26:	46c0      	nop			; (mov r8, r8)
 8007d28:	20000b44 	.word	0x20000b44
 8007d2c:	20000bb4 	.word	0x20000bb4
 8007d30:	20000bc9 	.word	0x20000bc9
 8007d34:	20000440 	.word	0x20000440

08007d38 <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
 8007d38:	b580      	push	{r7, lr}
 8007d3a:	af00      	add	r7, sp, #0
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
 8007d3c:	f000 f814 	bl	8007d68 <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
 8007d40:	f000 f81e 	bl	8007d80 <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
 8007d44:	4b07      	ldr	r3, [pc, #28]	; (8007d64 <protocol_buffer_synchronize+0x2c>)
 8007d46:	785b      	ldrb	r3, [r3, #1]
 8007d48:	2b00      	cmp	r3, #0
 8007d4a:	d108      	bne.n	8007d5e <protocol_buffer_synchronize+0x26>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
 8007d4c:	f7ff f85a 	bl	8006e04 <plan_get_current_block>
 8007d50:	1e03      	subs	r3, r0, #0
 8007d52:	d1f5      	bne.n	8007d40 <protocol_buffer_synchronize+0x8>
 8007d54:	4b03      	ldr	r3, [pc, #12]	; (8007d64 <protocol_buffer_synchronize+0x2c>)
 8007d56:	781b      	ldrb	r3, [r3, #0]
 8007d58:	2b08      	cmp	r3, #8
 8007d5a:	d0f1      	beq.n	8007d40 <protocol_buffer_synchronize+0x8>
 8007d5c:	e000      	b.n	8007d60 <protocol_buffer_synchronize+0x28>
    if (sys.abort) { return; } // Check for system abort
 8007d5e:	46c0      	nop			; (mov r8, r8)
}
 8007d60:	46bd      	mov	sp, r7
 8007d62:	bd80      	pop	{r7, pc}
 8007d64:	20000bb4 	.word	0x20000bb4

08007d68 <protocol_auto_cycle_start>:
// NOTE: This function is called from the main loop, buffer sync, and mc_line() only and executes
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming
// is finished, single commands), a command that needs to wait for the motions in the buffer to
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start()
{
 8007d68:	b580      	push	{r7, lr}
 8007d6a:	af00      	add	r7, sp, #0
  if (plan_get_current_block() != NULL) { // Check if there are any blocks in the buffer.
 8007d6c:	f7ff f84a 	bl	8006e04 <plan_get_current_block>
 8007d70:	1e03      	subs	r3, r0, #0
 8007d72:	d002      	beq.n	8007d7a <protocol_auto_cycle_start+0x12>
    system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
 8007d74:	2002      	movs	r0, #2
 8007d76:	f004 f995 	bl	800c0a4 <system_set_exec_state_flag>
  }
}
 8007d7a:	46c0      	nop			; (mov r8, r8)
 8007d7c:	46bd      	mov	sp, r7
 8007d7e:	bd80      	pop	{r7, pc}

08007d80 <protocol_execute_realtime>:
// also provides a controlled way to execute certain tasks without having two or more instances of
// the same task, such as the planner recalculating the buffer upon a feedhold or overrides.
// NOTE: The sys_rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
 8007d80:	b580      	push	{r7, lr}
 8007d82:	af00      	add	r7, sp, #0
  protocol_exec_rt_system();
 8007d84:	f000 f80c 	bl	8007da0 <protocol_exec_rt_system>
  if (sys.suspend) { protocol_exec_rt_suspend(); }
 8007d88:	4b04      	ldr	r3, [pc, #16]	; (8007d9c <protocol_execute_realtime+0x1c>)
 8007d8a:	789b      	ldrb	r3, [r3, #2]
 8007d8c:	2b00      	cmp	r3, #0
 8007d8e:	d001      	beq.n	8007d94 <protocol_execute_realtime+0x14>
 8007d90:	f000 fb04 	bl	800839c <protocol_exec_rt_suspend>
}
 8007d94:	46c0      	nop			; (mov r8, r8)
 8007d96:	46bd      	mov	sp, r7
 8007d98:	bd80      	pop	{r7, pc}
 8007d9a:	46c0      	nop			; (mov r8, r8)
 8007d9c:	20000bb4 	.word	0x20000bb4

08007da0 <protocol_exec_rt_system>:

// Executes run-time commands, when required. This function primarily operates as Grbl's state
// machine and controls the various real-time features Grbl has to offer.
// NOTE: Do not alter this unless you know exactly what you are doing!
void protocol_exec_rt_system()
{
 8007da0:	b580      	push	{r7, lr}
 8007da2:	b082      	sub	sp, #8
 8007da4:	af00      	add	r7, sp, #0
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
 8007da6:	1cfb      	adds	r3, r7, #3
 8007da8:	4abc      	ldr	r2, [pc, #752]	; (800809c <protocol_exec_rt_system+0x2fc>)
 8007daa:	7812      	ldrb	r2, [r2, #0]
 8007dac:	701a      	strb	r2, [r3, #0]
  if (rt_exec) { // Enter only if any bit flag is true
 8007dae:	1cfb      	adds	r3, r7, #3
 8007db0:	781b      	ldrb	r3, [r3, #0]
 8007db2:	2b00      	cmp	r3, #0
 8007db4:	d01e      	beq.n	8007df4 <protocol_exec_rt_system+0x54>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
 8007db6:	4bba      	ldr	r3, [pc, #744]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007db8:	2201      	movs	r2, #1
 8007dba:	701a      	strb	r2, [r3, #0]
    report_alarm_message(rt_exec);
 8007dbc:	1cfb      	adds	r3, r7, #3
 8007dbe:	781b      	ldrb	r3, [r3, #0]
 8007dc0:	0018      	movs	r0, r3
 8007dc2:	f000 fd0b 	bl	80087dc <report_alarm_message>
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if ((rt_exec == EXEC_ALARM_HARD_LIMIT) || (rt_exec == EXEC_ALARM_SOFT_LIMIT)) {
 8007dc6:	1cfb      	adds	r3, r7, #3
 8007dc8:	781b      	ldrb	r3, [r3, #0]
 8007dca:	2b01      	cmp	r3, #1
 8007dcc:	d003      	beq.n	8007dd6 <protocol_exec_rt_system+0x36>
 8007dce:	1cfb      	adds	r3, r7, #3
 8007dd0:	781b      	ldrb	r3, [r3, #0]
 8007dd2:	2b02      	cmp	r3, #2
 8007dd4:	d10c      	bne.n	8007df0 <protocol_exec_rt_system+0x50>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
 8007dd6:	2001      	movs	r0, #1
 8007dd8:	f000 fd1c 	bl	8008814 <report_feedback_message>
      system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
 8007ddc:	2010      	movs	r0, #16
 8007dde:	f004 f979 	bl	800c0d4 <system_clear_exec_state_flag>
        // Block everything, except reset and status reports, until user issues reset or power
        // cycles. Hard limits typically occur while unattended or not paying attention. Gives
        // the user and a GUI time to do what is needed before resetting, like killing the
        // incoming stream. The same could be said about soft limits. While the position is not
        // lost, continued streaming could cause a serious crash if by chance it gets executed.
      } while (bit_isfalse(sys_rt_exec_state,EXEC_RESET));
 8007de2:	4bb0      	ldr	r3, [pc, #704]	; (80080a4 <protocol_exec_rt_system+0x304>)
 8007de4:	781b      	ldrb	r3, [r3, #0]
 8007de6:	b2db      	uxtb	r3, r3
 8007de8:	001a      	movs	r2, r3
 8007dea:	2310      	movs	r3, #16
 8007dec:	4013      	ands	r3, r2
 8007dee:	d0f8      	beq.n	8007de2 <protocol_exec_rt_system+0x42>
    }
    system_clear_exec_alarm(); // Clear alarm
 8007df0:	f004 f9a4 	bl	800c13c <system_clear_exec_alarm>
  }

  rt_exec = sys_rt_exec_state; // Copy volatile sys_rt_exec_state.
 8007df4:	1cfb      	adds	r3, r7, #3
 8007df6:	4aab      	ldr	r2, [pc, #684]	; (80080a4 <protocol_exec_rt_system+0x304>)
 8007df8:	7812      	ldrb	r2, [r2, #0]
 8007dfa:	701a      	strb	r2, [r3, #0]
  if (rt_exec) {
 8007dfc:	1cfb      	adds	r3, r7, #3
 8007dfe:	781b      	ldrb	r3, [r3, #0]
 8007e00:	2b00      	cmp	r3, #0
 8007e02:	d100      	bne.n	8007e06 <protocol_exec_rt_system+0x66>
 8007e04:	e181      	b.n	800810a <protocol_exec_rt_system+0x36a>

    // Execute system abort.
    if (rt_exec & EXEC_RESET) {
 8007e06:	1cfb      	adds	r3, r7, #3
 8007e08:	781b      	ldrb	r3, [r3, #0]
 8007e0a:	2210      	movs	r2, #16
 8007e0c:	4013      	ands	r3, r2
 8007e0e:	d003      	beq.n	8007e18 <protocol_exec_rt_system+0x78>
      sys.abort = true;  // Only place this is set true.
 8007e10:	4ba3      	ldr	r3, [pc, #652]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007e12:	2201      	movs	r2, #1
 8007e14:	705a      	strb	r2, [r3, #1]
      return; // Nothing else to do but exit.
 8007e16:	e2b5      	b.n	8008384 <protocol_exec_rt_system+0x5e4>
    }

    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) {
 8007e18:	1cfb      	adds	r3, r7, #3
 8007e1a:	781b      	ldrb	r3, [r3, #0]
 8007e1c:	2201      	movs	r2, #1
 8007e1e:	4013      	ands	r3, r2
 8007e20:	d004      	beq.n	8007e2c <protocol_exec_rt_system+0x8c>
      report_realtime_status();
 8007e22:	f001 f87b 	bl	8008f1c <report_realtime_status>
      system_clear_exec_state_flag(EXEC_STATUS_REPORT);
 8007e26:	2001      	movs	r0, #1
 8007e28:	f004 f954 	bl	800c0d4 <system_clear_exec_state_flag>
    }

    // NOTE: Once hold is initiated, the system immediately enters a suspend state to block all
    // main program processes until either reset or resumed. This ensures a hold completes safely.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP)) {
 8007e2c:	1cfb      	adds	r3, r7, #3
 8007e2e:	781b      	ldrb	r3, [r3, #0]
 8007e30:	22e8      	movs	r2, #232	; 0xe8
 8007e32:	4013      	ands	r3, r2
 8007e34:	d100      	bne.n	8007e38 <protocol_exec_rt_system+0x98>
 8007e36:	e098      	b.n	8007f6a <protocol_exec_rt_system+0x1ca>

      // State check for allowable states for hold methods.
      if (!(sys.state & (STATE_ALARM | STATE_CHECK_MODE))) {
 8007e38:	4b99      	ldr	r3, [pc, #612]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007e3a:	781b      	ldrb	r3, [r3, #0]
 8007e3c:	001a      	movs	r2, r3
 8007e3e:	2303      	movs	r3, #3
 8007e40:	4013      	ands	r3, r2
 8007e42:	d000      	beq.n	8007e46 <protocol_exec_rt_system+0xa6>
 8007e44:	e07b      	b.n	8007f3e <protocol_exec_rt_system+0x19e>
      
        // If in CYCLE or JOG states, immediately initiate a motion HOLD.
        if (sys.state & (STATE_CYCLE | STATE_JOG)) {
 8007e46:	4b96      	ldr	r3, [pc, #600]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007e48:	781b      	ldrb	r3, [r3, #0]
 8007e4a:	001a      	movs	r2, r3
 8007e4c:	2328      	movs	r3, #40	; 0x28
 8007e4e:	4013      	ands	r3, r2
 8007e50:	d01b      	beq.n	8007e8a <protocol_exec_rt_system+0xea>
          if (!(sys.suspend & (SUSPEND_MOTION_CANCEL | SUSPEND_JOG_CANCEL))) { // Block, if already holding.
 8007e52:	4b93      	ldr	r3, [pc, #588]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007e54:	789b      	ldrb	r3, [r3, #2]
 8007e56:	001a      	movs	r2, r3
 8007e58:	23c0      	movs	r3, #192	; 0xc0
 8007e5a:	4013      	ands	r3, r2
 8007e5c:	d115      	bne.n	8007e8a <protocol_exec_rt_system+0xea>
            st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
 8007e5e:	f002 fe75 	bl	800ab4c <st_update_plan_block_parameters>
            sys.step_control = STEP_CONTROL_EXECUTE_HOLD; // Initiate suspend state with active flag.
 8007e62:	4b8f      	ldr	r3, [pc, #572]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007e64:	2202      	movs	r2, #2
 8007e66:	711a      	strb	r2, [r3, #4]
            if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping.
 8007e68:	4b8d      	ldr	r3, [pc, #564]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007e6a:	781b      	ldrb	r3, [r3, #0]
 8007e6c:	2b20      	cmp	r3, #32
 8007e6e:	d10c      	bne.n	8007e8a <protocol_exec_rt_system+0xea>
              if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
 8007e70:	1cfb      	adds	r3, r7, #3
 8007e72:	781b      	ldrb	r3, [r3, #0]
 8007e74:	b25b      	sxtb	r3, r3
 8007e76:	2b00      	cmp	r3, #0
 8007e78:	db07      	blt.n	8007e8a <protocol_exec_rt_system+0xea>
 8007e7a:	4b89      	ldr	r3, [pc, #548]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007e7c:	789b      	ldrb	r3, [r3, #2]
 8007e7e:	2280      	movs	r2, #128	; 0x80
 8007e80:	4252      	negs	r2, r2
 8007e82:	4313      	orrs	r3, r2
 8007e84:	b2da      	uxtb	r2, r3
 8007e86:	4b86      	ldr	r3, [pc, #536]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007e88:	709a      	strb	r2, [r3, #2]
            }
          }
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend state and hold is complete.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_HOLD_COMPLETE; }
 8007e8a:	4b85      	ldr	r3, [pc, #532]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007e8c:	781b      	ldrb	r3, [r3, #0]
 8007e8e:	2b00      	cmp	r3, #0
 8007e90:	d102      	bne.n	8007e98 <protocol_exec_rt_system+0xf8>
 8007e92:	4b83      	ldr	r3, [pc, #524]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007e94:	2201      	movs	r2, #1
 8007e96:	709a      	strb	r2, [r3, #2]

        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
 8007e98:	1cfb      	adds	r3, r7, #3
 8007e9a:	781b      	ldrb	r3, [r3, #0]
 8007e9c:	2240      	movs	r2, #64	; 0x40
 8007e9e:	4013      	ands	r3, r2
 8007ea0:	d00c      	beq.n	8007ebc <protocol_exec_rt_system+0x11c>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. Motion cancel is valid for a single planner block motion only, while jog cancel
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
 8007ea2:	4b7f      	ldr	r3, [pc, #508]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007ea4:	781b      	ldrb	r3, [r3, #0]
 8007ea6:	001a      	movs	r2, r3
 8007ea8:	2320      	movs	r3, #32
 8007eaa:	4013      	ands	r3, r2
 8007eac:	d106      	bne.n	8007ebc <protocol_exec_rt_system+0x11c>
 8007eae:	4b7c      	ldr	r3, [pc, #496]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007eb0:	789b      	ldrb	r3, [r3, #2]
 8007eb2:	2240      	movs	r2, #64	; 0x40
 8007eb4:	4313      	orrs	r3, r2
 8007eb6:	b2da      	uxtb	r2, r3
 8007eb8:	4b79      	ldr	r3, [pc, #484]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007eba:	709a      	strb	r2, [r3, #2]
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
 8007ebc:	1cfb      	adds	r3, r7, #3
 8007ebe:	781b      	ldrb	r3, [r3, #0]
 8007ec0:	2208      	movs	r2, #8
 8007ec2:	4013      	ands	r3, r2
 8007ec4:	d008      	beq.n	8007ed8 <protocol_exec_rt_system+0x138>
          // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
          if (!(sys.state & (STATE_SAFETY_DOOR | STATE_JOG | STATE_SLEEP))) { sys.state = STATE_HOLD; }
 8007ec6:	4b76      	ldr	r3, [pc, #472]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007ec8:	781b      	ldrb	r3, [r3, #0]
 8007eca:	001a      	movs	r2, r3
 8007ecc:	23e0      	movs	r3, #224	; 0xe0
 8007ece:	4013      	ands	r3, r2
 8007ed0:	d102      	bne.n	8007ed8 <protocol_exec_rt_system+0x138>
 8007ed2:	4b73      	ldr	r3, [pc, #460]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007ed4:	2210      	movs	r2, #16
 8007ed6:	701a      	strb	r2, [r3, #0]
        }

        // Execute a safety door stop with a feed hold and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged.
        if (rt_exec & EXEC_SAFETY_DOOR) {
 8007ed8:	1cfb      	adds	r3, r7, #3
 8007eda:	781b      	ldrb	r3, [r3, #0]
 8007edc:	2220      	movs	r2, #32
 8007ede:	4013      	ands	r3, r2
 8007ee0:	d02d      	beq.n	8007f3e <protocol_exec_rt_system+0x19e>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR);
 8007ee2:	2006      	movs	r0, #6
 8007ee4:	f000 fc96 	bl	8008814 <report_feedback_message>
          // If jogging, block safety door methods until jog cancel is complete. Just flag that it happened.
          if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
 8007ee8:	4b6d      	ldr	r3, [pc, #436]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007eea:	789b      	ldrb	r3, [r3, #2]
 8007eec:	b25b      	sxtb	r3, r3
 8007eee:	2b00      	cmp	r3, #0
 8007ef0:	db1e      	blt.n	8007f30 <protocol_exec_rt_system+0x190>
            // Check if the safety re-opened during a restore parking motion only. Ignore if
            // already retracting, parked or in sleep state.
            if (sys.state == STATE_SAFETY_DOOR) {
 8007ef2:	4b6b      	ldr	r3, [pc, #428]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007ef4:	781b      	ldrb	r3, [r3, #0]
 8007ef6:	2b40      	cmp	r3, #64	; 0x40
 8007ef8:	d113      	bne.n	8007f22 <protocol_exec_rt_system+0x182>
              if (sys.suspend & SUSPEND_INITIATE_RESTORE) { // Actively restoring
 8007efa:	4b69      	ldr	r3, [pc, #420]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007efc:	789b      	ldrb	r3, [r3, #2]
 8007efe:	001a      	movs	r2, r3
 8007f00:	2308      	movs	r3, #8
 8007f02:	4013      	ands	r3, r2
 8007f04:	d00d      	beq.n	8007f22 <protocol_exec_rt_system+0x182>
                    st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
                    sys.step_control = (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION);
                    sys.suspend &= ~(SUSPEND_HOLD_COMPLETE);
                  } // else NO_MOTION is active.
                #endif
                sys.suspend &= ~(SUSPEND_RETRACT_COMPLETE | SUSPEND_INITIATE_RESTORE | SUSPEND_RESTORE_COMPLETE);
 8007f06:	4b66      	ldr	r3, [pc, #408]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f08:	789b      	ldrb	r3, [r3, #2]
 8007f0a:	221c      	movs	r2, #28
 8007f0c:	4393      	bics	r3, r2
 8007f0e:	b2da      	uxtb	r2, r3
 8007f10:	4b63      	ldr	r3, [pc, #396]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f12:	709a      	strb	r2, [r3, #2]
                sys.suspend |= SUSPEND_RESTART_RETRACT;
 8007f14:	4b62      	ldr	r3, [pc, #392]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f16:	789b      	ldrb	r3, [r3, #2]
 8007f18:	2202      	movs	r2, #2
 8007f1a:	4313      	orrs	r3, r2
 8007f1c:	b2da      	uxtb	r2, r3
 8007f1e:	4b60      	ldr	r3, [pc, #384]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f20:	709a      	strb	r2, [r3, #2]
              }
            }
            if (sys.state != STATE_SLEEP) { sys.state = STATE_SAFETY_DOOR; }
 8007f22:	4b5f      	ldr	r3, [pc, #380]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f24:	781b      	ldrb	r3, [r3, #0]
 8007f26:	2b80      	cmp	r3, #128	; 0x80
 8007f28:	d002      	beq.n	8007f30 <protocol_exec_rt_system+0x190>
 8007f2a:	4b5d      	ldr	r3, [pc, #372]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f2c:	2240      	movs	r2, #64	; 0x40
 8007f2e:	701a      	strb	r2, [r3, #0]
          }
          // NOTE: This flag doesn't change when the door closes, unlike sys.state. Ensures any parking motions
          // are executed if the door switch closes and the state returns to HOLD.
          sys.suspend |= SUSPEND_SAFETY_DOOR_AJAR;
 8007f30:	4b5b      	ldr	r3, [pc, #364]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f32:	789b      	ldrb	r3, [r3, #2]
 8007f34:	2220      	movs	r2, #32
 8007f36:	4313      	orrs	r3, r2
 8007f38:	b2da      	uxtb	r2, r3
 8007f3a:	4b59      	ldr	r3, [pc, #356]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f3c:	709a      	strb	r2, [r3, #2]
        }
        
      }

      if (rt_exec & EXEC_SLEEP) {
 8007f3e:	1cfb      	adds	r3, r7, #3
 8007f40:	781b      	ldrb	r3, [r3, #0]
 8007f42:	b25b      	sxtb	r3, r3
 8007f44:	2b00      	cmp	r3, #0
 8007f46:	da0d      	bge.n	8007f64 <protocol_exec_rt_system+0x1c4>
        if (sys.state == STATE_ALARM) { sys.suspend |= (SUSPEND_RETRACT_COMPLETE|SUSPEND_HOLD_COMPLETE); }
 8007f48:	4b55      	ldr	r3, [pc, #340]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f4a:	781b      	ldrb	r3, [r3, #0]
 8007f4c:	2b01      	cmp	r3, #1
 8007f4e:	d106      	bne.n	8007f5e <protocol_exec_rt_system+0x1be>
 8007f50:	4b53      	ldr	r3, [pc, #332]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f52:	789b      	ldrb	r3, [r3, #2]
 8007f54:	2205      	movs	r2, #5
 8007f56:	4313      	orrs	r3, r2
 8007f58:	b2da      	uxtb	r2, r3
 8007f5a:	4b51      	ldr	r3, [pc, #324]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f5c:	709a      	strb	r2, [r3, #2]
        sys.state = STATE_SLEEP; 
 8007f5e:	4b50      	ldr	r3, [pc, #320]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f60:	2280      	movs	r2, #128	; 0x80
 8007f62:	701a      	strb	r2, [r3, #0]
      }

      system_clear_exec_state_flag((EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP));
 8007f64:	20e8      	movs	r0, #232	; 0xe8
 8007f66:	f004 f8b5 	bl	800c0d4 <system_clear_exec_state_flag>
    }

    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
 8007f6a:	1cfb      	adds	r3, r7, #3
 8007f6c:	781b      	ldrb	r3, [r3, #0]
 8007f6e:	2202      	movs	r2, #2
 8007f70:	4013      	ands	r3, r2
 8007f72:	d100      	bne.n	8007f76 <protocol_exec_rt_system+0x1d6>
 8007f74:	e066      	b.n	8008044 <protocol_exec_rt_system+0x2a4>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) {
 8007f76:	1cfb      	adds	r3, r7, #3
 8007f78:	781b      	ldrb	r3, [r3, #0]
 8007f7a:	2268      	movs	r2, #104	; 0x68
 8007f7c:	4013      	ands	r3, r2
 8007f7e:	d15e      	bne.n	800803e <protocol_exec_rt_system+0x29e>
        // Resume door state when parking motion has retracted and door has been closed.
        if ((sys.state == STATE_SAFETY_DOOR) && !(sys.suspend & SUSPEND_SAFETY_DOOR_AJAR)) {
 8007f80:	4b47      	ldr	r3, [pc, #284]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f82:	781b      	ldrb	r3, [r3, #0]
 8007f84:	2b40      	cmp	r3, #64	; 0x40
 8007f86:	d11c      	bne.n	8007fc2 <protocol_exec_rt_system+0x222>
 8007f88:	4b45      	ldr	r3, [pc, #276]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f8a:	789b      	ldrb	r3, [r3, #2]
 8007f8c:	001a      	movs	r2, r3
 8007f8e:	2320      	movs	r3, #32
 8007f90:	4013      	ands	r3, r2
 8007f92:	d116      	bne.n	8007fc2 <protocol_exec_rt_system+0x222>
          if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
 8007f94:	4b42      	ldr	r3, [pc, #264]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007f96:	789b      	ldrb	r3, [r3, #2]
 8007f98:	001a      	movs	r2, r3
 8007f9a:	2310      	movs	r3, #16
 8007f9c:	4013      	ands	r3, r2
 8007f9e:	d003      	beq.n	8007fa8 <protocol_exec_rt_system+0x208>
            sys.state = STATE_IDLE; // Set to IDLE to immediately resume the cycle.
 8007fa0:	4b3f      	ldr	r3, [pc, #252]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007fa2:	2200      	movs	r2, #0
 8007fa4:	701a      	strb	r2, [r3, #0]
 8007fa6:	e00c      	b.n	8007fc2 <protocol_exec_rt_system+0x222>
          } else if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
 8007fa8:	4b3d      	ldr	r3, [pc, #244]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007faa:	789b      	ldrb	r3, [r3, #2]
 8007fac:	001a      	movs	r2, r3
 8007fae:	2304      	movs	r3, #4
 8007fb0:	4013      	ands	r3, r2
 8007fb2:	d006      	beq.n	8007fc2 <protocol_exec_rt_system+0x222>
            // Flag to re-energize powered components and restore original position, if disabled by SAFETY_DOOR.
            // NOTE: For a safety door to resume, the switch must be closed, as indicated by HOLD state, and
            // the retraction execution is complete, which implies the initial feed hold is not active. To
            // restore normal operation, the restore procedures must be initiated by the following flag. Once,
            // they are complete, it will call CYCLE_START automatically to resume and exit the suspend.
            sys.suspend |= SUSPEND_INITIATE_RESTORE;
 8007fb4:	4b3a      	ldr	r3, [pc, #232]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007fb6:	789b      	ldrb	r3, [r3, #2]
 8007fb8:	2208      	movs	r2, #8
 8007fba:	4313      	orrs	r3, r2
 8007fbc:	b2da      	uxtb	r2, r3
 8007fbe:	4b38      	ldr	r3, [pc, #224]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007fc0:	709a      	strb	r2, [r3, #2]
          }
        }
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        if ((sys.state == STATE_IDLE) || ((sys.state & STATE_HOLD) && (sys.suspend & SUSPEND_HOLD_COMPLETE))) {
 8007fc2:	4b37      	ldr	r3, [pc, #220]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007fc4:	781b      	ldrb	r3, [r3, #0]
 8007fc6:	2b00      	cmp	r3, #0
 8007fc8:	d00b      	beq.n	8007fe2 <protocol_exec_rt_system+0x242>
 8007fca:	4b35      	ldr	r3, [pc, #212]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007fcc:	781b      	ldrb	r3, [r3, #0]
 8007fce:	001a      	movs	r2, r3
 8007fd0:	2310      	movs	r3, #16
 8007fd2:	4013      	ands	r3, r2
 8007fd4:	d033      	beq.n	800803e <protocol_exec_rt_system+0x29e>
 8007fd6:	4b32      	ldr	r3, [pc, #200]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007fd8:	789b      	ldrb	r3, [r3, #2]
 8007fda:	001a      	movs	r2, r3
 8007fdc:	2301      	movs	r3, #1
 8007fde:	4013      	ands	r3, r2
 8007fe0:	d02d      	beq.n	800803e <protocol_exec_rt_system+0x29e>
          if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
 8007fe2:	4b2f      	ldr	r3, [pc, #188]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007fe4:	781b      	ldrb	r3, [r3, #0]
 8007fe6:	2b10      	cmp	r3, #16
 8007fe8:	d10b      	bne.n	8008002 <protocol_exec_rt_system+0x262>
 8007fea:	4b2d      	ldr	r3, [pc, #180]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007fec:	7a9b      	ldrb	r3, [r3, #10]
 8007fee:	2b00      	cmp	r3, #0
 8007ff0:	d007      	beq.n	8008002 <protocol_exec_rt_system+0x262>
            sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend routine and cycle start after.
 8007ff2:	4b2b      	ldr	r3, [pc, #172]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007ff4:	7a9b      	ldrb	r3, [r3, #10]
 8007ff6:	2208      	movs	r2, #8
 8007ff8:	4313      	orrs	r3, r2
 8007ffa:	b2da      	uxtb	r2, r3
 8007ffc:	4b28      	ldr	r3, [pc, #160]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8007ffe:	729a      	strb	r2, [r3, #10]
 8008000:	e01d      	b.n	800803e <protocol_exec_rt_system+0x29e>
          } else {
            // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
            sys.step_control = STEP_CONTROL_NORMAL_OP; // Restore step control to normal operation
 8008002:	4b27      	ldr	r3, [pc, #156]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8008004:	2200      	movs	r2, #0
 8008006:	711a      	strb	r2, [r3, #4]
            if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
 8008008:	f7fe fefc 	bl	8006e04 <plan_get_current_block>
 800800c:	1e03      	subs	r3, r0, #0
 800800e:	d010      	beq.n	8008032 <protocol_exec_rt_system+0x292>
 8008010:	4b23      	ldr	r3, [pc, #140]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8008012:	789b      	ldrb	r3, [r3, #2]
 8008014:	001a      	movs	r2, r3
 8008016:	2340      	movs	r3, #64	; 0x40
 8008018:	4013      	ands	r3, r2
 800801a:	d10a      	bne.n	8008032 <protocol_exec_rt_system+0x292>
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
 800801c:	4b20      	ldr	r3, [pc, #128]	; (80080a0 <protocol_exec_rt_system+0x300>)
 800801e:	2200      	movs	r2, #0
 8008020:	709a      	strb	r2, [r3, #2]
              sys.state = STATE_CYCLE;
 8008022:	4b1f      	ldr	r3, [pc, #124]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8008024:	2208      	movs	r2, #8
 8008026:	701a      	strb	r2, [r3, #0]
              st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
 8008028:	f002 fdcc 	bl	800abc4 <st_prep_buffer>
              st_wake_up();
 800802c:	f002 f940 	bl	800a2b0 <st_wake_up>
 8008030:	e005      	b.n	800803e <protocol_exec_rt_system+0x29e>
            } else { // Otherwise, do nothing. Set and resume IDLE state.
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
 8008032:	4b1b      	ldr	r3, [pc, #108]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8008034:	2200      	movs	r2, #0
 8008036:	709a      	strb	r2, [r3, #2]
              sys.state = STATE_IDLE;
 8008038:	4b19      	ldr	r3, [pc, #100]	; (80080a0 <protocol_exec_rt_system+0x300>)
 800803a:	2200      	movs	r2, #0
 800803c:	701a      	strb	r2, [r3, #0]
            }
          }
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_START);
 800803e:	2002      	movs	r0, #2
 8008040:	f004 f848 	bl	800c0d4 <system_clear_exec_state_flag>
    }

    if (rt_exec & EXEC_CYCLE_STOP) {
 8008044:	1cfb      	adds	r3, r7, #3
 8008046:	781b      	ldrb	r3, [r3, #0]
 8008048:	2204      	movs	r2, #4
 800804a:	4013      	ands	r3, r2
 800804c:	d05d      	beq.n	800810a <protocol_exec_rt_system+0x36a>
      // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by
      // realtime command execution in the main program, ensuring that the planner re-plans safely.
      // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
      // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.
      // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
      if ((sys.state & (STATE_HOLD|STATE_SAFETY_DOOR|STATE_SLEEP)) && !(sys.soft_limit) && !(sys.suspend & SUSPEND_JOG_CANCEL)) {
 800804e:	4b14      	ldr	r3, [pc, #80]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8008050:	781b      	ldrb	r3, [r3, #0]
 8008052:	001a      	movs	r2, r3
 8008054:	23d0      	movs	r3, #208	; 0xd0
 8008056:	4013      	ands	r3, r2
 8008058:	d026      	beq.n	80080a8 <protocol_exec_rt_system+0x308>
 800805a:	4b11      	ldr	r3, [pc, #68]	; (80080a0 <protocol_exec_rt_system+0x300>)
 800805c:	78db      	ldrb	r3, [r3, #3]
 800805e:	2b00      	cmp	r3, #0
 8008060:	d122      	bne.n	80080a8 <protocol_exec_rt_system+0x308>
 8008062:	4b0f      	ldr	r3, [pc, #60]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8008064:	789b      	ldrb	r3, [r3, #2]
 8008066:	b25b      	sxtb	r3, r3
 8008068:	2b00      	cmp	r3, #0
 800806a:	db1d      	blt.n	80080a8 <protocol_exec_rt_system+0x308>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        plan_cycle_reinitialize();
 800806c:	f7ff fb30 	bl	80076d0 <plan_cycle_reinitialize>
        if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { sys.suspend |= SUSPEND_HOLD_COMPLETE; }
 8008070:	4b0b      	ldr	r3, [pc, #44]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8008072:	791b      	ldrb	r3, [r3, #4]
 8008074:	001a      	movs	r2, r3
 8008076:	2302      	movs	r3, #2
 8008078:	4013      	ands	r3, r2
 800807a:	d006      	beq.n	800808a <protocol_exec_rt_system+0x2ea>
 800807c:	4b08      	ldr	r3, [pc, #32]	; (80080a0 <protocol_exec_rt_system+0x300>)
 800807e:	789b      	ldrb	r3, [r3, #2]
 8008080:	2201      	movs	r2, #1
 8008082:	4313      	orrs	r3, r2
 8008084:	b2da      	uxtb	r2, r3
 8008086:	4b06      	ldr	r3, [pc, #24]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8008088:	709a      	strb	r2, [r3, #2]
        bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
 800808a:	4b05      	ldr	r3, [pc, #20]	; (80080a0 <protocol_exec_rt_system+0x300>)
 800808c:	791b      	ldrb	r3, [r3, #4]
 800808e:	2206      	movs	r2, #6
 8008090:	4393      	bics	r3, r2
 8008092:	b2da      	uxtb	r2, r3
 8008094:	4b02      	ldr	r3, [pc, #8]	; (80080a0 <protocol_exec_rt_system+0x300>)
 8008096:	711a      	strb	r2, [r3, #4]
 8008098:	e034      	b.n	8008104 <protocol_exec_rt_system+0x364>
 800809a:	46c0      	nop			; (mov r8, r8)
 800809c:	20000bec 	.word	0x20000bec
 80080a0:	20000bb4 	.word	0x20000bb4
 80080a4:	20000bc9 	.word	0x20000bc9
      } else {
        // Motion complete. Includes CYCLE/JOG/HOMING states and jog cancel/motion cancel/soft limit events.
        // NOTE: Motion and jog cancel both immediately return to idle after the hold completes.
        if (sys.suspend & SUSPEND_JOG_CANCEL) {   // For jog cancel, flush buffers and sync positions.
 80080a8:	4bb8      	ldr	r3, [pc, #736]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80080aa:	789b      	ldrb	r3, [r3, #2]
 80080ac:	b25b      	sxtb	r3, r3
 80080ae:	2b00      	cmp	r3, #0
 80080b0:	da0a      	bge.n	80080c8 <protocol_exec_rt_system+0x328>
          sys.step_control = STEP_CONTROL_NORMAL_OP;
 80080b2:	4bb6      	ldr	r3, [pc, #728]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80080b4:	2200      	movs	r2, #0
 80080b6:	711a      	strb	r2, [r3, #4]
          plan_reset();
 80080b8:	f7fe fe3e 	bl	8006d38 <plan_reset>
          st_reset();
 80080bc:	f002 fc60 	bl	800a980 <st_reset>
          gc_sync_position();
 80080c0:	f7fb fcd0 	bl	8003a64 <gc_sync_position>
          plan_sync_position();
 80080c4:	f7ff faaa 	bl	800761c <plan_sync_position>
        }
        if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) { // Only occurs when safety door opens during jog.
 80080c8:	4bb0      	ldr	r3, [pc, #704]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80080ca:	789b      	ldrb	r3, [r3, #2]
 80080cc:	001a      	movs	r2, r3
 80080ce:	2320      	movs	r3, #32
 80080d0:	4013      	ands	r3, r2
 80080d2:	d011      	beq.n	80080f8 <protocol_exec_rt_system+0x358>
          sys.suspend &= ~(SUSPEND_JOG_CANCEL);
 80080d4:	4bad      	ldr	r3, [pc, #692]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80080d6:	789b      	ldrb	r3, [r3, #2]
 80080d8:	227f      	movs	r2, #127	; 0x7f
 80080da:	4013      	ands	r3, r2
 80080dc:	b2da      	uxtb	r2, r3
 80080de:	4bab      	ldr	r3, [pc, #684]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80080e0:	709a      	strb	r2, [r3, #2]
          sys.suspend |= SUSPEND_HOLD_COMPLETE;
 80080e2:	4baa      	ldr	r3, [pc, #680]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80080e4:	789b      	ldrb	r3, [r3, #2]
 80080e6:	2201      	movs	r2, #1
 80080e8:	4313      	orrs	r3, r2
 80080ea:	b2da      	uxtb	r2, r3
 80080ec:	4ba7      	ldr	r3, [pc, #668]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80080ee:	709a      	strb	r2, [r3, #2]
          sys.state = STATE_SAFETY_DOOR;
 80080f0:	4ba6      	ldr	r3, [pc, #664]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80080f2:	2240      	movs	r2, #64	; 0x40
 80080f4:	701a      	strb	r2, [r3, #0]
 80080f6:	e005      	b.n	8008104 <protocol_exec_rt_system+0x364>
        } else {
          sys.suspend = SUSPEND_DISABLE;
 80080f8:	4ba4      	ldr	r3, [pc, #656]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80080fa:	2200      	movs	r2, #0
 80080fc:	709a      	strb	r2, [r3, #2]
          sys.state = STATE_IDLE;
 80080fe:	4ba3      	ldr	r3, [pc, #652]	; (800838c <protocol_exec_rt_system+0x5ec>)
 8008100:	2200      	movs	r2, #0
 8008102:	701a      	strb	r2, [r3, #0]
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_STOP);
 8008104:	2004      	movs	r0, #4
 8008106:	f003 ffe5 	bl	800c0d4 <system_clear_exec_state_flag>
    }
  }

  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
 800810a:	1cfb      	adds	r3, r7, #3
 800810c:	4aa0      	ldr	r2, [pc, #640]	; (8008390 <protocol_exec_rt_system+0x5f0>)
 800810e:	7812      	ldrb	r2, [r2, #0]
 8008110:	701a      	strb	r2, [r3, #0]
  if (rt_exec) {
 8008112:	1cfb      	adds	r3, r7, #3
 8008114:	781b      	ldrb	r3, [r3, #0]
 8008116:	2b00      	cmp	r3, #0
 8008118:	d100      	bne.n	800811c <protocol_exec_rt_system+0x37c>
 800811a:	e07c      	b.n	8008216 <protocol_exec_rt_system+0x476>
    system_clear_exec_motion_overrides(); // Clear all motion override flags.
 800811c:	f004 f84a 	bl	800c1b4 <system_clear_exec_motion_overrides>

    uint8_t new_f_override =  sys.f_override;
 8008120:	1dfb      	adds	r3, r7, #7
 8008122:	4a9a      	ldr	r2, [pc, #616]	; (800838c <protocol_exec_rt_system+0x5ec>)
 8008124:	79d2      	ldrb	r2, [r2, #7]
 8008126:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
 8008128:	1cfb      	adds	r3, r7, #3
 800812a:	781b      	ldrb	r3, [r3, #0]
 800812c:	2201      	movs	r2, #1
 800812e:	4013      	ands	r3, r2
 8008130:	d002      	beq.n	8008138 <protocol_exec_rt_system+0x398>
 8008132:	1dfb      	adds	r3, r7, #7
 8008134:	2264      	movs	r2, #100	; 0x64
 8008136:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_FEED_OVR_COARSE_PLUS) { new_f_override += FEED_OVERRIDE_COARSE_INCREMENT; }
 8008138:	1cfb      	adds	r3, r7, #3
 800813a:	781b      	ldrb	r3, [r3, #0]
 800813c:	2202      	movs	r2, #2
 800813e:	4013      	ands	r3, r2
 8008140:	d004      	beq.n	800814c <protocol_exec_rt_system+0x3ac>
 8008142:	1dfb      	adds	r3, r7, #7
 8008144:	1dfa      	adds	r2, r7, #7
 8008146:	7812      	ldrb	r2, [r2, #0]
 8008148:	320a      	adds	r2, #10
 800814a:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_FEED_OVR_COARSE_MINUS) { new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT; }
 800814c:	1cfb      	adds	r3, r7, #3
 800814e:	781b      	ldrb	r3, [r3, #0]
 8008150:	2204      	movs	r2, #4
 8008152:	4013      	ands	r3, r2
 8008154:	d004      	beq.n	8008160 <protocol_exec_rt_system+0x3c0>
 8008156:	1dfb      	adds	r3, r7, #7
 8008158:	1dfa      	adds	r2, r7, #7
 800815a:	7812      	ldrb	r2, [r2, #0]
 800815c:	3a0a      	subs	r2, #10
 800815e:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
 8008160:	1cfb      	adds	r3, r7, #3
 8008162:	781b      	ldrb	r3, [r3, #0]
 8008164:	2208      	movs	r2, #8
 8008166:	4013      	ands	r3, r2
 8008168:	d004      	beq.n	8008174 <protocol_exec_rt_system+0x3d4>
 800816a:	1dfb      	adds	r3, r7, #7
 800816c:	1dfa      	adds	r2, r7, #7
 800816e:	7812      	ldrb	r2, [r2, #0]
 8008170:	3201      	adds	r2, #1
 8008172:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
 8008174:	1cfb      	adds	r3, r7, #3
 8008176:	781b      	ldrb	r3, [r3, #0]
 8008178:	2210      	movs	r2, #16
 800817a:	4013      	ands	r3, r2
 800817c:	d004      	beq.n	8008188 <protocol_exec_rt_system+0x3e8>
 800817e:	1dfb      	adds	r3, r7, #7
 8008180:	1dfa      	adds	r2, r7, #7
 8008182:	7812      	ldrb	r2, [r2, #0]
 8008184:	3a01      	subs	r2, #1
 8008186:	701a      	strb	r2, [r3, #0]
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
 8008188:	1dfa      	adds	r2, r7, #7
 800818a:	1dfb      	adds	r3, r7, #7
 800818c:	781b      	ldrb	r3, [r3, #0]
 800818e:	b2d9      	uxtb	r1, r3
 8008190:	29c8      	cmp	r1, #200	; 0xc8
 8008192:	d900      	bls.n	8008196 <protocol_exec_rt_system+0x3f6>
 8008194:	23c8      	movs	r3, #200	; 0xc8
 8008196:	7013      	strb	r3, [r2, #0]
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);
 8008198:	1dfa      	adds	r2, r7, #7
 800819a:	1dfb      	adds	r3, r7, #7
 800819c:	781b      	ldrb	r3, [r3, #0]
 800819e:	b2d9      	uxtb	r1, r3
 80081a0:	290a      	cmp	r1, #10
 80081a2:	d200      	bcs.n	80081a6 <protocol_exec_rt_system+0x406>
 80081a4:	230a      	movs	r3, #10
 80081a6:	7013      	strb	r3, [r2, #0]

    uint8_t new_r_override = sys.r_override;
 80081a8:	1dbb      	adds	r3, r7, #6
 80081aa:	4a78      	ldr	r2, [pc, #480]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80081ac:	7a12      	ldrb	r2, [r2, #8]
 80081ae:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
 80081b0:	1cfb      	adds	r3, r7, #3
 80081b2:	781b      	ldrb	r3, [r3, #0]
 80081b4:	2220      	movs	r2, #32
 80081b6:	4013      	ands	r3, r2
 80081b8:	d002      	beq.n	80081c0 <protocol_exec_rt_system+0x420>
 80081ba:	1dbb      	adds	r3, r7, #6
 80081bc:	2264      	movs	r2, #100	; 0x64
 80081be:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_RAPID_OVR_MEDIUM) { new_r_override = RAPID_OVERRIDE_MEDIUM; }
 80081c0:	1cfb      	adds	r3, r7, #3
 80081c2:	781b      	ldrb	r3, [r3, #0]
 80081c4:	2240      	movs	r2, #64	; 0x40
 80081c6:	4013      	ands	r3, r2
 80081c8:	d002      	beq.n	80081d0 <protocol_exec_rt_system+0x430>
 80081ca:	1dbb      	adds	r3, r7, #6
 80081cc:	2232      	movs	r2, #50	; 0x32
 80081ce:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_RAPID_OVR_LOW) { new_r_override = RAPID_OVERRIDE_LOW; }
 80081d0:	1cfb      	adds	r3, r7, #3
 80081d2:	781b      	ldrb	r3, [r3, #0]
 80081d4:	b25b      	sxtb	r3, r3
 80081d6:	2b00      	cmp	r3, #0
 80081d8:	da02      	bge.n	80081e0 <protocol_exec_rt_system+0x440>
 80081da:	1dbb      	adds	r3, r7, #6
 80081dc:	2219      	movs	r2, #25
 80081de:	701a      	strb	r2, [r3, #0]

    if ((new_f_override != sys.f_override) || (new_r_override != sys.r_override)) {
 80081e0:	4b6a      	ldr	r3, [pc, #424]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80081e2:	79db      	ldrb	r3, [r3, #7]
 80081e4:	1dfa      	adds	r2, r7, #7
 80081e6:	7812      	ldrb	r2, [r2, #0]
 80081e8:	429a      	cmp	r2, r3
 80081ea:	d105      	bne.n	80081f8 <protocol_exec_rt_system+0x458>
 80081ec:	4b67      	ldr	r3, [pc, #412]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80081ee:	7a1b      	ldrb	r3, [r3, #8]
 80081f0:	1dba      	adds	r2, r7, #6
 80081f2:	7812      	ldrb	r2, [r2, #0]
 80081f4:	429a      	cmp	r2, r3
 80081f6:	d00e      	beq.n	8008216 <protocol_exec_rt_system+0x476>
      sys.f_override = new_f_override;
 80081f8:	4b64      	ldr	r3, [pc, #400]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80081fa:	1dfa      	adds	r2, r7, #7
 80081fc:	7812      	ldrb	r2, [r2, #0]
 80081fe:	71da      	strb	r2, [r3, #7]
      sys.r_override = new_r_override;
 8008200:	4b62      	ldr	r3, [pc, #392]	; (800838c <protocol_exec_rt_system+0x5ec>)
 8008202:	1dba      	adds	r2, r7, #6
 8008204:	7812      	ldrb	r2, [r2, #0]
 8008206:	721a      	strb	r2, [r3, #8]
      sys.report_ovr_counter = 0; // Set to report change immediately
 8008208:	4b60      	ldr	r3, [pc, #384]	; (800838c <protocol_exec_rt_system+0x5ec>)
 800820a:	2200      	movs	r2, #0
 800820c:	72da      	strb	r2, [r3, #11]
      plan_update_velocity_profile_parameters();
 800820e:	f7fe fed3 	bl	8006fb8 <plan_update_velocity_profile_parameters>
      plan_cycle_reinitialize();
 8008212:	f7ff fa5d 	bl	80076d0 <plan_cycle_reinitialize>
    }
  }

  rt_exec = sys_rt_exec_accessory_override;
 8008216:	1cfb      	adds	r3, r7, #3
 8008218:	4a5e      	ldr	r2, [pc, #376]	; (8008394 <protocol_exec_rt_system+0x5f4>)
 800821a:	7812      	ldrb	r2, [r2, #0]
 800821c:	701a      	strb	r2, [r3, #0]
  if (rt_exec) {
 800821e:	1cfb      	adds	r3, r7, #3
 8008220:	781b      	ldrb	r3, [r3, #0]
 8008222:	2b00      	cmp	r3, #0
 8008224:	d100      	bne.n	8008228 <protocol_exec_rt_system+0x488>
 8008226:	e0a5      	b.n	8008374 <protocol_exec_rt_system+0x5d4>
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.
 8008228:	f003 ffd0 	bl	800c1cc <system_clear_exec_accessory_overrides>

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
 800822c:	1d7b      	adds	r3, r7, #5
 800822e:	4a57      	ldr	r2, [pc, #348]	; (800838c <protocol_exec_rt_system+0x5ec>)
 8008230:	7a52      	ldrb	r2, [r2, #9]
 8008232:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
 8008234:	1cfb      	adds	r3, r7, #3
 8008236:	781b      	ldrb	r3, [r3, #0]
 8008238:	2201      	movs	r2, #1
 800823a:	4013      	ands	r3, r2
 800823c:	d002      	beq.n	8008244 <protocol_exec_rt_system+0x4a4>
 800823e:	1d7b      	adds	r3, r7, #5
 8008240:	2264      	movs	r2, #100	; 0x64
 8008242:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_PLUS) { last_s_override += SPINDLE_OVERRIDE_COARSE_INCREMENT; }
 8008244:	1cfb      	adds	r3, r7, #3
 8008246:	781b      	ldrb	r3, [r3, #0]
 8008248:	2202      	movs	r2, #2
 800824a:	4013      	ands	r3, r2
 800824c:	d004      	beq.n	8008258 <protocol_exec_rt_system+0x4b8>
 800824e:	1d7b      	adds	r3, r7, #5
 8008250:	1d7a      	adds	r2, r7, #5
 8008252:	7812      	ldrb	r2, [r2, #0]
 8008254:	320a      	adds	r2, #10
 8008256:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_COARSE_INCREMENT; }
 8008258:	1cfb      	adds	r3, r7, #3
 800825a:	781b      	ldrb	r3, [r3, #0]
 800825c:	2204      	movs	r2, #4
 800825e:	4013      	ands	r3, r2
 8008260:	d004      	beq.n	800826c <protocol_exec_rt_system+0x4cc>
 8008262:	1d7b      	adds	r3, r7, #5
 8008264:	1d7a      	adds	r2, r7, #5
 8008266:	7812      	ldrb	r2, [r2, #0]
 8008268:	3a0a      	subs	r2, #10
 800826a:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_PLUS) { last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT; }
 800826c:	1cfb      	adds	r3, r7, #3
 800826e:	781b      	ldrb	r3, [r3, #0]
 8008270:	2208      	movs	r2, #8
 8008272:	4013      	ands	r3, r2
 8008274:	d004      	beq.n	8008280 <protocol_exec_rt_system+0x4e0>
 8008276:	1d7b      	adds	r3, r7, #5
 8008278:	1d7a      	adds	r2, r7, #5
 800827a:	7812      	ldrb	r2, [r2, #0]
 800827c:	3201      	adds	r2, #1
 800827e:	701a      	strb	r2, [r3, #0]
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT; }
 8008280:	1cfb      	adds	r3, r7, #3
 8008282:	781b      	ldrb	r3, [r3, #0]
 8008284:	2210      	movs	r2, #16
 8008286:	4013      	ands	r3, r2
 8008288:	d004      	beq.n	8008294 <protocol_exec_rt_system+0x4f4>
 800828a:	1d7b      	adds	r3, r7, #5
 800828c:	1d7a      	adds	r2, r7, #5
 800828e:	7812      	ldrb	r2, [r2, #0]
 8008290:	3a01      	subs	r2, #1
 8008292:	701a      	strb	r2, [r3, #0]
    last_s_override = min(last_s_override,MAX_SPINDLE_SPEED_OVERRIDE);
 8008294:	1d7a      	adds	r2, r7, #5
 8008296:	1d7b      	adds	r3, r7, #5
 8008298:	781b      	ldrb	r3, [r3, #0]
 800829a:	b2d9      	uxtb	r1, r3
 800829c:	29c8      	cmp	r1, #200	; 0xc8
 800829e:	d900      	bls.n	80082a2 <protocol_exec_rt_system+0x502>
 80082a0:	23c8      	movs	r3, #200	; 0xc8
 80082a2:	7013      	strb	r3, [r2, #0]
    last_s_override = max(last_s_override,MIN_SPINDLE_SPEED_OVERRIDE);
 80082a4:	1d7a      	adds	r2, r7, #5
 80082a6:	1d7b      	adds	r3, r7, #5
 80082a8:	781b      	ldrb	r3, [r3, #0]
 80082aa:	b2d9      	uxtb	r1, r3
 80082ac:	290a      	cmp	r1, #10
 80082ae:	d200      	bcs.n	80082b2 <protocol_exec_rt_system+0x512>
 80082b0:	230a      	movs	r3, #10
 80082b2:	7013      	strb	r3, [r2, #0]

    if (last_s_override != sys.spindle_speed_ovr) {
 80082b4:	4b35      	ldr	r3, [pc, #212]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80082b6:	7a5b      	ldrb	r3, [r3, #9]
 80082b8:	1d7a      	adds	r2, r7, #5
 80082ba:	7812      	ldrb	r2, [r2, #0]
 80082bc:	429a      	cmp	r2, r3
 80082be:	d00d      	beq.n	80082dc <protocol_exec_rt_system+0x53c>
      bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 80082c0:	4b32      	ldr	r3, [pc, #200]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80082c2:	791b      	ldrb	r3, [r3, #4]
 80082c4:	2208      	movs	r2, #8
 80082c6:	4313      	orrs	r3, r2
 80082c8:	b2da      	uxtb	r2, r3
 80082ca:	4b30      	ldr	r3, [pc, #192]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80082cc:	711a      	strb	r2, [r3, #4]
      sys.spindle_speed_ovr = last_s_override;
 80082ce:	4b2f      	ldr	r3, [pc, #188]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80082d0:	1d7a      	adds	r2, r7, #5
 80082d2:	7812      	ldrb	r2, [r2, #0]
 80082d4:	725a      	strb	r2, [r3, #9]
      sys.report_ovr_counter = 0; // Set to report change immediately
 80082d6:	4b2d      	ldr	r3, [pc, #180]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80082d8:	2200      	movs	r2, #0
 80082da:	72da      	strb	r2, [r3, #11]
    }

    if (rt_exec & EXEC_SPINDLE_OVR_STOP) {
 80082dc:	1cfb      	adds	r3, r7, #3
 80082de:	781b      	ldrb	r3, [r3, #0]
 80082e0:	2220      	movs	r2, #32
 80082e2:	4013      	ands	r3, r2
 80082e4:	d018      	beq.n	8008318 <protocol_exec_rt_system+0x578>
      // Spindle stop override allowed only while in HOLD state.
      // NOTE: Report counters are set in spindle_set_state() when spindle stop is executed.
      if (sys.state == STATE_HOLD) {
 80082e6:	4b29      	ldr	r3, [pc, #164]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80082e8:	781b      	ldrb	r3, [r3, #0]
 80082ea:	2b10      	cmp	r3, #16
 80082ec:	d114      	bne.n	8008318 <protocol_exec_rt_system+0x578>
        if (!(sys.spindle_stop_ovr)) { sys.spindle_stop_ovr = SPINDLE_STOP_OVR_INITIATE; }
 80082ee:	4b27      	ldr	r3, [pc, #156]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80082f0:	7a9b      	ldrb	r3, [r3, #10]
 80082f2:	2b00      	cmp	r3, #0
 80082f4:	d103      	bne.n	80082fe <protocol_exec_rt_system+0x55e>
 80082f6:	4b25      	ldr	r3, [pc, #148]	; (800838c <protocol_exec_rt_system+0x5ec>)
 80082f8:	2202      	movs	r2, #2
 80082fa:	729a      	strb	r2, [r3, #10]
 80082fc:	e00c      	b.n	8008318 <protocol_exec_rt_system+0x578>
        else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE; }
 80082fe:	4b23      	ldr	r3, [pc, #140]	; (800838c <protocol_exec_rt_system+0x5ec>)
 8008300:	7a9b      	ldrb	r3, [r3, #10]
 8008302:	001a      	movs	r2, r3
 8008304:	2301      	movs	r3, #1
 8008306:	4013      	ands	r3, r2
 8008308:	d006      	beq.n	8008318 <protocol_exec_rt_system+0x578>
 800830a:	4b20      	ldr	r3, [pc, #128]	; (800838c <protocol_exec_rt_system+0x5ec>)
 800830c:	7a9b      	ldrb	r3, [r3, #10]
 800830e:	2204      	movs	r2, #4
 8008310:	4313      	orrs	r3, r2
 8008312:	b2da      	uxtb	r2, r3
 8008314:	4b1d      	ldr	r3, [pc, #116]	; (800838c <protocol_exec_rt_system+0x5ec>)
 8008316:	729a      	strb	r2, [r3, #10]
      }
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
 8008318:	1cfb      	adds	r3, r7, #3
 800831a:	781b      	ldrb	r3, [r3, #0]
 800831c:	22c0      	movs	r2, #192	; 0xc0
 800831e:	4013      	ands	r3, r2
 8008320:	d028      	beq.n	8008374 <protocol_exec_rt_system+0x5d4>
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 8008322:	4b1a      	ldr	r3, [pc, #104]	; (800838c <protocol_exec_rt_system+0x5ec>)
 8008324:	781b      	ldrb	r3, [r3, #0]
 8008326:	2b00      	cmp	r3, #0
 8008328:	d005      	beq.n	8008336 <protocol_exec_rt_system+0x596>
 800832a:	4b18      	ldr	r3, [pc, #96]	; (800838c <protocol_exec_rt_system+0x5ec>)
 800832c:	781b      	ldrb	r3, [r3, #0]
 800832e:	001a      	movs	r2, r3
 8008330:	2318      	movs	r3, #24
 8008332:	4013      	ands	r3, r2
 8008334:	d01e      	beq.n	8008374 <protocol_exec_rt_system+0x5d4>
        uint8_t coolant_state = gc_state.modal.coolant;
 8008336:	1d3b      	adds	r3, r7, #4
 8008338:	4a17      	ldr	r2, [pc, #92]	; (8008398 <protocol_exec_rt_system+0x5f8>)
 800833a:	7a12      	ldrb	r2, [r2, #8]
 800833c:	701a      	strb	r2, [r3, #0]
          if (rt_exec & EXEC_COOLANT_FLOOD_OVR_TOGGLE) {
            if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABLE); }
            else { coolant_state |= COOLANT_FLOOD_ENABLE; }
          }
        #else
          if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABLE); }
 800833e:	1d3b      	adds	r3, r7, #4
 8008340:	781b      	ldrb	r3, [r3, #0]
 8008342:	2240      	movs	r2, #64	; 0x40
 8008344:	4013      	ands	r3, r2
 8008346:	d006      	beq.n	8008356 <protocol_exec_rt_system+0x5b6>
 8008348:	1d3b      	adds	r3, r7, #4
 800834a:	1d3a      	adds	r2, r7, #4
 800834c:	7812      	ldrb	r2, [r2, #0]
 800834e:	2140      	movs	r1, #64	; 0x40
 8008350:	438a      	bics	r2, r1
 8008352:	701a      	strb	r2, [r3, #0]
 8008354:	e005      	b.n	8008362 <protocol_exec_rt_system+0x5c2>
          else { coolant_state |= COOLANT_FLOOD_ENABLE; }
 8008356:	1d3b      	adds	r3, r7, #4
 8008358:	1d3a      	adds	r2, r7, #4
 800835a:	7812      	ldrb	r2, [r2, #0]
 800835c:	2140      	movs	r1, #64	; 0x40
 800835e:	430a      	orrs	r2, r1
 8008360:	701a      	strb	r2, [r3, #0]
        #endif
        coolant_set_state(coolant_state); // Report counter set in coolant_set_state().
 8008362:	1d3b      	adds	r3, r7, #4
 8008364:	781b      	ldrb	r3, [r3, #0]
 8008366:	0018      	movs	r0, r3
 8008368:	f7fb fa7c 	bl	8003864 <coolant_set_state>
        gc_state.modal.coolant = coolant_state;
 800836c:	4b0a      	ldr	r3, [pc, #40]	; (8008398 <protocol_exec_rt_system+0x5f8>)
 800836e:	1d3a      	adds	r2, r7, #4
 8008370:	7812      	ldrb	r2, [r2, #0]
 8008372:	721a      	strb	r2, [r3, #8]
      sys_rt_exec_debug = 0;
    }
  #endif

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
 8008374:	4b05      	ldr	r3, [pc, #20]	; (800838c <protocol_exec_rt_system+0x5ec>)
 8008376:	781b      	ldrb	r3, [r3, #0]
 8008378:	001a      	movs	r2, r3
 800837a:	23fc      	movs	r3, #252	; 0xfc
 800837c:	4013      	ands	r3, r2
 800837e:	d001      	beq.n	8008384 <protocol_exec_rt_system+0x5e4>
    st_prep_buffer();
 8008380:	f002 fc20 	bl	800abc4 <st_prep_buffer>
  }

}
 8008384:	46bd      	mov	sp, r7
 8008386:	b002      	add	sp, #8
 8008388:	bd80      	pop	{r7, pc}
 800838a:	46c0      	nop			; (mov r8, r8)
 800838c:	20000bb4 	.word	0x20000bb4
 8008390:	20000bb0 	.word	0x20000bb0
 8008394:	20000bc8 	.word	0x20000bc8
 8008398:	200009c4 	.word	0x200009c4

0800839c <protocol_exec_rt_suspend>:
// The system will enter this loop, create local variables for suspend tasks, and return to
// whatever function that invoked the suspend, such that Grbl resumes normal operation.
// This function is written in a way to promote custom parking motions. Simply use this as a
// template
static void protocol_exec_rt_suspend()
{
 800839c:	b580      	push	{r7, lr}
 800839e:	b084      	sub	sp, #16
 80083a0:	af00      	add	r7, sp, #0
    #ifdef USE_LINE_NUMBERS
      pl_data->line_number = PARKING_MOTION_LINE_NUMBER;
    #endif
  #endif

  plan_block_t *block = plan_get_current_block();
 80083a2:	f7fe fd2f 	bl	8006e04 <plan_get_current_block>
 80083a6:	0003      	movs	r3, r0
 80083a8:	607b      	str	r3, [r7, #4]
  uint8_t restore_condition;
  #ifdef VARIABLE_SPINDLE
    float restore_spindle_speed;
    if (block == NULL) {
 80083aa:	687b      	ldr	r3, [r7, #4]
 80083ac:	2b00      	cmp	r3, #0
 80083ae:	d10b      	bne.n	80083c8 <protocol_exec_rt_suspend+0x2c>
      restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant);
 80083b0:	4ba4      	ldr	r3, [pc, #656]	; (8008644 <protocol_exec_rt_suspend+0x2a8>)
 80083b2:	7a59      	ldrb	r1, [r3, #9]
 80083b4:	4ba3      	ldr	r3, [pc, #652]	; (8008644 <protocol_exec_rt_suspend+0x2a8>)
 80083b6:	7a1a      	ldrb	r2, [r3, #8]
 80083b8:	230f      	movs	r3, #15
 80083ba:	18fb      	adds	r3, r7, r3
 80083bc:	430a      	orrs	r2, r1
 80083be:	701a      	strb	r2, [r3, #0]
      restore_spindle_speed = gc_state.spindle_speed;
 80083c0:	4ba0      	ldr	r3, [pc, #640]	; (8008644 <protocol_exec_rt_suspend+0x2a8>)
 80083c2:	68db      	ldr	r3, [r3, #12]
 80083c4:	60bb      	str	r3, [r7, #8]
 80083c6:	e007      	b.n	80083d8 <protocol_exec_rt_suspend+0x3c>
    } else {
      restore_condition = block->condition;
 80083c8:	230f      	movs	r3, #15
 80083ca:	18fb      	adds	r3, r7, r3
 80083cc:	687a      	ldr	r2, [r7, #4]
 80083ce:	7d52      	ldrb	r2, [r2, #21]
 80083d0:	701a      	strb	r2, [r3, #0]
      restore_spindle_speed = block->spindle_speed;
 80083d2:	687b      	ldr	r3, [r7, #4]
 80083d4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80083d6:	60bb      	str	r3, [r7, #8]
    }
    #ifdef DISABLE_LASER_DURING_HOLD
      if (bit_istrue(settings.flags, BITFLAG_LASER_MODE)) {
 80083d8:	4b9b      	ldr	r3, [pc, #620]	; (8008648 <protocol_exec_rt_suspend+0x2ac>)
 80083da:	2258      	movs	r2, #88	; 0x58
 80083dc:	5c9b      	ldrb	r3, [r3, r2]
 80083de:	001a      	movs	r2, r3
 80083e0:	2302      	movs	r3, #2
 80083e2:	4013      	ands	r3, r2
 80083e4:	d100      	bne.n	80083e8 <protocol_exec_rt_suspend+0x4c>
 80083e6:	e123      	b.n	8008630 <protocol_exec_rt_suspend+0x294>
        system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
 80083e8:	2020      	movs	r0, #32
 80083ea:	f003 fecb 	bl	800c184 <system_set_exec_accessory_override_flag>
  #else
    if (block == NULL) { restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant); }
    else { restore_condition = block->condition; }
  #endif

  while (sys.suspend) {
 80083ee:	e11f      	b.n	8008630 <protocol_exec_rt_suspend+0x294>

    if (sys.abort) { return; }
 80083f0:	4b96      	ldr	r3, [pc, #600]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 80083f2:	785b      	ldrb	r3, [r3, #1]
 80083f4:	2b00      	cmp	r3, #0
 80083f6:	d000      	beq.n	80083fa <protocol_exec_rt_suspend+0x5e>
 80083f8:	e120      	b.n	800863c <protocol_exec_rt_suspend+0x2a0>

    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {
 80083fa:	4b94      	ldr	r3, [pc, #592]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 80083fc:	789b      	ldrb	r3, [r3, #2]
 80083fe:	001a      	movs	r2, r3
 8008400:	2301      	movs	r3, #1
 8008402:	4013      	ands	r3, r2
 8008404:	d100      	bne.n	8008408 <protocol_exec_rt_suspend+0x6c>
 8008406:	e111      	b.n	800862c <protocol_exec_rt_suspend+0x290>

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
 8008408:	4b90      	ldr	r3, [pc, #576]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 800840a:	781b      	ldrb	r3, [r3, #0]
 800840c:	001a      	movs	r2, r3
 800840e:	23c0      	movs	r3, #192	; 0xc0
 8008410:	4013      	ands	r3, r2
 8008412:	d100      	bne.n	8008416 <protocol_exec_rt_suspend+0x7a>
 8008414:	e0a3      	b.n	800855e <protocol_exec_rt_suspend+0x1c2>
      
        // Handles retraction motions and de-energizing.
        if (bit_isfalse(sys.suspend,SUSPEND_RETRACT_COMPLETE)) {
 8008416:	4b8d      	ldr	r3, [pc, #564]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008418:	789b      	ldrb	r3, [r3, #2]
 800841a:	001a      	movs	r2, r3
 800841c:	2304      	movs	r3, #4
 800841e:	4013      	ands	r3, r2
 8008420:	d119      	bne.n	8008456 <protocol_exec_rt_suspend+0xba>

          // Ensure any prior spindle stop override is disabled at start of safety door routine.
          sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED;
 8008422:	4b8a      	ldr	r3, [pc, #552]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008424:	2200      	movs	r2, #0
 8008426:	729a      	strb	r2, [r3, #10]

          #ifndef PARKING_ENABLE

            spindle_set_state(SPINDLE_DISABLE,0.0f); // De-energize
 8008428:	2300      	movs	r3, #0
 800842a:	1c19      	adds	r1, r3, #0
 800842c:	2000      	movs	r0, #0
 800842e:	f001 feab 	bl	800a188 <spindle_set_state>
            coolant_set_state(COOLANT_DISABLE);     // De-energize
 8008432:	2000      	movs	r0, #0
 8008434:	f7fb fa16 	bl	8003864 <coolant_set_state>

            }

          #endif

          sys.suspend &= ~(SUSPEND_RESTART_RETRACT);
 8008438:	4b84      	ldr	r3, [pc, #528]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 800843a:	789b      	ldrb	r3, [r3, #2]
 800843c:	2202      	movs	r2, #2
 800843e:	4393      	bics	r3, r2
 8008440:	b2da      	uxtb	r2, r3
 8008442:	4b82      	ldr	r3, [pc, #520]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008444:	709a      	strb	r2, [r3, #2]
          sys.suspend |= SUSPEND_RETRACT_COMPLETE;
 8008446:	4b81      	ldr	r3, [pc, #516]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008448:	789b      	ldrb	r3, [r3, #2]
 800844a:	2204      	movs	r2, #4
 800844c:	4313      	orrs	r3, r2
 800844e:	b2da      	uxtb	r2, r3
 8008450:	4b7e      	ldr	r3, [pc, #504]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008452:	709a      	strb	r2, [r3, #2]
 8008454:	e0ea      	b.n	800862c <protocol_exec_rt_suspend+0x290>

        } else {

          
          if (sys.state == STATE_SLEEP) {
 8008456:	4b7d      	ldr	r3, [pc, #500]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008458:	781b      	ldrb	r3, [r3, #0]
 800845a:	2b80      	cmp	r3, #128	; 0x80
 800845c:	d114      	bne.n	8008488 <protocol_exec_rt_suspend+0xec>
            report_feedback_message(MESSAGE_SLEEP_MODE);
 800845e:	200b      	movs	r0, #11
 8008460:	f000 f9d8 	bl	8008814 <report_feedback_message>
            // Spindle and coolant should already be stopped, but do it again just to be sure.
            spindle_set_state(SPINDLE_DISABLE,0.0f); // De-energize
 8008464:	2300      	movs	r3, #0
 8008466:	1c19      	adds	r1, r3, #0
 8008468:	2000      	movs	r0, #0
 800846a:	f001 fe8d 	bl	800a188 <spindle_set_state>
            coolant_set_state(COOLANT_DISABLE); // De-energize
 800846e:	2000      	movs	r0, #0
 8008470:	f7fb f9f8 	bl	8003864 <coolant_set_state>
            st_go_idle(); // Disable steppers
 8008474:	f001 ff70 	bl	800a358 <st_go_idle>
            while (!(sys.abort)) { protocol_exec_rt_system(); } // Do nothing until reset.
 8008478:	e001      	b.n	800847e <protocol_exec_rt_suspend+0xe2>
 800847a:	f7ff fc91 	bl	8007da0 <protocol_exec_rt_system>
 800847e:	4b73      	ldr	r3, [pc, #460]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008480:	785b      	ldrb	r3, [r3, #1]
 8008482:	2b00      	cmp	r3, #0
 8008484:	d0f9      	beq.n	800847a <protocol_exec_rt_suspend+0xde>
            return; // Abort received. Return to re-initialize.
 8008486:	e0da      	b.n	800863e <protocol_exec_rt_suspend+0x2a2>
          }    
          
          // Allows resuming from parking/safety door. Actively checks if safety door is closed and ready to resume.
          if (sys.state == STATE_SAFETY_DOOR) {
 8008488:	4b70      	ldr	r3, [pc, #448]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 800848a:	781b      	ldrb	r3, [r3, #0]
 800848c:	2b40      	cmp	r3, #64	; 0x40
 800848e:	d10a      	bne.n	80084a6 <protocol_exec_rt_suspend+0x10a>
            if (!(system_check_safety_door_ajar())) {
 8008490:	f003 fa6c 	bl	800b96c <system_check_safety_door_ajar>
 8008494:	1e03      	subs	r3, r0, #0
 8008496:	d106      	bne.n	80084a6 <protocol_exec_rt_suspend+0x10a>
              sys.suspend &= ~(SUSPEND_SAFETY_DOOR_AJAR); // Reset door ajar flag to denote ready to resume.
 8008498:	4b6c      	ldr	r3, [pc, #432]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 800849a:	789b      	ldrb	r3, [r3, #2]
 800849c:	2220      	movs	r2, #32
 800849e:	4393      	bics	r3, r2
 80084a0:	b2da      	uxtb	r2, r3
 80084a2:	4b6a      	ldr	r3, [pc, #424]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 80084a4:	709a      	strb	r2, [r3, #2]
            }
          }

          // Handles parking restore and safety door resume.
          if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
 80084a6:	4b69      	ldr	r3, [pc, #420]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 80084a8:	789b      	ldrb	r3, [r3, #2]
 80084aa:	001a      	movs	r2, r3
 80084ac:	2308      	movs	r3, #8
 80084ae:	4013      	ands	r3, r2
 80084b0:	d100      	bne.n	80084b4 <protocol_exec_rt_suspend+0x118>
 80084b2:	e0bb      	b.n	800862c <protocol_exec_rt_suspend+0x290>
                }
              }
            #endif

            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
 80084b4:	4b63      	ldr	r3, [pc, #396]	; (8008644 <protocol_exec_rt_suspend+0x2a8>)
 80084b6:	7a5b      	ldrb	r3, [r3, #9]
 80084b8:	2b00      	cmp	r3, #0
 80084ba:	d025      	beq.n	8008508 <protocol_exec_rt_suspend+0x16c>
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
 80084bc:	4b63      	ldr	r3, [pc, #396]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 80084be:	789b      	ldrb	r3, [r3, #2]
 80084c0:	001a      	movs	r2, r3
 80084c2:	2302      	movs	r3, #2
 80084c4:	4013      	ands	r3, r2
 80084c6:	d11f      	bne.n	8008508 <protocol_exec_rt_suspend+0x16c>
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
 80084c8:	4b5f      	ldr	r3, [pc, #380]	; (8008648 <protocol_exec_rt_suspend+0x2ac>)
 80084ca:	2258      	movs	r2, #88	; 0x58
 80084cc:	5c9b      	ldrb	r3, [r3, r2]
 80084ce:	001a      	movs	r2, r3
 80084d0:	2302      	movs	r3, #2
 80084d2:	4013      	ands	r3, r2
 80084d4:	d007      	beq.n	80084e6 <protocol_exec_rt_suspend+0x14a>
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 80084d6:	4b5d      	ldr	r3, [pc, #372]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 80084d8:	791b      	ldrb	r3, [r3, #4]
 80084da:	2208      	movs	r2, #8
 80084dc:	4313      	orrs	r3, r2
 80084de:	b2da      	uxtb	r2, r3
 80084e0:	4b5a      	ldr	r3, [pc, #360]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 80084e2:	711a      	strb	r2, [r3, #4]
 80084e4:	e010      	b.n	8008508 <protocol_exec_rt_suspend+0x16c>
                } else {
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
 80084e6:	230f      	movs	r3, #15
 80084e8:	18fb      	adds	r3, r7, r3
 80084ea:	781b      	ldrb	r3, [r3, #0]
 80084ec:	2230      	movs	r2, #48	; 0x30
 80084ee:	4013      	ands	r3, r2
 80084f0:	b2db      	uxtb	r3, r3
 80084f2:	68ba      	ldr	r2, [r7, #8]
 80084f4:	1c11      	adds	r1, r2, #0
 80084f6:	0018      	movs	r0, r3
 80084f8:	f001 fe46 	bl	800a188 <spindle_set_state>
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
 80084fc:	2381      	movs	r3, #129	; 0x81
 80084fe:	05db      	lsls	r3, r3, #23
 8008500:	2101      	movs	r1, #1
 8008502:	1c18      	adds	r0, r3, #0
 8008504:	f7fe f968 	bl	80067d8 <delay_sec>
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
 8008508:	4b4e      	ldr	r3, [pc, #312]	; (8008644 <protocol_exec_rt_suspend+0x2a8>)
 800850a:	7a1b      	ldrb	r3, [r3, #8]
 800850c:	2b00      	cmp	r3, #0
 800850e:	d014      	beq.n	800853a <protocol_exec_rt_suspend+0x19e>
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
 8008510:	4b4e      	ldr	r3, [pc, #312]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008512:	789b      	ldrb	r3, [r3, #2]
 8008514:	001a      	movs	r2, r3
 8008516:	2302      	movs	r3, #2
 8008518:	4013      	ands	r3, r2
 800851a:	d10e      	bne.n	800853a <protocol_exec_rt_suspend+0x19e>
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_FLOOD)));
 800851c:	230f      	movs	r3, #15
 800851e:	18fb      	adds	r3, r7, r3
 8008520:	781b      	ldrb	r3, [r3, #0]
 8008522:	2240      	movs	r2, #64	; 0x40
 8008524:	4013      	ands	r3, r2
 8008526:	b2db      	uxtb	r3, r3
 8008528:	0018      	movs	r0, r3
 800852a:	f7fb f99b 	bl	8003864 <coolant_set_state>
                delay_sec(SAFETY_DOOR_COOLANT_DELAY, DELAY_MODE_SYS_SUSPEND);
 800852e:	23fe      	movs	r3, #254	; 0xfe
 8008530:	059b      	lsls	r3, r3, #22
 8008532:	2101      	movs	r1, #1
 8008534:	1c18      	adds	r0, r3, #0
 8008536:	f7fe f94f 	bl	80067d8 <delay_sec>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
 800853a:	4b44      	ldr	r3, [pc, #272]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 800853c:	789b      	ldrb	r3, [r3, #2]
 800853e:	001a      	movs	r2, r3
 8008540:	2302      	movs	r3, #2
 8008542:	4013      	ands	r3, r2
 8008544:	d000      	beq.n	8008548 <protocol_exec_rt_suspend+0x1ac>
 8008546:	e071      	b.n	800862c <protocol_exec_rt_suspend+0x290>
              sys.suspend |= SUSPEND_RESTORE_COMPLETE;
 8008548:	4b40      	ldr	r3, [pc, #256]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 800854a:	789b      	ldrb	r3, [r3, #2]
 800854c:	2210      	movs	r2, #16
 800854e:	4313      	orrs	r3, r2
 8008550:	b2da      	uxtb	r2, r3
 8008552:	4b3e      	ldr	r3, [pc, #248]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008554:	709a      	strb	r2, [r3, #2]
              system_set_exec_state_flag(EXEC_CYCLE_START); // Set to resume program.
 8008556:	2002      	movs	r0, #2
 8008558:	f003 fda4 	bl	800c0a4 <system_set_exec_state_flag>
 800855c:	e066      	b.n	800862c <protocol_exec_rt_suspend+0x290>

      } else {

        // Feed hold manager. Controls spindle stop override states.
        // NOTE: Hold ensured as completed by condition check at the beginning of suspend routine.
        if (sys.spindle_stop_ovr) {
 800855e:	4b3b      	ldr	r3, [pc, #236]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008560:	7a9b      	ldrb	r3, [r3, #10]
 8008562:	2b00      	cmp	r3, #0
 8008564:	d04a      	beq.n	80085fc <protocol_exec_rt_suspend+0x260>
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
 8008566:	4b39      	ldr	r3, [pc, #228]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008568:	7a9b      	ldrb	r3, [r3, #10]
 800856a:	001a      	movs	r2, r3
 800856c:	2302      	movs	r3, #2
 800856e:	4013      	ands	r3, r2
 8008570:	d010      	beq.n	8008594 <protocol_exec_rt_suspend+0x1f8>
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
 8008572:	4b34      	ldr	r3, [pc, #208]	; (8008644 <protocol_exec_rt_suspend+0x2a8>)
 8008574:	7a5b      	ldrb	r3, [r3, #9]
 8008576:	2b00      	cmp	r3, #0
 8008578:	d008      	beq.n	800858c <protocol_exec_rt_suspend+0x1f0>
              spindle_set_state(SPINDLE_DISABLE,0.0f); // De-energize
 800857a:	2300      	movs	r3, #0
 800857c:	1c19      	adds	r1, r3, #0
 800857e:	2000      	movs	r0, #0
 8008580:	f001 fe02 	bl	800a188 <spindle_set_state>
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
 8008584:	4b31      	ldr	r3, [pc, #196]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008586:	2201      	movs	r2, #1
 8008588:	729a      	strb	r2, [r3, #10]
 800858a:	e04f      	b.n	800862c <protocol_exec_rt_suspend+0x290>
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
 800858c:	4b2f      	ldr	r3, [pc, #188]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 800858e:	2200      	movs	r2, #0
 8008590:	729a      	strb	r2, [r3, #10]
 8008592:	e04b      	b.n	800862c <protocol_exec_rt_suspend+0x290>
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
 8008594:	4b2d      	ldr	r3, [pc, #180]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008596:	7a9b      	ldrb	r3, [r3, #10]
 8008598:	001a      	movs	r2, r3
 800859a:	230c      	movs	r3, #12
 800859c:	4013      	ands	r3, r2
 800859e:	d045      	beq.n	800862c <protocol_exec_rt_suspend+0x290>
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
 80085a0:	4b28      	ldr	r3, [pc, #160]	; (8008644 <protocol_exec_rt_suspend+0x2a8>)
 80085a2:	7a5b      	ldrb	r3, [r3, #9]
 80085a4:	2b00      	cmp	r3, #0
 80085a6:	d01c      	beq.n	80085e2 <protocol_exec_rt_suspend+0x246>
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
 80085a8:	200a      	movs	r0, #10
 80085aa:	f000 f933 	bl	8008814 <report_feedback_message>
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
 80085ae:	4b26      	ldr	r3, [pc, #152]	; (8008648 <protocol_exec_rt_suspend+0x2ac>)
 80085b0:	2258      	movs	r2, #88	; 0x58
 80085b2:	5c9b      	ldrb	r3, [r3, r2]
 80085b4:	001a      	movs	r2, r3
 80085b6:	2302      	movs	r3, #2
 80085b8:	4013      	ands	r3, r2
 80085ba:	d007      	beq.n	80085cc <protocol_exec_rt_suspend+0x230>
                // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 80085bc:	4b23      	ldr	r3, [pc, #140]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 80085be:	791b      	ldrb	r3, [r3, #4]
 80085c0:	2208      	movs	r2, #8
 80085c2:	4313      	orrs	r3, r2
 80085c4:	b2da      	uxtb	r2, r3
 80085c6:	4b21      	ldr	r3, [pc, #132]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 80085c8:	711a      	strb	r2, [r3, #4]
 80085ca:	e00a      	b.n	80085e2 <protocol_exec_rt_suspend+0x246>
              } else {
                spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
 80085cc:	230f      	movs	r3, #15
 80085ce:	18fb      	adds	r3, r7, r3
 80085d0:	781b      	ldrb	r3, [r3, #0]
 80085d2:	2230      	movs	r2, #48	; 0x30
 80085d4:	4013      	ands	r3, r2
 80085d6:	b2db      	uxtb	r3, r3
 80085d8:	68ba      	ldr	r2, [r7, #8]
 80085da:	1c11      	adds	r1, r2, #0
 80085dc:	0018      	movs	r0, r3
 80085de:	f001 fdd3 	bl	800a188 <spindle_set_state>
              }
            }
            if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_RESTORE_CYCLE) {
 80085e2:	4b1a      	ldr	r3, [pc, #104]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 80085e4:	7a9b      	ldrb	r3, [r3, #10]
 80085e6:	001a      	movs	r2, r3
 80085e8:	2308      	movs	r3, #8
 80085ea:	4013      	ands	r3, r2
 80085ec:	d002      	beq.n	80085f4 <protocol_exec_rt_suspend+0x258>
              system_set_exec_state_flag(EXEC_CYCLE_START);  // Set to resume program.
 80085ee:	2002      	movs	r0, #2
 80085f0:	f003 fd58 	bl	800c0a4 <system_set_exec_state_flag>
            }
            sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
 80085f4:	4b15      	ldr	r3, [pc, #84]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 80085f6:	2200      	movs	r2, #0
 80085f8:	729a      	strb	r2, [r3, #10]
 80085fa:	e017      	b.n	800862c <protocol_exec_rt_suspend+0x290>
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
 80085fc:	4b13      	ldr	r3, [pc, #76]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 80085fe:	791b      	ldrb	r3, [r3, #4]
 8008600:	001a      	movs	r2, r3
 8008602:	2308      	movs	r3, #8
 8008604:	4013      	ands	r3, r2
 8008606:	d011      	beq.n	800862c <protocol_exec_rt_suspend+0x290>
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
 8008608:	230f      	movs	r3, #15
 800860a:	18fb      	adds	r3, r7, r3
 800860c:	781b      	ldrb	r3, [r3, #0]
 800860e:	2230      	movs	r2, #48	; 0x30
 8008610:	4013      	ands	r3, r2
 8008612:	b2db      	uxtb	r3, r3
 8008614:	68ba      	ldr	r2, [r7, #8]
 8008616:	1c11      	adds	r1, r2, #0
 8008618:	0018      	movs	r0, r3
 800861a:	f001 fdb5 	bl	800a188 <spindle_set_state>
            bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 800861e:	4b0b      	ldr	r3, [pc, #44]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008620:	791b      	ldrb	r3, [r3, #4]
 8008622:	2208      	movs	r2, #8
 8008624:	4393      	bics	r3, r2
 8008626:	b2da      	uxtb	r2, r3
 8008628:	4b08      	ldr	r3, [pc, #32]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 800862a:	711a      	strb	r2, [r3, #4]
        }

      }
    }

    protocol_exec_rt_system();
 800862c:	f7ff fbb8 	bl	8007da0 <protocol_exec_rt_system>
  while (sys.suspend) {
 8008630:	4b06      	ldr	r3, [pc, #24]	; (800864c <protocol_exec_rt_suspend+0x2b0>)
 8008632:	789b      	ldrb	r3, [r3, #2]
 8008634:	2b00      	cmp	r3, #0
 8008636:	d000      	beq.n	800863a <protocol_exec_rt_suspend+0x29e>
 8008638:	e6da      	b.n	80083f0 <protocol_exec_rt_suspend+0x54>
 800863a:	e000      	b.n	800863e <protocol_exec_rt_suspend+0x2a2>
    if (sys.abort) { return; }
 800863c:	46c0      	nop			; (mov r8, r8)

  }
}
 800863e:	46bd      	mov	sp, r7
 8008640:	b004      	add	sp, #16
 8008642:	bd80      	pop	{r7, pc}
 8008644:	200009c4 	.word	0x200009c4
 8008648:	20000b44 	.word	0x20000b44
 800864c:	20000bb4 	.word	0x20000bb4

08008650 <report_util_setting_prefix>:

#include "grbl.h"


// Internal report utilities to reduce flash with repetitive tasks turned into functions.
void report_util_setting_prefix(uint8_t n) { serial_write('$'); print_uint8_base10(n); serial_write('='); }
 8008650:	b580      	push	{r7, lr}
 8008652:	b082      	sub	sp, #8
 8008654:	af00      	add	r7, sp, #0
 8008656:	0002      	movs	r2, r0
 8008658:	1dfb      	adds	r3, r7, #7
 800865a:	701a      	strb	r2, [r3, #0]
 800865c:	2024      	movs	r0, #36	; 0x24
 800865e:	f000 fefd 	bl	800945c <serial_write>
 8008662:	1dfb      	adds	r3, r7, #7
 8008664:	781b      	ldrb	r3, [r3, #0]
 8008666:	0018      	movs	r0, r3
 8008668:	f7ff f858 	bl	800771c <print_uint8_base10>
 800866c:	203d      	movs	r0, #61	; 0x3d
 800866e:	f000 fef5 	bl	800945c <serial_write>
 8008672:	46c0      	nop			; (mov r8, r8)
 8008674:	46bd      	mov	sp, r7
 8008676:	b002      	add	sp, #8
 8008678:	bd80      	pop	{r7, pc}
	...

0800867c <report_util_line_feed>:
static void report_util_line_feed() { printPgmString(PSTR("\r\n")); }
 800867c:	b580      	push	{r7, lr}
 800867e:	af00      	add	r7, sp, #0
 8008680:	4b03      	ldr	r3, [pc, #12]	; (8008690 <report_util_line_feed+0x14>)
 8008682:	0018      	movs	r0, r3
 8008684:	f7ff f836 	bl	80076f4 <printString>
 8008688:	46c0      	nop			; (mov r8, r8)
 800868a:	46bd      	mov	sp, r7
 800868c:	bd80      	pop	{r7, pc}
 800868e:	46c0      	nop			; (mov r8, r8)
 8008690:	0800da04 	.word	0x0800da04

08008694 <report_util_feedback_line_feed>:
static void report_util_feedback_line_feed() { serial_write(']'); report_util_line_feed(); }
 8008694:	b580      	push	{r7, lr}
 8008696:	af00      	add	r7, sp, #0
 8008698:	205d      	movs	r0, #93	; 0x5d
 800869a:	f000 fedf 	bl	800945c <serial_write>
 800869e:	f7ff ffed 	bl	800867c <report_util_line_feed>
 80086a2:	46c0      	nop			; (mov r8, r8)
 80086a4:	46bd      	mov	sp, r7
 80086a6:	bd80      	pop	{r7, pc}

080086a8 <report_util_gcode_modes_G>:
static void report_util_gcode_modes_G() { printPgmString(PSTR(" G")); }
 80086a8:	b580      	push	{r7, lr}
 80086aa:	af00      	add	r7, sp, #0
 80086ac:	4b03      	ldr	r3, [pc, #12]	; (80086bc <report_util_gcode_modes_G+0x14>)
 80086ae:	0018      	movs	r0, r3
 80086b0:	f7ff f820 	bl	80076f4 <printString>
 80086b4:	46c0      	nop			; (mov r8, r8)
 80086b6:	46bd      	mov	sp, r7
 80086b8:	bd80      	pop	{r7, pc}
 80086ba:	46c0      	nop			; (mov r8, r8)
 80086bc:	0800da08 	.word	0x0800da08

080086c0 <report_util_gcode_modes_M>:
static void report_util_gcode_modes_M() { printPgmString(PSTR(" M")); }
 80086c0:	b580      	push	{r7, lr}
 80086c2:	af00      	add	r7, sp, #0
 80086c4:	4b03      	ldr	r3, [pc, #12]	; (80086d4 <report_util_gcode_modes_M+0x14>)
 80086c6:	0018      	movs	r0, r3
 80086c8:	f7ff f814 	bl	80076f4 <printString>
 80086cc:	46c0      	nop			; (mov r8, r8)
 80086ce:	46bd      	mov	sp, r7
 80086d0:	bd80      	pop	{r7, pc}
 80086d2:	46c0      	nop			; (mov r8, r8)
 80086d4:	0800da0c 	.word	0x0800da0c

080086d8 <report_util_axis_values>:
// static void report_util_comment_line_feed() { serial_write(')'); report_util_line_feed(); }
static void report_util_axis_values(float *axis_value) {
 80086d8:	b580      	push	{r7, lr}
 80086da:	b084      	sub	sp, #16
 80086dc:	af00      	add	r7, sp, #0
 80086de:	6078      	str	r0, [r7, #4]
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 80086e0:	230f      	movs	r3, #15
 80086e2:	18fb      	adds	r3, r7, r3
 80086e4:	2200      	movs	r2, #0
 80086e6:	701a      	strb	r2, [r3, #0]
 80086e8:	e018      	b.n	800871c <report_util_axis_values+0x44>
    printFloat_CoordValue(axis_value[idx]);
 80086ea:	230f      	movs	r3, #15
 80086ec:	18fb      	adds	r3, r7, r3
 80086ee:	781b      	ldrb	r3, [r3, #0]
 80086f0:	009b      	lsls	r3, r3, #2
 80086f2:	687a      	ldr	r2, [r7, #4]
 80086f4:	18d3      	adds	r3, r2, r3
 80086f6:	681b      	ldr	r3, [r3, #0]
 80086f8:	1c18      	adds	r0, r3, #0
 80086fa:	f7ff f929 	bl	8007950 <printFloat_CoordValue>
    if (idx < (N_AXIS-1)) { serial_write(','); }
 80086fe:	230f      	movs	r3, #15
 8008700:	18fb      	adds	r3, r7, r3
 8008702:	781b      	ldrb	r3, [r3, #0]
 8008704:	2b02      	cmp	r3, #2
 8008706:	d802      	bhi.n	800870e <report_util_axis_values+0x36>
 8008708:	202c      	movs	r0, #44	; 0x2c
 800870a:	f000 fea7 	bl	800945c <serial_write>
  for (idx=0; idx<N_AXIS; idx++) {
 800870e:	230f      	movs	r3, #15
 8008710:	18fb      	adds	r3, r7, r3
 8008712:	781a      	ldrb	r2, [r3, #0]
 8008714:	230f      	movs	r3, #15
 8008716:	18fb      	adds	r3, r7, r3
 8008718:	3201      	adds	r2, #1
 800871a:	701a      	strb	r2, [r3, #0]
 800871c:	230f      	movs	r3, #15
 800871e:	18fb      	adds	r3, r7, r3
 8008720:	781b      	ldrb	r3, [r3, #0]
 8008722:	2b03      	cmp	r3, #3
 8008724:	d9e1      	bls.n	80086ea <report_util_axis_values+0x12>
  }
}
 8008726:	46c0      	nop			; (mov r8, r8)
 8008728:	46bd      	mov	sp, r7
 800872a:	b004      	add	sp, #16
 800872c:	bd80      	pop	{r7, pc}

0800872e <report_util_uint8_setting>:
  }
  report_util_comment_line_feed();
}
*/

static void report_util_uint8_setting(uint8_t n, int val) {
 800872e:	b580      	push	{r7, lr}
 8008730:	b082      	sub	sp, #8
 8008732:	af00      	add	r7, sp, #0
 8008734:	0002      	movs	r2, r0
 8008736:	6039      	str	r1, [r7, #0]
 8008738:	1dfb      	adds	r3, r7, #7
 800873a:	701a      	strb	r2, [r3, #0]
  report_util_setting_prefix(n);
 800873c:	1dfb      	adds	r3, r7, #7
 800873e:	781b      	ldrb	r3, [r3, #0]
 8008740:	0018      	movs	r0, r3
 8008742:	f7ff ff85 	bl	8008650 <report_util_setting_prefix>
  print_uint8_base10(val);
 8008746:	683b      	ldr	r3, [r7, #0]
 8008748:	b2db      	uxtb	r3, r3
 800874a:	0018      	movs	r0, r3
 800874c:	f7fe ffe6 	bl	800771c <print_uint8_base10>
  report_util_line_feed(); // report_util_setting_string(n); 
 8008750:	f7ff ff94 	bl	800867c <report_util_line_feed>
}
 8008754:	46c0      	nop			; (mov r8, r8)
 8008756:	46bd      	mov	sp, r7
 8008758:	b002      	add	sp, #8
 800875a:	bd80      	pop	{r7, pc}

0800875c <report_util_float_setting>:
static void report_util_float_setting(uint8_t n, float val, uint8_t n_decimal) {
 800875c:	b580      	push	{r7, lr}
 800875e:	b082      	sub	sp, #8
 8008760:	af00      	add	r7, sp, #0
 8008762:	6039      	str	r1, [r7, #0]
 8008764:	0011      	movs	r1, r2
 8008766:	1dfb      	adds	r3, r7, #7
 8008768:	1c02      	adds	r2, r0, #0
 800876a:	701a      	strb	r2, [r3, #0]
 800876c:	1dbb      	adds	r3, r7, #6
 800876e:	1c0a      	adds	r2, r1, #0
 8008770:	701a      	strb	r2, [r3, #0]
  report_util_setting_prefix(n);
 8008772:	1dfb      	adds	r3, r7, #7
 8008774:	781b      	ldrb	r3, [r3, #0]
 8008776:	0018      	movs	r0, r3
 8008778:	f7ff ff6a 	bl	8008650 <report_util_setting_prefix>
  printFloat(val, n_decimal);
 800877c:	1dbb      	adds	r3, r7, #6
 800877e:	781a      	ldrb	r2, [r3, #0]
 8008780:	683b      	ldr	r3, [r7, #0]
 8008782:	0011      	movs	r1, r2
 8008784:	1c18      	adds	r0, r3, #0
 8008786:	f7ff f82b 	bl	80077e0 <printFloat>
  report_util_line_feed(); // report_util_setting_string(n);
 800878a:	f7ff ff77 	bl	800867c <report_util_line_feed>
}
 800878e:	46c0      	nop			; (mov r8, r8)
 8008790:	46bd      	mov	sp, r7
 8008792:	b002      	add	sp, #8
 8008794:	bd80      	pop	{r7, pc}
	...

08008798 <report_status_message>:
// 'error:'  to indicate some error event with the line or some critical system error during
// operation. Errors events can originate from the g-code parser, settings module, or asynchronously
// from a critical error, such as a triggered hard limit. Interface should always monitor for these
// responses.
void report_status_message(uint8_t status_code)
{
 8008798:	b580      	push	{r7, lr}
 800879a:	b082      	sub	sp, #8
 800879c:	af00      	add	r7, sp, #0
 800879e:	0002      	movs	r2, r0
 80087a0:	1dfb      	adds	r3, r7, #7
 80087a2:	701a      	strb	r2, [r3, #0]
  switch(status_code) {
 80087a4:	1dfb      	adds	r3, r7, #7
 80087a6:	781b      	ldrb	r3, [r3, #0]
 80087a8:	2b00      	cmp	r3, #0
 80087aa:	d104      	bne.n	80087b6 <report_status_message+0x1e>
    case STATUS_OK: // STATUS_OK
      printPgmString(PSTR("ok\r\n")); break;
 80087ac:	4b09      	ldr	r3, [pc, #36]	; (80087d4 <report_status_message+0x3c>)
 80087ae:	0018      	movs	r0, r3
 80087b0:	f7fe ffa0 	bl	80076f4 <printString>
 80087b4:	e00a      	b.n	80087cc <report_status_message+0x34>
    default:
      printPgmString(PSTR("error:"));
 80087b6:	4b08      	ldr	r3, [pc, #32]	; (80087d8 <report_status_message+0x40>)
 80087b8:	0018      	movs	r0, r3
 80087ba:	f7fe ff9b 	bl	80076f4 <printString>
      print_uint8_base10(status_code);
 80087be:	1dfb      	adds	r3, r7, #7
 80087c0:	781b      	ldrb	r3, [r3, #0]
 80087c2:	0018      	movs	r0, r3
 80087c4:	f7fe ffaa 	bl	800771c <print_uint8_base10>
      report_util_line_feed();
 80087c8:	f7ff ff58 	bl	800867c <report_util_line_feed>
  }
}
 80087cc:	46c0      	nop			; (mov r8, r8)
 80087ce:	46bd      	mov	sp, r7
 80087d0:	b002      	add	sp, #8
 80087d2:	bd80      	pop	{r7, pc}
 80087d4:	0800da10 	.word	0x0800da10
 80087d8:	0800da18 	.word	0x0800da18

080087dc <report_alarm_message>:

// Prints alarm messages.
void report_alarm_message(uint8_t alarm_code)
{
 80087dc:	b580      	push	{r7, lr}
 80087de:	b082      	sub	sp, #8
 80087e0:	af00      	add	r7, sp, #0
 80087e2:	0002      	movs	r2, r0
 80087e4:	1dfb      	adds	r3, r7, #7
 80087e6:	701a      	strb	r2, [r3, #0]
  printPgmString(PSTR("ALARM:"));
 80087e8:	4b09      	ldr	r3, [pc, #36]	; (8008810 <report_alarm_message+0x34>)
 80087ea:	0018      	movs	r0, r3
 80087ec:	f7fe ff82 	bl	80076f4 <printString>
  print_uint8_base10(alarm_code);
 80087f0:	1dfb      	adds	r3, r7, #7
 80087f2:	781b      	ldrb	r3, [r3, #0]
 80087f4:	0018      	movs	r0, r3
 80087f6:	f7fe ff91 	bl	800771c <print_uint8_base10>
  report_util_line_feed();
 80087fa:	f7ff ff3f 	bl	800867c <report_util_line_feed>
  delay_ms(500); // Force delay to ensure message clears serial write buffer.
 80087fe:	23fa      	movs	r3, #250	; 0xfa
 8008800:	005b      	lsls	r3, r3, #1
 8008802:	0018      	movs	r0, r3
 8008804:	f7fe f82a 	bl	800685c <delay_ms>
}
 8008808:	46c0      	nop			; (mov r8, r8)
 800880a:	46bd      	mov	sp, r7
 800880c:	b002      	add	sp, #8
 800880e:	bd80      	pop	{r7, pc}
 8008810:	0800da20 	.word	0x0800da20

08008814 <report_feedback_message>:
// user feedback for things that are not of the status/alarm message protocol. These are
// messages such as setup warnings, switch toggling, and how to exit alarms.
// NOTE: For interfaces, messages are always placed within brackets. And if silent mode
// is installed, the message number codes are less than zero.
void report_feedback_message(uint8_t message_code)
{
 8008814:	b580      	push	{r7, lr}
 8008816:	b082      	sub	sp, #8
 8008818:	af00      	add	r7, sp, #0
 800881a:	0002      	movs	r2, r0
 800881c:	1dfb      	adds	r3, r7, #7
 800881e:	701a      	strb	r2, [r3, #0]
  printPgmString(PSTR("[MSG:"));
 8008820:	4b24      	ldr	r3, [pc, #144]	; (80088b4 <report_feedback_message+0xa0>)
 8008822:	0018      	movs	r0, r3
 8008824:	f7fe ff66 	bl	80076f4 <printString>
  switch(message_code) {
 8008828:	1dfb      	adds	r3, r7, #7
 800882a:	781b      	ldrb	r3, [r3, #0]
 800882c:	2b0b      	cmp	r3, #11
 800882e:	d83b      	bhi.n	80088a8 <report_feedback_message+0x94>
 8008830:	009a      	lsls	r2, r3, #2
 8008832:	4b21      	ldr	r3, [pc, #132]	; (80088b8 <report_feedback_message+0xa4>)
 8008834:	18d3      	adds	r3, r2, r3
 8008836:	681b      	ldr	r3, [r3, #0]
 8008838:	469f      	mov	pc, r3
    case MESSAGE_CRITICAL_EVENT:
      printPgmString(PSTR("Reset to continue")); break;
 800883a:	4b20      	ldr	r3, [pc, #128]	; (80088bc <report_feedback_message+0xa8>)
 800883c:	0018      	movs	r0, r3
 800883e:	f7fe ff59 	bl	80076f4 <printString>
 8008842:	e031      	b.n	80088a8 <report_feedback_message+0x94>
    case MESSAGE_ALARM_LOCK:
      printPgmString(PSTR("'$H'|'$X' to unlock")); break;
 8008844:	4b1e      	ldr	r3, [pc, #120]	; (80088c0 <report_feedback_message+0xac>)
 8008846:	0018      	movs	r0, r3
 8008848:	f7fe ff54 	bl	80076f4 <printString>
 800884c:	e02c      	b.n	80088a8 <report_feedback_message+0x94>
    case MESSAGE_ALARM_UNLOCK:
      printPgmString(PSTR("Caution: Unlocked")); break;
 800884e:	4b1d      	ldr	r3, [pc, #116]	; (80088c4 <report_feedback_message+0xb0>)
 8008850:	0018      	movs	r0, r3
 8008852:	f7fe ff4f 	bl	80076f4 <printString>
 8008856:	e027      	b.n	80088a8 <report_feedback_message+0x94>
    case MESSAGE_ENABLED:
      printPgmString(PSTR("Enabled")); break;
 8008858:	4b1b      	ldr	r3, [pc, #108]	; (80088c8 <report_feedback_message+0xb4>)
 800885a:	0018      	movs	r0, r3
 800885c:	f7fe ff4a 	bl	80076f4 <printString>
 8008860:	e022      	b.n	80088a8 <report_feedback_message+0x94>
    case MESSAGE_DISABLED:
      printPgmString(PSTR("Disabled")); break;
 8008862:	4b1a      	ldr	r3, [pc, #104]	; (80088cc <report_feedback_message+0xb8>)
 8008864:	0018      	movs	r0, r3
 8008866:	f7fe ff45 	bl	80076f4 <printString>
 800886a:	e01d      	b.n	80088a8 <report_feedback_message+0x94>
    case MESSAGE_SAFETY_DOOR_AJAR:
      printPgmString(PSTR("Check Door")); break;
 800886c:	4b18      	ldr	r3, [pc, #96]	; (80088d0 <report_feedback_message+0xbc>)
 800886e:	0018      	movs	r0, r3
 8008870:	f7fe ff40 	bl	80076f4 <printString>
 8008874:	e018      	b.n	80088a8 <report_feedback_message+0x94>
    case MESSAGE_CHECK_LIMITS:
      printPgmString(PSTR("Check Limits")); break;
 8008876:	4b17      	ldr	r3, [pc, #92]	; (80088d4 <report_feedback_message+0xc0>)
 8008878:	0018      	movs	r0, r3
 800887a:	f7fe ff3b 	bl	80076f4 <printString>
 800887e:	e013      	b.n	80088a8 <report_feedback_message+0x94>
    case MESSAGE_PROGRAM_END:
      printPgmString(PSTR("Pgm End")); break;
 8008880:	4b15      	ldr	r3, [pc, #84]	; (80088d8 <report_feedback_message+0xc4>)
 8008882:	0018      	movs	r0, r3
 8008884:	f7fe ff36 	bl	80076f4 <printString>
 8008888:	e00e      	b.n	80088a8 <report_feedback_message+0x94>
    case MESSAGE_RESTORE_DEFAULTS:
      printPgmString(PSTR("Restoring defaults")); break;
 800888a:	4b14      	ldr	r3, [pc, #80]	; (80088dc <report_feedback_message+0xc8>)
 800888c:	0018      	movs	r0, r3
 800888e:	f7fe ff31 	bl	80076f4 <printString>
 8008892:	e009      	b.n	80088a8 <report_feedback_message+0x94>
    case MESSAGE_SPINDLE_RESTORE:
      printPgmString(PSTR("Restoring spindle")); break;
 8008894:	4b12      	ldr	r3, [pc, #72]	; (80088e0 <report_feedback_message+0xcc>)
 8008896:	0018      	movs	r0, r3
 8008898:	f7fe ff2c 	bl	80076f4 <printString>
 800889c:	e004      	b.n	80088a8 <report_feedback_message+0x94>
    case MESSAGE_SLEEP_MODE:
      printPgmString(PSTR("Sleeping")); break;
 800889e:	4b11      	ldr	r3, [pc, #68]	; (80088e4 <report_feedback_message+0xd0>)
 80088a0:	0018      	movs	r0, r3
 80088a2:	f7fe ff27 	bl	80076f4 <printString>
 80088a6:	46c0      	nop			; (mov r8, r8)
  }
  report_util_feedback_line_feed();
 80088a8:	f7ff fef4 	bl	8008694 <report_util_feedback_line_feed>
}
 80088ac:	46c0      	nop			; (mov r8, r8)
 80088ae:	46bd      	mov	sp, r7
 80088b0:	b002      	add	sp, #8
 80088b2:	bd80      	pop	{r7, pc}
 80088b4:	0800da28 	.word	0x0800da28
 80088b8:	0800df84 	.word	0x0800df84
 80088bc:	0800da30 	.word	0x0800da30
 80088c0:	0800da44 	.word	0x0800da44
 80088c4:	0800da58 	.word	0x0800da58
 80088c8:	0800da6c 	.word	0x0800da6c
 80088cc:	0800da74 	.word	0x0800da74
 80088d0:	0800da80 	.word	0x0800da80
 80088d4:	0800da8c 	.word	0x0800da8c
 80088d8:	0800da9c 	.word	0x0800da9c
 80088dc:	0800daa4 	.word	0x0800daa4
 80088e0:	0800dab8 	.word	0x0800dab8
 80088e4:	0800dacc 	.word	0x0800dacc

080088e8 <report_init_message>:


// Welcome message
void report_init_message()
{
 80088e8:	b580      	push	{r7, lr}
 80088ea:	af00      	add	r7, sp, #0
  printPgmString(PSTR("\r\nGrbl " GRBL_VERSION " ['$' for help]\r\n"));
 80088ec:	4b03      	ldr	r3, [pc, #12]	; (80088fc <report_init_message+0x14>)
 80088ee:	0018      	movs	r0, r3
 80088f0:	f7fe ff00 	bl	80076f4 <printString>
}
 80088f4:	46c0      	nop			; (mov r8, r8)
 80088f6:	46bd      	mov	sp, r7
 80088f8:	bd80      	pop	{r7, pc}
 80088fa:	46c0      	nop			; (mov r8, r8)
 80088fc:	0800dad8 	.word	0x0800dad8

08008900 <report_grbl_help>:

// Grbl help message
void report_grbl_help() {
 8008900:	b580      	push	{r7, lr}
 8008902:	af00      	add	r7, sp, #0
  printPgmString(PSTR("[HLP:$$ $# $G $I $N $x=val $Nx=line $J=line $SLP $C $X $H ~ ! ? ctrl-x]\r\n"));    
 8008904:	4b03      	ldr	r3, [pc, #12]	; (8008914 <report_grbl_help+0x14>)
 8008906:	0018      	movs	r0, r3
 8008908:	f7fe fef4 	bl	80076f4 <printString>
}
 800890c:	46c0      	nop			; (mov r8, r8)
 800890e:	46bd      	mov	sp, r7
 8008910:	bd80      	pop	{r7, pc}
 8008912:	46c0      	nop			; (mov r8, r8)
 8008914:	0800daf8 	.word	0x0800daf8

08008918 <report_grbl_settings>:


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
 8008918:	b590      	push	{r4, r7, lr}
 800891a:	b083      	sub	sp, #12
 800891c:	af00      	add	r7, sp, #0
  // Print Grbl settings.
  report_util_uint8_setting(0,settings.pulse_microseconds);
 800891e:	4ba3      	ldr	r3, [pc, #652]	; (8008bac <report_grbl_settings+0x294>)
 8008920:	2240      	movs	r2, #64	; 0x40
 8008922:	5c9b      	ldrb	r3, [r3, r2]
 8008924:	0019      	movs	r1, r3
 8008926:	2000      	movs	r0, #0
 8008928:	f7ff ff01 	bl	800872e <report_util_uint8_setting>
  report_util_uint8_setting(1,settings.stepper_idle_lock_time);
 800892c:	4b9f      	ldr	r3, [pc, #636]	; (8008bac <report_grbl_settings+0x294>)
 800892e:	2243      	movs	r2, #67	; 0x43
 8008930:	5c9b      	ldrb	r3, [r3, r2]
 8008932:	0019      	movs	r1, r3
 8008934:	2001      	movs	r0, #1
 8008936:	f7ff fefa 	bl	800872e <report_util_uint8_setting>
  report_util_uint8_setting(2,settings.step_invert_mask);
 800893a:	4b9c      	ldr	r3, [pc, #624]	; (8008bac <report_grbl_settings+0x294>)
 800893c:	2241      	movs	r2, #65	; 0x41
 800893e:	5c9b      	ldrb	r3, [r3, r2]
 8008940:	0019      	movs	r1, r3
 8008942:	2002      	movs	r0, #2
 8008944:	f7ff fef3 	bl	800872e <report_util_uint8_setting>
  report_util_uint8_setting(3,settings.dir_invert_mask);
 8008948:	4b98      	ldr	r3, [pc, #608]	; (8008bac <report_grbl_settings+0x294>)
 800894a:	2242      	movs	r2, #66	; 0x42
 800894c:	5c9b      	ldrb	r3, [r3, r2]
 800894e:	0019      	movs	r1, r3
 8008950:	2003      	movs	r0, #3
 8008952:	f7ff feec 	bl	800872e <report_util_uint8_setting>
  report_util_uint8_setting(4,bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE));
 8008956:	4b95      	ldr	r3, [pc, #596]	; (8008bac <report_grbl_settings+0x294>)
 8008958:	2258      	movs	r2, #88	; 0x58
 800895a:	5c9b      	ldrb	r3, [r3, r2]
 800895c:	001a      	movs	r2, r3
 800895e:	2304      	movs	r3, #4
 8008960:	4013      	ands	r3, r2
 8008962:	1e5a      	subs	r2, r3, #1
 8008964:	4193      	sbcs	r3, r2
 8008966:	b2db      	uxtb	r3, r3
 8008968:	0019      	movs	r1, r3
 800896a:	2004      	movs	r0, #4
 800896c:	f7ff fedf 	bl	800872e <report_util_uint8_setting>
  report_util_uint8_setting(5,bit_istrue(settings.flags,BITFLAG_INVERT_LIMIT_PINS));
 8008970:	4b8e      	ldr	r3, [pc, #568]	; (8008bac <report_grbl_settings+0x294>)
 8008972:	2258      	movs	r2, #88	; 0x58
 8008974:	5c9b      	ldrb	r3, [r3, r2]
 8008976:	001a      	movs	r2, r3
 8008978:	2340      	movs	r3, #64	; 0x40
 800897a:	4013      	ands	r3, r2
 800897c:	1e5a      	subs	r2, r3, #1
 800897e:	4193      	sbcs	r3, r2
 8008980:	b2db      	uxtb	r3, r3
 8008982:	0019      	movs	r1, r3
 8008984:	2005      	movs	r0, #5
 8008986:	f7ff fed2 	bl	800872e <report_util_uint8_setting>
  report_util_uint8_setting(6,bit_istrue(settings.flags,BITFLAG_INVERT_PROBE_PIN));
 800898a:	4b88      	ldr	r3, [pc, #544]	; (8008bac <report_grbl_settings+0x294>)
 800898c:	2258      	movs	r2, #88	; 0x58
 800898e:	5c9b      	ldrb	r3, [r3, r2]
 8008990:	b25b      	sxtb	r3, r3
 8008992:	b2db      	uxtb	r3, r3
 8008994:	09db      	lsrs	r3, r3, #7
 8008996:	b2db      	uxtb	r3, r3
 8008998:	0019      	movs	r1, r3
 800899a:	2006      	movs	r0, #6
 800899c:	f7ff fec7 	bl	800872e <report_util_uint8_setting>
  report_util_uint8_setting(10,settings.status_report_mask);
 80089a0:	4b82      	ldr	r3, [pc, #520]	; (8008bac <report_grbl_settings+0x294>)
 80089a2:	2244      	movs	r2, #68	; 0x44
 80089a4:	5c9b      	ldrb	r3, [r3, r2]
 80089a6:	0019      	movs	r1, r3
 80089a8:	200a      	movs	r0, #10
 80089aa:	f7ff fec0 	bl	800872e <report_util_uint8_setting>
  report_util_float_setting(11,settings.junction_deviation,N_DECIMAL_SETTINGVALUE);
 80089ae:	4b7f      	ldr	r3, [pc, #508]	; (8008bac <report_grbl_settings+0x294>)
 80089b0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80089b2:	2203      	movs	r2, #3
 80089b4:	1c19      	adds	r1, r3, #0
 80089b6:	200b      	movs	r0, #11
 80089b8:	f7ff fed0 	bl	800875c <report_util_float_setting>
  report_util_float_setting(12,settings.arc_tolerance,N_DECIMAL_SETTINGVALUE);
 80089bc:	4b7b      	ldr	r3, [pc, #492]	; (8008bac <report_grbl_settings+0x294>)
 80089be:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80089c0:	2203      	movs	r2, #3
 80089c2:	1c19      	adds	r1, r3, #0
 80089c4:	200c      	movs	r0, #12
 80089c6:	f7ff fec9 	bl	800875c <report_util_float_setting>
  report_util_uint8_setting(13,bit_istrue(settings.flags,BITFLAG_REPORT_INCHES));
 80089ca:	4b78      	ldr	r3, [pc, #480]	; (8008bac <report_grbl_settings+0x294>)
 80089cc:	2258      	movs	r2, #88	; 0x58
 80089ce:	5c9b      	ldrb	r3, [r3, r2]
 80089d0:	001a      	movs	r2, r3
 80089d2:	2301      	movs	r3, #1
 80089d4:	4013      	ands	r3, r2
 80089d6:	1e5a      	subs	r2, r3, #1
 80089d8:	4193      	sbcs	r3, r2
 80089da:	b2db      	uxtb	r3, r3
 80089dc:	0019      	movs	r1, r3
 80089de:	200d      	movs	r0, #13
 80089e0:	f7ff fea5 	bl	800872e <report_util_uint8_setting>
  report_util_uint8_setting(20,bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE));
 80089e4:	4b71      	ldr	r3, [pc, #452]	; (8008bac <report_grbl_settings+0x294>)
 80089e6:	2258      	movs	r2, #88	; 0x58
 80089e8:	5c9b      	ldrb	r3, [r3, r2]
 80089ea:	001a      	movs	r2, r3
 80089ec:	2320      	movs	r3, #32
 80089ee:	4013      	ands	r3, r2
 80089f0:	1e5a      	subs	r2, r3, #1
 80089f2:	4193      	sbcs	r3, r2
 80089f4:	b2db      	uxtb	r3, r3
 80089f6:	0019      	movs	r1, r3
 80089f8:	2014      	movs	r0, #20
 80089fa:	f7ff fe98 	bl	800872e <report_util_uint8_setting>
  report_util_uint8_setting(21,bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE));
 80089fe:	4b6b      	ldr	r3, [pc, #428]	; (8008bac <report_grbl_settings+0x294>)
 8008a00:	2258      	movs	r2, #88	; 0x58
 8008a02:	5c9b      	ldrb	r3, [r3, r2]
 8008a04:	001a      	movs	r2, r3
 8008a06:	2308      	movs	r3, #8
 8008a08:	4013      	ands	r3, r2
 8008a0a:	1e5a      	subs	r2, r3, #1
 8008a0c:	4193      	sbcs	r3, r2
 8008a0e:	b2db      	uxtb	r3, r3
 8008a10:	0019      	movs	r1, r3
 8008a12:	2015      	movs	r0, #21
 8008a14:	f7ff fe8b 	bl	800872e <report_util_uint8_setting>
  report_util_uint8_setting(22,bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE));
 8008a18:	4b64      	ldr	r3, [pc, #400]	; (8008bac <report_grbl_settings+0x294>)
 8008a1a:	2258      	movs	r2, #88	; 0x58
 8008a1c:	5c9b      	ldrb	r3, [r3, r2]
 8008a1e:	001a      	movs	r2, r3
 8008a20:	2310      	movs	r3, #16
 8008a22:	4013      	ands	r3, r2
 8008a24:	1e5a      	subs	r2, r3, #1
 8008a26:	4193      	sbcs	r3, r2
 8008a28:	b2db      	uxtb	r3, r3
 8008a2a:	0019      	movs	r1, r3
 8008a2c:	2016      	movs	r0, #22
 8008a2e:	f7ff fe7e 	bl	800872e <report_util_uint8_setting>
  report_util_uint8_setting(23,settings.homing_dir_mask);
 8008a32:	4b5e      	ldr	r3, [pc, #376]	; (8008bac <report_grbl_settings+0x294>)
 8008a34:	2259      	movs	r2, #89	; 0x59
 8008a36:	5c9b      	ldrb	r3, [r3, r2]
 8008a38:	0019      	movs	r1, r3
 8008a3a:	2017      	movs	r0, #23
 8008a3c:	f7ff fe77 	bl	800872e <report_util_uint8_setting>
  report_util_float_setting(24,settings.homing_feed_rate,N_DECIMAL_SETTINGVALUE);
 8008a40:	4b5a      	ldr	r3, [pc, #360]	; (8008bac <report_grbl_settings+0x294>)
 8008a42:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8008a44:	2203      	movs	r2, #3
 8008a46:	1c19      	adds	r1, r3, #0
 8008a48:	2018      	movs	r0, #24
 8008a4a:	f7ff fe87 	bl	800875c <report_util_float_setting>
  report_util_float_setting(25,settings.homing_seek_rate,N_DECIMAL_SETTINGVALUE);
 8008a4e:	4b57      	ldr	r3, [pc, #348]	; (8008bac <report_grbl_settings+0x294>)
 8008a50:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8008a52:	2203      	movs	r2, #3
 8008a54:	1c19      	adds	r1, r3, #0
 8008a56:	2019      	movs	r0, #25
 8008a58:	f7ff fe80 	bl	800875c <report_util_float_setting>
  report_util_uint8_setting(26,settings.homing_debounce_delay);
 8008a5c:	4b53      	ldr	r3, [pc, #332]	; (8008bac <report_grbl_settings+0x294>)
 8008a5e:	2264      	movs	r2, #100	; 0x64
 8008a60:	5a9b      	ldrh	r3, [r3, r2]
 8008a62:	0019      	movs	r1, r3
 8008a64:	201a      	movs	r0, #26
 8008a66:	f7ff fe62 	bl	800872e <report_util_uint8_setting>
  report_util_float_setting(27,settings.homing_pulloff,N_DECIMAL_SETTINGVALUE);
 8008a6a:	4b50      	ldr	r3, [pc, #320]	; (8008bac <report_grbl_settings+0x294>)
 8008a6c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8008a6e:	2203      	movs	r2, #3
 8008a70:	1c19      	adds	r1, r3, #0
 8008a72:	201b      	movs	r0, #27
 8008a74:	f7ff fe72 	bl	800875c <report_util_float_setting>
  report_util_float_setting(30,settings.rpm_max,N_DECIMAL_RPMVALUE);
 8008a78:	4b4c      	ldr	r3, [pc, #304]	; (8008bac <report_grbl_settings+0x294>)
 8008a7a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008a7c:	2200      	movs	r2, #0
 8008a7e:	1c19      	adds	r1, r3, #0
 8008a80:	201e      	movs	r0, #30
 8008a82:	f7ff fe6b 	bl	800875c <report_util_float_setting>
  report_util_float_setting(31,settings.rpm_min,N_DECIMAL_RPMVALUE);
 8008a86:	4b49      	ldr	r3, [pc, #292]	; (8008bac <report_grbl_settings+0x294>)
 8008a88:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8008a8a:	2200      	movs	r2, #0
 8008a8c:	1c19      	adds	r1, r3, #0
 8008a8e:	201f      	movs	r0, #31
 8008a90:	f7ff fe64 	bl	800875c <report_util_float_setting>
  #ifdef VARIABLE_SPINDLE
    report_util_uint8_setting(32,bit_istrue(settings.flags,BITFLAG_LASER_MODE));
 8008a94:	4b45      	ldr	r3, [pc, #276]	; (8008bac <report_grbl_settings+0x294>)
 8008a96:	2258      	movs	r2, #88	; 0x58
 8008a98:	5c9b      	ldrb	r3, [r3, r2]
 8008a9a:	001a      	movs	r2, r3
 8008a9c:	2302      	movs	r3, #2
 8008a9e:	4013      	ands	r3, r2
 8008aa0:	1e5a      	subs	r2, r3, #1
 8008aa2:	4193      	sbcs	r3, r2
 8008aa4:	b2db      	uxtb	r3, r3
 8008aa6:	0019      	movs	r1, r3
 8008aa8:	2020      	movs	r0, #32
 8008aaa:	f7ff fe40 	bl	800872e <report_util_uint8_setting>
  #else
    report_util_uint8_setting(32,0);
  #endif
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
 8008aae:	1d7b      	adds	r3, r7, #5
 8008ab0:	2264      	movs	r2, #100	; 0x64
 8008ab2:	701a      	strb	r2, [r3, #0]
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
 8008ab4:	1dbb      	adds	r3, r7, #6
 8008ab6:	2200      	movs	r2, #0
 8008ab8:	701a      	strb	r2, [r3, #0]
 8008aba:	e06f      	b.n	8008b9c <report_grbl_settings+0x284>
    for (idx=0; idx<N_AXIS; idx++) {
 8008abc:	1dfb      	adds	r3, r7, #7
 8008abe:	2200      	movs	r2, #0
 8008ac0:	701a      	strb	r2, [r3, #0]
 8008ac2:	e05d      	b.n	8008b80 <report_grbl_settings+0x268>
      switch (set_idx) {
 8008ac4:	1dbb      	adds	r3, r7, #6
 8008ac6:	781b      	ldrb	r3, [r3, #0]
 8008ac8:	2b01      	cmp	r3, #1
 8008aca:	d018      	beq.n	8008afe <report_grbl_settings+0x1e6>
 8008acc:	dc02      	bgt.n	8008ad4 <report_grbl_settings+0x1bc>
 8008ace:	2b00      	cmp	r3, #0
 8008ad0:	d005      	beq.n	8008ade <report_grbl_settings+0x1c6>
 8008ad2:	e050      	b.n	8008b76 <report_grbl_settings+0x25e>
 8008ad4:	2b02      	cmp	r3, #2
 8008ad6:	d023      	beq.n	8008b20 <report_grbl_settings+0x208>
 8008ad8:	2b03      	cmp	r3, #3
 8008ada:	d038      	beq.n	8008b4e <report_grbl_settings+0x236>
 8008adc:	e04b      	b.n	8008b76 <report_grbl_settings+0x25e>
        case 0: report_util_float_setting(val+idx,settings.steps_per_mm[idx],N_DECIMAL_SETTINGVALUE); break;
 8008ade:	1d7a      	adds	r2, r7, #5
 8008ae0:	1dfb      	adds	r3, r7, #7
 8008ae2:	7812      	ldrb	r2, [r2, #0]
 8008ae4:	781b      	ldrb	r3, [r3, #0]
 8008ae6:	18d3      	adds	r3, r2, r3
 8008ae8:	b2d8      	uxtb	r0, r3
 8008aea:	1dfb      	adds	r3, r7, #7
 8008aec:	781a      	ldrb	r2, [r3, #0]
 8008aee:	4b2f      	ldr	r3, [pc, #188]	; (8008bac <report_grbl_settings+0x294>)
 8008af0:	0092      	lsls	r2, r2, #2
 8008af2:	58d3      	ldr	r3, [r2, r3]
 8008af4:	2203      	movs	r2, #3
 8008af6:	1c19      	adds	r1, r3, #0
 8008af8:	f7ff fe30 	bl	800875c <report_util_float_setting>
 8008afc:	e03b      	b.n	8008b76 <report_grbl_settings+0x25e>
        case 1: report_util_float_setting(val+idx,settings.max_rate[idx],N_DECIMAL_SETTINGVALUE); break;
 8008afe:	1d7a      	adds	r2, r7, #5
 8008b00:	1dfb      	adds	r3, r7, #7
 8008b02:	7812      	ldrb	r2, [r2, #0]
 8008b04:	781b      	ldrb	r3, [r3, #0]
 8008b06:	18d3      	adds	r3, r2, r3
 8008b08:	b2d8      	uxtb	r0, r3
 8008b0a:	1dfb      	adds	r3, r7, #7
 8008b0c:	781a      	ldrb	r2, [r3, #0]
 8008b0e:	4b27      	ldr	r3, [pc, #156]	; (8008bac <report_grbl_settings+0x294>)
 8008b10:	3204      	adds	r2, #4
 8008b12:	0092      	lsls	r2, r2, #2
 8008b14:	58d3      	ldr	r3, [r2, r3]
 8008b16:	2203      	movs	r2, #3
 8008b18:	1c19      	adds	r1, r3, #0
 8008b1a:	f7ff fe1f 	bl	800875c <report_util_float_setting>
 8008b1e:	e02a      	b.n	8008b76 <report_grbl_settings+0x25e>
        case 2: report_util_float_setting(val+idx,settings.acceleration[idx]/(60*60),N_DECIMAL_SETTINGVALUE); break;
 8008b20:	1d7a      	adds	r2, r7, #5
 8008b22:	1dfb      	adds	r3, r7, #7
 8008b24:	7812      	ldrb	r2, [r2, #0]
 8008b26:	781b      	ldrb	r3, [r3, #0]
 8008b28:	18d3      	adds	r3, r2, r3
 8008b2a:	b2dc      	uxtb	r4, r3
 8008b2c:	1dfb      	adds	r3, r7, #7
 8008b2e:	781a      	ldrb	r2, [r3, #0]
 8008b30:	4b1e      	ldr	r3, [pc, #120]	; (8008bac <report_grbl_settings+0x294>)
 8008b32:	3208      	adds	r2, #8
 8008b34:	0092      	lsls	r2, r2, #2
 8008b36:	58d3      	ldr	r3, [r2, r3]
 8008b38:	491d      	ldr	r1, [pc, #116]	; (8008bb0 <report_grbl_settings+0x298>)
 8008b3a:	1c18      	adds	r0, r3, #0
 8008b3c:	f7f7 fdba 	bl	80006b4 <__aeabi_fdiv>
 8008b40:	1c03      	adds	r3, r0, #0
 8008b42:	2203      	movs	r2, #3
 8008b44:	1c19      	adds	r1, r3, #0
 8008b46:	0020      	movs	r0, r4
 8008b48:	f7ff fe08 	bl	800875c <report_util_float_setting>
 8008b4c:	e013      	b.n	8008b76 <report_grbl_settings+0x25e>
        case 3: report_util_float_setting(val+idx,-settings.max_travel[idx],N_DECIMAL_SETTINGVALUE); break;
 8008b4e:	1d7a      	adds	r2, r7, #5
 8008b50:	1dfb      	adds	r3, r7, #7
 8008b52:	7812      	ldrb	r2, [r2, #0]
 8008b54:	781b      	ldrb	r3, [r3, #0]
 8008b56:	18d3      	adds	r3, r2, r3
 8008b58:	b2d8      	uxtb	r0, r3
 8008b5a:	1dfb      	adds	r3, r7, #7
 8008b5c:	781a      	ldrb	r2, [r3, #0]
 8008b5e:	4b13      	ldr	r3, [pc, #76]	; (8008bac <report_grbl_settings+0x294>)
 8008b60:	320c      	adds	r2, #12
 8008b62:	0092      	lsls	r2, r2, #2
 8008b64:	58d3      	ldr	r3, [r2, r3]
 8008b66:	2280      	movs	r2, #128	; 0x80
 8008b68:	0612      	lsls	r2, r2, #24
 8008b6a:	4053      	eors	r3, r2
 8008b6c:	2203      	movs	r2, #3
 8008b6e:	1c19      	adds	r1, r3, #0
 8008b70:	f7ff fdf4 	bl	800875c <report_util_float_setting>
 8008b74:	46c0      	nop			; (mov r8, r8)
    for (idx=0; idx<N_AXIS; idx++) {
 8008b76:	1dfb      	adds	r3, r7, #7
 8008b78:	781a      	ldrb	r2, [r3, #0]
 8008b7a:	1dfb      	adds	r3, r7, #7
 8008b7c:	3201      	adds	r2, #1
 8008b7e:	701a      	strb	r2, [r3, #0]
 8008b80:	1dfb      	adds	r3, r7, #7
 8008b82:	781b      	ldrb	r3, [r3, #0]
 8008b84:	2b03      	cmp	r3, #3
 8008b86:	d99d      	bls.n	8008ac4 <report_grbl_settings+0x1ac>
      }
    }
    val += AXIS_SETTINGS_INCREMENT;
 8008b88:	1d7b      	adds	r3, r7, #5
 8008b8a:	1d7a      	adds	r2, r7, #5
 8008b8c:	7812      	ldrb	r2, [r2, #0]
 8008b8e:	320a      	adds	r2, #10
 8008b90:	701a      	strb	r2, [r3, #0]
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
 8008b92:	1dbb      	adds	r3, r7, #6
 8008b94:	781a      	ldrb	r2, [r3, #0]
 8008b96:	1dbb      	adds	r3, r7, #6
 8008b98:	3201      	adds	r2, #1
 8008b9a:	701a      	strb	r2, [r3, #0]
 8008b9c:	1dbb      	adds	r3, r7, #6
 8008b9e:	781b      	ldrb	r3, [r3, #0]
 8008ba0:	2b03      	cmp	r3, #3
 8008ba2:	d98b      	bls.n	8008abc <report_grbl_settings+0x1a4>
  }
}
 8008ba4:	46c0      	nop			; (mov r8, r8)
 8008ba6:	46bd      	mov	sp, r7
 8008ba8:	b003      	add	sp, #12
 8008baa:	bd90      	pop	{r4, r7, pc}
 8008bac:	20000b44 	.word	0x20000b44
 8008bb0:	45610000 	.word	0x45610000

08008bb4 <report_probe_parameters>:

// Prints current probe parameters. Upon a probe command, these parameters are updated upon a
// successful probe or upon a failed probe with the G38.3 without errors command (if supported).
// These values are retained until Grbl is power-cycled, whereby they will be re-zeroed.
void report_probe_parameters()
{
 8008bb4:	b580      	push	{r7, lr}
 8008bb6:	b084      	sub	sp, #16
 8008bb8:	af00      	add	r7, sp, #0
  // Report in terms of machine position.
  printPgmString(PSTR("[PRB:"));
 8008bba:	4b0e      	ldr	r3, [pc, #56]	; (8008bf4 <report_probe_parameters+0x40>)
 8008bbc:	0018      	movs	r0, r3
 8008bbe:	f7fe fd99 	bl	80076f4 <printString>
  float print_position[N_AXIS];
  system_convert_array_steps_to_mpos(print_position,sys_probe_position);
 8008bc2:	4a0d      	ldr	r2, [pc, #52]	; (8008bf8 <report_probe_parameters+0x44>)
 8008bc4:	003b      	movs	r3, r7
 8008bc6:	0011      	movs	r1, r2
 8008bc8:	0018      	movs	r0, r3
 8008bca:	f003 f9df 	bl	800bf8c <system_convert_array_steps_to_mpos>
  report_util_axis_values(print_position);
 8008bce:	003b      	movs	r3, r7
 8008bd0:	0018      	movs	r0, r3
 8008bd2:	f7ff fd81 	bl	80086d8 <report_util_axis_values>
  serial_write(':');
 8008bd6:	203a      	movs	r0, #58	; 0x3a
 8008bd8:	f000 fc40 	bl	800945c <serial_write>
  print_uint8_base10(sys.probe_succeeded);
 8008bdc:	4b07      	ldr	r3, [pc, #28]	; (8008bfc <report_probe_parameters+0x48>)
 8008bde:	795b      	ldrb	r3, [r3, #5]
 8008be0:	0018      	movs	r0, r3
 8008be2:	f7fe fd9b 	bl	800771c <print_uint8_base10>
  report_util_feedback_line_feed();
 8008be6:	f7ff fd55 	bl	8008694 <report_util_feedback_line_feed>
}
 8008bea:	46c0      	nop			; (mov r8, r8)
 8008bec:	46bd      	mov	sp, r7
 8008bee:	b004      	add	sp, #16
 8008bf0:	bd80      	pop	{r7, pc}
 8008bf2:	46c0      	nop			; (mov r8, r8)
 8008bf4:	0800db44 	.word	0x0800db44
 8008bf8:	20000bcc 	.word	0x20000bcc
 8008bfc:	20000bb4 	.word	0x20000bb4

08008c00 <report_ngc_parameters>:


// Prints Grbl NGC parameters (coordinate offsets, probing)
void report_ngc_parameters()
{
 8008c00:	b580      	push	{r7, lr}
 8008c02:	b086      	sub	sp, #24
 8008c04:	af00      	add	r7, sp, #0
  float coord_data[N_AXIS];
  uint8_t coord_select;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) {
 8008c06:	2317      	movs	r3, #23
 8008c08:	18fb      	adds	r3, r7, r3
 8008c0a:	2200      	movs	r2, #0
 8008c0c:	701a      	strb	r2, [r3, #0]
 8008c0e:	e03c      	b.n	8008c8a <report_ngc_parameters+0x8a>
    if (!(settings_read_coord_data(coord_select,coord_data))) {
 8008c10:	1d3a      	adds	r2, r7, #4
 8008c12:	2317      	movs	r3, #23
 8008c14:	18fb      	adds	r3, r7, r3
 8008c16:	781b      	ldrb	r3, [r3, #0]
 8008c18:	0011      	movs	r1, r2
 8008c1a:	0018      	movs	r0, r3
 8008c1c:	f000 fee4 	bl	80099e8 <settings_read_coord_data>
 8008c20:	1e03      	subs	r3, r0, #0
 8008c22:	d103      	bne.n	8008c2c <report_ngc_parameters+0x2c>
      report_status_message(STATUS_SETTING_READ_FAIL);
 8008c24:	2007      	movs	r0, #7
 8008c26:	f7ff fdb7 	bl	8008798 <report_status_message>
 8008c2a:	e04a      	b.n	8008cc2 <report_ngc_parameters+0xc2>
      return;
    }
    printPgmString(PSTR("[G"));
 8008c2c:	4b26      	ldr	r3, [pc, #152]	; (8008cc8 <report_ngc_parameters+0xc8>)
 8008c2e:	0018      	movs	r0, r3
 8008c30:	f7fe fd60 	bl	80076f4 <printString>
    switch (coord_select) {
 8008c34:	2317      	movs	r3, #23
 8008c36:	18fb      	adds	r3, r7, r3
 8008c38:	781b      	ldrb	r3, [r3, #0]
 8008c3a:	2b06      	cmp	r3, #6
 8008c3c:	d002      	beq.n	8008c44 <report_ngc_parameters+0x44>
 8008c3e:	2b07      	cmp	r3, #7
 8008c40:	d005      	beq.n	8008c4e <report_ngc_parameters+0x4e>
 8008c42:	e009      	b.n	8008c58 <report_ngc_parameters+0x58>
      case 6: printPgmString(PSTR("28")); break;
 8008c44:	4b21      	ldr	r3, [pc, #132]	; (8008ccc <report_ngc_parameters+0xcc>)
 8008c46:	0018      	movs	r0, r3
 8008c48:	f7fe fd54 	bl	80076f4 <printString>
 8008c4c:	e00d      	b.n	8008c6a <report_ngc_parameters+0x6a>
      case 7: printPgmString(PSTR("30")); break;
 8008c4e:	4b20      	ldr	r3, [pc, #128]	; (8008cd0 <report_ngc_parameters+0xd0>)
 8008c50:	0018      	movs	r0, r3
 8008c52:	f7fe fd4f 	bl	80076f4 <printString>
 8008c56:	e008      	b.n	8008c6a <report_ngc_parameters+0x6a>
      default: print_uint8_base10(coord_select+54); break; // G54-G59
 8008c58:	2317      	movs	r3, #23
 8008c5a:	18fb      	adds	r3, r7, r3
 8008c5c:	781b      	ldrb	r3, [r3, #0]
 8008c5e:	3336      	adds	r3, #54	; 0x36
 8008c60:	b2db      	uxtb	r3, r3
 8008c62:	0018      	movs	r0, r3
 8008c64:	f7fe fd5a 	bl	800771c <print_uint8_base10>
 8008c68:	46c0      	nop			; (mov r8, r8)
    }
    serial_write(':');
 8008c6a:	203a      	movs	r0, #58	; 0x3a
 8008c6c:	f000 fbf6 	bl	800945c <serial_write>
    report_util_axis_values(coord_data);
 8008c70:	1d3b      	adds	r3, r7, #4
 8008c72:	0018      	movs	r0, r3
 8008c74:	f7ff fd30 	bl	80086d8 <report_util_axis_values>
    report_util_feedback_line_feed();
 8008c78:	f7ff fd0c 	bl	8008694 <report_util_feedback_line_feed>
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) {
 8008c7c:	2317      	movs	r3, #23
 8008c7e:	18fb      	adds	r3, r7, r3
 8008c80:	781a      	ldrb	r2, [r3, #0]
 8008c82:	2317      	movs	r3, #23
 8008c84:	18fb      	adds	r3, r7, r3
 8008c86:	3201      	adds	r2, #1
 8008c88:	701a      	strb	r2, [r3, #0]
 8008c8a:	2317      	movs	r3, #23
 8008c8c:	18fb      	adds	r3, r7, r3
 8008c8e:	781b      	ldrb	r3, [r3, #0]
 8008c90:	2b07      	cmp	r3, #7
 8008c92:	d9bd      	bls.n	8008c10 <report_ngc_parameters+0x10>
  }
  printPgmString(PSTR("[G92:")); // Print G92,G92.1 which are not persistent in memory
 8008c94:	4b0f      	ldr	r3, [pc, #60]	; (8008cd4 <report_ngc_parameters+0xd4>)
 8008c96:	0018      	movs	r0, r3
 8008c98:	f7fe fd2c 	bl	80076f4 <printString>
  report_util_axis_values(gc_state.coord_offset);
 8008c9c:	4b0e      	ldr	r3, [pc, #56]	; (8008cd8 <report_ngc_parameters+0xd8>)
 8008c9e:	0018      	movs	r0, r3
 8008ca0:	f7ff fd1a 	bl	80086d8 <report_util_axis_values>
  report_util_feedback_line_feed();
 8008ca4:	f7ff fcf6 	bl	8008694 <report_util_feedback_line_feed>
  printPgmString(PSTR("[TLO:")); // Print tool length offset value
 8008ca8:	4b0c      	ldr	r3, [pc, #48]	; (8008cdc <report_ngc_parameters+0xdc>)
 8008caa:	0018      	movs	r0, r3
 8008cac:	f7fe fd22 	bl	80076f4 <printString>
  printFloat_CoordValue(gc_state.tool_length_offset);
 8008cb0:	4b0b      	ldr	r3, [pc, #44]	; (8008ce0 <report_ngc_parameters+0xe0>)
 8008cb2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8008cb4:	1c18      	adds	r0, r3, #0
 8008cb6:	f7fe fe4b 	bl	8007950 <printFloat_CoordValue>
  report_util_feedback_line_feed();
 8008cba:	f7ff fceb 	bl	8008694 <report_util_feedback_line_feed>
  report_probe_parameters(); // Print probe parameters. Not persistent in memory.
 8008cbe:	f7ff ff79 	bl	8008bb4 <report_probe_parameters>
}
 8008cc2:	46bd      	mov	sp, r7
 8008cc4:	b006      	add	sp, #24
 8008cc6:	bd80      	pop	{r7, pc}
 8008cc8:	0800db4c 	.word	0x0800db4c
 8008ccc:	0800db50 	.word	0x0800db50
 8008cd0:	0800db54 	.word	0x0800db54
 8008cd4:	0800db58 	.word	0x0800db58
 8008cd8:	20000a00 	.word	0x20000a00
 8008cdc:	0800db60 	.word	0x0800db60
 8008ce0:	200009c4 	.word	0x200009c4

08008ce4 <report_gcode_modes>:


// Print current gcode parser mode state
void report_gcode_modes()
{
 8008ce4:	b580      	push	{r7, lr}
 8008ce6:	af00      	add	r7, sp, #0
  printPgmString(PSTR("[GC:G"));
 8008ce8:	4b52      	ldr	r3, [pc, #328]	; (8008e34 <report_gcode_modes+0x150>)
 8008cea:	0018      	movs	r0, r3
 8008cec:	f7fe fd02 	bl	80076f4 <printString>
  if (gc_state.modal.motion >= MOTION_MODE_PROBE_TOWARD) {
 8008cf0:	4b51      	ldr	r3, [pc, #324]	; (8008e38 <report_gcode_modes+0x154>)
 8008cf2:	781b      	ldrb	r3, [r3, #0]
 8008cf4:	2b8b      	cmp	r3, #139	; 0x8b
 8008cf6:	d90b      	bls.n	8008d10 <report_gcode_modes+0x2c>
    printPgmString(PSTR("38."));
 8008cf8:	4b50      	ldr	r3, [pc, #320]	; (8008e3c <report_gcode_modes+0x158>)
 8008cfa:	0018      	movs	r0, r3
 8008cfc:	f7fe fcfa 	bl	80076f4 <printString>
    print_uint8_base10(gc_state.modal.motion - (MOTION_MODE_PROBE_TOWARD-2));
 8008d00:	4b4d      	ldr	r3, [pc, #308]	; (8008e38 <report_gcode_modes+0x154>)
 8008d02:	781b      	ldrb	r3, [r3, #0]
 8008d04:	3376      	adds	r3, #118	; 0x76
 8008d06:	b2db      	uxtb	r3, r3
 8008d08:	0018      	movs	r0, r3
 8008d0a:	f7fe fd07 	bl	800771c <print_uint8_base10>
 8008d0e:	e004      	b.n	8008d1a <report_gcode_modes+0x36>
  } else {
    print_uint8_base10(gc_state.modal.motion);
 8008d10:	4b49      	ldr	r3, [pc, #292]	; (8008e38 <report_gcode_modes+0x154>)
 8008d12:	781b      	ldrb	r3, [r3, #0]
 8008d14:	0018      	movs	r0, r3
 8008d16:	f7fe fd01 	bl	800771c <print_uint8_base10>
  }

  report_util_gcode_modes_G();
 8008d1a:	f7ff fcc5 	bl	80086a8 <report_util_gcode_modes_G>
  print_uint8_base10(gc_state.modal.coord_select+54);
 8008d1e:	4b46      	ldr	r3, [pc, #280]	; (8008e38 <report_gcode_modes+0x154>)
 8008d20:	799b      	ldrb	r3, [r3, #6]
 8008d22:	3336      	adds	r3, #54	; 0x36
 8008d24:	b2db      	uxtb	r3, r3
 8008d26:	0018      	movs	r0, r3
 8008d28:	f7fe fcf8 	bl	800771c <print_uint8_base10>

  report_util_gcode_modes_G();
 8008d2c:	f7ff fcbc 	bl	80086a8 <report_util_gcode_modes_G>
  print_uint8_base10(gc_state.modal.plane_select+17);
 8008d30:	4b41      	ldr	r3, [pc, #260]	; (8008e38 <report_gcode_modes+0x154>)
 8008d32:	791b      	ldrb	r3, [r3, #4]
 8008d34:	3311      	adds	r3, #17
 8008d36:	b2db      	uxtb	r3, r3
 8008d38:	0018      	movs	r0, r3
 8008d3a:	f7fe fcef 	bl	800771c <print_uint8_base10>

  report_util_gcode_modes_G();
 8008d3e:	f7ff fcb3 	bl	80086a8 <report_util_gcode_modes_G>
  print_uint8_base10(21-gc_state.modal.units);
 8008d42:	4b3d      	ldr	r3, [pc, #244]	; (8008e38 <report_gcode_modes+0x154>)
 8008d44:	789b      	ldrb	r3, [r3, #2]
 8008d46:	2215      	movs	r2, #21
 8008d48:	1ad3      	subs	r3, r2, r3
 8008d4a:	b2db      	uxtb	r3, r3
 8008d4c:	0018      	movs	r0, r3
 8008d4e:	f7fe fce5 	bl	800771c <print_uint8_base10>

  report_util_gcode_modes_G();
 8008d52:	f7ff fca9 	bl	80086a8 <report_util_gcode_modes_G>
  print_uint8_base10(gc_state.modal.distance+90);
 8008d56:	4b38      	ldr	r3, [pc, #224]	; (8008e38 <report_gcode_modes+0x154>)
 8008d58:	78db      	ldrb	r3, [r3, #3]
 8008d5a:	335a      	adds	r3, #90	; 0x5a
 8008d5c:	b2db      	uxtb	r3, r3
 8008d5e:	0018      	movs	r0, r3
 8008d60:	f7fe fcdc 	bl	800771c <print_uint8_base10>

  report_util_gcode_modes_G();
 8008d64:	f7ff fca0 	bl	80086a8 <report_util_gcode_modes_G>
  print_uint8_base10(94-gc_state.modal.feed_rate);
 8008d68:	4b33      	ldr	r3, [pc, #204]	; (8008e38 <report_gcode_modes+0x154>)
 8008d6a:	785b      	ldrb	r3, [r3, #1]
 8008d6c:	225e      	movs	r2, #94	; 0x5e
 8008d6e:	1ad3      	subs	r3, r2, r3
 8008d70:	b2db      	uxtb	r3, r3
 8008d72:	0018      	movs	r0, r3
 8008d74:	f7fe fcd2 	bl	800771c <print_uint8_base10>

  if (gc_state.modal.program_flow) {
 8008d78:	4b2f      	ldr	r3, [pc, #188]	; (8008e38 <report_gcode_modes+0x154>)
 8008d7a:	79db      	ldrb	r3, [r3, #7]
 8008d7c:	2b00      	cmp	r3, #0
 8008d7e:	d014      	beq.n	8008daa <report_gcode_modes+0xc6>
    report_util_gcode_modes_M();
 8008d80:	f7ff fc9e 	bl	80086c0 <report_util_gcode_modes_M>
    switch (gc_state.modal.program_flow) {
 8008d84:	4b2c      	ldr	r3, [pc, #176]	; (8008e38 <report_gcode_modes+0x154>)
 8008d86:	79db      	ldrb	r3, [r3, #7]
 8008d88:	2b03      	cmp	r3, #3
 8008d8a:	d004      	beq.n	8008d96 <report_gcode_modes+0xb2>
 8008d8c:	2b1e      	cmp	r3, #30
 8008d8e:	d006      	beq.n	8008d9e <report_gcode_modes+0xba>
 8008d90:	2b02      	cmp	r3, #2
 8008d92:	d004      	beq.n	8008d9e <report_gcode_modes+0xba>
 8008d94:	e009      	b.n	8008daa <report_gcode_modes+0xc6>
      case PROGRAM_FLOW_PAUSED : serial_write('0'); break;
 8008d96:	2030      	movs	r0, #48	; 0x30
 8008d98:	f000 fb60 	bl	800945c <serial_write>
 8008d9c:	e005      	b.n	8008daa <report_gcode_modes+0xc6>
      // case PROGRAM_FLOW_OPTIONAL_STOP : serial_write('1'); break; // M1 is ignored and not supported.
      case PROGRAM_FLOW_COMPLETED_M2 : 
      case PROGRAM_FLOW_COMPLETED_M30 : 
        print_uint8_base10(gc_state.modal.program_flow);
 8008d9e:	4b26      	ldr	r3, [pc, #152]	; (8008e38 <report_gcode_modes+0x154>)
 8008da0:	79db      	ldrb	r3, [r3, #7]
 8008da2:	0018      	movs	r0, r3
 8008da4:	f7fe fcba 	bl	800771c <print_uint8_base10>
        break;
 8008da8:	46c0      	nop			; (mov r8, r8)
    }
  }

  report_util_gcode_modes_M();
 8008daa:	f7ff fc89 	bl	80086c0 <report_util_gcode_modes_M>
  switch (gc_state.modal.spindle) {
 8008dae:	4b22      	ldr	r3, [pc, #136]	; (8008e38 <report_gcode_modes+0x154>)
 8008db0:	7a5b      	ldrb	r3, [r3, #9]
 8008db2:	2b10      	cmp	r3, #16
 8008db4:	d004      	beq.n	8008dc0 <report_gcode_modes+0xdc>
 8008db6:	2b20      	cmp	r3, #32
 8008db8:	d006      	beq.n	8008dc8 <report_gcode_modes+0xe4>
 8008dba:	2b00      	cmp	r3, #0
 8008dbc:	d008      	beq.n	8008dd0 <report_gcode_modes+0xec>
 8008dbe:	e00b      	b.n	8008dd8 <report_gcode_modes+0xf4>
    case SPINDLE_ENABLE_CW : serial_write('3'); break;
 8008dc0:	2033      	movs	r0, #51	; 0x33
 8008dc2:	f000 fb4b 	bl	800945c <serial_write>
 8008dc6:	e007      	b.n	8008dd8 <report_gcode_modes+0xf4>
    case SPINDLE_ENABLE_CCW : serial_write('4'); break;
 8008dc8:	2034      	movs	r0, #52	; 0x34
 8008dca:	f000 fb47 	bl	800945c <serial_write>
 8008dce:	e003      	b.n	8008dd8 <report_gcode_modes+0xf4>
    case SPINDLE_DISABLE : serial_write('5'); break;
 8008dd0:	2035      	movs	r0, #53	; 0x35
 8008dd2:	f000 fb43 	bl	800945c <serial_write>
 8008dd6:	46c0      	nop			; (mov r8, r8)
  }

  report_util_gcode_modes_M();
 8008dd8:	f7ff fc72 	bl	80086c0 <report_util_gcode_modes_M>
    if (gc_state.modal.coolant) { // Note: Multiple coolant states may be active at the same time.
      if (gc_state.modal.coolant & PL_COND_FLAG_COOLANT_MIST) { serial_write('7'); }
      if (gc_state.modal.coolant & PL_COND_FLAG_COOLANT_FLOOD) { serial_write('8'); }
    } else { serial_write('9'); }
  #else
    if (gc_state.modal.coolant) { serial_write('8'); }
 8008ddc:	4b16      	ldr	r3, [pc, #88]	; (8008e38 <report_gcode_modes+0x154>)
 8008dde:	7a1b      	ldrb	r3, [r3, #8]
 8008de0:	2b00      	cmp	r3, #0
 8008de2:	d003      	beq.n	8008dec <report_gcode_modes+0x108>
 8008de4:	2038      	movs	r0, #56	; 0x38
 8008de6:	f000 fb39 	bl	800945c <serial_write>
 8008dea:	e002      	b.n	8008df2 <report_gcode_modes+0x10e>
    else { serial_write('9'); }
 8008dec:	2039      	movs	r0, #57	; 0x39
 8008dee:	f000 fb35 	bl	800945c <serial_write>
			report_util_gcode_modes_M();
			print_uint8_base10(56);
		}
	#endif

  printPgmString(PSTR(" T"));
 8008df2:	4b13      	ldr	r3, [pc, #76]	; (8008e40 <report_gcode_modes+0x15c>)
 8008df4:	0018      	movs	r0, r3
 8008df6:	f7fe fc7d 	bl	80076f4 <printString>
  print_uint8_base10(gc_state.tool);
 8008dfa:	4b0f      	ldr	r3, [pc, #60]	; (8008e38 <report_gcode_modes+0x154>)
 8008dfc:	7d1b      	ldrb	r3, [r3, #20]
 8008dfe:	0018      	movs	r0, r3
 8008e00:	f7fe fc8c 	bl	800771c <print_uint8_base10>

  printPgmString(PSTR(" F"));
 8008e04:	4b0f      	ldr	r3, [pc, #60]	; (8008e44 <report_gcode_modes+0x160>)
 8008e06:	0018      	movs	r0, r3
 8008e08:	f7fe fc74 	bl	80076f4 <printString>
  printFloat_RateValue(gc_state.feed_rate);
 8008e0c:	4b0a      	ldr	r3, [pc, #40]	; (8008e38 <report_gcode_modes+0x154>)
 8008e0e:	691b      	ldr	r3, [r3, #16]
 8008e10:	1c18      	adds	r0, r3, #0
 8008e12:	f7fe fdbf 	bl	8007994 <printFloat_RateValue>

  #ifdef VARIABLE_SPINDLE
    printPgmString(PSTR(" S"));
 8008e16:	4b0c      	ldr	r3, [pc, #48]	; (8008e48 <report_gcode_modes+0x164>)
 8008e18:	0018      	movs	r0, r3
 8008e1a:	f7fe fc6b 	bl	80076f4 <printString>
    printFloat(gc_state.spindle_speed,N_DECIMAL_RPMVALUE);
 8008e1e:	4b06      	ldr	r3, [pc, #24]	; (8008e38 <report_gcode_modes+0x154>)
 8008e20:	68db      	ldr	r3, [r3, #12]
 8008e22:	2100      	movs	r1, #0
 8008e24:	1c18      	adds	r0, r3, #0
 8008e26:	f7fe fcdb 	bl	80077e0 <printFloat>
  #endif

  report_util_feedback_line_feed();
 8008e2a:	f7ff fc33 	bl	8008694 <report_util_feedback_line_feed>
}
 8008e2e:	46c0      	nop			; (mov r8, r8)
 8008e30:	46bd      	mov	sp, r7
 8008e32:	bd80      	pop	{r7, pc}
 8008e34:	0800db68 	.word	0x0800db68
 8008e38:	200009c4 	.word	0x200009c4
 8008e3c:	0800db70 	.word	0x0800db70
 8008e40:	0800db74 	.word	0x0800db74
 8008e44:	0800db78 	.word	0x0800db78
 8008e48:	0800db7c 	.word	0x0800db7c

08008e4c <report_startup_line>:

// Prints specified startup line
void report_startup_line(uint8_t n, char *line)
{
 8008e4c:	b580      	push	{r7, lr}
 8008e4e:	b082      	sub	sp, #8
 8008e50:	af00      	add	r7, sp, #0
 8008e52:	0002      	movs	r2, r0
 8008e54:	6039      	str	r1, [r7, #0]
 8008e56:	1dfb      	adds	r3, r7, #7
 8008e58:	701a      	strb	r2, [r3, #0]
  printPgmString(PSTR("$N"));
 8008e5a:	4b0b      	ldr	r3, [pc, #44]	; (8008e88 <report_startup_line+0x3c>)
 8008e5c:	0018      	movs	r0, r3
 8008e5e:	f7fe fc49 	bl	80076f4 <printString>
  print_uint8_base10(n);
 8008e62:	1dfb      	adds	r3, r7, #7
 8008e64:	781b      	ldrb	r3, [r3, #0]
 8008e66:	0018      	movs	r0, r3
 8008e68:	f7fe fc58 	bl	800771c <print_uint8_base10>
  serial_write('=');
 8008e6c:	203d      	movs	r0, #61	; 0x3d
 8008e6e:	f000 faf5 	bl	800945c <serial_write>
  printString(line);
 8008e72:	683b      	ldr	r3, [r7, #0]
 8008e74:	0018      	movs	r0, r3
 8008e76:	f7fe fc3d 	bl	80076f4 <printString>
  report_util_line_feed();
 8008e7a:	f7ff fbff 	bl	800867c <report_util_line_feed>
}
 8008e7e:	46c0      	nop			; (mov r8, r8)
 8008e80:	46bd      	mov	sp, r7
 8008e82:	b002      	add	sp, #8
 8008e84:	bd80      	pop	{r7, pc}
 8008e86:	46c0      	nop			; (mov r8, r8)
 8008e88:	0800db80 	.word	0x0800db80

08008e8c <report_execute_startup_message>:

void report_execute_startup_message(char *line, uint8_t status_code)
{
 8008e8c:	b580      	push	{r7, lr}
 8008e8e:	b082      	sub	sp, #8
 8008e90:	af00      	add	r7, sp, #0
 8008e92:	6078      	str	r0, [r7, #4]
 8008e94:	000a      	movs	r2, r1
 8008e96:	1cfb      	adds	r3, r7, #3
 8008e98:	701a      	strb	r2, [r3, #0]
  serial_write('>');
 8008e9a:	203e      	movs	r0, #62	; 0x3e
 8008e9c:	f000 fade 	bl	800945c <serial_write>
  printString(line);
 8008ea0:	687b      	ldr	r3, [r7, #4]
 8008ea2:	0018      	movs	r0, r3
 8008ea4:	f7fe fc26 	bl	80076f4 <printString>
  serial_write(':');
 8008ea8:	203a      	movs	r0, #58	; 0x3a
 8008eaa:	f000 fad7 	bl	800945c <serial_write>
  report_status_message(status_code);
 8008eae:	1cfb      	adds	r3, r7, #3
 8008eb0:	781b      	ldrb	r3, [r3, #0]
 8008eb2:	0018      	movs	r0, r3
 8008eb4:	f7ff fc70 	bl	8008798 <report_status_message>
}
 8008eb8:	46c0      	nop			; (mov r8, r8)
 8008eba:	46bd      	mov	sp, r7
 8008ebc:	b002      	add	sp, #8
 8008ebe:	bd80      	pop	{r7, pc}

08008ec0 <report_build_info>:

// Prints build info line
void report_build_info(char *line)
{
 8008ec0:	b580      	push	{r7, lr}
 8008ec2:	b082      	sub	sp, #8
 8008ec4:	af00      	add	r7, sp, #0
 8008ec6:	6078      	str	r0, [r7, #4]
  printPgmString(PSTR("[VER:" GRBL_VERSION "." GRBL_VERSION_BUILD ":"));
 8008ec8:	4b12      	ldr	r3, [pc, #72]	; (8008f14 <report_build_info+0x54>)
 8008eca:	0018      	movs	r0, r3
 8008ecc:	f7fe fc12 	bl	80076f4 <printString>
  printString(line);
 8008ed0:	687b      	ldr	r3, [r7, #4]
 8008ed2:	0018      	movs	r0, r3
 8008ed4:	f7fe fc0e 	bl	80076f4 <printString>
  report_util_feedback_line_feed();
 8008ed8:	f7ff fbdc 	bl	8008694 <report_util_feedback_line_feed>
  printPgmString(PSTR("[OPT:")); // Generate compile-time build option list
 8008edc:	4b0e      	ldr	r3, [pc, #56]	; (8008f18 <report_build_info+0x58>)
 8008ede:	0018      	movs	r0, r3
 8008ee0:	f7fe fc08 	bl	80076f4 <printString>
  #ifdef VARIABLE_SPINDLE
    serial_write('V');
 8008ee4:	2056      	movs	r0, #86	; 0x56
 8008ee6:	f000 fab9 	bl	800945c <serial_write>
  #endif
  #ifdef ENABLE_M7
    serial_write('M');
  #endif
  #ifdef COREXY
    serial_write('C');
 8008eea:	2043      	movs	r0, #67	; 0x43
 8008eec:	f000 fab6 	bl	800945c <serial_write>
	#ifndef HOMING_INIT_LOCK
		serial_write('L');
	#endif

  // NOTE: Compiled values, like override increments/max/min values, may be added at some point later.
	serial_write(',');
 8008ef0:	202c      	movs	r0, #44	; 0x2c
 8008ef2:	f000 fab3 	bl	800945c <serial_write>
	print_uint8_base10(BLOCK_BUFFER_SIZE - 1);
 8008ef6:	200f      	movs	r0, #15
 8008ef8:	f7fe fc10 	bl	800771c <print_uint8_base10>
	serial_write(',');
 8008efc:	202c      	movs	r0, #44	; 0x2c
 8008efe:	f000 faad 	bl	800945c <serial_write>
	print_uint8_base10(RX_BUFFER_SIZE);
 8008f02:	2080      	movs	r0, #128	; 0x80
 8008f04:	f7fe fc0a 	bl	800771c <print_uint8_base10>

	report_util_feedback_line_feed();
 8008f08:	f7ff fbc4 	bl	8008694 <report_util_feedback_line_feed>
}
 8008f0c:	46c0      	nop			; (mov r8, r8)
 8008f0e:	46bd      	mov	sp, r7
 8008f10:	b002      	add	sp, #8
 8008f12:	bd80      	pop	{r7, pc}
 8008f14:	0800db84 	.word	0x0800db84
 8008f18:	0800db98 	.word	0x0800db98

08008f1c <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly,
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
 8008f1c:	b590      	push	{r4, r7, lr}
 8008f1e:	b08f      	sub	sp, #60	; 0x3c
 8008f20:	af00      	add	r7, sp, #0
  uint8_t idx;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position, sys_position, sizeof(sys_position));
 8008f22:	2320      	movs	r3, #32
 8008f24:	18fb      	adds	r3, r7, r3
 8008f26:	4a84      	ldr	r2, [pc, #528]	; (8009138 <report_realtime_status+0x21c>)
 8008f28:	ca13      	ldmia	r2!, {r0, r1, r4}
 8008f2a:	c313      	stmia	r3!, {r0, r1, r4}
 8008f2c:	6812      	ldr	r2, [r2, #0]
 8008f2e:	601a      	str	r2, [r3, #0]
  float print_position[N_AXIS];
  system_convert_array_steps_to_mpos(print_position, current_position);
 8008f30:	2320      	movs	r3, #32
 8008f32:	18fa      	adds	r2, r7, r3
 8008f34:	2310      	movs	r3, #16
 8008f36:	18fb      	adds	r3, r7, r3
 8008f38:	0011      	movs	r1, r2
 8008f3a:	0018      	movs	r0, r3
 8008f3c:	f003 f826 	bl	800bf8c <system_convert_array_steps_to_mpos>

  // Report current machine state and sub-states
  serial_write('<');
 8008f40:	203c      	movs	r0, #60	; 0x3c
 8008f42:	f000 fa8b 	bl	800945c <serial_write>
  switch (sys.state) {
 8008f46:	4b7d      	ldr	r3, [pc, #500]	; (800913c <report_realtime_status+0x220>)
 8008f48:	781b      	ldrb	r3, [r3, #0]
 8008f4a:	2b08      	cmp	r3, #8
 8008f4c:	d01b      	beq.n	8008f86 <report_realtime_status+0x6a>
 8008f4e:	dc0a      	bgt.n	8008f66 <report_realtime_status+0x4a>
 8008f50:	2b01      	cmp	r3, #1
 8008f52:	d03e      	beq.n	8008fd2 <report_realtime_status+0xb6>
 8008f54:	dc02      	bgt.n	8008f5c <report_realtime_status+0x40>
 8008f56:	2b00      	cmp	r3, #0
 8008f58:	d010      	beq.n	8008f7c <report_realtime_status+0x60>
 8008f5a:	e06f      	b.n	800903c <report_realtime_status+0x120>
 8008f5c:	2b02      	cmp	r3, #2
 8008f5e:	d03d      	beq.n	8008fdc <report_realtime_status+0xc0>
 8008f60:	2b04      	cmp	r3, #4
 8008f62:	d031      	beq.n	8008fc8 <report_realtime_status+0xac>
 8008f64:	e06a      	b.n	800903c <report_realtime_status+0x120>
 8008f66:	2b20      	cmp	r3, #32
 8008f68:	d029      	beq.n	8008fbe <report_realtime_status+0xa2>
 8008f6a:	dc02      	bgt.n	8008f72 <report_realtime_status+0x56>
 8008f6c:	2b10      	cmp	r3, #16
 8008f6e:	d00f      	beq.n	8008f90 <report_realtime_status+0x74>
 8008f70:	e064      	b.n	800903c <report_realtime_status+0x120>
 8008f72:	2b40      	cmp	r3, #64	; 0x40
 8008f74:	d037      	beq.n	8008fe6 <report_realtime_status+0xca>
 8008f76:	2b80      	cmp	r3, #128	; 0x80
 8008f78:	d05b      	beq.n	8009032 <report_realtime_status+0x116>
 8008f7a:	e05f      	b.n	800903c <report_realtime_status+0x120>
  case STATE_IDLE: printPgmString(PSTR("Idle")); break;
 8008f7c:	4b70      	ldr	r3, [pc, #448]	; (8009140 <report_realtime_status+0x224>)
 8008f7e:	0018      	movs	r0, r3
 8008f80:	f7fe fbb8 	bl	80076f4 <printString>
 8008f84:	e05a      	b.n	800903c <report_realtime_status+0x120>
  case STATE_CYCLE: printPgmString(PSTR("Run")); break;
 8008f86:	4b6f      	ldr	r3, [pc, #444]	; (8009144 <report_realtime_status+0x228>)
 8008f88:	0018      	movs	r0, r3
 8008f8a:	f7fe fbb3 	bl	80076f4 <printString>
 8008f8e:	e055      	b.n	800903c <report_realtime_status+0x120>
  case STATE_HOLD:
    if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
 8008f90:	4b6a      	ldr	r3, [pc, #424]	; (800913c <report_realtime_status+0x220>)
 8008f92:	789b      	ldrb	r3, [r3, #2]
 8008f94:	b25b      	sxtb	r3, r3
 8008f96:	2b00      	cmp	r3, #0
 8008f98:	db11      	blt.n	8008fbe <report_realtime_status+0xa2>
      printPgmString(PSTR("Hold:"));
 8008f9a:	4b6b      	ldr	r3, [pc, #428]	; (8009148 <report_realtime_status+0x22c>)
 8008f9c:	0018      	movs	r0, r3
 8008f9e:	f7fe fba9 	bl	80076f4 <printString>
      if (sys.suspend & SUSPEND_HOLD_COMPLETE) { serial_write('0'); } // Ready to resume
 8008fa2:	4b66      	ldr	r3, [pc, #408]	; (800913c <report_realtime_status+0x220>)
 8008fa4:	789b      	ldrb	r3, [r3, #2]
 8008fa6:	001a      	movs	r2, r3
 8008fa8:	2301      	movs	r3, #1
 8008faa:	4013      	ands	r3, r2
 8008fac:	d003      	beq.n	8008fb6 <report_realtime_status+0x9a>
 8008fae:	2030      	movs	r0, #48	; 0x30
 8008fb0:	f000 fa54 	bl	800945c <serial_write>
      else { serial_write('1'); } // Actively holding
      break;
 8008fb4:	e042      	b.n	800903c <report_realtime_status+0x120>
      else { serial_write('1'); } // Actively holding
 8008fb6:	2031      	movs	r0, #49	; 0x31
 8008fb8:	f000 fa50 	bl	800945c <serial_write>
      break;
 8008fbc:	e03e      	b.n	800903c <report_realtime_status+0x120>
    } // Continues to print jog state during jog cancel.
  case STATE_JOG: printPgmString(PSTR("Jog")); break;
 8008fbe:	4b63      	ldr	r3, [pc, #396]	; (800914c <report_realtime_status+0x230>)
 8008fc0:	0018      	movs	r0, r3
 8008fc2:	f7fe fb97 	bl	80076f4 <printString>
 8008fc6:	e039      	b.n	800903c <report_realtime_status+0x120>
  case STATE_HOMING: printPgmString(PSTR("Home")); break;
 8008fc8:	4b61      	ldr	r3, [pc, #388]	; (8009150 <report_realtime_status+0x234>)
 8008fca:	0018      	movs	r0, r3
 8008fcc:	f7fe fb92 	bl	80076f4 <printString>
 8008fd0:	e034      	b.n	800903c <report_realtime_status+0x120>
  case STATE_ALARM: printPgmString(PSTR("Alarm")); break;
 8008fd2:	4b60      	ldr	r3, [pc, #384]	; (8009154 <report_realtime_status+0x238>)
 8008fd4:	0018      	movs	r0, r3
 8008fd6:	f7fe fb8d 	bl	80076f4 <printString>
 8008fda:	e02f      	b.n	800903c <report_realtime_status+0x120>
  case STATE_CHECK_MODE: printPgmString(PSTR("Check")); break;
 8008fdc:	4b5e      	ldr	r3, [pc, #376]	; (8009158 <report_realtime_status+0x23c>)
 8008fde:	0018      	movs	r0, r3
 8008fe0:	f7fe fb88 	bl	80076f4 <printString>
 8008fe4:	e02a      	b.n	800903c <report_realtime_status+0x120>
  case STATE_SAFETY_DOOR:
    printPgmString(PSTR("Door:"));
 8008fe6:	4b5d      	ldr	r3, [pc, #372]	; (800915c <report_realtime_status+0x240>)
 8008fe8:	0018      	movs	r0, r3
 8008fea:	f7fe fb83 	bl	80076f4 <printString>
    if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
 8008fee:	4b53      	ldr	r3, [pc, #332]	; (800913c <report_realtime_status+0x220>)
 8008ff0:	789b      	ldrb	r3, [r3, #2]
 8008ff2:	001a      	movs	r2, r3
 8008ff4:	2308      	movs	r3, #8
 8008ff6:	4013      	ands	r3, r2
 8008ff8:	d003      	beq.n	8009002 <report_realtime_status+0xe6>
      serial_write('3'); // Restoring
 8008ffa:	2033      	movs	r0, #51	; 0x33
 8008ffc:	f000 fa2e 	bl	800945c <serial_write>
      }
      else {
        serial_write('2'); // Retracting
      }
    }
    break;
 8009000:	e01c      	b.n	800903c <report_realtime_status+0x120>
      if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
 8009002:	4b4e      	ldr	r3, [pc, #312]	; (800913c <report_realtime_status+0x220>)
 8009004:	789b      	ldrb	r3, [r3, #2]
 8009006:	001a      	movs	r2, r3
 8009008:	2304      	movs	r3, #4
 800900a:	4013      	ands	r3, r2
 800900c:	d00d      	beq.n	800902a <report_realtime_status+0x10e>
        if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) {
 800900e:	4b4b      	ldr	r3, [pc, #300]	; (800913c <report_realtime_status+0x220>)
 8009010:	789b      	ldrb	r3, [r3, #2]
 8009012:	001a      	movs	r2, r3
 8009014:	2320      	movs	r3, #32
 8009016:	4013      	ands	r3, r2
 8009018:	d003      	beq.n	8009022 <report_realtime_status+0x106>
          serial_write('1'); // Door ajar
 800901a:	2031      	movs	r0, #49	; 0x31
 800901c:	f000 fa1e 	bl	800945c <serial_write>
    break;
 8009020:	e00c      	b.n	800903c <report_realtime_status+0x120>
          serial_write('0');
 8009022:	2030      	movs	r0, #48	; 0x30
 8009024:	f000 fa1a 	bl	800945c <serial_write>
    break;
 8009028:	e008      	b.n	800903c <report_realtime_status+0x120>
        serial_write('2'); // Retracting
 800902a:	2032      	movs	r0, #50	; 0x32
 800902c:	f000 fa16 	bl	800945c <serial_write>
    break;
 8009030:	e004      	b.n	800903c <report_realtime_status+0x120>
  case STATE_SLEEP: printPgmString(PSTR("Sleep")); break;
 8009032:	4b4b      	ldr	r3, [pc, #300]	; (8009160 <report_realtime_status+0x244>)
 8009034:	0018      	movs	r0, r3
 8009036:	f7fe fb5d 	bl	80076f4 <printString>
 800903a:	46c0      	nop			; (mov r8, r8)
  }

  float wco[N_AXIS];
  if (bit_isfalse(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE) ||
 800903c:	4b49      	ldr	r3, [pc, #292]	; (8009164 <report_realtime_status+0x248>)
 800903e:	2244      	movs	r2, #68	; 0x44
 8009040:	5c9b      	ldrb	r3, [r3, r2]
 8009042:	001a      	movs	r2, r3
 8009044:	2301      	movs	r3, #1
 8009046:	4013      	ands	r3, r2
 8009048:	d003      	beq.n	8009052 <report_realtime_status+0x136>
    (sys.report_wco_counter == 0)) {
 800904a:	4b3c      	ldr	r3, [pc, #240]	; (800913c <report_realtime_status+0x220>)
 800904c:	7b1b      	ldrb	r3, [r3, #12]
  if (bit_isfalse(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE) ||
 800904e:	2b00      	cmp	r3, #0
 8009050:	d166      	bne.n	8009120 <report_realtime_status+0x204>
    for (idx = 0; idx< N_AXIS; idx++) {
 8009052:	2337      	movs	r3, #55	; 0x37
 8009054:	18fb      	adds	r3, r7, r3
 8009056:	2200      	movs	r2, #0
 8009058:	701a      	strb	r2, [r3, #0]
 800905a:	e05c      	b.n	8009116 <report_realtime_status+0x1fa>
      // Apply work coordinate offsets and tool length offset to current position.
      wco[idx] = gc_state.coord_system[idx] + gc_state.coord_offset[idx];
 800905c:	2337      	movs	r3, #55	; 0x37
 800905e:	18fb      	adds	r3, r7, r3
 8009060:	781c      	ldrb	r4, [r3, #0]
 8009062:	2337      	movs	r3, #55	; 0x37
 8009064:	18fb      	adds	r3, r7, r3
 8009066:	781b      	ldrb	r3, [r3, #0]
 8009068:	4a3f      	ldr	r2, [pc, #252]	; (8009168 <report_realtime_status+0x24c>)
 800906a:	330a      	adds	r3, #10
 800906c:	009b      	lsls	r3, r3, #2
 800906e:	18d3      	adds	r3, r2, r3
 8009070:	3304      	adds	r3, #4
 8009072:	6818      	ldr	r0, [r3, #0]
 8009074:	2337      	movs	r3, #55	; 0x37
 8009076:	18fb      	adds	r3, r7, r3
 8009078:	781b      	ldrb	r3, [r3, #0]
 800907a:	4a3b      	ldr	r2, [pc, #236]	; (8009168 <report_realtime_status+0x24c>)
 800907c:	330e      	adds	r3, #14
 800907e:	009b      	lsls	r3, r3, #2
 8009080:	18d3      	adds	r3, r2, r3
 8009082:	3304      	adds	r3, #4
 8009084:	681b      	ldr	r3, [r3, #0]
 8009086:	1c19      	adds	r1, r3, #0
 8009088:	f7f7 f982 	bl	8000390 <__aeabi_fadd>
 800908c:	1c03      	adds	r3, r0, #0
 800908e:	1c19      	adds	r1, r3, #0
 8009090:	003b      	movs	r3, r7
 8009092:	00a2      	lsls	r2, r4, #2
 8009094:	50d1      	str	r1, [r2, r3]
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { wco[idx] += gc_state.tool_length_offset; }
 8009096:	2337      	movs	r3, #55	; 0x37
 8009098:	18fb      	adds	r3, r7, r3
 800909a:	781b      	ldrb	r3, [r3, #0]
 800909c:	2b02      	cmp	r3, #2
 800909e:	d113      	bne.n	80090c8 <report_realtime_status+0x1ac>
 80090a0:	2337      	movs	r3, #55	; 0x37
 80090a2:	18fb      	adds	r3, r7, r3
 80090a4:	781c      	ldrb	r4, [r3, #0]
 80090a6:	2337      	movs	r3, #55	; 0x37
 80090a8:	18fb      	adds	r3, r7, r3
 80090aa:	781a      	ldrb	r2, [r3, #0]
 80090ac:	003b      	movs	r3, r7
 80090ae:	0092      	lsls	r2, r2, #2
 80090b0:	58d2      	ldr	r2, [r2, r3]
 80090b2:	4b2d      	ldr	r3, [pc, #180]	; (8009168 <report_realtime_status+0x24c>)
 80090b4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80090b6:	1c19      	adds	r1, r3, #0
 80090b8:	1c10      	adds	r0, r2, #0
 80090ba:	f7f7 f969 	bl	8000390 <__aeabi_fadd>
 80090be:	1c03      	adds	r3, r0, #0
 80090c0:	1c19      	adds	r1, r3, #0
 80090c2:	003b      	movs	r3, r7
 80090c4:	00a2      	lsls	r2, r4, #2
 80090c6:	50d1      	str	r1, [r2, r3]
      if (bit_isfalse(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE)) {
 80090c8:	4b26      	ldr	r3, [pc, #152]	; (8009164 <report_realtime_status+0x248>)
 80090ca:	2244      	movs	r2, #68	; 0x44
 80090cc:	5c9b      	ldrb	r3, [r3, r2]
 80090ce:	001a      	movs	r2, r3
 80090d0:	2301      	movs	r3, #1
 80090d2:	4013      	ands	r3, r2
 80090d4:	d118      	bne.n	8009108 <report_realtime_status+0x1ec>
        print_position[idx] -= wco[idx];
 80090d6:	2337      	movs	r3, #55	; 0x37
 80090d8:	18fb      	adds	r3, r7, r3
 80090da:	781c      	ldrb	r4, [r3, #0]
 80090dc:	2337      	movs	r3, #55	; 0x37
 80090de:	18fb      	adds	r3, r7, r3
 80090e0:	781a      	ldrb	r2, [r3, #0]
 80090e2:	2310      	movs	r3, #16
 80090e4:	18fb      	adds	r3, r7, r3
 80090e6:	0092      	lsls	r2, r2, #2
 80090e8:	58d0      	ldr	r0, [r2, r3]
 80090ea:	2337      	movs	r3, #55	; 0x37
 80090ec:	18fb      	adds	r3, r7, r3
 80090ee:	781a      	ldrb	r2, [r3, #0]
 80090f0:	003b      	movs	r3, r7
 80090f2:	0092      	lsls	r2, r2, #2
 80090f4:	58d3      	ldr	r3, [r2, r3]
 80090f6:	1c19      	adds	r1, r3, #0
 80090f8:	f7f7 fdec 	bl	8000cd4 <__aeabi_fsub>
 80090fc:	1c03      	adds	r3, r0, #0
 80090fe:	1c19      	adds	r1, r3, #0
 8009100:	2310      	movs	r3, #16
 8009102:	18fb      	adds	r3, r7, r3
 8009104:	00a2      	lsls	r2, r4, #2
 8009106:	50d1      	str	r1, [r2, r3]
    for (idx = 0; idx< N_AXIS; idx++) {
 8009108:	2337      	movs	r3, #55	; 0x37
 800910a:	18fb      	adds	r3, r7, r3
 800910c:	781a      	ldrb	r2, [r3, #0]
 800910e:	2337      	movs	r3, #55	; 0x37
 8009110:	18fb      	adds	r3, r7, r3
 8009112:	3201      	adds	r2, #1
 8009114:	701a      	strb	r2, [r3, #0]
 8009116:	2337      	movs	r3, #55	; 0x37
 8009118:	18fb      	adds	r3, r7, r3
 800911a:	781b      	ldrb	r3, [r3, #0]
 800911c:	2b03      	cmp	r3, #3
 800911e:	d99d      	bls.n	800905c <report_realtime_status+0x140>
      }
    }
  }

  // Report machine position
  if (bit_istrue(settings.status_report_mask, BITFLAG_RT_STATUS_POSITION_TYPE)) {
 8009120:	4b10      	ldr	r3, [pc, #64]	; (8009164 <report_realtime_status+0x248>)
 8009122:	2244      	movs	r2, #68	; 0x44
 8009124:	5c9b      	ldrb	r3, [r3, r2]
 8009126:	001a      	movs	r2, r3
 8009128:	2301      	movs	r3, #1
 800912a:	4013      	ands	r3, r2
 800912c:	d020      	beq.n	8009170 <report_realtime_status+0x254>
    printPgmString(PSTR("|MPos:"));
 800912e:	4b0f      	ldr	r3, [pc, #60]	; (800916c <report_realtime_status+0x250>)
 8009130:	0018      	movs	r0, r3
 8009132:	f7fe fadf 	bl	80076f4 <printString>
 8009136:	e01f      	b.n	8009178 <report_realtime_status+0x25c>
 8009138:	20000bdc 	.word	0x20000bdc
 800913c:	20000bb4 	.word	0x20000bb4
 8009140:	0800dba8 	.word	0x0800dba8
 8009144:	0800dbb0 	.word	0x0800dbb0
 8009148:	0800dbb4 	.word	0x0800dbb4
 800914c:	0800dbbc 	.word	0x0800dbbc
 8009150:	0800dbc0 	.word	0x0800dbc0
 8009154:	0800dbc8 	.word	0x0800dbc8
 8009158:	0800dbd0 	.word	0x0800dbd0
 800915c:	0800dbd8 	.word	0x0800dbd8
 8009160:	0800dbe0 	.word	0x0800dbe0
 8009164:	20000b44 	.word	0x20000b44
 8009168:	200009c4 	.word	0x200009c4
 800916c:	0800dbe8 	.word	0x0800dbe8
  }
  else {
    printPgmString(PSTR("|WPos:"));
 8009170:	4b9b      	ldr	r3, [pc, #620]	; (80093e0 <report_realtime_status+0x4c4>)
 8009172:	0018      	movs	r0, r3
 8009174:	f7fe fabe 	bl	80076f4 <printString>
  }
  report_util_axis_values(print_position);
 8009178:	2310      	movs	r3, #16
 800917a:	18fb      	adds	r3, r7, r3
 800917c:	0018      	movs	r0, r3
 800917e:	f7ff faab 	bl	80086d8 <report_util_axis_values>

  // Returns planner and serial read buffer states.
#ifdef REPORT_FIELD_BUFFER_STATE
  if (bit_istrue(settings.status_report_mask, BITFLAG_RT_STATUS_BUFFER_STATE)) {
 8009182:	4b98      	ldr	r3, [pc, #608]	; (80093e4 <report_realtime_status+0x4c8>)
 8009184:	2244      	movs	r2, #68	; 0x44
 8009186:	5c9b      	ldrb	r3, [r3, r2]
 8009188:	001a      	movs	r2, r3
 800918a:	2302      	movs	r3, #2
 800918c:	4013      	ands	r3, r2
 800918e:	d012      	beq.n	80091b6 <report_realtime_status+0x29a>
    printPgmString(PSTR("|Bf:"));
 8009190:	4b95      	ldr	r3, [pc, #596]	; (80093e8 <report_realtime_status+0x4cc>)
 8009192:	0018      	movs	r0, r3
 8009194:	f7fe faae 	bl	80076f4 <printString>
    print_uint8_base10(plan_get_block_buffer_available());
 8009198:	f7fe fa7a 	bl	8007690 <plan_get_block_buffer_available>
 800919c:	0003      	movs	r3, r0
 800919e:	0018      	movs	r0, r3
 80091a0:	f7fe fabc 	bl	800771c <print_uint8_base10>
    serial_write(',');
 80091a4:	202c      	movs	r0, #44	; 0x2c
 80091a6:	f000 f959 	bl	800945c <serial_write>
    print_uint8_base10(serial_get_rx_buffer_available());
 80091aa:	f000 f92b 	bl	8009404 <serial_get_rx_buffer_available>
 80091ae:	0003      	movs	r3, r0
 80091b0:	0018      	movs	r0, r3
 80091b2:	f7fe fab3 	bl	800771c <print_uint8_base10>
#endif

  // Report realtime feed speed
#ifdef REPORT_FIELD_CURRENT_FEED_SPEED
#ifdef VARIABLE_SPINDLE
  printPgmString(PSTR("|FS:"));
 80091b6:	4b8d      	ldr	r3, [pc, #564]	; (80093ec <report_realtime_status+0x4d0>)
 80091b8:	0018      	movs	r0, r3
 80091ba:	f7fe fa9b 	bl	80076f4 <printString>
  printFloat_RateValue(st_get_realtime_rate());
 80091be:	f002 fab7 	bl	800b730 <st_get_realtime_rate>
 80091c2:	1c03      	adds	r3, r0, #0
 80091c4:	1c18      	adds	r0, r3, #0
 80091c6:	f7fe fbe5 	bl	8007994 <printFloat_RateValue>
  serial_write(',');
 80091ca:	202c      	movs	r0, #44	; 0x2c
 80091cc:	f000 f946 	bl	800945c <serial_write>
  printFloat(sys.spindle_speed, N_DECIMAL_RPMVALUE);
 80091d0:	4b87      	ldr	r3, [pc, #540]	; (80093f0 <report_realtime_status+0x4d4>)
 80091d2:	691b      	ldr	r3, [r3, #16]
 80091d4:	2100      	movs	r1, #0
 80091d6:	1c18      	adds	r0, r3, #0
 80091d8:	f7fe fb02 	bl	80077e0 <printFloat>
  printFloat_RateValue(st_get_realtime_rate());
#endif      
#endif

#ifdef REPORT_FIELD_PIN_STATE
  uint8_t lim_pin_state = limits_get_state();
 80091dc:	2336      	movs	r3, #54	; 0x36
 80091de:	18fc      	adds	r4, r7, r3
 80091e0:	f7fc fa80 	bl	80056e4 <limits_get_state>
 80091e4:	0003      	movs	r3, r0
 80091e6:	7023      	strb	r3, [r4, #0]
  uint8_t ctrl_pin_state = system_control_get_state();
 80091e8:	2335      	movs	r3, #53	; 0x35
 80091ea:	18fc      	adds	r4, r7, r3
 80091ec:	f002 fb84 	bl	800b8f8 <system_control_get_state>
 80091f0:	0003      	movs	r3, r0
 80091f2:	7023      	strb	r3, [r4, #0]
  uint8_t prb_pin_state = probe_get_state();
 80091f4:	2334      	movs	r3, #52	; 0x34
 80091f6:	18fc      	adds	r4, r7, r3
 80091f8:	f7fe fc36 	bl	8007a68 <probe_get_state>
 80091fc:	0003      	movs	r3, r0
 80091fe:	7023      	strb	r3, [r4, #0]
  if (lim_pin_state | ctrl_pin_state | prb_pin_state) {
 8009200:	2336      	movs	r3, #54	; 0x36
 8009202:	18fa      	adds	r2, r7, r3
 8009204:	2335      	movs	r3, #53	; 0x35
 8009206:	18fb      	adds	r3, r7, r3
 8009208:	7812      	ldrb	r2, [r2, #0]
 800920a:	781b      	ldrb	r3, [r3, #0]
 800920c:	4313      	orrs	r3, r2
 800920e:	b2da      	uxtb	r2, r3
 8009210:	2334      	movs	r3, #52	; 0x34
 8009212:	18fb      	adds	r3, r7, r3
 8009214:	781b      	ldrb	r3, [r3, #0]
 8009216:	4313      	orrs	r3, r2
 8009218:	b2db      	uxtb	r3, r3
 800921a:	2b00      	cmp	r3, #0
 800921c:	d04b      	beq.n	80092b6 <report_realtime_status+0x39a>
    printPgmString(PSTR("|Pn:"));
 800921e:	4b75      	ldr	r3, [pc, #468]	; (80093f4 <report_realtime_status+0x4d8>)
 8009220:	0018      	movs	r0, r3
 8009222:	f7fe fa67 	bl	80076f4 <printString>
    if (prb_pin_state) { serial_write('P'); }
 8009226:	2334      	movs	r3, #52	; 0x34
 8009228:	18fb      	adds	r3, r7, r3
 800922a:	781b      	ldrb	r3, [r3, #0]
 800922c:	2b00      	cmp	r3, #0
 800922e:	d002      	beq.n	8009236 <report_realtime_status+0x31a>
 8009230:	2050      	movs	r0, #80	; 0x50
 8009232:	f000 f913 	bl	800945c <serial_write>
    if (lim_pin_state) {
 8009236:	2336      	movs	r3, #54	; 0x36
 8009238:	18fb      	adds	r3, r7, r3
 800923a:	781b      	ldrb	r3, [r3, #0]
 800923c:	2b00      	cmp	r3, #0
 800923e:	d01a      	beq.n	8009276 <report_realtime_status+0x35a>
      if (bit_istrue(lim_pin_state, bit(X_AXIS))) { serial_write('X'); }
 8009240:	2336      	movs	r3, #54	; 0x36
 8009242:	18fb      	adds	r3, r7, r3
 8009244:	781b      	ldrb	r3, [r3, #0]
 8009246:	2201      	movs	r2, #1
 8009248:	4013      	ands	r3, r2
 800924a:	d002      	beq.n	8009252 <report_realtime_status+0x336>
 800924c:	2058      	movs	r0, #88	; 0x58
 800924e:	f000 f905 	bl	800945c <serial_write>
      if (bit_istrue(lim_pin_state, bit(Y_AXIS))) { serial_write('Y'); }
 8009252:	2336      	movs	r3, #54	; 0x36
 8009254:	18fb      	adds	r3, r7, r3
 8009256:	781b      	ldrb	r3, [r3, #0]
 8009258:	2202      	movs	r2, #2
 800925a:	4013      	ands	r3, r2
 800925c:	d002      	beq.n	8009264 <report_realtime_status+0x348>
 800925e:	2059      	movs	r0, #89	; 0x59
 8009260:	f000 f8fc 	bl	800945c <serial_write>
      if (bit_istrue(lim_pin_state, bit(Z_AXIS))) { serial_write('Z'); }
 8009264:	2336      	movs	r3, #54	; 0x36
 8009266:	18fb      	adds	r3, r7, r3
 8009268:	781b      	ldrb	r3, [r3, #0]
 800926a:	2204      	movs	r2, #4
 800926c:	4013      	ands	r3, r2
 800926e:	d002      	beq.n	8009276 <report_realtime_status+0x35a>
 8009270:	205a      	movs	r0, #90	; 0x5a
 8009272:	f000 f8f3 	bl	800945c <serial_write>
    }
    if (ctrl_pin_state) {
 8009276:	2335      	movs	r3, #53	; 0x35
 8009278:	18fb      	adds	r3, r7, r3
 800927a:	781b      	ldrb	r3, [r3, #0]
 800927c:	2b00      	cmp	r3, #0
 800927e:	d01a      	beq.n	80092b6 <report_realtime_status+0x39a>
#ifdef ENABLE_SAFETY_DOOR_INPUT_PIN
      if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_SAFETY_DOOR)) { serial_write('D'); }
#endif
      if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_RESET)) { serial_write('R'); }
 8009280:	2335      	movs	r3, #53	; 0x35
 8009282:	18fb      	adds	r3, r7, r3
 8009284:	781b      	ldrb	r3, [r3, #0]
 8009286:	2201      	movs	r2, #1
 8009288:	4013      	ands	r3, r2
 800928a:	d002      	beq.n	8009292 <report_realtime_status+0x376>
 800928c:	2052      	movs	r0, #82	; 0x52
 800928e:	f000 f8e5 	bl	800945c <serial_write>
      if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_FEED_HOLD)) { serial_write('H'); }
 8009292:	2335      	movs	r3, #53	; 0x35
 8009294:	18fb      	adds	r3, r7, r3
 8009296:	781b      	ldrb	r3, [r3, #0]
 8009298:	2202      	movs	r2, #2
 800929a:	4013      	ands	r3, r2
 800929c:	d002      	beq.n	80092a4 <report_realtime_status+0x388>
 800929e:	2048      	movs	r0, #72	; 0x48
 80092a0:	f000 f8dc 	bl	800945c <serial_write>
      if (bit_istrue(ctrl_pin_state, CONTROL_PIN_INDEX_CYCLE_START)) { serial_write('S'); }
 80092a4:	2335      	movs	r3, #53	; 0x35
 80092a6:	18fb      	adds	r3, r7, r3
 80092a8:	781b      	ldrb	r3, [r3, #0]
 80092aa:	2204      	movs	r2, #4
 80092ac:	4013      	ands	r3, r2
 80092ae:	d002      	beq.n	80092b6 <report_realtime_status+0x39a>
 80092b0:	2053      	movs	r0, #83	; 0x53
 80092b2:	f000 f8d3 	bl	800945c <serial_write>
    }
  }
#endif

#ifdef REPORT_FIELD_WORK_COORD_OFFSET
  if (sys.report_wco_counter > 0) { sys.report_wco_counter--; }
 80092b6:	4b4e      	ldr	r3, [pc, #312]	; (80093f0 <report_realtime_status+0x4d4>)
 80092b8:	7b1b      	ldrb	r3, [r3, #12]
 80092ba:	2b00      	cmp	r3, #0
 80092bc:	d006      	beq.n	80092cc <report_realtime_status+0x3b0>
 80092be:	4b4c      	ldr	r3, [pc, #304]	; (80093f0 <report_realtime_status+0x4d4>)
 80092c0:	7b1b      	ldrb	r3, [r3, #12]
 80092c2:	3b01      	subs	r3, #1
 80092c4:	b2da      	uxtb	r2, r3
 80092c6:	4b4a      	ldr	r3, [pc, #296]	; (80093f0 <report_realtime_status+0x4d4>)
 80092c8:	731a      	strb	r2, [r3, #12]
 80092ca:	e01b      	b.n	8009304 <report_realtime_status+0x3e8>
  else {
    if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
 80092cc:	4b48      	ldr	r3, [pc, #288]	; (80093f0 <report_realtime_status+0x4d4>)
 80092ce:	781b      	ldrb	r3, [r3, #0]
 80092d0:	001a      	movs	r2, r3
 80092d2:	237c      	movs	r3, #124	; 0x7c
 80092d4:	4013      	ands	r3, r2
 80092d6:	d003      	beq.n	80092e0 <report_realtime_status+0x3c4>
      sys.report_wco_counter = (REPORT_WCO_REFRESH_BUSY_COUNT - 1); // Reset counter for slow refresh
 80092d8:	4b45      	ldr	r3, [pc, #276]	; (80093f0 <report_realtime_status+0x4d4>)
 80092da:	221d      	movs	r2, #29
 80092dc:	731a      	strb	r2, [r3, #12]
 80092de:	e002      	b.n	80092e6 <report_realtime_status+0x3ca>
    }
    else { sys.report_wco_counter = (REPORT_WCO_REFRESH_IDLE_COUNT - 1); }
 80092e0:	4b43      	ldr	r3, [pc, #268]	; (80093f0 <report_realtime_status+0x4d4>)
 80092e2:	2209      	movs	r2, #9
 80092e4:	731a      	strb	r2, [r3, #12]
    if (sys.report_ovr_counter == 0) { sys.report_ovr_counter = 1; } // Set override on next report.
 80092e6:	4b42      	ldr	r3, [pc, #264]	; (80093f0 <report_realtime_status+0x4d4>)
 80092e8:	7adb      	ldrb	r3, [r3, #11]
 80092ea:	2b00      	cmp	r3, #0
 80092ec:	d102      	bne.n	80092f4 <report_realtime_status+0x3d8>
 80092ee:	4b40      	ldr	r3, [pc, #256]	; (80093f0 <report_realtime_status+0x4d4>)
 80092f0:	2201      	movs	r2, #1
 80092f2:	72da      	strb	r2, [r3, #11]
    printPgmString(PSTR("|WCO:"));
 80092f4:	4b40      	ldr	r3, [pc, #256]	; (80093f8 <report_realtime_status+0x4dc>)
 80092f6:	0018      	movs	r0, r3
 80092f8:	f7fe f9fc 	bl	80076f4 <printString>
    report_util_axis_values(wco);
 80092fc:	003b      	movs	r3, r7
 80092fe:	0018      	movs	r0, r3
 8009300:	f7ff f9ea 	bl	80086d8 <report_util_axis_values>
  }
#endif

  #ifdef REPORT_FIELD_OVERRIDES
    if (sys.report_ovr_counter > 0) { sys.report_ovr_counter--; }
 8009304:	4b3a      	ldr	r3, [pc, #232]	; (80093f0 <report_realtime_status+0x4d4>)
 8009306:	7adb      	ldrb	r3, [r3, #11]
 8009308:	2b00      	cmp	r3, #0
 800930a:	d006      	beq.n	800931a <report_realtime_status+0x3fe>
 800930c:	4b38      	ldr	r3, [pc, #224]	; (80093f0 <report_realtime_status+0x4d4>)
 800930e:	7adb      	ldrb	r3, [r3, #11]
 8009310:	3b01      	subs	r3, #1
 8009312:	b2da      	uxtb	r2, r3
 8009314:	4b36      	ldr	r3, [pc, #216]	; (80093f0 <report_realtime_status+0x4d4>)
 8009316:	72da      	strb	r2, [r3, #11]
 8009318:	e059      	b.n	80093ce <report_realtime_status+0x4b2>
    else {
      if (sys.state & (STATE_HOMING | STATE_CYCLE | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)) {
 800931a:	4b35      	ldr	r3, [pc, #212]	; (80093f0 <report_realtime_status+0x4d4>)
 800931c:	781b      	ldrb	r3, [r3, #0]
 800931e:	001a      	movs	r2, r3
 8009320:	237c      	movs	r3, #124	; 0x7c
 8009322:	4013      	ands	r3, r2
 8009324:	d003      	beq.n	800932e <report_realtime_status+0x412>
        sys.report_ovr_counter = (REPORT_OVR_REFRESH_BUSY_COUNT - 1); // Reset counter for slow refresh
 8009326:	4b32      	ldr	r3, [pc, #200]	; (80093f0 <report_realtime_status+0x4d4>)
 8009328:	2213      	movs	r2, #19
 800932a:	72da      	strb	r2, [r3, #11]
 800932c:	e002      	b.n	8009334 <report_realtime_status+0x418>
      }
      else { sys.report_ovr_counter = (REPORT_OVR_REFRESH_IDLE_COUNT - 1); }
 800932e:	4b30      	ldr	r3, [pc, #192]	; (80093f0 <report_realtime_status+0x4d4>)
 8009330:	2209      	movs	r2, #9
 8009332:	72da      	strb	r2, [r3, #11]
      printPgmString(PSTR("|Ov:"));
 8009334:	4b31      	ldr	r3, [pc, #196]	; (80093fc <report_realtime_status+0x4e0>)
 8009336:	0018      	movs	r0, r3
 8009338:	f7fe f9dc 	bl	80076f4 <printString>
      print_uint8_base10(sys.f_override);
 800933c:	4b2c      	ldr	r3, [pc, #176]	; (80093f0 <report_realtime_status+0x4d4>)
 800933e:	79db      	ldrb	r3, [r3, #7]
 8009340:	0018      	movs	r0, r3
 8009342:	f7fe f9eb 	bl	800771c <print_uint8_base10>
      serial_write(',');
 8009346:	202c      	movs	r0, #44	; 0x2c
 8009348:	f000 f888 	bl	800945c <serial_write>
      print_uint8_base10(sys.r_override);
 800934c:	4b28      	ldr	r3, [pc, #160]	; (80093f0 <report_realtime_status+0x4d4>)
 800934e:	7a1b      	ldrb	r3, [r3, #8]
 8009350:	0018      	movs	r0, r3
 8009352:	f7fe f9e3 	bl	800771c <print_uint8_base10>
      serial_write(',');
 8009356:	202c      	movs	r0, #44	; 0x2c
 8009358:	f000 f880 	bl	800945c <serial_write>
      print_uint8_base10(sys.spindle_speed_ovr);
 800935c:	4b24      	ldr	r3, [pc, #144]	; (80093f0 <report_realtime_status+0x4d4>)
 800935e:	7a5b      	ldrb	r3, [r3, #9]
 8009360:	0018      	movs	r0, r3
 8009362:	f7fe f9db 	bl	800771c <print_uint8_base10>

      uint8_t sp_state = spindle_get_state();
 8009366:	2333      	movs	r3, #51	; 0x33
 8009368:	18fc      	adds	r4, r7, r3
 800936a:	f000 fe47 	bl	8009ffc <spindle_get_state>
 800936e:	0003      	movs	r3, r0
 8009370:	7023      	strb	r3, [r4, #0]
      uint8_t cl_state = coolant_get_state();
 8009372:	2332      	movs	r3, #50	; 0x32
 8009374:	18fc      	adds	r4, r7, r3
 8009376:	f7fa fa64 	bl	8003842 <coolant_get_state>
 800937a:	0003      	movs	r3, r0
 800937c:	7023      	strb	r3, [r4, #0]
      if (sp_state || cl_state) {
 800937e:	2333      	movs	r3, #51	; 0x33
 8009380:	18fb      	adds	r3, r7, r3
 8009382:	781b      	ldrb	r3, [r3, #0]
 8009384:	2b00      	cmp	r3, #0
 8009386:	d104      	bne.n	8009392 <report_realtime_status+0x476>
 8009388:	2332      	movs	r3, #50	; 0x32
 800938a:	18fb      	adds	r3, r7, r3
 800938c:	781b      	ldrb	r3, [r3, #0]
 800938e:	2b00      	cmp	r3, #0
 8009390:	d01d      	beq.n	80093ce <report_realtime_status+0x4b2>
        printPgmString(PSTR("|A:"));
 8009392:	4b1b      	ldr	r3, [pc, #108]	; (8009400 <report_realtime_status+0x4e4>)
 8009394:	0018      	movs	r0, r3
 8009396:	f7fe f9ad 	bl	80076f4 <printString>
        if (sp_state) { // != SPINDLE_STATE_DISABLE
 800939a:	2333      	movs	r3, #51	; 0x33
 800939c:	18fb      	adds	r3, r7, r3
 800939e:	781b      	ldrb	r3, [r3, #0]
 80093a0:	2b00      	cmp	r3, #0
 80093a2:	d00b      	beq.n	80093bc <report_realtime_status+0x4a0>
          #ifdef VARIABLE_SPINDLE 
            #ifdef USE_SPINDLE_DIR_AS_ENABLE_PIN
              serial_write('S'); // CW
            #else
              if (sp_state == SPINDLE_STATE_CW) { serial_write('S'); } // CW
 80093a4:	2333      	movs	r3, #51	; 0x33
 80093a6:	18fb      	adds	r3, r7, r3
 80093a8:	781b      	ldrb	r3, [r3, #0]
 80093aa:	2b01      	cmp	r3, #1
 80093ac:	d103      	bne.n	80093b6 <report_realtime_status+0x49a>
 80093ae:	2053      	movs	r0, #83	; 0x53
 80093b0:	f000 f854 	bl	800945c <serial_write>
 80093b4:	e002      	b.n	80093bc <report_realtime_status+0x4a0>
              else { serial_write('C'); } // CCW
 80093b6:	2043      	movs	r0, #67	; 0x43
 80093b8:	f000 f850 	bl	800945c <serial_write>
          #else
            if (sp_state & SPINDLE_STATE_CW) { serial_write('S'); } // CW
            else { serial_write('C'); } // CCW
          #endif
        }
        if (cl_state & COOLANT_STATE_FLOOD) { serial_write('F'); }
 80093bc:	2332      	movs	r3, #50	; 0x32
 80093be:	18fb      	adds	r3, r7, r3
 80093c0:	781b      	ldrb	r3, [r3, #0]
 80093c2:	2201      	movs	r2, #1
 80093c4:	4013      	ands	r3, r2
 80093c6:	d002      	beq.n	80093ce <report_realtime_status+0x4b2>
 80093c8:	2046      	movs	r0, #70	; 0x46
 80093ca:	f000 f847 	bl	800945c <serial_write>
        #endif
      }
    }
  #endif

  serial_write('>');
 80093ce:	203e      	movs	r0, #62	; 0x3e
 80093d0:	f000 f844 	bl	800945c <serial_write>
  report_util_line_feed();
 80093d4:	f7ff f952 	bl	800867c <report_util_line_feed>
}
 80093d8:	46c0      	nop			; (mov r8, r8)
 80093da:	46bd      	mov	sp, r7
 80093dc:	b00f      	add	sp, #60	; 0x3c
 80093de:	bd90      	pop	{r4, r7, pc}
 80093e0:	0800dbf0 	.word	0x0800dbf0
 80093e4:	20000b44 	.word	0x20000b44
 80093e8:	0800dbf8 	.word	0x0800dbf8
 80093ec:	0800dc00 	.word	0x0800dc00
 80093f0:	20000bb4 	.word	0x20000bb4
 80093f4:	0800dc08 	.word	0x0800dc08
 80093f8:	0800dc10 	.word	0x0800dc10
 80093fc:	0800dc18 	.word	0x0800dc18
 8009400:	0800dc20 	.word	0x0800dc20

08009404 <serial_get_rx_buffer_available>:
volatile uint8_t serial_tx_buffer_tail = 0;


// Returns the number of bytes available in the RX serial buffer.
uint8_t serial_get_rx_buffer_available()
{
 8009404:	b580      	push	{r7, lr}
 8009406:	b082      	sub	sp, #8
 8009408:	af00      	add	r7, sp, #0
  uint8_t rtail = serial_rx_buffer_tail; // Copy to limit multiple calls to volatile
 800940a:	1dfb      	adds	r3, r7, #7
 800940c:	4a0e      	ldr	r2, [pc, #56]	; (8009448 <serial_get_rx_buffer_available+0x44>)
 800940e:	7812      	ldrb	r2, [r2, #0]
 8009410:	701a      	strb	r2, [r3, #0]
  if (serial_rx_buffer_head >= rtail) { return(RX_BUFFER_SIZE - (serial_rx_buffer_head-rtail)); }
 8009412:	4b0e      	ldr	r3, [pc, #56]	; (800944c <serial_get_rx_buffer_available+0x48>)
 8009414:	781b      	ldrb	r3, [r3, #0]
 8009416:	1dfa      	adds	r2, r7, #7
 8009418:	7812      	ldrb	r2, [r2, #0]
 800941a:	429a      	cmp	r2, r3
 800941c:	d808      	bhi.n	8009430 <serial_get_rx_buffer_available+0x2c>
 800941e:	4b0b      	ldr	r3, [pc, #44]	; (800944c <serial_get_rx_buffer_available+0x48>)
 8009420:	781b      	ldrb	r3, [r3, #0]
 8009422:	1dfa      	adds	r2, r7, #7
 8009424:	7812      	ldrb	r2, [r2, #0]
 8009426:	1ad3      	subs	r3, r2, r3
 8009428:	b2db      	uxtb	r3, r3
 800942a:	3b80      	subs	r3, #128	; 0x80
 800942c:	b2db      	uxtb	r3, r3
 800942e:	e007      	b.n	8009440 <serial_get_rx_buffer_available+0x3c>
  return((rtail-serial_rx_buffer_head-1));
 8009430:	4b06      	ldr	r3, [pc, #24]	; (800944c <serial_get_rx_buffer_available+0x48>)
 8009432:	781b      	ldrb	r3, [r3, #0]
 8009434:	1dfa      	adds	r2, r7, #7
 8009436:	7812      	ldrb	r2, [r2, #0]
 8009438:	1ad3      	subs	r3, r2, r3
 800943a:	b2db      	uxtb	r3, r3
 800943c:	3b01      	subs	r3, #1
 800943e:	b2db      	uxtb	r3, r3
}
 8009440:	0018      	movs	r0, r3
 8009442:	46bd      	mov	sp, r7
 8009444:	b002      	add	sp, #8
 8009446:	bd80      	pop	{r7, pc}
 8009448:	20000491 	.word	0x20000491
 800944c:	20000490 	.word	0x20000490

08009450 <serial_init>:
  return (TX_RING_BUFFER - (ttail-serial_tx_buffer_head));
}


void serial_init()
{
 8009450:	b580      	push	{r7, lr}
 8009452:	af00      	add	r7, sp, #0
  // defaults to 8-bit, no parity, 1 stop bit
#endif
#ifdef WIN32
  InitializeCriticalSectionAndSpinCount(&CriticalSection,0x00000400);
#endif
}
 8009454:	46c0      	nop			; (mov r8, r8)
 8009456:	46bd      	mov	sp, r7
 8009458:	bd80      	pop	{r7, pc}
	...

0800945c <serial_write>:
}
#endif


// Writes one byte to the TX serial buffer. Called by main program.
void serial_write(uint8_t data) {
 800945c:	b580      	push	{r7, lr}
 800945e:	b084      	sub	sp, #16
 8009460:	af00      	add	r7, sp, #0
 8009462:	0002      	movs	r2, r0
 8009464:	1dfb      	adds	r3, r7, #7
 8009466:	701a      	strb	r2, [r3, #0]
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
 8009468:	4b0b      	ldr	r3, [pc, #44]	; (8009498 <serial_write+0x3c>)
 800946a:	781a      	ldrb	r2, [r3, #0]
 800946c:	230f      	movs	r3, #15
 800946e:	18fb      	adds	r3, r7, r3
 8009470:	3201      	adds	r2, #1
 8009472:	701a      	strb	r2, [r3, #0]
    return;
#endif
#endif
#ifdef STM32F0DISCOVERY
#ifndef USEUSB
	USART_SendData(USART1, data);
 8009474:	1dfb      	adds	r3, r7, #7
 8009476:	781b      	ldrb	r3, [r3, #0]
 8009478:	b29b      	uxth	r3, r3
 800947a:	4a08      	ldr	r2, [pc, #32]	; (800949c <serial_write+0x40>)
 800947c:	0019      	movs	r1, r3
 800947e:	0010      	movs	r0, r2
 8009480:	f7fa f98b 	bl	800379a <USART_SendData>
	while (!(USART1->ISR & USART_ISR_TXE));		 //
 8009484:	46c0      	nop			; (mov r8, r8)
 8009486:	4b05      	ldr	r3, [pc, #20]	; (800949c <serial_write+0x40>)
 8009488:	69db      	ldr	r3, [r3, #28]
 800948a:	2280      	movs	r2, #128	; 0x80
 800948c:	4013      	ands	r3, r2
 800948e:	d0fa      	beq.n	8009486 <serial_write+0x2a>
  return;
 8009490:	46c0      	nop			; (mov r8, r8)

#ifdef AVRTARGET
  // Enable Data Register Empty Interrupt to make sure tx-streaming is running
  UCSR0B |=  (1 << UDRIE0);
#endif
}
 8009492:	46bd      	mov	sp, r7
 8009494:	b004      	add	sp, #16
 8009496:	bd80      	pop	{r7, pc}
 8009498:	20000492 	.word	0x20000492
 800949c:	40013800 	.word	0x40013800

080094a0 <serial_read>:
}
#endif

// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
 80094a0:	b580      	push	{r7, lr}
 80094a2:	b082      	sub	sp, #8
 80094a4:	af00      	add	r7, sp, #0
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
 80094a6:	1dfb      	adds	r3, r7, #7
 80094a8:	4a13      	ldr	r2, [pc, #76]	; (80094f8 <serial_read+0x58>)
 80094aa:	7812      	ldrb	r2, [r2, #0]
 80094ac:	701a      	strb	r2, [r3, #0]
  if (serial_rx_buffer_head == tail) {
 80094ae:	4b13      	ldr	r3, [pc, #76]	; (80094fc <serial_read+0x5c>)
 80094b0:	781b      	ldrb	r3, [r3, #0]
 80094b2:	1dfa      	adds	r2, r7, #7
 80094b4:	7812      	ldrb	r2, [r2, #0]
 80094b6:	429a      	cmp	r2, r3
 80094b8:	d101      	bne.n	80094be <serial_read+0x1e>
    return SERIAL_NO_DATA;
 80094ba:	23ff      	movs	r3, #255	; 0xff
 80094bc:	e017      	b.n	80094ee <serial_read+0x4e>
  } else {
    uint8_t data = serial_rx_buffer[tail];
 80094be:	1dfb      	adds	r3, r7, #7
 80094c0:	781a      	ldrb	r2, [r3, #0]
 80094c2:	1dbb      	adds	r3, r7, #6
 80094c4:	490e      	ldr	r1, [pc, #56]	; (8009500 <serial_read+0x60>)
 80094c6:	5c8a      	ldrb	r2, [r1, r2]
 80094c8:	701a      	strb	r2, [r3, #0]

    tail++;
 80094ca:	1dfb      	adds	r3, r7, #7
 80094cc:	781a      	ldrb	r2, [r3, #0]
 80094ce:	1dfb      	adds	r3, r7, #7
 80094d0:	3201      	adds	r2, #1
 80094d2:	701a      	strb	r2, [r3, #0]
    if (tail == RX_RING_BUFFER) { tail = 0; }
 80094d4:	1dfb      	adds	r3, r7, #7
 80094d6:	781b      	ldrb	r3, [r3, #0]
 80094d8:	2b80      	cmp	r3, #128	; 0x80
 80094da:	d102      	bne.n	80094e2 <serial_read+0x42>
 80094dc:	1dfb      	adds	r3, r7, #7
 80094de:	2200      	movs	r2, #0
 80094e0:	701a      	strb	r2, [r3, #0]
    serial_rx_buffer_tail = tail;
 80094e2:	4b05      	ldr	r3, [pc, #20]	; (80094f8 <serial_read+0x58>)
 80094e4:	1dfa      	adds	r2, r7, #7
 80094e6:	7812      	ldrb	r2, [r2, #0]
 80094e8:	701a      	strb	r2, [r3, #0]

    return data;
 80094ea:	1dbb      	adds	r3, r7, #6
 80094ec:	781b      	ldrb	r3, [r3, #0]
  }
}
 80094ee:	0018      	movs	r0, r3
 80094f0:	46bd      	mov	sp, r7
 80094f2:	b002      	add	sp, #8
 80094f4:	bd80      	pop	{r7, pc}
 80094f6:	46c0      	nop			; (mov r8, r8)
 80094f8:	20000491 	.word	0x20000491
 80094fc:	20000490 	.word	0x20000490
 8009500:	20000ac4 	.word	0x20000ac4

08009504 <USART1_IRQHandler>:
/*----------------------------------------------------------------------------
  USART1_IRQHandler
  Handles USART1 global interrupt request.
 *----------------------------------------------------------------------------*/
void USART1_IRQHandler (void)
{
 8009504:	b580      	push	{r7, lr}
 8009506:	b082      	sub	sp, #8
 8009508:	af00      	add	r7, sp, #0
    volatile unsigned int IIR;
    uint8_t data;
    uint8_t next_head;

    IIR = USART1->ISR;
 800950a:	4b57      	ldr	r3, [pc, #348]	; (8009668 <USART1_IRQHandler+0x164>)
 800950c:	69db      	ldr	r3, [r3, #28]
 800950e:	603b      	str	r3, [r7, #0]
    if (IIR & USART_ISR_RXNE)
 8009510:	683b      	ldr	r3, [r7, #0]
 8009512:	2220      	movs	r2, #32
 8009514:	4013      	ands	r3, r2
 8009516:	d100      	bne.n	800951a <USART1_IRQHandler+0x16>
 8009518:	e0a1      	b.n	800965e <USART1_IRQHandler+0x15a>
    {                  // read interrupt
        data = USART1->RDR & 0x1FF;
 800951a:	4b53      	ldr	r3, [pc, #332]	; (8009668 <USART1_IRQHandler+0x164>)
 800951c:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800951e:	b29a      	uxth	r2, r3
 8009520:	1dbb      	adds	r3, r7, #6
 8009522:	701a      	strb	r2, [r3, #0]
#endif
#endif
  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the main buffer, but these set system state flag bits for realtime execution.
  switch (data) {
 8009524:	1dbb      	adds	r3, r7, #6
 8009526:	781b      	ldrb	r3, [r3, #0]
 8009528:	2b21      	cmp	r3, #33	; 0x21
 800952a:	d013      	beq.n	8009554 <USART1_IRQHandler+0x50>
 800952c:	dc02      	bgt.n	8009534 <USART1_IRQHandler+0x30>
 800952e:	2b18      	cmp	r3, #24
 8009530:	d005      	beq.n	800953e <USART1_IRQHandler+0x3a>
 8009532:	e013      	b.n	800955c <USART1_IRQHandler+0x58>
 8009534:	2b3f      	cmp	r3, #63	; 0x3f
 8009536:	d005      	beq.n	8009544 <USART1_IRQHandler+0x40>
 8009538:	2b7e      	cmp	r3, #126	; 0x7e
 800953a:	d007      	beq.n	800954c <USART1_IRQHandler+0x48>
 800953c:	e00e      	b.n	800955c <USART1_IRQHandler+0x58>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
 800953e:	f7fd f819 	bl	8006574 <mc_reset>
 8009542:	e086      	b.n	8009652 <USART1_IRQHandler+0x14e>
    case CMD_STATUS_REPORT: system_set_exec_state_flag(EXEC_STATUS_REPORT); break; // Set as true
 8009544:	2001      	movs	r0, #1
 8009546:	f002 fdad 	bl	800c0a4 <system_set_exec_state_flag>
 800954a:	e082      	b.n	8009652 <USART1_IRQHandler+0x14e>
    case CMD_CYCLE_START:   system_set_exec_state_flag(EXEC_CYCLE_START); break; // Set as true
 800954c:	2002      	movs	r0, #2
 800954e:	f002 fda9 	bl	800c0a4 <system_set_exec_state_flag>
 8009552:	e07e      	b.n	8009652 <USART1_IRQHandler+0x14e>
    case CMD_FEED_HOLD:     system_set_exec_state_flag(EXEC_FEED_HOLD); break; // Set as true
 8009554:	2008      	movs	r0, #8
 8009556:	f002 fda5 	bl	800c0a4 <system_set_exec_state_flag>
 800955a:	e07a      	b.n	8009652 <USART1_IRQHandler+0x14e>
    default :
      if (data > 0x7F) { // Real-time control characters are extended ACSII only.
 800955c:	1dbb      	adds	r3, r7, #6
 800955e:	781b      	ldrb	r3, [r3, #0]
 8009560:	b25b      	sxtb	r3, r3
 8009562:	2b00      	cmp	r3, #0
 8009564:	da55      	bge.n	8009612 <USART1_IRQHandler+0x10e>
        switch(data) {
 8009566:	1dbb      	adds	r3, r7, #6
 8009568:	781b      	ldrb	r3, [r3, #0]
 800956a:	3b84      	subs	r3, #132	; 0x84
 800956c:	2b1c      	cmp	r3, #28
 800956e:	d900      	bls.n	8009572 <USART1_IRQHandler+0x6e>
 8009570:	e06f      	b.n	8009652 <USART1_IRQHandler+0x14e>
 8009572:	009a      	lsls	r2, r3, #2
 8009574:	4b3d      	ldr	r3, [pc, #244]	; (800966c <USART1_IRQHandler+0x168>)
 8009576:	18d3      	adds	r3, r2, r3
 8009578:	681b      	ldr	r3, [r3, #0]
 800957a:	469f      	mov	pc, r3
          case CMD_SAFETY_DOOR:   system_set_exec_state_flag(EXEC_SAFETY_DOOR); break; // Set as true
 800957c:	2020      	movs	r0, #32
 800957e:	f002 fd91 	bl	800c0a4 <system_set_exec_state_flag>
 8009582:	e066      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_JOG_CANCEL:   
            if (sys.state & STATE_JOG) { // Block all other states from invoking motion cancel.
 8009584:	4b3a      	ldr	r3, [pc, #232]	; (8009670 <USART1_IRQHandler+0x16c>)
 8009586:	781b      	ldrb	r3, [r3, #0]
 8009588:	001a      	movs	r2, r3
 800958a:	2320      	movs	r3, #32
 800958c:	4013      	ands	r3, r2
 800958e:	d05f      	beq.n	8009650 <USART1_IRQHandler+0x14c>
              system_set_exec_state_flag(EXEC_MOTION_CANCEL); 
 8009590:	2040      	movs	r0, #64	; 0x40
 8009592:	f002 fd87 	bl	800c0a4 <system_set_exec_state_flag>
            }
            break; 
 8009596:	e05b      	b.n	8009650 <USART1_IRQHandler+0x14c>
          #ifdef DEBUG
            case CMD_DEBUG_REPORT: {uint8_t sreg = SREG; cli(); bit_true(sys_rt_exec_debug,EXEC_DEBUG_REPORT); SREG = sreg;} break;
          #endif
          case CMD_FEED_OVR_RESET: system_set_exec_motion_override_flag(EXEC_FEED_OVR_RESET); break;
 8009598:	2001      	movs	r0, #1
 800959a:	f002 fddb 	bl	800c154 <system_set_exec_motion_override_flag>
 800959e:	e058      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_FEED_OVR_COARSE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_PLUS); break;
 80095a0:	2002      	movs	r0, #2
 80095a2:	f002 fdd7 	bl	800c154 <system_set_exec_motion_override_flag>
 80095a6:	e054      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_FEED_OVR_COARSE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_MINUS); break;
 80095a8:	2004      	movs	r0, #4
 80095aa:	f002 fdd3 	bl	800c154 <system_set_exec_motion_override_flag>
 80095ae:	e050      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_FEED_OVR_FINE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_PLUS); break;
 80095b0:	2008      	movs	r0, #8
 80095b2:	f002 fdcf 	bl	800c154 <system_set_exec_motion_override_flag>
 80095b6:	e04c      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_FEED_OVR_FINE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_MINUS); break;
 80095b8:	2010      	movs	r0, #16
 80095ba:	f002 fdcb 	bl	800c154 <system_set_exec_motion_override_flag>
 80095be:	e048      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_RAPID_OVR_RESET: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_RESET); break;
 80095c0:	2020      	movs	r0, #32
 80095c2:	f002 fdc7 	bl	800c154 <system_set_exec_motion_override_flag>
 80095c6:	e044      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_RAPID_OVR_MEDIUM: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_MEDIUM); break;
 80095c8:	2040      	movs	r0, #64	; 0x40
 80095ca:	f002 fdc3 	bl	800c154 <system_set_exec_motion_override_flag>
 80095ce:	e040      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_RAPID_OVR_LOW: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_LOW); break;
 80095d0:	2080      	movs	r0, #128	; 0x80
 80095d2:	f002 fdbf 	bl	800c154 <system_set_exec_motion_override_flag>
 80095d6:	e03c      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_SPINDLE_OVR_RESET: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_RESET); break;
 80095d8:	2001      	movs	r0, #1
 80095da:	f002 fdd3 	bl	800c184 <system_set_exec_accessory_override_flag>
 80095de:	e038      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_SPINDLE_OVR_COARSE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_PLUS); break;
 80095e0:	2002      	movs	r0, #2
 80095e2:	f002 fdcf 	bl	800c184 <system_set_exec_accessory_override_flag>
 80095e6:	e034      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_SPINDLE_OVR_COARSE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_MINUS); break;
 80095e8:	2004      	movs	r0, #4
 80095ea:	f002 fdcb 	bl	800c184 <system_set_exec_accessory_override_flag>
 80095ee:	e030      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_SPINDLE_OVR_FINE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_PLUS); break;
 80095f0:	2008      	movs	r0, #8
 80095f2:	f002 fdc7 	bl	800c184 <system_set_exec_accessory_override_flag>
 80095f6:	e02c      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_SPINDLE_OVR_FINE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_MINUS); break;
 80095f8:	2010      	movs	r0, #16
 80095fa:	f002 fdc3 	bl	800c184 <system_set_exec_accessory_override_flag>
 80095fe:	e028      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_SPINDLE_OVR_STOP: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP); break;
 8009600:	2020      	movs	r0, #32
 8009602:	f002 fdbf 	bl	800c184 <system_set_exec_accessory_override_flag>
 8009606:	e024      	b.n	8009652 <USART1_IRQHandler+0x14e>
          case CMD_COOLANT_FLOOD_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_FLOOD_OVR_TOGGLE); break;
 8009608:	2040      	movs	r0, #64	; 0x40
 800960a:	f002 fdbb 	bl	800c184 <system_set_exec_accessory_override_flag>
 800960e:	46c0      	nop			; (mov r8, r8)
 8009610:	e01f      	b.n	8009652 <USART1_IRQHandler+0x14e>
            case CMD_COOLANT_MIST_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_MIST_OVR_TOGGLE); break;
          #endif
        }
        // Throw away any unfound extended-ASCII character by not passing it to the serial buffer.
      } else { // Write character to buffer
        next_head = serial_rx_buffer_head + 1;
 8009612:	4b18      	ldr	r3, [pc, #96]	; (8009674 <USART1_IRQHandler+0x170>)
 8009614:	781a      	ldrb	r2, [r3, #0]
 8009616:	1dfb      	adds	r3, r7, #7
 8009618:	3201      	adds	r2, #1
 800961a:	701a      	strb	r2, [r3, #0]
        if (next_head == RX_RING_BUFFER) { next_head = 0; }
 800961c:	1dfb      	adds	r3, r7, #7
 800961e:	781b      	ldrb	r3, [r3, #0]
 8009620:	2b80      	cmp	r3, #128	; 0x80
 8009622:	d102      	bne.n	800962a <USART1_IRQHandler+0x126>
 8009624:	1dfb      	adds	r3, r7, #7
 8009626:	2200      	movs	r2, #0
 8009628:	701a      	strb	r2, [r3, #0]

        // Write data to buffer unless it is full.
        if (next_head != serial_rx_buffer_tail) {
 800962a:	4b13      	ldr	r3, [pc, #76]	; (8009678 <USART1_IRQHandler+0x174>)
 800962c:	781b      	ldrb	r3, [r3, #0]
 800962e:	b2db      	uxtb	r3, r3
 8009630:	1dfa      	adds	r2, r7, #7
 8009632:	7812      	ldrb	r2, [r2, #0]
 8009634:	429a      	cmp	r2, r3
 8009636:	d00c      	beq.n	8009652 <USART1_IRQHandler+0x14e>
          serial_rx_buffer[serial_rx_buffer_head] = data;
 8009638:	4b0e      	ldr	r3, [pc, #56]	; (8009674 <USART1_IRQHandler+0x170>)
 800963a:	781b      	ldrb	r3, [r3, #0]
 800963c:	0019      	movs	r1, r3
 800963e:	4b0f      	ldr	r3, [pc, #60]	; (800967c <USART1_IRQHandler+0x178>)
 8009640:	1dba      	adds	r2, r7, #6
 8009642:	7812      	ldrb	r2, [r2, #0]
 8009644:	545a      	strb	r2, [r3, r1]
          serial_rx_buffer_head = next_head;
 8009646:	4b0b      	ldr	r3, [pc, #44]	; (8009674 <USART1_IRQHandler+0x170>)
 8009648:	1dfa      	adds	r2, r7, #7
 800964a:	7812      	ldrb	r2, [r2, #0]
 800964c:	701a      	strb	r2, [r3, #0]
 800964e:	e000      	b.n	8009652 <USART1_IRQHandler+0x14e>
            break; 
 8009650:	46c0      	nop			; (mov r8, r8)
#endif
   }
#endif
#ifdef STM32F0DISCOVERY
#ifndef USEUSB
        USART1->ISR &= ~USART_ISR_RXNE;	          // clear interrupt
 8009652:	4b05      	ldr	r3, [pc, #20]	; (8009668 <USART1_IRQHandler+0x164>)
 8009654:	4a04      	ldr	r2, [pc, #16]	; (8009668 <USART1_IRQHandler+0x164>)
 8009656:	69d2      	ldr	r2, [r2, #28]
 8009658:	2120      	movs	r1, #32
 800965a:	438a      	bics	r2, r1
 800965c:	61da      	str	r2, [r3, #28]
#else
    length--;
#endif
   }
#endif
}
 800965e:	46c0      	nop			; (mov r8, r8)
 8009660:	46bd      	mov	sp, r7
 8009662:	b002      	add	sp, #8
 8009664:	bd80      	pop	{r7, pc}
 8009666:	46c0      	nop			; (mov r8, r8)
 8009668:	40013800 	.word	0x40013800
 800966c:	0800dfb4 	.word	0x0800dfb4
 8009670:	20000bb4 	.word	0x20000bb4
 8009674:	20000490 	.word	0x20000490
 8009678:	20000491 	.word	0x20000491
 800967c:	20000ac4 	.word	0x20000ac4

08009680 <serial_reset_read_buffer>:

void serial_reset_read_buffer()
{
 8009680:	b580      	push	{r7, lr}
 8009682:	af00      	add	r7, sp, #0
  serial_rx_buffer_tail = serial_rx_buffer_head;
 8009684:	4b03      	ldr	r3, [pc, #12]	; (8009694 <serial_reset_read_buffer+0x14>)
 8009686:	781a      	ldrb	r2, [r3, #0]
 8009688:	4b03      	ldr	r3, [pc, #12]	; (8009698 <serial_reset_read_buffer+0x18>)
 800968a:	701a      	strb	r2, [r3, #0]
}
 800968c:	46c0      	nop			; (mov r8, r8)
 800968e:	46bd      	mov	sp, r7
 8009690:	bd80      	pop	{r7, pc}
 8009692:	46c0      	nop			; (mov r8, r8)
 8009694:	20000490 	.word	0x20000490
 8009698:	20000491 	.word	0x20000491

0800969c <settings_store_startup_line>:
settings_t settings;


// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
 800969c:	b580      	push	{r7, lr}
 800969e:	b084      	sub	sp, #16
 80096a0:	af00      	add	r7, sp, #0
 80096a2:	0002      	movs	r2, r0
 80096a4:	6039      	str	r1, [r7, #0]
 80096a6:	1dfb      	adds	r3, r7, #7
 80096a8:	701a      	strb	r2, [r3, #0]
  #ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize(); // A startup line may contain a motion and be executing. 
 80096aa:	f7fe fb45 	bl	8007d38 <protocol_buffer_synchronize>
  #endif
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
 80096ae:	1dfb      	adds	r3, r7, #7
 80096b0:	781a      	ldrb	r2, [r3, #0]
 80096b2:	0013      	movs	r3, r2
 80096b4:	00db      	lsls	r3, r3, #3
 80096b6:	189b      	adds	r3, r3, r2
 80096b8:	00da      	lsls	r2, r3, #3
 80096ba:	189b      	adds	r3, r3, r2
 80096bc:	22c0      	movs	r2, #192	; 0xc0
 80096be:	0092      	lsls	r2, r2, #2
 80096c0:	4694      	mov	ip, r2
 80096c2:	4463      	add	r3, ip
 80096c4:	60fb      	str	r3, [r7, #12]
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
 80096c6:	6839      	ldr	r1, [r7, #0]
 80096c8:	68fb      	ldr	r3, [r7, #12]
 80096ca:	2250      	movs	r2, #80	; 0x50
 80096cc:	0018      	movs	r0, r3
 80096ce:	f7fa f91d 	bl	800390c <memcpy_to_eeprom_with_checksum>
}
 80096d2:	46c0      	nop			; (mov r8, r8)
 80096d4:	46bd      	mov	sp, r7
 80096d6:	b004      	add	sp, #16
 80096d8:	bd80      	pop	{r7, pc}
	...

080096dc <settings_store_build_info>:


// Method to store build info into EEPROM
// NOTE: This function can only be called in IDLE state.
void settings_store_build_info(char *line)
{
 80096dc:	b580      	push	{r7, lr}
 80096de:	b082      	sub	sp, #8
 80096e0:	af00      	add	r7, sp, #0
 80096e2:	6078      	str	r0, [r7, #4]
  // Build info can only be stored when state is IDLE.
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
 80096e4:	687b      	ldr	r3, [r7, #4]
 80096e6:	4804      	ldr	r0, [pc, #16]	; (80096f8 <settings_store_build_info+0x1c>)
 80096e8:	2250      	movs	r2, #80	; 0x50
 80096ea:	0019      	movs	r1, r3
 80096ec:	f7fa f90e 	bl	800390c <memcpy_to_eeprom_with_checksum>
}
 80096f0:	46c0      	nop			; (mov r8, r8)
 80096f2:	46bd      	mov	sp, r7
 80096f4:	b002      	add	sp, #8
 80096f6:	bd80      	pop	{r7, pc}
 80096f8:	000003ae 	.word	0x000003ae

080096fc <settings_write_coord_data>:


// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{
 80096fc:	b580      	push	{r7, lr}
 80096fe:	b084      	sub	sp, #16
 8009700:	af00      	add	r7, sp, #0
 8009702:	0002      	movs	r2, r0
 8009704:	6039      	str	r1, [r7, #0]
 8009706:	1dfb      	adds	r3, r7, #7
 8009708:	701a      	strb	r2, [r3, #0]
  #ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize();
 800970a:	f7fe fb15 	bl	8007d38 <protocol_buffer_synchronize>
  #endif
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
 800970e:	1dfb      	adds	r3, r7, #7
 8009710:	781a      	ldrb	r2, [r3, #0]
 8009712:	0013      	movs	r3, r2
 8009714:	011b      	lsls	r3, r3, #4
 8009716:	189b      	adds	r3, r3, r2
 8009718:	2280      	movs	r2, #128	; 0x80
 800971a:	0092      	lsls	r2, r2, #2
 800971c:	4694      	mov	ip, r2
 800971e:	4463      	add	r3, ip
 8009720:	60fb      	str	r3, [r7, #12]
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
 8009722:	6839      	ldr	r1, [r7, #0]
 8009724:	68fb      	ldr	r3, [r7, #12]
 8009726:	2210      	movs	r2, #16
 8009728:	0018      	movs	r0, r3
 800972a:	f7fa f8ef 	bl	800390c <memcpy_to_eeprom_with_checksum>
}
 800972e:	46c0      	nop			; (mov r8, r8)
 8009730:	46bd      	mov	sp, r7
 8009732:	b004      	add	sp, #16
 8009734:	bd80      	pop	{r7, pc}
	...

08009738 <write_global_settings>:


// Method to store Grbl global settings struct and version number into EEPROM
// NOTE: This function can only be called in IDLE state.
void write_global_settings()
{
 8009738:	b580      	push	{r7, lr}
 800973a:	af00      	add	r7, sp, #0
  eeprom_put_char(0, SETTINGS_VERSION);
 800973c:	210a      	movs	r1, #10
 800973e:	2000      	movs	r0, #0
 8009740:	f7fa f8d0 	bl	80038e4 <eeprom_put_char>
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
 8009744:	4b04      	ldr	r3, [pc, #16]	; (8009758 <write_global_settings+0x20>)
 8009746:	226c      	movs	r2, #108	; 0x6c
 8009748:	0019      	movs	r1, r3
 800974a:	2001      	movs	r0, #1
 800974c:	f7fa f8de 	bl	800390c <memcpy_to_eeprom_with_checksum>
}
 8009750:	46c0      	nop			; (mov r8, r8)
 8009752:	46bd      	mov	sp, r7
 8009754:	bd80      	pop	{r7, pc}
 8009756:	46c0      	nop			; (mov r8, r8)
 8009758:	20000b44 	.word	0x20000b44

0800975c <settings_restore>:


// Method to restore EEPROM-saved Grbl global settings back to defaults.
void settings_restore(uint8_t restore_flag) {
 800975c:	b580      	push	{r7, lr}
 800975e:	b088      	sub	sp, #32
 8009760:	af00      	add	r7, sp, #0
 8009762:	0002      	movs	r2, r0
 8009764:	1dfb      	adds	r3, r7, #7
 8009766:	701a      	strb	r2, [r3, #0]
  if (restore_flag & SETTINGS_RESTORE_DEFAULTS) {
 8009768:	1dfb      	adds	r3, r7, #7
 800976a:	781b      	ldrb	r3, [r3, #0]
 800976c:	2201      	movs	r2, #1
 800976e:	4013      	ands	r3, r2
 8009770:	d078      	beq.n	8009864 <settings_restore+0x108>
    settings.pulse_microseconds = DEFAULT_STEP_PULSE_MICROSECONDS;
 8009772:	4b66      	ldr	r3, [pc, #408]	; (800990c <settings_restore+0x1b0>)
 8009774:	2240      	movs	r2, #64	; 0x40
 8009776:	210a      	movs	r1, #10
 8009778:	5499      	strb	r1, [r3, r2]
    settings.stepper_idle_lock_time = DEFAULT_STEPPER_IDLE_LOCK_TIME;
 800977a:	4b64      	ldr	r3, [pc, #400]	; (800990c <settings_restore+0x1b0>)
 800977c:	2243      	movs	r2, #67	; 0x43
 800977e:	2100      	movs	r1, #0
 8009780:	5499      	strb	r1, [r3, r2]
    settings.step_invert_mask = DEFAULT_STEPPING_INVERT_MASK;
 8009782:	4b62      	ldr	r3, [pc, #392]	; (800990c <settings_restore+0x1b0>)
 8009784:	2241      	movs	r2, #65	; 0x41
 8009786:	2107      	movs	r1, #7
 8009788:	5499      	strb	r1, [r3, r2]
    settings.dir_invert_mask = DEFAULT_DIRECTION_INVERT_MASK;
 800978a:	4b60      	ldr	r3, [pc, #384]	; (800990c <settings_restore+0x1b0>)
 800978c:	2242      	movs	r2, #66	; 0x42
 800978e:	2100      	movs	r1, #0
 8009790:	5499      	strb	r1, [r3, r2]
    settings.status_report_mask = DEFAULT_STATUS_REPORT_MASK;
 8009792:	4b5e      	ldr	r3, [pc, #376]	; (800990c <settings_restore+0x1b0>)
 8009794:	2244      	movs	r2, #68	; 0x44
 8009796:	2101      	movs	r1, #1
 8009798:	5499      	strb	r1, [r3, r2]
    settings.junction_deviation = DEFAULT_JUNCTION_DEVIATION;
 800979a:	4b5c      	ldr	r3, [pc, #368]	; (800990c <settings_restore+0x1b0>)
 800979c:	4a5c      	ldr	r2, [pc, #368]	; (8009910 <settings_restore+0x1b4>)
 800979e:	649a      	str	r2, [r3, #72]	; 0x48
    settings.arc_tolerance = DEFAULT_ARC_TOLERANCE;
 80097a0:	4b5a      	ldr	r3, [pc, #360]	; (800990c <settings_restore+0x1b0>)
 80097a2:	4a5c      	ldr	r2, [pc, #368]	; (8009914 <settings_restore+0x1b8>)
 80097a4:	64da      	str	r2, [r3, #76]	; 0x4c

    settings.rpm_max = DEFAULT_SPINDLE_RPM_MAX;
 80097a6:	4b59      	ldr	r3, [pc, #356]	; (800990c <settings_restore+0x1b0>)
 80097a8:	4a5b      	ldr	r2, [pc, #364]	; (8009918 <settings_restore+0x1bc>)
 80097aa:	651a      	str	r2, [r3, #80]	; 0x50
    settings.rpm_min = DEFAULT_SPINDLE_RPM_MIN;
 80097ac:	4b57      	ldr	r3, [pc, #348]	; (800990c <settings_restore+0x1b0>)
 80097ae:	2200      	movs	r2, #0
 80097b0:	655a      	str	r2, [r3, #84]	; 0x54

    settings.homing_dir_mask = DEFAULT_HOMING_DIR_MASK;
 80097b2:	4b56      	ldr	r3, [pc, #344]	; (800990c <settings_restore+0x1b0>)
 80097b4:	2259      	movs	r2, #89	; 0x59
 80097b6:	210f      	movs	r1, #15
 80097b8:	5499      	strb	r1, [r3, r2]
    settings.homing_feed_rate = DEFAULT_HOMING_FEED_RATE;
 80097ba:	4b54      	ldr	r3, [pc, #336]	; (800990c <settings_restore+0x1b0>)
 80097bc:	4a57      	ldr	r2, [pc, #348]	; (800991c <settings_restore+0x1c0>)
 80097be:	65da      	str	r2, [r3, #92]	; 0x5c
    settings.homing_seek_rate = DEFAULT_HOMING_SEEK_RATE;
 80097c0:	4b52      	ldr	r3, [pc, #328]	; (800990c <settings_restore+0x1b0>)
 80097c2:	4a56      	ldr	r2, [pc, #344]	; (800991c <settings_restore+0x1c0>)
 80097c4:	661a      	str	r2, [r3, #96]	; 0x60
    settings.homing_debounce_delay = DEFAULT_HOMING_DEBOUNCE_DELAY;
 80097c6:	4b51      	ldr	r3, [pc, #324]	; (800990c <settings_restore+0x1b0>)
 80097c8:	2264      	movs	r2, #100	; 0x64
 80097ca:	21fa      	movs	r1, #250	; 0xfa
 80097cc:	5299      	strh	r1, [r3, r2]
    settings.homing_pulloff = DEFAULT_HOMING_PULLOFF;
 80097ce:	4b4f      	ldr	r3, [pc, #316]	; (800990c <settings_restore+0x1b0>)
 80097d0:	2200      	movs	r2, #0
 80097d2:	669a      	str	r2, [r3, #104]	; 0x68

    settings.flags = 0;
 80097d4:	4b4d      	ldr	r3, [pc, #308]	; (800990c <settings_restore+0x1b0>)
 80097d6:	2258      	movs	r2, #88	; 0x58
 80097d8:	2100      	movs	r1, #0
 80097da:	5499      	strb	r1, [r3, r2]
    if (DEFAULT_REPORT_INCHES) { settings.flags |= BITFLAG_REPORT_INCHES; }
    if (DEFAULT_LASER_MODE) { settings.flags |= BITFLAG_LASER_MODE; }
 80097dc:	4b4b      	ldr	r3, [pc, #300]	; (800990c <settings_restore+0x1b0>)
 80097de:	2258      	movs	r2, #88	; 0x58
 80097e0:	5c9b      	ldrb	r3, [r3, r2]
 80097e2:	2202      	movs	r2, #2
 80097e4:	4313      	orrs	r3, r2
 80097e6:	b2d9      	uxtb	r1, r3
 80097e8:	4b48      	ldr	r3, [pc, #288]	; (800990c <settings_restore+0x1b0>)
 80097ea:	2258      	movs	r2, #88	; 0x58
 80097ec:	5499      	strb	r1, [r3, r2]
    if (DEFAULT_INVERT_ST_ENABLE) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
    if (DEFAULT_HARD_LIMIT_ENABLE) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
    if (DEFAULT_HOMING_ENABLE) { settings.flags |= BITFLAG_HOMING_ENABLE; }
 80097ee:	4b47      	ldr	r3, [pc, #284]	; (800990c <settings_restore+0x1b0>)
 80097f0:	2258      	movs	r2, #88	; 0x58
 80097f2:	5c9b      	ldrb	r3, [r3, r2]
 80097f4:	2210      	movs	r2, #16
 80097f6:	4313      	orrs	r3, r2
 80097f8:	b2d9      	uxtb	r1, r3
 80097fa:	4b44      	ldr	r3, [pc, #272]	; (800990c <settings_restore+0x1b0>)
 80097fc:	2258      	movs	r2, #88	; 0x58
 80097fe:	5499      	strb	r1, [r3, r2]
    if (DEFAULT_SOFT_LIMIT_ENABLE) { settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; }
    if (DEFAULT_INVERT_LIMIT_PINS) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
    if (DEFAULT_INVERT_PROBE_PIN) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }

    settings.steps_per_mm[X_AXIS] = DEFAULT_X_STEPS_PER_MM;
 8009800:	4b42      	ldr	r3, [pc, #264]	; (800990c <settings_restore+0x1b0>)
 8009802:	4a47      	ldr	r2, [pc, #284]	; (8009920 <settings_restore+0x1c4>)
 8009804:	601a      	str	r2, [r3, #0]
    settings.steps_per_mm[Y_AXIS] = DEFAULT_Y_STEPS_PER_MM;
 8009806:	4b41      	ldr	r3, [pc, #260]	; (800990c <settings_restore+0x1b0>)
 8009808:	4a45      	ldr	r2, [pc, #276]	; (8009920 <settings_restore+0x1c4>)
 800980a:	605a      	str	r2, [r3, #4]
    settings.steps_per_mm[Z_AXIS] = DEFAULT_Z_STEPS_PER_MM;
 800980c:	4b3f      	ldr	r3, [pc, #252]	; (800990c <settings_restore+0x1b0>)
 800980e:	4a45      	ldr	r2, [pc, #276]	; (8009924 <settings_restore+0x1c8>)
 8009810:	609a      	str	r2, [r3, #8]
    settings.max_rate[X_AXIS] = DEFAULT_X_MAX_RATE;
 8009812:	4b3e      	ldr	r3, [pc, #248]	; (800990c <settings_restore+0x1b0>)
 8009814:	4a44      	ldr	r2, [pc, #272]	; (8009928 <settings_restore+0x1cc>)
 8009816:	611a      	str	r2, [r3, #16]
    settings.max_rate[Y_AXIS] = DEFAULT_Y_MAX_RATE;
 8009818:	4b3c      	ldr	r3, [pc, #240]	; (800990c <settings_restore+0x1b0>)
 800981a:	4a43      	ldr	r2, [pc, #268]	; (8009928 <settings_restore+0x1cc>)
 800981c:	615a      	str	r2, [r3, #20]
    settings.max_rate[Z_AXIS] = DEFAULT_Z_MAX_RATE;
 800981e:	4b3b      	ldr	r3, [pc, #236]	; (800990c <settings_restore+0x1b0>)
 8009820:	4a41      	ldr	r2, [pc, #260]	; (8009928 <settings_restore+0x1cc>)
 8009822:	619a      	str	r2, [r3, #24]
    settings.acceleration[X_AXIS] = DEFAULT_X_ACCELERATION;
 8009824:	4b39      	ldr	r3, [pc, #228]	; (800990c <settings_restore+0x1b0>)
 8009826:	4a41      	ldr	r2, [pc, #260]	; (800992c <settings_restore+0x1d0>)
 8009828:	621a      	str	r2, [r3, #32]
    settings.acceleration[Y_AXIS] = DEFAULT_Y_ACCELERATION;
 800982a:	4b38      	ldr	r3, [pc, #224]	; (800990c <settings_restore+0x1b0>)
 800982c:	4a3f      	ldr	r2, [pc, #252]	; (800992c <settings_restore+0x1d0>)
 800982e:	625a      	str	r2, [r3, #36]	; 0x24
    settings.acceleration[Z_AXIS] = DEFAULT_Z_ACCELERATION;
 8009830:	4b36      	ldr	r3, [pc, #216]	; (800990c <settings_restore+0x1b0>)
 8009832:	4a3e      	ldr	r2, [pc, #248]	; (800992c <settings_restore+0x1d0>)
 8009834:	629a      	str	r2, [r3, #40]	; 0x28
    settings.max_travel[X_AXIS] = (-DEFAULT_X_MAX_TRAVEL);
 8009836:	4b35      	ldr	r3, [pc, #212]	; (800990c <settings_restore+0x1b0>)
 8009838:	4a3d      	ldr	r2, [pc, #244]	; (8009930 <settings_restore+0x1d4>)
 800983a:	631a      	str	r2, [r3, #48]	; 0x30
    settings.max_travel[Y_AXIS] = (-DEFAULT_Y_MAX_TRAVEL);
 800983c:	4b33      	ldr	r3, [pc, #204]	; (800990c <settings_restore+0x1b0>)
 800983e:	4a3d      	ldr	r2, [pc, #244]	; (8009934 <settings_restore+0x1d8>)
 8009840:	635a      	str	r2, [r3, #52]	; 0x34
    settings.max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL);
 8009842:	4b32      	ldr	r3, [pc, #200]	; (800990c <settings_restore+0x1b0>)
 8009844:	4a3c      	ldr	r2, [pc, #240]	; (8009938 <settings_restore+0x1dc>)
 8009846:	639a      	str	r2, [r3, #56]	; 0x38

#ifdef A_AXIS
    settings.steps_per_mm[A_AXIS] = DEFAULT_A_STEPS_PER_MM;
 8009848:	4b30      	ldr	r3, [pc, #192]	; (800990c <settings_restore+0x1b0>)
 800984a:	4a3c      	ldr	r2, [pc, #240]	; (800993c <settings_restore+0x1e0>)
 800984c:	60da      	str	r2, [r3, #12]
    settings.max_rate[A_AXIS] = DEFAULT_A_MAX_RATE;
 800984e:	4b2f      	ldr	r3, [pc, #188]	; (800990c <settings_restore+0x1b0>)
 8009850:	4a35      	ldr	r2, [pc, #212]	; (8009928 <settings_restore+0x1cc>)
 8009852:	61da      	str	r2, [r3, #28]
    settings.acceleration[A_AXIS] = DEFAULT_A_ACCELERATION;
 8009854:	4b2d      	ldr	r3, [pc, #180]	; (800990c <settings_restore+0x1b0>)
 8009856:	4a35      	ldr	r2, [pc, #212]	; (800992c <settings_restore+0x1d0>)
 8009858:	62da      	str	r2, [r3, #44]	; 0x2c
    settings.max_travel[A_AXIS] = (-DEFAULT_A_MAX_TRAVEL);
 800985a:	4b2c      	ldr	r3, [pc, #176]	; (800990c <settings_restore+0x1b0>)
 800985c:	4a38      	ldr	r2, [pc, #224]	; (8009940 <settings_restore+0x1e4>)
 800985e:	63da      	str	r2, [r3, #60]	; 0x3c
#endif

    write_global_settings();
 8009860:	f7ff ff6a 	bl	8009738 <write_global_settings>
  }

  if (restore_flag & SETTINGS_RESTORE_PARAMETERS) {
 8009864:	1dfb      	adds	r3, r7, #7
 8009866:	781b      	ldrb	r3, [r3, #0]
 8009868:	2202      	movs	r2, #2
 800986a:	4013      	ands	r3, r2
 800986c:	d020      	beq.n	80098b0 <settings_restore+0x154>
    uint8_t idx;
    float coord_data[N_AXIS];
    memset(&coord_data, 0, sizeof(coord_data));
 800986e:	230c      	movs	r3, #12
 8009870:	18fb      	adds	r3, r7, r3
 8009872:	2210      	movs	r2, #16
 8009874:	2100      	movs	r1, #0
 8009876:	0018      	movs	r0, r3
 8009878:	f002 ff44 	bl	800c704 <memset>
    for (idx=0; idx <= SETTING_INDEX_NCOORD; idx++) { settings_write_coord_data(idx, coord_data); }
 800987c:	231f      	movs	r3, #31
 800987e:	18fb      	adds	r3, r7, r3
 8009880:	2200      	movs	r2, #0
 8009882:	701a      	strb	r2, [r3, #0]
 8009884:	e00f      	b.n	80098a6 <settings_restore+0x14a>
 8009886:	230c      	movs	r3, #12
 8009888:	18fa      	adds	r2, r7, r3
 800988a:	231f      	movs	r3, #31
 800988c:	18fb      	adds	r3, r7, r3
 800988e:	781b      	ldrb	r3, [r3, #0]
 8009890:	0011      	movs	r1, r2
 8009892:	0018      	movs	r0, r3
 8009894:	f7ff ff32 	bl	80096fc <settings_write_coord_data>
 8009898:	231f      	movs	r3, #31
 800989a:	18fb      	adds	r3, r7, r3
 800989c:	781a      	ldrb	r2, [r3, #0]
 800989e:	231f      	movs	r3, #31
 80098a0:	18fb      	adds	r3, r7, r3
 80098a2:	3201      	adds	r2, #1
 80098a4:	701a      	strb	r2, [r3, #0]
 80098a6:	231f      	movs	r3, #31
 80098a8:	18fb      	adds	r3, r7, r3
 80098aa:	781b      	ldrb	r3, [r3, #0]
 80098ac:	2b07      	cmp	r3, #7
 80098ae:	d9ea      	bls.n	8009886 <settings_restore+0x12a>
  }

  if (restore_flag & SETTINGS_RESTORE_STARTUP_LINES) {
 80098b0:	1dfb      	adds	r3, r7, #7
 80098b2:	781b      	ldrb	r3, [r3, #0]
 80098b4:	2204      	movs	r2, #4
 80098b6:	4013      	ands	r3, r2
 80098b8:	d014      	beq.n	80098e4 <settings_restore+0x188>
    #if N_STARTUP_LINE > 0
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);
 80098ba:	23c0      	movs	r3, #192	; 0xc0
 80098bc:	009b      	lsls	r3, r3, #2
 80098be:	2100      	movs	r1, #0
 80098c0:	0018      	movs	r0, r3
 80098c2:	f7fa f80f 	bl	80038e4 <eeprom_put_char>
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+1, 0); // Checksum
 80098c6:	4b1f      	ldr	r3, [pc, #124]	; (8009944 <settings_restore+0x1e8>)
 80098c8:	2100      	movs	r1, #0
 80098ca:	0018      	movs	r0, r3
 80098cc:	f7fa f80a 	bl	80038e4 <eeprom_put_char>
    #endif
    #if N_STARTUP_LINE > 1
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);
 80098d0:	4b1d      	ldr	r3, [pc, #116]	; (8009948 <settings_restore+0x1ec>)
 80098d2:	2100      	movs	r1, #0
 80098d4:	0018      	movs	r0, r3
 80098d6:	f7fa f805 	bl	80038e4 <eeprom_put_char>
      eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+2), 0); // Checksum
 80098da:	4b1c      	ldr	r3, [pc, #112]	; (800994c <settings_restore+0x1f0>)
 80098dc:	2100      	movs	r1, #0
 80098de:	0018      	movs	r0, r3
 80098e0:	f7fa f800 	bl	80038e4 <eeprom_put_char>
    #endif
  }

  if (restore_flag & SETTINGS_RESTORE_BUILD_INFO) {
 80098e4:	1dfb      	adds	r3, r7, #7
 80098e6:	781b      	ldrb	r3, [r3, #0]
 80098e8:	2208      	movs	r2, #8
 80098ea:	4013      	ands	r3, r2
 80098ec:	d009      	beq.n	8009902 <settings_restore+0x1a6>
    eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0);
 80098ee:	4b18      	ldr	r3, [pc, #96]	; (8009950 <settings_restore+0x1f4>)
 80098f0:	2100      	movs	r1, #0
 80098f2:	0018      	movs	r0, r3
 80098f4:	f7f9 fff6 	bl	80038e4 <eeprom_put_char>
    eeprom_put_char(EEPROM_ADDR_BUILD_INFO+1 , 0); // Checksum
 80098f8:	4b16      	ldr	r3, [pc, #88]	; (8009954 <settings_restore+0x1f8>)
 80098fa:	2100      	movs	r1, #0
 80098fc:	0018      	movs	r0, r3
 80098fe:	f7f9 fff1 	bl	80038e4 <eeprom_put_char>
  }
}
 8009902:	46c0      	nop			; (mov r8, r8)
 8009904:	46bd      	mov	sp, r7
 8009906:	b008      	add	sp, #32
 8009908:	bd80      	pop	{r7, pc}
 800990a:	46c0      	nop			; (mov r8, r8)
 800990c:	20000b44 	.word	0x20000b44
 8009910:	3c23d70a 	.word	0x3c23d70a
 8009914:	3b03126f 	.word	0x3b03126f
 8009918:	447a0000 	.word	0x447a0000
 800991c:	43fa0000 	.word	0x43fa0000
 8009920:	42a00000 	.word	0x42a00000
 8009924:	43160000 	.word	0x43160000
 8009928:	44160000 	.word	0x44160000
 800992c:	481e3400 	.word	0x481e3400
 8009930:	c3480000 	.word	0xc3480000
 8009934:	c3960000 	.word	0xc3960000
 8009938:	c2480000 	.word	0xc2480000
 800993c:	41366666 	.word	0x41366666
 8009940:	c3b3f333 	.word	0xc3b3f333
 8009944:	00000301 	.word	0x00000301
 8009948:	00000351 	.word	0x00000351
 800994c:	00000352 	.word	0x00000352
 8009950:	000003ae 	.word	0x000003ae
 8009954:	000003af 	.word	0x000003af

08009958 <settings_read_startup_line>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
 8009958:	b580      	push	{r7, lr}
 800995a:	b084      	sub	sp, #16
 800995c:	af00      	add	r7, sp, #0
 800995e:	0002      	movs	r2, r0
 8009960:	6039      	str	r1, [r7, #0]
 8009962:	1dfb      	adds	r3, r7, #7
 8009964:	701a      	strb	r2, [r3, #0]
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
 8009966:	1dfb      	adds	r3, r7, #7
 8009968:	781a      	ldrb	r2, [r3, #0]
 800996a:	0013      	movs	r3, r2
 800996c:	00db      	lsls	r3, r3, #3
 800996e:	189b      	adds	r3, r3, r2
 8009970:	00da      	lsls	r2, r3, #3
 8009972:	189b      	adds	r3, r3, r2
 8009974:	22c0      	movs	r2, #192	; 0xc0
 8009976:	0092      	lsls	r2, r2, #2
 8009978:	4694      	mov	ip, r2
 800997a:	4463      	add	r3, ip
 800997c:	60fb      	str	r3, [r7, #12]
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
 800997e:	68f9      	ldr	r1, [r7, #12]
 8009980:	683b      	ldr	r3, [r7, #0]
 8009982:	2250      	movs	r2, #80	; 0x50
 8009984:	0018      	movs	r0, r3
 8009986:	f7fa f803 	bl	8003990 <memcpy_from_eeprom_with_checksum>
 800998a:	1e03      	subs	r3, r0, #0
 800998c:	d10b      	bne.n	80099a6 <settings_read_startup_line+0x4e>
    // Reset line with default value
    line[0] = 0; // Empty line
 800998e:	683b      	ldr	r3, [r7, #0]
 8009990:	2200      	movs	r2, #0
 8009992:	701a      	strb	r2, [r3, #0]
    settings_store_startup_line(n, line);
 8009994:	683a      	ldr	r2, [r7, #0]
 8009996:	1dfb      	adds	r3, r7, #7
 8009998:	781b      	ldrb	r3, [r3, #0]
 800999a:	0011      	movs	r1, r2
 800999c:	0018      	movs	r0, r3
 800999e:	f7ff fe7d 	bl	800969c <settings_store_startup_line>
    return(false);
 80099a2:	2300      	movs	r3, #0
 80099a4:	e000      	b.n	80099a8 <settings_read_startup_line+0x50>
  }
  return(true);
 80099a6:	2301      	movs	r3, #1
}
 80099a8:	0018      	movs	r0, r3
 80099aa:	46bd      	mov	sp, r7
 80099ac:	b004      	add	sp, #16
 80099ae:	bd80      	pop	{r7, pc}

080099b0 <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
 80099b0:	b580      	push	{r7, lr}
 80099b2:	b082      	sub	sp, #8
 80099b4:	af00      	add	r7, sp, #0
 80099b6:	6078      	str	r0, [r7, #4]
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
 80099b8:	490a      	ldr	r1, [pc, #40]	; (80099e4 <settings_read_build_info+0x34>)
 80099ba:	687b      	ldr	r3, [r7, #4]
 80099bc:	2250      	movs	r2, #80	; 0x50
 80099be:	0018      	movs	r0, r3
 80099c0:	f7f9 ffe6 	bl	8003990 <memcpy_from_eeprom_with_checksum>
 80099c4:	1e03      	subs	r3, r0, #0
 80099c6:	d108      	bne.n	80099da <settings_read_build_info+0x2a>
    // Reset line with default value
    line[0] = 0; // Empty line
 80099c8:	687b      	ldr	r3, [r7, #4]
 80099ca:	2200      	movs	r2, #0
 80099cc:	701a      	strb	r2, [r3, #0]
    settings_store_build_info(line);
 80099ce:	687b      	ldr	r3, [r7, #4]
 80099d0:	0018      	movs	r0, r3
 80099d2:	f7ff fe83 	bl	80096dc <settings_store_build_info>
    return(false);
 80099d6:	2300      	movs	r3, #0
 80099d8:	e000      	b.n	80099dc <settings_read_build_info+0x2c>
  }
  return(true);
 80099da:	2301      	movs	r3, #1
}
 80099dc:	0018      	movs	r0, r3
 80099de:	46bd      	mov	sp, r7
 80099e0:	b002      	add	sp, #8
 80099e2:	bd80      	pop	{r7, pc}
 80099e4:	000003ae 	.word	0x000003ae

080099e8 <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
 80099e8:	b580      	push	{r7, lr}
 80099ea:	b084      	sub	sp, #16
 80099ec:	af00      	add	r7, sp, #0
 80099ee:	0002      	movs	r2, r0
 80099f0:	6039      	str	r1, [r7, #0]
 80099f2:	1dfb      	adds	r3, r7, #7
 80099f4:	701a      	strb	r2, [r3, #0]
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
 80099f6:	1dfb      	adds	r3, r7, #7
 80099f8:	781a      	ldrb	r2, [r3, #0]
 80099fa:	0013      	movs	r3, r2
 80099fc:	011b      	lsls	r3, r3, #4
 80099fe:	189b      	adds	r3, r3, r2
 8009a00:	2280      	movs	r2, #128	; 0x80
 8009a02:	0092      	lsls	r2, r2, #2
 8009a04:	4694      	mov	ip, r2
 8009a06:	4463      	add	r3, ip
 8009a08:	60fb      	str	r3, [r7, #12]
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
 8009a0a:	68f9      	ldr	r1, [r7, #12]
 8009a0c:	683b      	ldr	r3, [r7, #0]
 8009a0e:	2210      	movs	r2, #16
 8009a10:	0018      	movs	r0, r3
 8009a12:	f7f9 ffbd 	bl	8003990 <memcpy_from_eeprom_with_checksum>
 8009a16:	1e03      	subs	r3, r0, #0
 8009a18:	d10e      	bne.n	8009a38 <settings_read_coord_data+0x50>
    // Reset with default zero vector
    clear_vector_float(coord_data);
 8009a1a:	683b      	ldr	r3, [r7, #0]
 8009a1c:	2210      	movs	r2, #16
 8009a1e:	2100      	movs	r1, #0
 8009a20:	0018      	movs	r0, r3
 8009a22:	f002 fe6f 	bl	800c704 <memset>
    settings_write_coord_data(coord_select,coord_data);
 8009a26:	683a      	ldr	r2, [r7, #0]
 8009a28:	1dfb      	adds	r3, r7, #7
 8009a2a:	781b      	ldrb	r3, [r3, #0]
 8009a2c:	0011      	movs	r1, r2
 8009a2e:	0018      	movs	r0, r3
 8009a30:	f7ff fe64 	bl	80096fc <settings_write_coord_data>
    return(false);
 8009a34:	2300      	movs	r3, #0
 8009a36:	e000      	b.n	8009a3a <settings_read_coord_data+0x52>
  }
  return(true);
 8009a38:	2301      	movs	r3, #1
}
 8009a3a:	0018      	movs	r0, r3
 8009a3c:	46bd      	mov	sp, r7
 8009a3e:	b004      	add	sp, #16
 8009a40:	bd80      	pop	{r7, pc}
	...

08009a44 <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
 8009a44:	b590      	push	{r4, r7, lr}
 8009a46:	b083      	sub	sp, #12
 8009a48:	af00      	add	r7, sp, #0
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
 8009a4a:	1dfc      	adds	r4, r7, #7
 8009a4c:	2000      	movs	r0, #0
 8009a4e:	f7f9 ff3b 	bl	80038c8 <eeprom_get_char>
 8009a52:	0003      	movs	r3, r0
 8009a54:	7023      	strb	r3, [r4, #0]
  if (version == SETTINGS_VERSION) {
 8009a56:	1dfb      	adds	r3, r7, #7
 8009a58:	781b      	ldrb	r3, [r3, #0]
 8009a5a:	2b0a      	cmp	r3, #10
 8009a5c:	d109      	bne.n	8009a72 <read_global_settings+0x2e>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
 8009a5e:	4b08      	ldr	r3, [pc, #32]	; (8009a80 <read_global_settings+0x3c>)
 8009a60:	226c      	movs	r2, #108	; 0x6c
 8009a62:	2101      	movs	r1, #1
 8009a64:	0018      	movs	r0, r3
 8009a66:	f7f9 ff93 	bl	8003990 <memcpy_from_eeprom_with_checksum>
 8009a6a:	1e03      	subs	r3, r0, #0
 8009a6c:	d103      	bne.n	8009a76 <read_global_settings+0x32>
      return(false);
 8009a6e:	2300      	movs	r3, #0
 8009a70:	e002      	b.n	8009a78 <read_global_settings+0x34>
    }
  } else {
    return(false);
 8009a72:	2300      	movs	r3, #0
 8009a74:	e000      	b.n	8009a78 <read_global_settings+0x34>
  }
  return(true);
 8009a76:	2301      	movs	r3, #1
}
 8009a78:	0018      	movs	r0, r3
 8009a7a:	46bd      	mov	sp, r7
 8009a7c:	b003      	add	sp, #12
 8009a7e:	bd90      	pop	{r4, r7, pc}
 8009a80:	20000b44 	.word	0x20000b44

08009a84 <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
 8009a84:	b590      	push	{r4, r7, lr}
 8009a86:	b085      	sub	sp, #20
 8009a88:	af00      	add	r7, sp, #0
 8009a8a:	0002      	movs	r2, r0
 8009a8c:	6039      	str	r1, [r7, #0]
 8009a8e:	1dfb      	adds	r3, r7, #7
 8009a90:	701a      	strb	r2, [r3, #0]
  if (value < 0.0f) { return(STATUS_NEGATIVE_VALUE); }
 8009a92:	2100      	movs	r1, #0
 8009a94:	6838      	ldr	r0, [r7, #0]
 8009a96:	f7f6 fc1d 	bl	80002d4 <__aeabi_fcmplt>
 8009a9a:	1e03      	subs	r3, r0, #0
 8009a9c:	d001      	beq.n	8009aa2 <settings_store_global_setting+0x1e>
 8009a9e:	2304      	movs	r3, #4
 8009aa0:	e1d3      	b.n	8009e4a <settings_store_global_setting+0x3c6>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
 8009aa2:	1dfb      	adds	r3, r7, #7
 8009aa4:	781b      	ldrb	r3, [r3, #0]
 8009aa6:	2b63      	cmp	r3, #99	; 0x63
 8009aa8:	d800      	bhi.n	8009aac <settings_store_global_setting+0x28>
 8009aaa:	e066      	b.n	8009b7a <settings_store_global_setting+0xf6>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
 8009aac:	1dfb      	adds	r3, r7, #7
 8009aae:	1dfa      	adds	r2, r7, #7
 8009ab0:	7812      	ldrb	r2, [r2, #0]
 8009ab2:	3a64      	subs	r2, #100	; 0x64
 8009ab4:	701a      	strb	r2, [r3, #0]
    uint8_t set_idx = 0;
 8009ab6:	230f      	movs	r3, #15
 8009ab8:	18fb      	adds	r3, r7, r3
 8009aba:	2200      	movs	r2, #0
 8009abc:	701a      	strb	r2, [r3, #0]
    while (set_idx < AXIS_N_SETTINGS) {
 8009abe:	e056      	b.n	8009b6e <settings_store_global_setting+0xea>
      if (parameter < N_AXIS) {
 8009ac0:	1dfb      	adds	r3, r7, #7
 8009ac2:	781b      	ldrb	r3, [r3, #0]
 8009ac4:	2b03      	cmp	r3, #3
 8009ac6:	d83b      	bhi.n	8009b40 <settings_store_global_setting+0xbc>
        // Valid axis setting found.
        switch (set_idx) {
 8009ac8:	230f      	movs	r3, #15
 8009aca:	18fb      	adds	r3, r7, r3
 8009acc:	781b      	ldrb	r3, [r3, #0]
 8009ace:	2b01      	cmp	r3, #1
 8009ad0:	d00f      	beq.n	8009af2 <settings_store_global_setting+0x6e>
 8009ad2:	dc02      	bgt.n	8009ada <settings_store_global_setting+0x56>
 8009ad4:	2b00      	cmp	r3, #0
 8009ad6:	d005      	beq.n	8009ae4 <settings_store_global_setting+0x60>
            settings.max_rate[parameter] = value;
            break;
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
 8009ad8:	e1b4      	b.n	8009e44 <settings_store_global_setting+0x3c0>
        switch (set_idx) {
 8009ada:	2b02      	cmp	r3, #2
 8009adc:	d011      	beq.n	8009b02 <settings_store_global_setting+0x7e>
 8009ade:	2b03      	cmp	r3, #3
 8009ae0:	d022      	beq.n	8009b28 <settings_store_global_setting+0xa4>
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
 8009ae2:	e1af      	b.n	8009e44 <settings_store_global_setting+0x3c0>
            settings.steps_per_mm[parameter] = value;
 8009ae4:	1dfb      	adds	r3, r7, #7
 8009ae6:	781a      	ldrb	r2, [r3, #0]
 8009ae8:	4bd3      	ldr	r3, [pc, #844]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009aea:	0092      	lsls	r2, r2, #2
 8009aec:	6839      	ldr	r1, [r7, #0]
 8009aee:	50d1      	str	r1, [r2, r3]
            break;
 8009af0:	e025      	b.n	8009b3e <settings_store_global_setting+0xba>
            settings.max_rate[parameter] = value;
 8009af2:	1dfb      	adds	r3, r7, #7
 8009af4:	781a      	ldrb	r2, [r3, #0]
 8009af6:	4bd0      	ldr	r3, [pc, #832]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009af8:	3204      	adds	r2, #4
 8009afa:	0092      	lsls	r2, r2, #2
 8009afc:	6839      	ldr	r1, [r7, #0]
 8009afe:	50d1      	str	r1, [r2, r3]
            break;
 8009b00:	e01d      	b.n	8009b3e <settings_store_global_setting+0xba>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
 8009b02:	1dfb      	adds	r3, r7, #7
 8009b04:	781c      	ldrb	r4, [r3, #0]
 8009b06:	49cd      	ldr	r1, [pc, #820]	; (8009e3c <settings_store_global_setting+0x3b8>)
 8009b08:	6838      	ldr	r0, [r7, #0]
 8009b0a:	f7f6 ffc3 	bl	8000a94 <__aeabi_fmul>
 8009b0e:	1c03      	adds	r3, r0, #0
 8009b10:	49ca      	ldr	r1, [pc, #808]	; (8009e3c <settings_store_global_setting+0x3b8>)
 8009b12:	1c18      	adds	r0, r3, #0
 8009b14:	f7f6 ffbe 	bl	8000a94 <__aeabi_fmul>
 8009b18:	1c03      	adds	r3, r0, #0
 8009b1a:	1c19      	adds	r1, r3, #0
 8009b1c:	4bc6      	ldr	r3, [pc, #792]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009b1e:	0022      	movs	r2, r4
 8009b20:	3208      	adds	r2, #8
 8009b22:	0092      	lsls	r2, r2, #2
 8009b24:	50d1      	str	r1, [r2, r3]
 8009b26:	e00a      	b.n	8009b3e <settings_store_global_setting+0xba>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
 8009b28:	1dfb      	adds	r3, r7, #7
 8009b2a:	781a      	ldrb	r2, [r3, #0]
 8009b2c:	683b      	ldr	r3, [r7, #0]
 8009b2e:	2180      	movs	r1, #128	; 0x80
 8009b30:	0609      	lsls	r1, r1, #24
 8009b32:	4059      	eors	r1, r3
 8009b34:	4bc0      	ldr	r3, [pc, #768]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009b36:	320c      	adds	r2, #12
 8009b38:	0092      	lsls	r2, r2, #2
 8009b3a:	50d1      	str	r1, [r2, r3]
 8009b3c:	46c0      	nop			; (mov r8, r8)
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
 8009b3e:	e181      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      } else {
        set_idx++;
 8009b40:	230f      	movs	r3, #15
 8009b42:	18fb      	adds	r3, r7, r3
 8009b44:	781a      	ldrb	r2, [r3, #0]
 8009b46:	230f      	movs	r3, #15
 8009b48:	18fb      	adds	r3, r7, r3
 8009b4a:	3201      	adds	r2, #1
 8009b4c:	701a      	strb	r2, [r3, #0]
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
 8009b4e:	1dfb      	adds	r3, r7, #7
 8009b50:	781b      	ldrb	r3, [r3, #0]
 8009b52:	2b09      	cmp	r3, #9
 8009b54:	d904      	bls.n	8009b60 <settings_store_global_setting+0xdc>
 8009b56:	230f      	movs	r3, #15
 8009b58:	18fb      	adds	r3, r7, r3
 8009b5a:	781b      	ldrb	r3, [r3, #0]
 8009b5c:	2b04      	cmp	r3, #4
 8009b5e:	d101      	bne.n	8009b64 <settings_store_global_setting+0xe0>
 8009b60:	2303      	movs	r3, #3
 8009b62:	e172      	b.n	8009e4a <settings_store_global_setting+0x3c6>
        parameter -= AXIS_SETTINGS_INCREMENT;
 8009b64:	1dfb      	adds	r3, r7, #7
 8009b66:	1dfa      	adds	r2, r7, #7
 8009b68:	7812      	ldrb	r2, [r2, #0]
 8009b6a:	3a0a      	subs	r2, #10
 8009b6c:	701a      	strb	r2, [r3, #0]
    while (set_idx < AXIS_N_SETTINGS) {
 8009b6e:	230f      	movs	r3, #15
 8009b70:	18fb      	adds	r3, r7, r3
 8009b72:	781b      	ldrb	r3, [r3, #0]
 8009b74:	2b03      	cmp	r3, #3
 8009b76:	d9a3      	bls.n	8009ac0 <settings_store_global_setting+0x3c>
 8009b78:	e164      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
 8009b7a:	6838      	ldr	r0, [r7, #0]
 8009b7c:	f7f8 fda2 	bl	80026c4 <__aeabi_f2d>
 8009b80:	0003      	movs	r3, r0
 8009b82:	000c      	movs	r4, r1
 8009b84:	0018      	movs	r0, r3
 8009b86:	0021      	movs	r1, r4
 8009b88:	f002 fe12 	bl	800c7b0 <trunc>
 8009b8c:	0002      	movs	r2, r0
 8009b8e:	000b      	movs	r3, r1
 8009b90:	210e      	movs	r1, #14
 8009b92:	187c      	adds	r4, r7, r1
 8009b94:	0010      	movs	r0, r2
 8009b96:	0019      	movs	r1, r3
 8009b98:	f7f6 fbdc 	bl	8000354 <__aeabi_d2uiz>
 8009b9c:	0003      	movs	r3, r0
 8009b9e:	7023      	strb	r3, [r4, #0]
    switch(parameter) {
 8009ba0:	1dfb      	adds	r3, r7, #7
 8009ba2:	781b      	ldrb	r3, [r3, #0]
 8009ba4:	2b20      	cmp	r3, #32
 8009ba6:	d900      	bls.n	8009baa <settings_store_global_setting+0x126>
 8009ba8:	e143      	b.n	8009e32 <settings_store_global_setting+0x3ae>
 8009baa:	009a      	lsls	r2, r3, #2
 8009bac:	4ba4      	ldr	r3, [pc, #656]	; (8009e40 <settings_store_global_setting+0x3bc>)
 8009bae:	18d3      	adds	r3, r2, r3
 8009bb0:	681b      	ldr	r3, [r3, #0]
 8009bb2:	469f      	mov	pc, r3
      case 0:
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
 8009bb4:	230e      	movs	r3, #14
 8009bb6:	18fb      	adds	r3, r7, r3
 8009bb8:	781b      	ldrb	r3, [r3, #0]
 8009bba:	2b02      	cmp	r3, #2
 8009bbc:	d801      	bhi.n	8009bc2 <settings_store_global_setting+0x13e>
 8009bbe:	2306      	movs	r3, #6
 8009bc0:	e143      	b.n	8009e4a <settings_store_global_setting+0x3c6>
        settings.pulse_microseconds = int_value; break;
 8009bc2:	4b9d      	ldr	r3, [pc, #628]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009bc4:	220e      	movs	r2, #14
 8009bc6:	18ba      	adds	r2, r7, r2
 8009bc8:	2140      	movs	r1, #64	; 0x40
 8009bca:	7812      	ldrb	r2, [r2, #0]
 8009bcc:	545a      	strb	r2, [r3, r1]
 8009bce:	e139      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 1: settings.stepper_idle_lock_time = int_value; break;
 8009bd0:	4b99      	ldr	r3, [pc, #612]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009bd2:	220e      	movs	r2, #14
 8009bd4:	18ba      	adds	r2, r7, r2
 8009bd6:	2143      	movs	r1, #67	; 0x43
 8009bd8:	7812      	ldrb	r2, [r2, #0]
 8009bda:	545a      	strb	r2, [r3, r1]
 8009bdc:	e132      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 2:
        settings.step_invert_mask = int_value;
 8009bde:	4b96      	ldr	r3, [pc, #600]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009be0:	220e      	movs	r2, #14
 8009be2:	18ba      	adds	r2, r7, r2
 8009be4:	2141      	movs	r1, #65	; 0x41
 8009be6:	7812      	ldrb	r2, [r2, #0]
 8009be8:	545a      	strb	r2, [r3, r1]
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
 8009bea:	f000 fe79 	bl	800a8e0 <st_generate_step_dir_invert_masks>
        break;
 8009bee:	e129      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 3:
        settings.dir_invert_mask = int_value;
 8009bf0:	4b91      	ldr	r3, [pc, #580]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009bf2:	220e      	movs	r2, #14
 8009bf4:	18ba      	adds	r2, r7, r2
 8009bf6:	2142      	movs	r1, #66	; 0x42
 8009bf8:	7812      	ldrb	r2, [r2, #0]
 8009bfa:	545a      	strb	r2, [r3, r1]
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
 8009bfc:	f000 fe70 	bl	800a8e0 <st_generate_step_dir_invert_masks>
        break;
 8009c00:	e120      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
 8009c02:	230e      	movs	r3, #14
 8009c04:	18fb      	adds	r3, r7, r3
 8009c06:	781b      	ldrb	r3, [r3, #0]
 8009c08:	2b00      	cmp	r3, #0
 8009c0a:	d009      	beq.n	8009c20 <settings_store_global_setting+0x19c>
 8009c0c:	4b8a      	ldr	r3, [pc, #552]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009c0e:	2258      	movs	r2, #88	; 0x58
 8009c10:	5c9b      	ldrb	r3, [r3, r2]
 8009c12:	2204      	movs	r2, #4
 8009c14:	4313      	orrs	r3, r2
 8009c16:	b2d9      	uxtb	r1, r3
 8009c18:	4b87      	ldr	r3, [pc, #540]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009c1a:	2258      	movs	r2, #88	; 0x58
 8009c1c:	5499      	strb	r1, [r3, r2]
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
        break;
 8009c1e:	e111      	b.n	8009e44 <settings_store_global_setting+0x3c0>
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
 8009c20:	4b85      	ldr	r3, [pc, #532]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009c22:	2258      	movs	r2, #88	; 0x58
 8009c24:	5c9b      	ldrb	r3, [r3, r2]
 8009c26:	2204      	movs	r2, #4
 8009c28:	4393      	bics	r3, r2
 8009c2a:	b2d9      	uxtb	r1, r3
 8009c2c:	4b82      	ldr	r3, [pc, #520]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009c2e:	2258      	movs	r2, #88	; 0x58
 8009c30:	5499      	strb	r1, [r3, r2]
        break;
 8009c32:	e107      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
 8009c34:	230e      	movs	r3, #14
 8009c36:	18fb      	adds	r3, r7, r3
 8009c38:	781b      	ldrb	r3, [r3, #0]
 8009c3a:	2b00      	cmp	r3, #0
 8009c3c:	d009      	beq.n	8009c52 <settings_store_global_setting+0x1ce>
 8009c3e:	4b7e      	ldr	r3, [pc, #504]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009c40:	2258      	movs	r2, #88	; 0x58
 8009c42:	5c9b      	ldrb	r3, [r3, r2]
 8009c44:	2240      	movs	r2, #64	; 0x40
 8009c46:	4313      	orrs	r3, r2
 8009c48:	b2d9      	uxtb	r1, r3
 8009c4a:	4b7b      	ldr	r3, [pc, #492]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009c4c:	2258      	movs	r2, #88	; 0x58
 8009c4e:	5499      	strb	r1, [r3, r2]
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
        break;
 8009c50:	e0f8      	b.n	8009e44 <settings_store_global_setting+0x3c0>
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
 8009c52:	4b79      	ldr	r3, [pc, #484]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009c54:	2258      	movs	r2, #88	; 0x58
 8009c56:	5c9b      	ldrb	r3, [r3, r2]
 8009c58:	2240      	movs	r2, #64	; 0x40
 8009c5a:	4393      	bics	r3, r2
 8009c5c:	b2d9      	uxtb	r1, r3
 8009c5e:	4b76      	ldr	r3, [pc, #472]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009c60:	2258      	movs	r2, #88	; 0x58
 8009c62:	5499      	strb	r1, [r3, r2]
        break;
 8009c64:	e0ee      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
 8009c66:	230e      	movs	r3, #14
 8009c68:	18fb      	adds	r3, r7, r3
 8009c6a:	781b      	ldrb	r3, [r3, #0]
 8009c6c:	2b00      	cmp	r3, #0
 8009c6e:	d00a      	beq.n	8009c86 <settings_store_global_setting+0x202>
 8009c70:	4b71      	ldr	r3, [pc, #452]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009c72:	2258      	movs	r2, #88	; 0x58
 8009c74:	5c9b      	ldrb	r3, [r3, r2]
 8009c76:	2280      	movs	r2, #128	; 0x80
 8009c78:	4252      	negs	r2, r2
 8009c7a:	4313      	orrs	r3, r2
 8009c7c:	b2d9      	uxtb	r1, r3
 8009c7e:	4b6e      	ldr	r3, [pc, #440]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009c80:	2258      	movs	r2, #88	; 0x58
 8009c82:	5499      	strb	r1, [r3, r2]
 8009c84:	e008      	b.n	8009c98 <settings_store_global_setting+0x214>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
 8009c86:	4b6c      	ldr	r3, [pc, #432]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009c88:	2258      	movs	r2, #88	; 0x58
 8009c8a:	5c9b      	ldrb	r3, [r3, r2]
 8009c8c:	227f      	movs	r2, #127	; 0x7f
 8009c8e:	4013      	ands	r3, r2
 8009c90:	b2d9      	uxtb	r1, r3
 8009c92:	4b69      	ldr	r3, [pc, #420]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009c94:	2258      	movs	r2, #88	; 0x58
 8009c96:	5499      	strb	r1, [r3, r2]
        probe_configure_invert_mask(false);
 8009c98:	2000      	movs	r0, #0
 8009c9a:	f7fd fec1 	bl	8007a20 <probe_configure_invert_mask>
        break;
 8009c9e:	e0d1      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 10: settings.status_report_mask = int_value; break;
 8009ca0:	4b65      	ldr	r3, [pc, #404]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009ca2:	220e      	movs	r2, #14
 8009ca4:	18ba      	adds	r2, r7, r2
 8009ca6:	2144      	movs	r1, #68	; 0x44
 8009ca8:	7812      	ldrb	r2, [r2, #0]
 8009caa:	545a      	strb	r2, [r3, r1]
 8009cac:	e0ca      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 11: settings.junction_deviation = value; break;
 8009cae:	4b62      	ldr	r3, [pc, #392]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009cb0:	683a      	ldr	r2, [r7, #0]
 8009cb2:	649a      	str	r2, [r3, #72]	; 0x48
 8009cb4:	e0c6      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 12: settings.arc_tolerance = value; break;
 8009cb6:	4b60      	ldr	r3, [pc, #384]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009cb8:	683a      	ldr	r2, [r7, #0]
 8009cba:	64da      	str	r2, [r3, #76]	; 0x4c
 8009cbc:	e0c2      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
 8009cbe:	230e      	movs	r3, #14
 8009cc0:	18fb      	adds	r3, r7, r3
 8009cc2:	781b      	ldrb	r3, [r3, #0]
 8009cc4:	2b00      	cmp	r3, #0
 8009cc6:	d009      	beq.n	8009cdc <settings_store_global_setting+0x258>
 8009cc8:	4b5b      	ldr	r3, [pc, #364]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009cca:	2258      	movs	r2, #88	; 0x58
 8009ccc:	5c9b      	ldrb	r3, [r3, r2]
 8009cce:	2201      	movs	r2, #1
 8009cd0:	4313      	orrs	r3, r2
 8009cd2:	b2d9      	uxtb	r1, r3
 8009cd4:	4b58      	ldr	r3, [pc, #352]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009cd6:	2258      	movs	r2, #88	; 0x58
 8009cd8:	5499      	strb	r1, [r3, r2]
 8009cda:	e008      	b.n	8009cee <settings_store_global_setting+0x26a>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
 8009cdc:	4b56      	ldr	r3, [pc, #344]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009cde:	2258      	movs	r2, #88	; 0x58
 8009ce0:	5c9b      	ldrb	r3, [r3, r2]
 8009ce2:	2201      	movs	r2, #1
 8009ce4:	4393      	bics	r3, r2
 8009ce6:	b2d9      	uxtb	r1, r3
 8009ce8:	4b53      	ldr	r3, [pc, #332]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009cea:	2258      	movs	r2, #88	; 0x58
 8009cec:	5499      	strb	r1, [r3, r2]
        system_flag_wco_change(); // Make sure WCO is immediately updated.
 8009cee:	f002 f8f1 	bl	800bed4 <system_flag_wco_change>
        break;
 8009cf2:	e0a7      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 20:
        if (int_value) {
 8009cf4:	230e      	movs	r3, #14
 8009cf6:	18fb      	adds	r3, r7, r3
 8009cf8:	781b      	ldrb	r3, [r3, #0]
 8009cfa:	2b00      	cmp	r3, #0
 8009cfc:	d012      	beq.n	8009d24 <settings_store_global_setting+0x2a0>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
 8009cfe:	4b4e      	ldr	r3, [pc, #312]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009d00:	2258      	movs	r2, #88	; 0x58
 8009d02:	5c9b      	ldrb	r3, [r3, r2]
 8009d04:	001a      	movs	r2, r3
 8009d06:	2310      	movs	r3, #16
 8009d08:	4013      	ands	r3, r2
 8009d0a:	d101      	bne.n	8009d10 <settings_store_global_setting+0x28c>
 8009d0c:	230a      	movs	r3, #10
 8009d0e:	e09c      	b.n	8009e4a <settings_store_global_setting+0x3c6>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE;
 8009d10:	4b49      	ldr	r3, [pc, #292]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009d12:	2258      	movs	r2, #88	; 0x58
 8009d14:	5c9b      	ldrb	r3, [r3, r2]
 8009d16:	2220      	movs	r2, #32
 8009d18:	4313      	orrs	r3, r2
 8009d1a:	b2d9      	uxtb	r1, r3
 8009d1c:	4b46      	ldr	r3, [pc, #280]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009d1e:	2258      	movs	r2, #88	; 0x58
 8009d20:	5499      	strb	r1, [r3, r2]
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
        break;
 8009d22:	e08f      	b.n	8009e44 <settings_store_global_setting+0x3c0>
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
 8009d24:	4b44      	ldr	r3, [pc, #272]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009d26:	2258      	movs	r2, #88	; 0x58
 8009d28:	5c9b      	ldrb	r3, [r3, r2]
 8009d2a:	2220      	movs	r2, #32
 8009d2c:	4393      	bics	r3, r2
 8009d2e:	b2d9      	uxtb	r1, r3
 8009d30:	4b41      	ldr	r3, [pc, #260]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009d32:	2258      	movs	r2, #88	; 0x58
 8009d34:	5499      	strb	r1, [r3, r2]
        break;
 8009d36:	e085      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
 8009d38:	230e      	movs	r3, #14
 8009d3a:	18fb      	adds	r3, r7, r3
 8009d3c:	781b      	ldrb	r3, [r3, #0]
 8009d3e:	2b00      	cmp	r3, #0
 8009d40:	d009      	beq.n	8009d56 <settings_store_global_setting+0x2d2>
 8009d42:	4b3d      	ldr	r3, [pc, #244]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009d44:	2258      	movs	r2, #88	; 0x58
 8009d46:	5c9b      	ldrb	r3, [r3, r2]
 8009d48:	2208      	movs	r2, #8
 8009d4a:	4313      	orrs	r3, r2
 8009d4c:	b2d9      	uxtb	r1, r3
 8009d4e:	4b3a      	ldr	r3, [pc, #232]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009d50:	2258      	movs	r2, #88	; 0x58
 8009d52:	5499      	strb	r1, [r3, r2]
 8009d54:	e008      	b.n	8009d68 <settings_store_global_setting+0x2e4>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
 8009d56:	4b38      	ldr	r3, [pc, #224]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009d58:	2258      	movs	r2, #88	; 0x58
 8009d5a:	5c9b      	ldrb	r3, [r3, r2]
 8009d5c:	2208      	movs	r2, #8
 8009d5e:	4393      	bics	r3, r2
 8009d60:	b2d9      	uxtb	r1, r3
 8009d62:	4b35      	ldr	r3, [pc, #212]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009d64:	2258      	movs	r2, #88	; 0x58
 8009d66:	5499      	strb	r1, [r3, r2]
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
 8009d68:	f7fb fc4a 	bl	8005600 <limits_init>
        break;
 8009d6c:	e06a      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
 8009d6e:	230e      	movs	r3, #14
 8009d70:	18fb      	adds	r3, r7, r3
 8009d72:	781b      	ldrb	r3, [r3, #0]
 8009d74:	2b00      	cmp	r3, #0
 8009d76:	d009      	beq.n	8009d8c <settings_store_global_setting+0x308>
 8009d78:	4b2f      	ldr	r3, [pc, #188]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009d7a:	2258      	movs	r2, #88	; 0x58
 8009d7c:	5c9b      	ldrb	r3, [r3, r2]
 8009d7e:	2210      	movs	r2, #16
 8009d80:	4313      	orrs	r3, r2
 8009d82:	b2d9      	uxtb	r1, r3
 8009d84:	4b2c      	ldr	r3, [pc, #176]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009d86:	2258      	movs	r2, #88	; 0x58
 8009d88:	5499      	strb	r1, [r3, r2]
        else {
          settings.flags &= ~BITFLAG_HOMING_ENABLE;
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
        }
        break;
 8009d8a:	e05b      	b.n	8009e44 <settings_store_global_setting+0x3c0>
          settings.flags &= ~BITFLAG_HOMING_ENABLE;
 8009d8c:	4b2a      	ldr	r3, [pc, #168]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009d8e:	2258      	movs	r2, #88	; 0x58
 8009d90:	5c9b      	ldrb	r3, [r3, r2]
 8009d92:	2210      	movs	r2, #16
 8009d94:	4393      	bics	r3, r2
 8009d96:	b2d9      	uxtb	r1, r3
 8009d98:	4b27      	ldr	r3, [pc, #156]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009d9a:	2258      	movs	r2, #88	; 0x58
 8009d9c:	5499      	strb	r1, [r3, r2]
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
 8009d9e:	4b26      	ldr	r3, [pc, #152]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009da0:	2258      	movs	r2, #88	; 0x58
 8009da2:	5c9b      	ldrb	r3, [r3, r2]
 8009da4:	2220      	movs	r2, #32
 8009da6:	4393      	bics	r3, r2
 8009da8:	b2d9      	uxtb	r1, r3
 8009daa:	4b23      	ldr	r3, [pc, #140]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009dac:	2258      	movs	r2, #88	; 0x58
 8009dae:	5499      	strb	r1, [r3, r2]
        break;
 8009db0:	e048      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 23: settings.homing_dir_mask = int_value; break;
 8009db2:	4b21      	ldr	r3, [pc, #132]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009db4:	220e      	movs	r2, #14
 8009db6:	18ba      	adds	r2, r7, r2
 8009db8:	2159      	movs	r1, #89	; 0x59
 8009dba:	7812      	ldrb	r2, [r2, #0]
 8009dbc:	545a      	strb	r2, [r3, r1]
 8009dbe:	e041      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 24: settings.homing_feed_rate = value; break;
 8009dc0:	4b1d      	ldr	r3, [pc, #116]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009dc2:	683a      	ldr	r2, [r7, #0]
 8009dc4:	65da      	str	r2, [r3, #92]	; 0x5c
 8009dc6:	e03d      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 25: settings.homing_seek_rate = value; break;
 8009dc8:	4b1b      	ldr	r3, [pc, #108]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009dca:	683a      	ldr	r2, [r7, #0]
 8009dcc:	661a      	str	r2, [r3, #96]	; 0x60
 8009dce:	e039      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 26: settings.homing_debounce_delay = int_value; break;
 8009dd0:	230e      	movs	r3, #14
 8009dd2:	18fb      	adds	r3, r7, r3
 8009dd4:	781b      	ldrb	r3, [r3, #0]
 8009dd6:	b299      	uxth	r1, r3
 8009dd8:	4b17      	ldr	r3, [pc, #92]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009dda:	2264      	movs	r2, #100	; 0x64
 8009ddc:	5299      	strh	r1, [r3, r2]
 8009dde:	e031      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 27: settings.homing_pulloff = value; break;
 8009de0:	4b15      	ldr	r3, [pc, #84]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009de2:	683a      	ldr	r2, [r7, #0]
 8009de4:	669a      	str	r2, [r3, #104]	; 0x68
 8009de6:	e02d      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 30: settings.rpm_max = value; spindle_init(); break; // Re-initialize spindle rpm calibration
 8009de8:	4b13      	ldr	r3, [pc, #76]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009dea:	683a      	ldr	r2, [r7, #0]
 8009dec:	651a      	str	r2, [r3, #80]	; 0x50
 8009dee:	f000 f843 	bl	8009e78 <spindle_init>
 8009df2:	e027      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 31: settings.rpm_min = value; spindle_init(); break; // Re-initialize spindle rpm calibration
 8009df4:	4b10      	ldr	r3, [pc, #64]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009df6:	683a      	ldr	r2, [r7, #0]
 8009df8:	655a      	str	r2, [r3, #84]	; 0x54
 8009dfa:	f000 f83d 	bl	8009e78 <spindle_init>
 8009dfe:	e021      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      case 32:
        #ifdef VARIABLE_SPINDLE
          if (int_value) { settings.flags |= BITFLAG_LASER_MODE; }
 8009e00:	230e      	movs	r3, #14
 8009e02:	18fb      	adds	r3, r7, r3
 8009e04:	781b      	ldrb	r3, [r3, #0]
 8009e06:	2b00      	cmp	r3, #0
 8009e08:	d009      	beq.n	8009e1e <settings_store_global_setting+0x39a>
 8009e0a:	4b0b      	ldr	r3, [pc, #44]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009e0c:	2258      	movs	r2, #88	; 0x58
 8009e0e:	5c9b      	ldrb	r3, [r3, r2]
 8009e10:	2202      	movs	r2, #2
 8009e12:	4313      	orrs	r3, r2
 8009e14:	b2d9      	uxtb	r1, r3
 8009e16:	4b08      	ldr	r3, [pc, #32]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009e18:	2258      	movs	r2, #88	; 0x58
 8009e1a:	5499      	strb	r1, [r3, r2]
          else { settings.flags &= ~BITFLAG_LASER_MODE; }
        #else
          return(STATUS_SETTING_DISABLED);
        #endif
        break;
 8009e1c:	e012      	b.n	8009e44 <settings_store_global_setting+0x3c0>
          else { settings.flags &= ~BITFLAG_LASER_MODE; }
 8009e1e:	4b06      	ldr	r3, [pc, #24]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009e20:	2258      	movs	r2, #88	; 0x58
 8009e22:	5c9b      	ldrb	r3, [r3, r2]
 8009e24:	2202      	movs	r2, #2
 8009e26:	4393      	bics	r3, r2
 8009e28:	b2d9      	uxtb	r1, r3
 8009e2a:	4b03      	ldr	r3, [pc, #12]	; (8009e38 <settings_store_global_setting+0x3b4>)
 8009e2c:	2258      	movs	r2, #88	; 0x58
 8009e2e:	5499      	strb	r1, [r3, r2]
        break;
 8009e30:	e008      	b.n	8009e44 <settings_store_global_setting+0x3c0>
      default:
        return(STATUS_INVALID_STATEMENT);
 8009e32:	2303      	movs	r3, #3
 8009e34:	e009      	b.n	8009e4a <settings_store_global_setting+0x3c6>
 8009e36:	46c0      	nop			; (mov r8, r8)
 8009e38:	20000b44 	.word	0x20000b44
 8009e3c:	42700000 	.word	0x42700000
 8009e40:	0800e028 	.word	0x0800e028
    }
  }
  write_global_settings();
 8009e44:	f7ff fc78 	bl	8009738 <write_global_settings>
  return(STATUS_OK);
 8009e48:	2300      	movs	r3, #0
}
 8009e4a:	0018      	movs	r0, r3
 8009e4c:	46bd      	mov	sp, r7
 8009e4e:	b005      	add	sp, #20
 8009e50:	bd90      	pop	{r4, r7, pc}
 8009e52:	46c0      	nop			; (mov r8, r8)

08009e54 <settings_init>:


// Initialize the config subsystem
void settings_init() {
 8009e54:	b580      	push	{r7, lr}
 8009e56:	af00      	add	r7, sp, #0
  if(!read_global_settings()) {
 8009e58:	f7ff fdf4 	bl	8009a44 <read_global_settings>
 8009e5c:	1e03      	subs	r3, r0, #0
 8009e5e:	d107      	bne.n	8009e70 <settings_init+0x1c>
    report_status_message(STATUS_SETTING_READ_FAIL);
 8009e60:	2007      	movs	r0, #7
 8009e62:	f7fe fc99 	bl	8008798 <report_status_message>
    settings_restore(SETTINGS_RESTORE_ALL); // Force restore all EEPROM data.
 8009e66:	20ff      	movs	r0, #255	; 0xff
 8009e68:	f7ff fc78 	bl	800975c <settings_restore>
    report_grbl_settings();
 8009e6c:	f7fe fd54 	bl	8008918 <report_grbl_settings>
  }
}
 8009e70:	46c0      	nop			; (mov r8, r8)
 8009e72:	46bd      	mov	sp, r7
 8009e74:	bd80      	pop	{r7, pc}
	...

08009e78 <spindle_init>:
  static float pwm_gradient; // Precalulated value to speed up rpm to PWM conversions.
#endif


void spindle_init()
{
 8009e78:	b580      	push	{r7, lr}
 8009e7a:	b08a      	sub	sp, #40	; 0x28
 8009e7c:	af00      	add	r7, sp, #0
#ifdef VARIABLE_SPINDLE
  pwm_gradient = SPINDLE_PWM_RANGE / (settings.rpm_max - settings.rpm_min);
 8009e7e:	4b58      	ldr	r3, [pc, #352]	; (8009fe0 <spindle_init+0x168>)
 8009e80:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8009e82:	4b57      	ldr	r3, [pc, #348]	; (8009fe0 <spindle_init+0x168>)
 8009e84:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009e86:	1c19      	adds	r1, r3, #0
 8009e88:	1c10      	adds	r0, r2, #0
 8009e8a:	f7f6 ff23 	bl	8000cd4 <__aeabi_fsub>
 8009e8e:	1c03      	adds	r3, r0, #0
 8009e90:	1c19      	adds	r1, r3, #0
 8009e92:	4854      	ldr	r0, [pc, #336]	; (8009fe4 <spindle_init+0x16c>)
 8009e94:	f7f6 fc0e 	bl	80006b4 <__aeabi_fdiv>
 8009e98:	1c03      	adds	r3, r0, #0
 8009e9a:	1c1a      	adds	r2, r3, #0
 8009e9c:	4b52      	ldr	r3, [pc, #328]	; (8009fe8 <spindle_init+0x170>)
 8009e9e:	601a      	str	r2, [r3, #0]

#endif
#endif
#if defined (STM32F0DISCOVERY)
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_AHBPeriphClockCmd(RCC_SPINDLE_ENABLE_PORT, ENABLE);
 8009ea0:	2380      	movs	r3, #128	; 0x80
 8009ea2:	02db      	lsls	r3, r3, #11
 8009ea4:	2101      	movs	r1, #1
 8009ea6:	0018      	movs	r0, r3
 8009ea8:	f7f9 f8fe 	bl	80030a8 <RCC_AHBPeriphClockCmd>
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8009eac:	2320      	movs	r3, #32
 8009eae:	18fb      	adds	r3, r7, r3
 8009eb0:	2203      	movs	r2, #3
 8009eb2:	715a      	strb	r2, [r3, #5]
	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8009eb4:	2320      	movs	r3, #32
 8009eb6:	18fb      	adds	r3, r7, r3
 8009eb8:	2201      	movs	r2, #1
 8009eba:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8009ebc:	2320      	movs	r3, #32
 8009ebe:	18fb      	adds	r3, r7, r3
 8009ec0:	2200      	movs	r2, #0
 8009ec2:	719a      	strb	r2, [r3, #6]
#ifdef USE_SPINDLE_DIR_AS_ENABLE_PIN
  GPIO_InitStructure.GPIO_Pin = 1 << SPINDLE_ENABLE_BIT;
#else
  GPIO_InitStructure.GPIO_Pin = 1 << SPINDLE_DIRECTION_BIT;
 8009ec4:	2320      	movs	r3, #32
 8009ec6:	18fb      	adds	r3, r7, r3
 8009ec8:	2202      	movs	r2, #2
 8009eca:	601a      	str	r2, [r3, #0]
#endif
  GPIO_Init(SPINDLE_ENABLE_PORT, &GPIO_InitStructure);
 8009ecc:	2320      	movs	r3, #32
 8009ece:	18fb      	adds	r3, r7, r3
 8009ed0:	4a46      	ldr	r2, [pc, #280]	; (8009fec <spindle_init+0x174>)
 8009ed2:	0019      	movs	r1, r3
 8009ed4:	0010      	movs	r0, r2
 8009ed6:	f7f8 fd8d 	bl	80029f4 <GPIO_Init>


#ifdef VARIABLE_SPINDLE
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
 8009eda:	2380      	movs	r3, #128	; 0x80
 8009edc:	011b      	lsls	r3, r3, #4
 8009ede:	2101      	movs	r1, #1
 8009ee0:	0018      	movs	r0, r3
 8009ee2:	f7f9 f901 	bl	80030e8 <RCC_APB2PeriphClockCmd>
  TIM_TimeBaseInitTypeDef timerInitStructure;
  TIM_OCInitTypeDef outputChannelInit = { 0 };
 8009ee6:	003b      	movs	r3, r7
 8009ee8:	0018      	movs	r0, r3
 8009eea:	2314      	movs	r3, #20
 8009eec:	001a      	movs	r2, r3
 8009eee:	2100      	movs	r1, #0
 8009ef0:	f002 fc08 	bl	800c704 <memset>
  TIM_TimeBaseStructInit(&timerInitStructure);
 8009ef4:	2314      	movs	r3, #20
 8009ef6:	18fb      	adds	r3, r7, r3
 8009ef8:	0018      	movs	r0, r3
 8009efa:	f7f9 f9d7 	bl	80032ac <TIM_TimeBaseStructInit>

  timerInitStructure.TIM_Prescaler = F_CPU / 1000000 - 1; // 1000K
 8009efe:	4b3c      	ldr	r3, [pc, #240]	; (8009ff0 <spindle_init+0x178>)
 8009f00:	681b      	ldr	r3, [r3, #0]
 8009f02:	493c      	ldr	r1, [pc, #240]	; (8009ff4 <spindle_init+0x17c>)
 8009f04:	0018      	movs	r0, r3
 8009f06:	f7f6 f909 	bl	800011c <__udivsi3>
 8009f0a:	0003      	movs	r3, r0
 8009f0c:	b29b      	uxth	r3, r3
 8009f0e:	3b01      	subs	r3, #1
 8009f10:	b29a      	uxth	r2, r3
 8009f12:	2314      	movs	r3, #20
 8009f14:	18fb      	adds	r3, r7, r3
 8009f16:	801a      	strh	r2, [r3, #0]
  timerInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8009f18:	2314      	movs	r3, #20
 8009f1a:	18fb      	adds	r3, r7, r3
 8009f1c:	2200      	movs	r2, #0
 8009f1e:	805a      	strh	r2, [r3, #2]
  timerInitStructure.TIM_Period = SPINDLE_PWM_MAX_VALUE - 1;
 8009f20:	2314      	movs	r3, #20
 8009f22:	18fb      	adds	r3, r7, r3
 8009f24:	2263      	movs	r2, #99	; 0x63
 8009f26:	605a      	str	r2, [r3, #4]
  timerInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
 8009f28:	2314      	movs	r3, #20
 8009f2a:	18fb      	adds	r3, r7, r3
 8009f2c:	2200      	movs	r2, #0
 8009f2e:	811a      	strh	r2, [r3, #8]
  timerInitStructure.TIM_RepetitionCounter = 0;
 8009f30:	2314      	movs	r3, #20
 8009f32:	18fb      	adds	r3, r7, r3
 8009f34:	2200      	movs	r2, #0
 8009f36:	729a      	strb	r2, [r3, #10]
  TIM_TimeBaseInit(TIM1, &timerInitStructure);
 8009f38:	2314      	movs	r3, #20
 8009f3a:	18fb      	adds	r3, r7, r3
 8009f3c:	4a2e      	ldr	r2, [pc, #184]	; (8009ff8 <spindle_init+0x180>)
 8009f3e:	0019      	movs	r1, r3
 8009f40:	0010      	movs	r0, r2
 8009f42:	f7f9 f93b 	bl	80031bc <TIM_TimeBaseInit>

  outputChannelInit.TIM_OCMode = TIM_OCMode_PWM1;
 8009f46:	003b      	movs	r3, r7
 8009f48:	2260      	movs	r2, #96	; 0x60
 8009f4a:	801a      	strh	r2, [r3, #0]
  outputChannelInit.TIM_Pulse = 0;     // initial speed is 0
 8009f4c:	003b      	movs	r3, r7
 8009f4e:	2200      	movs	r2, #0
 8009f50:	609a      	str	r2, [r3, #8]
  outputChannelInit.TIM_OutputState = TIM_OutputState_Enable;
 8009f52:	003b      	movs	r3, r7
 8009f54:	2201      	movs	r2, #1
 8009f56:	805a      	strh	r2, [r3, #2]
  outputChannelInit.TIM_OCPolarity = TIM_OCPolarity_High;
 8009f58:	003b      	movs	r3, r7
 8009f5a:	2200      	movs	r2, #0
 8009f5c:	819a      	strh	r2, [r3, #12]

  TIM_OC1Init(TIM1, &outputChannelInit);
 8009f5e:	003b      	movs	r3, r7
 8009f60:	4a25      	ldr	r2, [pc, #148]	; (8009ff8 <spindle_init+0x180>)
 8009f62:	0019      	movs	r1, r3
 8009f64:	0010      	movs	r0, r2
 8009f66:	f7f9 f9ff 	bl	8003368 <TIM_OC1Init>
  TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
 8009f6a:	4b23      	ldr	r3, [pc, #140]	; (8009ff8 <spindle_init+0x180>)
 8009f6c:	2108      	movs	r1, #8
 8009f6e:	0018      	movs	r0, r3
 8009f70:	f7f9 facc 	bl	800350c <TIM_OC1PreloadConfig>
  TIM_CtrlPWMOutputs(TIM1, DISABLE);
 8009f74:	4b20      	ldr	r3, [pc, #128]	; (8009ff8 <spindle_init+0x180>)
 8009f76:	2100      	movs	r1, #0
 8009f78:	0018      	movs	r0, r3
 8009f7a:	f7f9 f9cf 	bl	800331c <TIM_CtrlPWMOutputs>
  TIM_Cmd(TIM1, ENABLE);
 8009f7e:	4b1e      	ldr	r3, [pc, #120]	; (8009ff8 <spindle_init+0x180>)
 8009f80:	2101      	movs	r1, #1
 8009f82:	0018      	movs	r0, r3
 8009f84:	f7f9 f9aa 	bl	80032dc <TIM_Cmd>

  RCC_AHBPeriphClockCmd(RCC_SPINDLE_PWM_PORT, ENABLE);
 8009f88:	2380      	movs	r3, #128	; 0x80
 8009f8a:	029b      	lsls	r3, r3, #10
 8009f8c:	2101      	movs	r1, #1
 8009f8e:	0018      	movs	r0, r3
 8009f90:	f7f9 f88a 	bl	80030a8 <RCC_AHBPeriphClockCmd>
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8009f94:	2320      	movs	r3, #32
 8009f96:	18fb      	adds	r3, r7, r3
 8009f98:	2203      	movs	r2, #3
 8009f9a:	715a      	strb	r2, [r3, #5]
  //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8009f9c:	2320      	movs	r3, #32
 8009f9e:	18fb      	adds	r3, r7, r3
 8009fa0:	2202      	movs	r2, #2
 8009fa2:	711a      	strb	r2, [r3, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8009fa4:	2320      	movs	r3, #32
 8009fa6:	18fb      	adds	r3, r7, r3
 8009fa8:	2200      	movs	r2, #0
 8009faa:	719a      	strb	r2, [r3, #6]
  GPIO_InitStructure.GPIO_Pin = 1 << SPINDLE_PWM_BIT;
 8009fac:	2320      	movs	r3, #32
 8009fae:	18fb      	adds	r3, r7, r3
 8009fb0:	2280      	movs	r2, #128	; 0x80
 8009fb2:	0052      	lsls	r2, r2, #1
 8009fb4:	601a      	str	r2, [r3, #0]
  GPIO_Init(SPINDLE_PWM_PORT, &GPIO_InitStructure);
 8009fb6:	2320      	movs	r3, #32
 8009fb8:	18fa      	adds	r2, r7, r3
 8009fba:	2390      	movs	r3, #144	; 0x90
 8009fbc:	05db      	lsls	r3, r3, #23
 8009fbe:	0011      	movs	r1, r2
 8009fc0:	0018      	movs	r0, r3
 8009fc2:	f7f8 fd17 	bl	80029f4 <GPIO_Init>

  GPIO_PinAFConfig(SPINDLE_PWM_PORT, GPIO_PinSource8, GPIO_AF_2);
 8009fc6:	2390      	movs	r3, #144	; 0x90
 8009fc8:	05db      	lsls	r3, r3, #23
 8009fca:	2202      	movs	r2, #2
 8009fcc:	2108      	movs	r1, #8
 8009fce:	0018      	movs	r0, r3
 8009fd0:	f7f8 fe03 	bl	8002bda <GPIO_PinAFConfig>

#endif
#endif
  spindle_stop();
 8009fd4:	f000 f82e 	bl	800a034 <spindle_stop>
}
 8009fd8:	46c0      	nop			; (mov r8, r8)
 8009fda:	46bd      	mov	sp, r7
 8009fdc:	b00a      	add	sp, #40	; 0x28
 8009fde:	bd80      	pop	{r7, pc}
 8009fe0:	20000b44 	.word	0x20000b44
 8009fe4:	42c60000 	.word	0x42c60000
 8009fe8:	20000494 	.word	0x20000494
 8009fec:	48000400 	.word	0x48000400
 8009ff0:	20000010 	.word	0x20000010
 8009ff4:	000f4240 	.word	0x000f4240
 8009ff8:	40012c00 	.word	0x40012c00

08009ffc <spindle_get_state>:


uint8_t spindle_get_state()
{
 8009ffc:	b580      	push	{r7, lr}
 8009ffe:	b082      	sub	sp, #8
 800a000:	af00      	add	r7, sp, #0
  uint8_t pin = 0;
 800a002:	1dfb      	adds	r3, r7, #7
 800a004:	2200      	movs	r2, #0
 800a006:	701a      	strb	r2, [r3, #0]
#endif
#if defined (STM32F103C8)
      pin = GPIO_ReadInputData(SPINDLE_DIRECTION_PORT);
#endif
#if defined (STM32F0DISCOVERY)
      pin = GPIO_ReadInputData(SPINDLE_DIRECTION_PORT);
 800a008:	4b09      	ldr	r3, [pc, #36]	; (800a030 <spindle_get_state+0x34>)
 800a00a:	0018      	movs	r0, r3
 800a00c:	f7f8 fd85 	bl	8002b1a <GPIO_ReadInputData>
 800a010:	0003      	movs	r3, r0
 800a012:	001a      	movs	r2, r3
 800a014:	1dfb      	adds	r3, r7, #7
 800a016:	701a      	strb	r2, [r3, #0]
#endif
     {
        if (pin & (1<<SPINDLE_DIRECTION_BIT)) { return(SPINDLE_STATE_CCW); }
 800a018:	1dfb      	adds	r3, r7, #7
 800a01a:	781b      	ldrb	r3, [r3, #0]
 800a01c:	2202      	movs	r2, #2
 800a01e:	4013      	ands	r3, r2
 800a020:	d001      	beq.n	800a026 <spindle_get_state+0x2a>
 800a022:	2302      	movs	r3, #2
 800a024:	e000      	b.n	800a028 <spindle_get_state+0x2c>
        else { return(SPINDLE_STATE_CW); }
 800a026:	2301      	movs	r3, #1
		  if (pin & (1 << SPINDLE_DIRECTION_BIT)) { return(SPINDLE_STATE_CCW); }
		  else { return(SPINDLE_STATE_CW); }
		}
	#endif
	return(SPINDLE_STATE_DISABLE);
}
 800a028:	0018      	movs	r0, r3
 800a02a:	46bd      	mov	sp, r7
 800a02c:	b002      	add	sp, #8
 800a02e:	bd80      	pop	{r7, pc}
 800a030:	48000400 	.word	0x48000400

0800a034 <spindle_stop>:

// Disables the spindle and sets PWM output to zero when PWM variable spindle speed is enabled.
// Called by various main program and ISR routines. Keep routine small, fast, and efficient.
// Called by spindle_init(), spindle_set_speed(), spindle_set_state(), and mc_reset().
void spindle_stop()
{
 800a034:	b580      	push	{r7, lr}
 800a036:	af00      	add	r7, sp, #0
#endif
#if defined (STM32F103C8)
    TIM_CtrlPWMOutputs(TIM1, DISABLE);
#endif
#if defined (STM32F0DISCOVERY)
    TIM_CtrlPWMOutputs(TIM1, DISABLE);
 800a038:	4b03      	ldr	r3, [pc, #12]	; (800a048 <spindle_stop+0x14>)
 800a03a:	2100      	movs	r1, #0
 800a03c:	0018      	movs	r0, r3
 800a03e:	f7f9 f96d 	bl	800331c <TIM_CtrlPWMOutputs>
      SetSpindleEnablebit();
    #else
      ResetSpindleEnablebit();
    #endif
#endif
}
 800a042:	46c0      	nop			; (mov r8, r8)
 800a044:	46bd      	mov	sp, r7
 800a046:	bd80      	pop	{r7, pc}
 800a048:	40012c00 	.word	0x40012c00

0800a04c <spindle_set_speed>:

#ifdef VARIABLE_SPINDLE
  // Sets spindle speed PWM output and enable pin, if configured. Called by spindle_set_state()
  // and stepper ISR. Keep routine small and efficient.
  void spindle_set_speed(SPINDLE_PWM_TYPE pwm_value)
  {
 800a04c:	b580      	push	{r7, lr}
 800a04e:	b082      	sub	sp, #8
 800a050:	af00      	add	r7, sp, #0
 800a052:	0002      	movs	r2, r0
 800a054:	1dbb      	adds	r3, r7, #6
 800a056:	801a      	strh	r2, [r3, #0]
#endif
#if defined (STM32F103C8)
		TIM1->CCR1 = pwm_value;
#endif
#if defined (STM32F0DISCOVERY)
		TIM1->CCR1 = pwm_value;
 800a058:	4b0b      	ldr	r3, [pc, #44]	; (800a088 <spindle_set_speed+0x3c>)
 800a05a:	1dba      	adds	r2, r7, #6
 800a05c:	8812      	ldrh	r2, [r2, #0]
 800a05e:	635a      	str	r2, [r3, #52]	; 0x34
				#else
					SetSpindleEnablebit();
				#endif
		 }
		#else
			if (pwm_value == SPINDLE_PWM_OFF_VALUE) {
 800a060:	1dbb      	adds	r3, r7, #6
 800a062:	881b      	ldrh	r3, [r3, #0]
 800a064:	2b00      	cmp	r3, #0
 800a066:	d105      	bne.n	800a074 <spindle_set_speed+0x28>
			#endif
			#if defined (STM32F103C8)
				TIM_CtrlPWMOutputs(TIM1, DISABLE);
			#endif
			#if defined (STM32F0DISCOVERY)
				TIM_CtrlPWMOutputs(TIM1, DISABLE);
 800a068:	4b07      	ldr	r3, [pc, #28]	; (800a088 <spindle_set_speed+0x3c>)
 800a06a:	2100      	movs	r1, #0
 800a06c:	0018      	movs	r0, r3
 800a06e:	f7f9 f955 	bl	800331c <TIM_CtrlPWMOutputs>
			#if defined (STM32F0DISCOVERY)
      TIM_CtrlPWMOutputs(TIM1, ENABLE);
			#endif
			}
		#endif
  }
 800a072:	e004      	b.n	800a07e <spindle_set_speed+0x32>
      TIM_CtrlPWMOutputs(TIM1, ENABLE);
 800a074:	4b04      	ldr	r3, [pc, #16]	; (800a088 <spindle_set_speed+0x3c>)
 800a076:	2101      	movs	r1, #1
 800a078:	0018      	movs	r0, r3
 800a07a:	f7f9 f94f 	bl	800331c <TIM_CtrlPWMOutputs>
  }
 800a07e:	46c0      	nop			; (mov r8, r8)
 800a080:	46bd      	mov	sp, r7
 800a082:	b002      	add	sp, #8
 800a084:	bd80      	pop	{r7, pc}
 800a086:	46c0      	nop			; (mov r8, r8)
 800a088:	40012c00 	.word	0x40012c00

0800a08c <spindle_compute_pwm_value>:


  // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
  SPINDLE_PWM_TYPE spindle_compute_pwm_value(float rpm) // 328p PWM register is 8-bit.
  {
 800a08c:	b580      	push	{r7, lr}
 800a08e:	b084      	sub	sp, #16
 800a090:	af00      	add	r7, sp, #0
 800a092:	6078      	str	r0, [r7, #4]
    SPINDLE_PWM_TYPE pwm_value;
    rpm *= (0.010f*sys.spindle_speed_ovr); // Scale by spindle speed override value.
 800a094:	4b38      	ldr	r3, [pc, #224]	; (800a178 <spindle_compute_pwm_value+0xec>)
 800a096:	7a5b      	ldrb	r3, [r3, #9]
 800a098:	0018      	movs	r0, r3
 800a09a:	f7f6 ffef 	bl	800107c <__aeabi_i2f>
 800a09e:	1c03      	adds	r3, r0, #0
 800a0a0:	4936      	ldr	r1, [pc, #216]	; (800a17c <spindle_compute_pwm_value+0xf0>)
 800a0a2:	1c18      	adds	r0, r3, #0
 800a0a4:	f7f6 fcf6 	bl	8000a94 <__aeabi_fmul>
 800a0a8:	1c03      	adds	r3, r0, #0
 800a0aa:	1c19      	adds	r1, r3, #0
 800a0ac:	6878      	ldr	r0, [r7, #4]
 800a0ae:	f7f6 fcf1 	bl	8000a94 <__aeabi_fmul>
 800a0b2:	1c03      	adds	r3, r0, #0
 800a0b4:	607b      	str	r3, [r7, #4]
    // Calculate PWM register value based on rpm max/min settings and programmed rpm.
    if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
 800a0b6:	4b32      	ldr	r3, [pc, #200]	; (800a180 <spindle_compute_pwm_value+0xf4>)
 800a0b8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800a0ba:	4b31      	ldr	r3, [pc, #196]	; (800a180 <spindle_compute_pwm_value+0xf4>)
 800a0bc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800a0be:	1c19      	adds	r1, r3, #0
 800a0c0:	1c10      	adds	r0, r2, #0
 800a0c2:	f7f6 f925 	bl	8000310 <__aeabi_fcmpge>
 800a0c6:	1e03      	subs	r3, r0, #0
 800a0c8:	d107      	bne.n	800a0da <spindle_compute_pwm_value+0x4e>
 800a0ca:	4b2d      	ldr	r3, [pc, #180]	; (800a180 <spindle_compute_pwm_value+0xf4>)
 800a0cc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800a0ce:	6879      	ldr	r1, [r7, #4]
 800a0d0:	1c18      	adds	r0, r3, #0
 800a0d2:	f7f6 f909 	bl	80002e8 <__aeabi_fcmple>
 800a0d6:	1e03      	subs	r3, r0, #0
 800a0d8:	d008      	beq.n	800a0ec <spindle_compute_pwm_value+0x60>
      // No PWM range possible. Set simple on/off spindle control pin state.
      sys.spindle_speed = settings.rpm_max;
 800a0da:	4b29      	ldr	r3, [pc, #164]	; (800a180 <spindle_compute_pwm_value+0xf4>)
 800a0dc:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800a0de:	4b26      	ldr	r3, [pc, #152]	; (800a178 <spindle_compute_pwm_value+0xec>)
 800a0e0:	611a      	str	r2, [r3, #16]
      pwm_value = SPINDLE_PWM_MAX_VALUE;
 800a0e2:	230e      	movs	r3, #14
 800a0e4:	18fb      	adds	r3, r7, r3
 800a0e6:	2264      	movs	r2, #100	; 0x64
 800a0e8:	801a      	strh	r2, [r3, #0]
 800a0ea:	e03d      	b.n	800a168 <spindle_compute_pwm_value+0xdc>
    } else if (rpm <= settings.rpm_min) {
 800a0ec:	4b24      	ldr	r3, [pc, #144]	; (800a180 <spindle_compute_pwm_value+0xf4>)
 800a0ee:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a0f0:	6879      	ldr	r1, [r7, #4]
 800a0f2:	1c18      	adds	r0, r3, #0
 800a0f4:	f7f6 f90c 	bl	8000310 <__aeabi_fcmpge>
 800a0f8:	1e03      	subs	r3, r0, #0
 800a0fa:	d016      	beq.n	800a12a <spindle_compute_pwm_value+0x9e>
      if (rpm == 0.0f) { // S0 disables spindle
 800a0fc:	2100      	movs	r1, #0
 800a0fe:	6878      	ldr	r0, [r7, #4]
 800a100:	f7f6 f8e2 	bl	80002c8 <__aeabi_fcmpeq>
 800a104:	1e03      	subs	r3, r0, #0
 800a106:	d007      	beq.n	800a118 <spindle_compute_pwm_value+0x8c>
        sys.spindle_speed = 0.0f;
 800a108:	4b1b      	ldr	r3, [pc, #108]	; (800a178 <spindle_compute_pwm_value+0xec>)
 800a10a:	2200      	movs	r2, #0
 800a10c:	611a      	str	r2, [r3, #16]
        pwm_value = SPINDLE_PWM_OFF_VALUE;
 800a10e:	230e      	movs	r3, #14
 800a110:	18fb      	adds	r3, r7, r3
 800a112:	2200      	movs	r2, #0
 800a114:	801a      	strh	r2, [r3, #0]
 800a116:	e027      	b.n	800a168 <spindle_compute_pwm_value+0xdc>
      } else { // Set minimum PWM output
        sys.spindle_speed = settings.rpm_min;
 800a118:	4b19      	ldr	r3, [pc, #100]	; (800a180 <spindle_compute_pwm_value+0xf4>)
 800a11a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800a11c:	4b16      	ldr	r3, [pc, #88]	; (800a178 <spindle_compute_pwm_value+0xec>)
 800a11e:	611a      	str	r2, [r3, #16]
        pwm_value = SPINDLE_PWM_MIN_VALUE;
 800a120:	230e      	movs	r3, #14
 800a122:	18fb      	adds	r3, r7, r3
 800a124:	2201      	movs	r2, #1
 800a126:	801a      	strh	r2, [r3, #0]
 800a128:	e01e      	b.n	800a168 <spindle_compute_pwm_value+0xdc>
      }
    } else { 
      // Compute intermediate PWM value with linear spindle speed model.
      // NOTE: A nonlinear model could be installed here, if required, but keep it VERY light-weight.
      sys.spindle_speed = rpm;
 800a12a:	4b13      	ldr	r3, [pc, #76]	; (800a178 <spindle_compute_pwm_value+0xec>)
 800a12c:	687a      	ldr	r2, [r7, #4]
 800a12e:	611a      	str	r2, [r3, #16]
	    pwm_value = (SPINDLE_PWM_TYPE)floorf((rpm - settings.rpm_min)*pwm_gradient) + SPINDLE_PWM_MIN_VALUE;
 800a130:	4b13      	ldr	r3, [pc, #76]	; (800a180 <spindle_compute_pwm_value+0xf4>)
 800a132:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a134:	1c19      	adds	r1, r3, #0
 800a136:	6878      	ldr	r0, [r7, #4]
 800a138:	f7f6 fdcc 	bl	8000cd4 <__aeabi_fsub>
 800a13c:	1c03      	adds	r3, r0, #0
 800a13e:	1c1a      	adds	r2, r3, #0
 800a140:	4b10      	ldr	r3, [pc, #64]	; (800a184 <spindle_compute_pwm_value+0xf8>)
 800a142:	681b      	ldr	r3, [r3, #0]
 800a144:	1c19      	adds	r1, r3, #0
 800a146:	1c10      	adds	r0, r2, #0
 800a148:	f7f6 fca4 	bl	8000a94 <__aeabi_fmul>
 800a14c:	1c03      	adds	r3, r0, #0
 800a14e:	1c18      	adds	r0, r3, #0
 800a150:	f002 fbd2 	bl	800c8f8 <floorf>
 800a154:	1c03      	adds	r3, r0, #0
 800a156:	1c18      	adds	r0, r3, #0
 800a158:	f7f6 f8e4 	bl	8000324 <__aeabi_f2uiz>
 800a15c:	0003      	movs	r3, r0
 800a15e:	b29a      	uxth	r2, r3
 800a160:	230e      	movs	r3, #14
 800a162:	18fb      	adds	r3, r7, r3
 800a164:	3201      	adds	r2, #1
 800a166:	801a      	strh	r2, [r3, #0]
    }
    return(pwm_value);
 800a168:	230e      	movs	r3, #14
 800a16a:	18fb      	adds	r3, r7, r3
 800a16c:	881b      	ldrh	r3, [r3, #0]
  }
 800a16e:	0018      	movs	r0, r3
 800a170:	46bd      	mov	sp, r7
 800a172:	b004      	add	sp, #16
 800a174:	bd80      	pop	{r7, pc}
 800a176:	46c0      	nop			; (mov r8, r8)
 800a178:	20000bb4 	.word	0x20000bb4
 800a17c:	3c23d70a 	.word	0x3c23d70a
 800a180:	20000b44 	.word	0x20000b44
 800a184:	20000494 	.word	0x20000494

0800a188 <spindle_set_state>:
#ifdef VARIABLE_SPINDLE
  void spindle_set_state(uint8_t state, float rpm)
#else
  void _spindle_set_state(uint8_t state)
#endif
{
 800a188:	b580      	push	{r7, lr}
 800a18a:	b082      	sub	sp, #8
 800a18c:	af00      	add	r7, sp, #0
 800a18e:	0002      	movs	r2, r0
 800a190:	6039      	str	r1, [r7, #0]
 800a192:	1dfb      	adds	r3, r7, #7
 800a194:	701a      	strb	r2, [r3, #0]
  if (sys.abort) { return; } // Block during abort.
 800a196:	4b1e      	ldr	r3, [pc, #120]	; (800a210 <spindle_set_state+0x88>)
 800a198:	785b      	ldrb	r3, [r3, #1]
 800a19a:	2b00      	cmp	r3, #0
 800a19c:	d133      	bne.n	800a206 <spindle_set_state+0x7e>
  if (state == SPINDLE_DISABLE) { // Halt or set spindle direction and rpm.
 800a19e:	1dfb      	adds	r3, r7, #7
 800a1a0:	781b      	ldrb	r3, [r3, #0]
 800a1a2:	2b00      	cmp	r3, #0
 800a1a4:	d105      	bne.n	800a1b2 <spindle_set_state+0x2a>
  
    #ifdef VARIABLE_SPINDLE
      sys.spindle_speed = 0.0f;
 800a1a6:	4b1a      	ldr	r3, [pc, #104]	; (800a210 <spindle_set_state+0x88>)
 800a1a8:	2200      	movs	r2, #0
 800a1aa:	611a      	str	r2, [r3, #16]
    #endif
    spindle_stop();
 800a1ac:	f7ff ff42 	bl	800a034 <spindle_stop>
 800a1b0:	e025      	b.n	800a1fe <spindle_set_state+0x76>
  
  } else {
    #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
      if (state == SPINDLE_ENABLE_CW) {
 800a1b2:	1dfb      	adds	r3, r7, #7
 800a1b4:	781b      	ldrb	r3, [r3, #0]
 800a1b6:	2b10      	cmp	r3, #16
 800a1b8:	d106      	bne.n	800a1c8 <spindle_set_state+0x40>
        ResetSpindleDirectionBit();
 800a1ba:	4b16      	ldr	r3, [pc, #88]	; (800a214 <spindle_set_state+0x8c>)
 800a1bc:	2200      	movs	r2, #0
 800a1be:	2102      	movs	r1, #2
 800a1c0:	0018      	movs	r0, r3
 800a1c2:	f7f8 fcde 	bl	8002b82 <GPIO_WriteBit>
 800a1c6:	e005      	b.n	800a1d4 <spindle_set_state+0x4c>
	  }
	  else {
      SetSpindleDirectionBit();
 800a1c8:	4b12      	ldr	r3, [pc, #72]	; (800a214 <spindle_set_state+0x8c>)
 800a1ca:	2201      	movs	r2, #1
 800a1cc:	2102      	movs	r1, #2
 800a1ce:	0018      	movs	r0, r3
 800a1d0:	f7f8 fcd7 	bl	8002b82 <GPIO_WriteBit>
      }
    #endif
  
    #ifdef VARIABLE_SPINDLE
      // NOTE: Assumes all calls to this function is when Grbl is not moving or must remain off.
      if (settings.flags & BITFLAG_LASER_MODE) {
 800a1d4:	4b10      	ldr	r3, [pc, #64]	; (800a218 <spindle_set_state+0x90>)
 800a1d6:	2258      	movs	r2, #88	; 0x58
 800a1d8:	5c9b      	ldrb	r3, [r3, r2]
 800a1da:	001a      	movs	r2, r3
 800a1dc:	2302      	movs	r3, #2
 800a1de:	4013      	ands	r3, r2
 800a1e0:	d005      	beq.n	800a1ee <spindle_set_state+0x66>
        if (state == SPINDLE_ENABLE_CCW) { rpm = 0.0f; } // TODO: May need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE);
 800a1e2:	1dfb      	adds	r3, r7, #7
 800a1e4:	781b      	ldrb	r3, [r3, #0]
 800a1e6:	2b20      	cmp	r3, #32
 800a1e8:	d101      	bne.n	800a1ee <spindle_set_state+0x66>
 800a1ea:	2300      	movs	r3, #0
 800a1ec:	603b      	str	r3, [r7, #0]
      }
    spindle_set_speed(spindle_compute_pwm_value(rpm));
 800a1ee:	683b      	ldr	r3, [r7, #0]
 800a1f0:	1c18      	adds	r0, r3, #0
 800a1f2:	f7ff ff4b 	bl	800a08c <spindle_compute_pwm_value>
 800a1f6:	0003      	movs	r3, r0
 800a1f8:	0018      	movs	r0, r3
 800a1fa:	f7ff ff27 	bl	800a04c <spindle_set_speed>
        SetSpindleEnablebit();
      #endif    
    #endif
  }
  
  sys.report_ovr_counter = 0; // Set to report change immediately
 800a1fe:	4b04      	ldr	r3, [pc, #16]	; (800a210 <spindle_set_state+0x88>)
 800a200:	2200      	movs	r2, #0
 800a202:	72da      	strb	r2, [r3, #11]
 800a204:	e000      	b.n	800a208 <spindle_set_state+0x80>
  if (sys.abort) { return; } // Block during abort.
 800a206:	46c0      	nop			; (mov r8, r8)
}
 800a208:	46bd      	mov	sp, r7
 800a20a:	b002      	add	sp, #8
 800a20c:	bd80      	pop	{r7, pc}
 800a20e:	46c0      	nop			; (mov r8, r8)
 800a210:	20000bb4 	.word	0x20000bb4
 800a214:	48000400 	.word	0x48000400
 800a218:	20000b44 	.word	0x20000b44

0800a21c <spindle_sync>:

// G-code parser entry-point for setting spindle state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
#ifdef VARIABLE_SPINDLE
  void spindle_sync(uint8_t state, float rpm)
  {
 800a21c:	b580      	push	{r7, lr}
 800a21e:	b082      	sub	sp, #8
 800a220:	af00      	add	r7, sp, #0
 800a222:	0002      	movs	r2, r0
 800a224:	6039      	str	r1, [r7, #0]
 800a226:	1dfb      	adds	r3, r7, #7
 800a228:	701a      	strb	r2, [r3, #0]
    if (sys.state == STATE_CHECK_MODE) { return; }
 800a22a:	4b09      	ldr	r3, [pc, #36]	; (800a250 <spindle_sync+0x34>)
 800a22c:	781b      	ldrb	r3, [r3, #0]
 800a22e:	2b02      	cmp	r3, #2
 800a230:	d009      	beq.n	800a246 <spindle_sync+0x2a>
    protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.
 800a232:	f7fd fd81 	bl	8007d38 <protocol_buffer_synchronize>
    spindle_set_state(state,rpm);
 800a236:	683a      	ldr	r2, [r7, #0]
 800a238:	1dfb      	adds	r3, r7, #7
 800a23a:	781b      	ldrb	r3, [r3, #0]
 800a23c:	1c11      	adds	r1, r2, #0
 800a23e:	0018      	movs	r0, r3
 800a240:	f7ff ffa2 	bl	800a188 <spindle_set_state>
 800a244:	e000      	b.n	800a248 <spindle_sync+0x2c>
    if (sys.state == STATE_CHECK_MODE) { return; }
 800a246:	46c0      	nop			; (mov r8, r8)
  }
 800a248:	46bd      	mov	sp, r7
 800a24a:	b002      	add	sp, #8
 800a24c:	bd80      	pop	{r7, pc}
 800a24e:	46c0      	nop			; (mov r8, r8)
 800a250:	20000bb4 	.word	0x20000bb4

0800a254 <NVIC_EnableIRQ>:
{
 800a254:	b580      	push	{r7, lr}
 800a256:	b082      	sub	sp, #8
 800a258:	af00      	add	r7, sp, #0
 800a25a:	0002      	movs	r2, r0
 800a25c:	1dfb      	adds	r3, r7, #7
 800a25e:	701a      	strb	r2, [r3, #0]
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 800a260:	4b06      	ldr	r3, [pc, #24]	; (800a27c <NVIC_EnableIRQ+0x28>)
 800a262:	1dfa      	adds	r2, r7, #7
 800a264:	7812      	ldrb	r2, [r2, #0]
 800a266:	0011      	movs	r1, r2
 800a268:	221f      	movs	r2, #31
 800a26a:	400a      	ands	r2, r1
 800a26c:	2101      	movs	r1, #1
 800a26e:	4091      	lsls	r1, r2
 800a270:	000a      	movs	r2, r1
 800a272:	601a      	str	r2, [r3, #0]
}
 800a274:	46c0      	nop			; (mov r8, r8)
 800a276:	46bd      	mov	sp, r7
 800a278:	b002      	add	sp, #8
 800a27a:	bd80      	pop	{r7, pc}
 800a27c:	e000e100 	.word	0xe000e100

0800a280 <NVIC_DisableIRQ>:
{
 800a280:	b580      	push	{r7, lr}
 800a282:	b082      	sub	sp, #8
 800a284:	af00      	add	r7, sp, #0
 800a286:	0002      	movs	r2, r0
 800a288:	1dfb      	adds	r3, r7, #7
 800a28a:	701a      	strb	r2, [r3, #0]
  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
 800a28c:	4a07      	ldr	r2, [pc, #28]	; (800a2ac <NVIC_DisableIRQ+0x2c>)
 800a28e:	1dfb      	adds	r3, r7, #7
 800a290:	781b      	ldrb	r3, [r3, #0]
 800a292:	0019      	movs	r1, r3
 800a294:	231f      	movs	r3, #31
 800a296:	400b      	ands	r3, r1
 800a298:	2101      	movs	r1, #1
 800a29a:	4099      	lsls	r1, r3
 800a29c:	000b      	movs	r3, r1
 800a29e:	0019      	movs	r1, r3
 800a2a0:	2380      	movs	r3, #128	; 0x80
 800a2a2:	50d1      	str	r1, [r2, r3]
}
 800a2a4:	46c0      	nop			; (mov r8, r8)
 800a2a6:	46bd      	mov	sp, r7
 800a2a8:	b002      	add	sp, #8
 800a2aa:	bd80      	pop	{r7, pc}
 800a2ac:	e000e100 	.word	0xe000e100

0800a2b0 <st_wake_up>:


// Stepper state initialization. Cycle should only start if the st.cycle_start flag is
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up()
{
 800a2b0:	b5b0      	push	{r4, r5, r7, lr}
 800a2b2:	af00      	add	r7, sp, #0
  // Enable stepper drivers.
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) 
 800a2b4:	4b22      	ldr	r3, [pc, #136]	; (800a340 <st_wake_up+0x90>)
 800a2b6:	2258      	movs	r2, #88	; 0x58
 800a2b8:	5c9b      	ldrb	r3, [r3, r2]
 800a2ba:	001a      	movs	r2, r3
 800a2bc:	2304      	movs	r3, #4
 800a2be:	4013      	ands	r3, r2
 800a2c0:	d006      	beq.n	800a2d0 <st_wake_up+0x20>
  { 
	  SetStepperDisableBit();
 800a2c2:	2390      	movs	r3, #144	; 0x90
 800a2c4:	05db      	lsls	r3, r3, #23
 800a2c6:	2180      	movs	r1, #128	; 0x80
 800a2c8:	0018      	movs	r0, r3
 800a2ca:	f7f8 fc3c 	bl	8002b46 <GPIO_SetBits>
 800a2ce:	e005      	b.n	800a2dc <st_wake_up+0x2c>
  }
  else 
  { 
	  ResetStepperDisableBit(); 
 800a2d0:	2390      	movs	r3, #144	; 0x90
 800a2d2:	05db      	lsls	r3, r3, #23
 800a2d4:	2180      	movs	r1, #128	; 0x80
 800a2d6:	0018      	movs	r0, r3
 800a2d8:	f7f8 fc44 	bl	8002b64 <GPIO_ResetBits>
  }

  // Initialize stepper output bits to ensure first ISR call does not step.
  st.step_outbits = step_port_invert_mask;
 800a2dc:	4b19      	ldr	r3, [pc, #100]	; (800a344 <st_wake_up+0x94>)
 800a2de:	881a      	ldrh	r2, [r3, #0]
 800a2e0:	4b19      	ldr	r3, [pc, #100]	; (800a348 <st_wake_up+0x98>)
 800a2e2:	825a      	strh	r2, [r3, #18]
#elif defined (WIN32)
  st.step_pulse_time = (settings.pulse_microseconds)*TICKS_PER_MICROSECOND;
#elif defined(STM32F103C8)
  st.step_pulse_time = (settings.pulse_microseconds)*TICKS_PER_MICROSECOND;
#elif defined(STM32F0DISCOVERY)
  st.step_pulse_time = (settings.pulse_microseconds)*TICKS_PER_MICROSECOND;
 800a2e4:	4b16      	ldr	r3, [pc, #88]	; (800a340 <st_wake_up+0x90>)
 800a2e6:	2240      	movs	r2, #64	; 0x40
 800a2e8:	5c9c      	ldrb	r4, [r3, r2]
 800a2ea:	4b18      	ldr	r3, [pc, #96]	; (800a34c <st_wake_up+0x9c>)
 800a2ec:	681b      	ldr	r3, [r3, #0]
 800a2ee:	4918      	ldr	r1, [pc, #96]	; (800a350 <st_wake_up+0xa0>)
 800a2f0:	0018      	movs	r0, r3
 800a2f2:	f7f5 ff13 	bl	800011c <__udivsi3>
 800a2f6:	0003      	movs	r3, r0
 800a2f8:	b2db      	uxtb	r3, r3
 800a2fa:	4363      	muls	r3, r4
 800a2fc:	b2da      	uxtb	r2, r3
 800a2fe:	4b12      	ldr	r3, [pc, #72]	; (800a348 <st_wake_up+0x98>)
 800a300:	745a      	strb	r2, [r3, #17]
#endif
  TIM2->EGR = TIM_PSCReloadMode_Immediate;
  NVIC_EnableIRQ(TIM2_IRQn);
#endif
#if defined (STM32F0DISCOVERY)
  TIM3->ARR = st.step_pulse_time - 1;
 800a302:	4b14      	ldr	r3, [pc, #80]	; (800a354 <st_wake_up+0xa4>)
 800a304:	4a10      	ldr	r2, [pc, #64]	; (800a348 <st_wake_up+0x98>)
 800a306:	7c52      	ldrb	r2, [r2, #17]
 800a308:	3a01      	subs	r2, #1
 800a30a:	62da      	str	r2, [r3, #44]	; 0x2c
  TIM3->EGR = TIM_PSCReloadMode_Immediate;
 800a30c:	4b11      	ldr	r3, [pc, #68]	; (800a354 <st_wake_up+0xa4>)
 800a30e:	2201      	movs	r2, #1
 800a310:	829a      	strh	r2, [r3, #20]
  TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
 800a312:	4b10      	ldr	r3, [pc, #64]	; (800a354 <st_wake_up+0xa4>)
 800a314:	2101      	movs	r1, #1
 800a316:	0018      	movs	r0, r3
 800a318:	f7f9 f94b 	bl	80035b2 <TIM_ClearITPendingBit>

  TIM2->ARR = st.exec_segment->cycles_per_tick - 1;
 800a31c:	2380      	movs	r3, #128	; 0x80
 800a31e:	05db      	lsls	r3, r3, #23
 800a320:	4a09      	ldr	r2, [pc, #36]	; (800a348 <st_wake_up+0x98>)
 800a322:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800a324:	8852      	ldrh	r2, [r2, #2]
 800a326:	3a01      	subs	r2, #1
 800a328:	62da      	str	r2, [r3, #44]	; 0x2c
  /* Set the Autoreload value */
#ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
  TIM2->PSC = st.exec_segment->prescaler;
#endif
  TIM2->EGR = TIM_PSCReloadMode_Immediate;
 800a32a:	2380      	movs	r3, #128	; 0x80
 800a32c:	05db      	lsls	r3, r3, #23
 800a32e:	2201      	movs	r2, #1
 800a330:	829a      	strh	r2, [r3, #20]
  NVIC_EnableIRQ(TIM2_IRQn);
 800a332:	200f      	movs	r0, #15
 800a334:	f7ff ff8e 	bl	800a254 <NVIC_EnableIRQ>
#endif
}
 800a338:	46c0      	nop			; (mov r8, r8)
 800a33a:	46bd      	mov	sp, r7
 800a33c:	bdb0      	pop	{r4, r5, r7, pc}
 800a33e:	46c0      	nop			; (mov r8, r8)
 800a340:	20000b44 	.word	0x20000b44
 800a344:	2000057c 	.word	0x2000057c
 800a348:	20000544 	.word	0x20000544
 800a34c:	20000010 	.word	0x20000010
 800a350:	000f4240 	.word	0x000f4240
 800a354:	40000400 	.word	0x40000400

0800a358 <st_go_idle>:


// Stepper shutdown
void st_go_idle()
{
 800a358:	b580      	push	{r7, lr}
 800a35a:	b082      	sub	sp, #8
 800a35c:	af00      	add	r7, sp, #0
#endif
#ifdef STM32F103C8
  NVIC_DisableIRQ(TIM2_IRQn);
#endif
#ifdef STM32F0DISCOVERY
  NVIC_DisableIRQ(TIM2_IRQn);
 800a35e:	200f      	movs	r0, #15
 800a360:	f7ff ff8e 	bl	800a280 <NVIC_DisableIRQ>
#endif

  busy = false;
 800a364:	4b1f      	ldr	r3, [pc, #124]	; (800a3e4 <st_go_idle+0x8c>)
 800a366:	2200      	movs	r2, #0
 800a368:	701a      	strb	r2, [r3, #0]

  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
 800a36a:	2300      	movs	r3, #0
 800a36c:	607b      	str	r3, [r7, #4]
  if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
 800a36e:	4b1e      	ldr	r3, [pc, #120]	; (800a3e8 <st_go_idle+0x90>)
 800a370:	2243      	movs	r2, #67	; 0x43
 800a372:	5c9b      	ldrb	r3, [r3, r2]
 800a374:	2bff      	cmp	r3, #255	; 0xff
 800a376:	d108      	bne.n	800a38a <st_go_idle+0x32>
 800a378:	4b1c      	ldr	r3, [pc, #112]	; (800a3ec <st_go_idle+0x94>)
 800a37a:	781b      	ldrb	r3, [r3, #0]
 800a37c:	b2db      	uxtb	r3, r3
 800a37e:	2b00      	cmp	r3, #0
 800a380:	d103      	bne.n	800a38a <st_go_idle+0x32>
 800a382:	4b1b      	ldr	r3, [pc, #108]	; (800a3f0 <st_go_idle+0x98>)
 800a384:	781b      	ldrb	r3, [r3, #0]
 800a386:	2b80      	cmp	r3, #128	; 0x80
 800a388:	d10c      	bne.n	800a3a4 <st_go_idle+0x4c>
 800a38a:	4b19      	ldr	r3, [pc, #100]	; (800a3f0 <st_go_idle+0x98>)
 800a38c:	781b      	ldrb	r3, [r3, #0]
 800a38e:	2b04      	cmp	r3, #4
 800a390:	d008      	beq.n	800a3a4 <st_go_idle+0x4c>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
 800a392:	4b15      	ldr	r3, [pc, #84]	; (800a3e8 <st_go_idle+0x90>)
 800a394:	2243      	movs	r2, #67	; 0x43
 800a396:	5c9b      	ldrb	r3, [r3, r2]
 800a398:	b29b      	uxth	r3, r3
 800a39a:	0018      	movs	r0, r3
 800a39c:	f7fc fa5e 	bl	800685c <delay_ms>
    pin_state = true; // Override. Disable steppers.
 800a3a0:	2301      	movs	r3, #1
 800a3a2:	607b      	str	r3, [r7, #4]
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
 800a3a4:	4b10      	ldr	r3, [pc, #64]	; (800a3e8 <st_go_idle+0x90>)
 800a3a6:	2258      	movs	r2, #88	; 0x58
 800a3a8:	5c9b      	ldrb	r3, [r3, r2]
 800a3aa:	001a      	movs	r2, r3
 800a3ac:	2304      	movs	r3, #4
 800a3ae:	4013      	ands	r3, r2
 800a3b0:	d004      	beq.n	800a3bc <st_go_idle+0x64>
 800a3b2:	687b      	ldr	r3, [r7, #4]
 800a3b4:	425a      	negs	r2, r3
 800a3b6:	4153      	adcs	r3, r2
 800a3b8:	b2db      	uxtb	r3, r3
 800a3ba:	607b      	str	r3, [r7, #4]
  if (pin_state) 
 800a3bc:	687b      	ldr	r3, [r7, #4]
 800a3be:	2b00      	cmp	r3, #0
 800a3c0:	d006      	beq.n	800a3d0 <st_go_idle+0x78>
  { 
	  SetStepperDisableBit();
 800a3c2:	2390      	movs	r3, #144	; 0x90
 800a3c4:	05db      	lsls	r3, r3, #23
 800a3c6:	2180      	movs	r1, #128	; 0x80
 800a3c8:	0018      	movs	r0, r3
 800a3ca:	f7f8 fbbc 	bl	8002b46 <GPIO_SetBits>
  }
  else 
  { 
	  ResetStepperDisableBit();
  }
}
 800a3ce:	e005      	b.n	800a3dc <st_go_idle+0x84>
	  ResetStepperDisableBit();
 800a3d0:	2390      	movs	r3, #144	; 0x90
 800a3d2:	05db      	lsls	r3, r3, #23
 800a3d4:	2180      	movs	r1, #128	; 0x80
 800a3d6:	0018      	movs	r0, r3
 800a3d8:	f7f8 fbc4 	bl	8002b64 <GPIO_ResetBits>
}
 800a3dc:	46c0      	nop			; (mov r8, r8)
 800a3de:	46bd      	mov	sp, r7
 800a3e0:	b002      	add	sp, #8
 800a3e2:	bd80      	pop	{r7, pc}
 800a3e4:	20000580 	.word	0x20000580
 800a3e8:	20000b44 	.word	0x20000b44
 800a3ec:	20000bec 	.word	0x20000bec
 800a3f0:	20000bb4 	.word	0x20000bb4

0800a3f4 <TIM2_IRQHandler>:
ISR(TIMER1_COMPA_vect)
#endif
#ifdef WIN32
void Timer1Proc()
#endif
{
 800a3f4:	b580      	push	{r7, lr}
 800a3f6:	b082      	sub	sp, #8
 800a3f8:	af00      	add	r7, sp, #0
	{
		return;
	}
#endif
#ifdef STM32F0DISCOVERY
	if ((TIM2->SR & 0x0001) != 0)                  // check interrupt source
 800a3fa:	2380      	movs	r3, #128	; 0x80
 800a3fc:	05db      	lsls	r3, r3, #23
 800a3fe:	8a1b      	ldrh	r3, [r3, #16]
 800a400:	b29b      	uxth	r3, r3
 800a402:	001a      	movs	r2, r3
 800a404:	2301      	movs	r3, #1
 800a406:	4013      	ands	r3, r2
 800a408:	d100      	bne.n	800a40c <TIM2_IRQHandler+0x18>
 800a40a:	e21d      	b.n	800a848 <TIM2_IRQHandler+0x454>
	{
		TIM2->SR &= ~(1 << 0);                          // clear UIF flag
 800a40c:	2380      	movs	r3, #128	; 0x80
 800a40e:	05db      	lsls	r3, r3, #23
 800a410:	2280      	movs	r2, #128	; 0x80
 800a412:	05d2      	lsls	r2, r2, #23
 800a414:	8a12      	ldrh	r2, [r2, #16]
 800a416:	b292      	uxth	r2, r2
 800a418:	2101      	movs	r1, #1
 800a41a:	438a      	bics	r2, r1
 800a41c:	b292      	uxth	r2, r2
 800a41e:	821a      	strh	r2, [r3, #16]
		TIM2->CNT = 0;
 800a420:	2380      	movs	r3, #128	; 0x80
 800a422:	05db      	lsls	r3, r3, #23
 800a424:	2200      	movs	r2, #0
 800a426:	625a      	str	r2, [r3, #36]	; 0x24
	{
		return;
	}
#endif

  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
 800a428:	4bd3      	ldr	r3, [pc, #844]	; (800a778 <TIM2_IRQHandler+0x384>)
 800a42a:	781b      	ldrb	r3, [r3, #0]
 800a42c:	b2db      	uxtb	r3, r3
 800a42e:	2b00      	cmp	r3, #0
 800a430:	d000      	beq.n	800a434 <TIM2_IRQHandler+0x40>
 800a432:	e20b      	b.n	800a84c <TIM2_IRQHandler+0x458>
#ifdef STM32F103C8
  GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK));
  TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
#endif
#ifdef STM32F0DISCOVERY
  GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK));
 800a434:	2390      	movs	r3, #144	; 0x90
 800a436:	05db      	lsls	r3, r3, #23
 800a438:	0018      	movs	r0, r3
 800a43a:	f7f8 fb79 	bl	8002b30 <GPIO_ReadOutputData>
 800a43e:	0003      	movs	r3, r0
 800a440:	b21b      	sxth	r3, r3
 800a442:	2270      	movs	r2, #112	; 0x70
 800a444:	4393      	bics	r3, r2
 800a446:	b21a      	sxth	r2, r3
 800a448:	4bcc      	ldr	r3, [pc, #816]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a44a:	8a9b      	ldrh	r3, [r3, #20]
 800a44c:	b21b      	sxth	r3, r3
 800a44e:	2170      	movs	r1, #112	; 0x70
 800a450:	400b      	ands	r3, r1
 800a452:	b21b      	sxth	r3, r3
 800a454:	4313      	orrs	r3, r2
 800a456:	b21b      	sxth	r3, r3
 800a458:	b29a      	uxth	r2, r3
 800a45a:	2390      	movs	r3, #144	; 0x90
 800a45c:	05db      	lsls	r3, r3, #23
 800a45e:	0011      	movs	r1, r2
 800a460:	0018      	movs	r0, r3
 800a462:	f7f8 fbab 	bl	8002bbc <GPIO_Write>
  TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
 800a466:	4bc6      	ldr	r3, [pc, #792]	; (800a780 <TIM2_IRQHandler+0x38c>)
 800a468:	2101      	movs	r1, #1
 800a46a:	0018      	movs	r0, r3
 800a46c:	f7f9 f8a1 	bl	80035b2 <TIM_ClearITPendingBit>
#endif
#ifdef STM32F103C8
	GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | st.step_outbits);
#endif
#ifdef STM32F0DISCOVERY
	GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | st.step_outbits);
 800a470:	2390      	movs	r3, #144	; 0x90
 800a472:	05db      	lsls	r3, r3, #23
 800a474:	0018      	movs	r0, r3
 800a476:	f7f8 fb5b 	bl	8002b30 <GPIO_ReadOutputData>
 800a47a:	0003      	movs	r3, r0
 800a47c:	b21b      	sxth	r3, r3
 800a47e:	220e      	movs	r2, #14
 800a480:	4393      	bics	r3, r2
 800a482:	b21a      	sxth	r2, r3
 800a484:	4bbd      	ldr	r3, [pc, #756]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a486:	8a5b      	ldrh	r3, [r3, #18]
 800a488:	b21b      	sxth	r3, r3
 800a48a:	4313      	orrs	r3, r2
 800a48c:	b21b      	sxth	r3, r3
 800a48e:	b29a      	uxth	r2, r3
 800a490:	2390      	movs	r3, #144	; 0x90
 800a492:	05db      	lsls	r3, r3, #23
 800a494:	0011      	movs	r1, r2
 800a496:	0018      	movs	r0, r3
 800a498:	f7f8 fb90 	bl	8002bbc <GPIO_Write>
	// 28ByJ-48 step with ULN2003 driver board output
	GPIO_Write(STEP_PORT2, (GPIO_ReadOutputData(STEP_PORT2) & ~STEP_MASK2) | A_AXIS_LUT[lookUpIndex]);
 800a49c:	4bb9      	ldr	r3, [pc, #740]	; (800a784 <TIM2_IRQHandler+0x390>)
 800a49e:	0018      	movs	r0, r3
 800a4a0:	f7f8 fb46 	bl	8002b30 <GPIO_ReadOutputData>
 800a4a4:	0003      	movs	r3, r0
 800a4a6:	b21b      	sxth	r3, r3
 800a4a8:	4ab7      	ldr	r2, [pc, #732]	; (800a788 <TIM2_IRQHandler+0x394>)
 800a4aa:	4013      	ands	r3, r2
 800a4ac:	b21a      	sxth	r2, r3
 800a4ae:	4bb7      	ldr	r3, [pc, #732]	; (800a78c <TIM2_IRQHandler+0x398>)
 800a4b0:	6819      	ldr	r1, [r3, #0]
 800a4b2:	4bb7      	ldr	r3, [pc, #732]	; (800a790 <TIM2_IRQHandler+0x39c>)
 800a4b4:	0049      	lsls	r1, r1, #1
 800a4b6:	5acb      	ldrh	r3, [r1, r3]
 800a4b8:	b21b      	sxth	r3, r3
 800a4ba:	4313      	orrs	r3, r2
 800a4bc:	b21b      	sxth	r3, r3
 800a4be:	b29b      	uxth	r3, r3
 800a4c0:	4ab0      	ldr	r2, [pc, #704]	; (800a784 <TIM2_IRQHandler+0x390>)
 800a4c2:	0019      	movs	r1, r3
 800a4c4:	0010      	movs	r0, r2
 800a4c6:	f7f8 fb79 	bl	8002bbc <GPIO_Write>
#endif
#ifdef STM32F103C8
  NVIC_EnableIRQ(TIM3_IRQn);
#endif
#ifdef STM32F0DISCOVERY
  NVIC_EnableIRQ(TIM3_IRQn);
 800a4ca:	2010      	movs	r0, #16
 800a4cc:	f7ff fec2 	bl	800a254 <NVIC_EnableIRQ>
#endif

  busy = true;
 800a4d0:	4ba9      	ldr	r3, [pc, #676]	; (800a778 <TIM2_IRQHandler+0x384>)
 800a4d2:	2201      	movs	r2, #1
 800a4d4:	701a      	strb	r2, [r3, #0]
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time.
         // NOTE: The remaining code in this ISR will finish before returning to main program.
#endif

  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
 800a4d6:	4ba9      	ldr	r3, [pc, #676]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a4d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a4da:	2b00      	cmp	r3, #0
 800a4dc:	d000      	beq.n	800a4e0 <TIM2_IRQHandler+0xec>
 800a4de:	e08a      	b.n	800a5f6 <TIM2_IRQHandler+0x202>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
 800a4e0:	4bac      	ldr	r3, [pc, #688]	; (800a794 <TIM2_IRQHandler+0x3a0>)
 800a4e2:	781a      	ldrb	r2, [r3, #0]
 800a4e4:	4bac      	ldr	r3, [pc, #688]	; (800a798 <TIM2_IRQHandler+0x3a4>)
 800a4e6:	781b      	ldrb	r3, [r3, #0]
 800a4e8:	b2db      	uxtb	r3, r3
 800a4ea:	429a      	cmp	r2, r3
 800a4ec:	d075      	beq.n	800a5da <TIM2_IRQHandler+0x1e6>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
 800a4ee:	4baa      	ldr	r3, [pc, #680]	; (800a798 <TIM2_IRQHandler+0x3a4>)
 800a4f0:	781b      	ldrb	r3, [r3, #0]
 800a4f2:	b2db      	uxtb	r3, r3
 800a4f4:	00da      	lsls	r2, r3, #3
 800a4f6:	4ba9      	ldr	r3, [pc, #676]	; (800a79c <TIM2_IRQHandler+0x3a8>)
 800a4f8:	18d2      	adds	r2, r2, r3
 800a4fa:	4ba0      	ldr	r3, [pc, #640]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a4fc:	631a      	str	r2, [r3, #48]	; 0x30
#ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
	  TIM2->PSC = st.exec_segment->prescaler;
#endif
#endif
#ifdef STM32F0DISCOVERY
	  TIM2->ARR = st.exec_segment->cycles_per_tick - 1;
 800a4fe:	2380      	movs	r3, #128	; 0x80
 800a500:	05db      	lsls	r3, r3, #23
 800a502:	4a9e      	ldr	r2, [pc, #632]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a504:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800a506:	8852      	ldrh	r2, [r2, #2]
 800a508:	3a01      	subs	r2, #1
 800a50a:	62da      	str	r2, [r3, #44]	; 0x2c
	  /* Set the Autoreload value */
#ifndef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
	  TIM2->PSC = st.exec_segment->prescaler;
#endif
#endif
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
 800a50c:	4b9b      	ldr	r3, [pc, #620]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a50e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a510:	881a      	ldrh	r2, [r3, #0]
 800a512:	4b9a      	ldr	r3, [pc, #616]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a514:	851a      	strh	r2, [r3, #40]	; 0x28
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
 800a516:	4b99      	ldr	r3, [pc, #612]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a518:	222a      	movs	r2, #42	; 0x2a
 800a51a:	5c9a      	ldrb	r2, [r3, r2]
 800a51c:	4b97      	ldr	r3, [pc, #604]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a51e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a520:	791b      	ldrb	r3, [r3, #4]
 800a522:	429a      	cmp	r2, r3
 800a524:	d023      	beq.n	800a56e <TIM2_IRQHandler+0x17a>
        st.exec_block_index = st.exec_segment->st_block_index;
 800a526:	4b95      	ldr	r3, [pc, #596]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a528:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a52a:	7919      	ldrb	r1, [r3, #4]
 800a52c:	4b93      	ldr	r3, [pc, #588]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a52e:	222a      	movs	r2, #42	; 0x2a
 800a530:	5499      	strb	r1, [r3, r2]
        st.exec_block = &st_block_buffer[st.exec_block_index];
 800a532:	4b92      	ldr	r3, [pc, #584]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a534:	222a      	movs	r2, #42	; 0x2a
 800a536:	5c9b      	ldrb	r3, [r3, r2]
 800a538:	001a      	movs	r2, r3
 800a53a:	0013      	movs	r3, r2
 800a53c:	005b      	lsls	r3, r3, #1
 800a53e:	189b      	adds	r3, r3, r2
 800a540:	00db      	lsls	r3, r3, #3
 800a542:	4a97      	ldr	r2, [pc, #604]	; (800a7a0 <TIM2_IRQHandler+0x3ac>)
 800a544:	189a      	adds	r2, r3, r2
 800a546:	4b8d      	ldr	r3, [pc, #564]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a548:	62da      	str	r2, [r3, #44]	; 0x2c

        // Initialize Bresenham line and distance counters
        st.counter_x = st.counter_y = st.counter_z =st.counter_a = (st.exec_block->step_event_count >> 1);
 800a54a:	4b8c      	ldr	r3, [pc, #560]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a54c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a54e:	691b      	ldr	r3, [r3, #16]
 800a550:	085a      	lsrs	r2, r3, #1
 800a552:	4b8a      	ldr	r3, [pc, #552]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a554:	60da      	str	r2, [r3, #12]
 800a556:	4b89      	ldr	r3, [pc, #548]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a558:	68da      	ldr	r2, [r3, #12]
 800a55a:	4b88      	ldr	r3, [pc, #544]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a55c:	609a      	str	r2, [r3, #8]
 800a55e:	4b87      	ldr	r3, [pc, #540]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a560:	689a      	ldr	r2, [r3, #8]
 800a562:	4b86      	ldr	r3, [pc, #536]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a564:	605a      	str	r2, [r3, #4]
 800a566:	4b85      	ldr	r3, [pc, #532]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a568:	685a      	ldr	r2, [r3, #4]
 800a56a:	4b84      	ldr	r3, [pc, #528]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a56c:	601a      	str	r2, [r3, #0]
      }
      st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask;
 800a56e:	4b83      	ldr	r3, [pc, #524]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a570:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a572:	7d1b      	ldrb	r3, [r3, #20]
 800a574:	b29a      	uxth	r2, r3
 800a576:	4b8b      	ldr	r3, [pc, #556]	; (800a7a4 <TIM2_IRQHandler+0x3b0>)
 800a578:	881b      	ldrh	r3, [r3, #0]
 800a57a:	4053      	eors	r3, r2
 800a57c:	b29a      	uxth	r2, r3
 800a57e:	4b7f      	ldr	r3, [pc, #508]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a580:	829a      	strh	r2, [r3, #20]

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
 800a582:	4b7e      	ldr	r3, [pc, #504]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a584:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a586:	681a      	ldr	r2, [r3, #0]
 800a588:	4b7c      	ldr	r3, [pc, #496]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a58a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a58c:	795b      	ldrb	r3, [r3, #5]
 800a58e:	40da      	lsrs	r2, r3
 800a590:	4b7a      	ldr	r3, [pc, #488]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a592:	619a      	str	r2, [r3, #24]
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
 800a594:	4b79      	ldr	r3, [pc, #484]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a596:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a598:	685a      	ldr	r2, [r3, #4]
 800a59a:	4b78      	ldr	r3, [pc, #480]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a59c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a59e:	795b      	ldrb	r3, [r3, #5]
 800a5a0:	40da      	lsrs	r2, r3
 800a5a2:	4b76      	ldr	r3, [pc, #472]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a5a4:	61da      	str	r2, [r3, #28]
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
 800a5a6:	4b75      	ldr	r3, [pc, #468]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a5a8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a5aa:	689a      	ldr	r2, [r3, #8]
 800a5ac:	4b73      	ldr	r3, [pc, #460]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a5ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a5b0:	795b      	ldrb	r3, [r3, #5]
 800a5b2:	40da      	lsrs	r2, r3
 800a5b4:	4b71      	ldr	r3, [pc, #452]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a5b6:	621a      	str	r2, [r3, #32]
        st.steps[A_AXIS] = st.exec_block->steps[A_AXIS] >> st.exec_segment->amass_level;
 800a5b8:	4b70      	ldr	r3, [pc, #448]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a5ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a5bc:	68da      	ldr	r2, [r3, #12]
 800a5be:	4b6f      	ldr	r3, [pc, #444]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a5c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a5c2:	795b      	ldrb	r3, [r3, #5]
 800a5c4:	40da      	lsrs	r2, r3
 800a5c6:	4b6d      	ldr	r3, [pc, #436]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a5c8:	625a      	str	r2, [r3, #36]	; 0x24
      #endif

      #ifdef VARIABLE_SPINDLE
        // Set real-time spindle output as segment is loaded, just prior to the first step.
        spindle_set_speed(st.exec_segment->spindle_pwm);
 800a5ca:	4b6c      	ldr	r3, [pc, #432]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a5cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a5ce:	799b      	ldrb	r3, [r3, #6]
 800a5d0:	b29b      	uxth	r3, r3
 800a5d2:	0018      	movs	r0, r3
 800a5d4:	f7ff fd3a 	bl	800a04c <spindle_set_speed>
 800a5d8:	e00d      	b.n	800a5f6 <TIM2_IRQHandler+0x202>
      #endif

    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
 800a5da:	f7ff febd 	bl	800a358 <st_go_idle>
      // Ensure pwm is set properly upon completion of rate-controlled motion.
      #ifdef VARIABLE_SPINDLE
      if (st.exec_block->is_pwm_rate_adjusted) { spindle_set_speed(SPINDLE_PWM_OFF_VALUE); }
 800a5de:	4b67      	ldr	r3, [pc, #412]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a5e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a5e2:	7d5b      	ldrb	r3, [r3, #21]
 800a5e4:	2b00      	cmp	r3, #0
 800a5e6:	d002      	beq.n	800a5ee <TIM2_IRQHandler+0x1fa>
 800a5e8:	2000      	movs	r0, #0
 800a5ea:	f7ff fd2f 	bl	800a04c <spindle_set_speed>
      #endif
      system_set_exec_state_flag(EXEC_CYCLE_STOP); // Flag main program for cycle end
 800a5ee:	2004      	movs	r0, #4
 800a5f0:	f001 fd58 	bl	800c0a4 <system_set_exec_state_flag>
      return; // Nothing to do but exit.
 800a5f4:	e12b      	b.n	800a84e <TIM2_IRQHandler+0x45a>
    }
  }


  // Check probing state.
  if (sys_probe_state == PROBE_ACTIVE) { probe_state_monitor(); }
 800a5f6:	4b6c      	ldr	r3, [pc, #432]	; (800a7a8 <TIM2_IRQHandler+0x3b4>)
 800a5f8:	781b      	ldrb	r3, [r3, #0]
 800a5fa:	b2db      	uxtb	r3, r3
 800a5fc:	2b01      	cmp	r3, #1
 800a5fe:	d101      	bne.n	800a604 <TIM2_IRQHandler+0x210>
 800a600:	f7fd fa4a 	bl	8007a98 <probe_state_monitor>

  // Reset step out bits.
  st.step_outbits = 0;
 800a604:	4b5d      	ldr	r3, [pc, #372]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a606:	2200      	movs	r2, #0
 800a608:	825a      	strh	r2, [r3, #18]

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
 800a60a:	4b5c      	ldr	r3, [pc, #368]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a60c:	681a      	ldr	r2, [r3, #0]
 800a60e:	4b5b      	ldr	r3, [pc, #364]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a610:	699b      	ldr	r3, [r3, #24]
 800a612:	18d2      	adds	r2, r2, r3
 800a614:	4b59      	ldr	r3, [pc, #356]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a616:	601a      	str	r2, [r3, #0]
  #else
    st.counter_x += st.exec_block->steps[X_AXIS];
  #endif
  if (st.counter_x > st.exec_block->step_event_count) {
 800a618:	4b58      	ldr	r3, [pc, #352]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a61a:	681a      	ldr	r2, [r3, #0]
 800a61c:	4b57      	ldr	r3, [pc, #348]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a61e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a620:	691b      	ldr	r3, [r3, #16]
 800a622:	429a      	cmp	r2, r3
 800a624:	d920      	bls.n	800a668 <TIM2_IRQHandler+0x274>
    st.step_outbits |= (1<<X_STEP_BIT);
 800a626:	4b55      	ldr	r3, [pc, #340]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a628:	8a5b      	ldrh	r3, [r3, #18]
 800a62a:	2202      	movs	r2, #2
 800a62c:	4313      	orrs	r3, r2
 800a62e:	b29a      	uxth	r2, r3
 800a630:	4b52      	ldr	r3, [pc, #328]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a632:	825a      	strh	r2, [r3, #18]
    st.counter_x -= st.exec_block->step_event_count;
 800a634:	4b51      	ldr	r3, [pc, #324]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a636:	681a      	ldr	r2, [r3, #0]
 800a638:	4b50      	ldr	r3, [pc, #320]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a63a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a63c:	691b      	ldr	r3, [r3, #16]
 800a63e:	1ad2      	subs	r2, r2, r3
 800a640:	4b4e      	ldr	r3, [pc, #312]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a642:	601a      	str	r2, [r3, #0]
    if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys_position[X_AXIS]--; }
 800a644:	4b4d      	ldr	r3, [pc, #308]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a646:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a648:	7d1b      	ldrb	r3, [r3, #20]
 800a64a:	001a      	movs	r2, r3
 800a64c:	2310      	movs	r3, #16
 800a64e:	4013      	ands	r3, r2
 800a650:	d005      	beq.n	800a65e <TIM2_IRQHandler+0x26a>
 800a652:	4b56      	ldr	r3, [pc, #344]	; (800a7ac <TIM2_IRQHandler+0x3b8>)
 800a654:	681b      	ldr	r3, [r3, #0]
 800a656:	1e5a      	subs	r2, r3, #1
 800a658:	4b54      	ldr	r3, [pc, #336]	; (800a7ac <TIM2_IRQHandler+0x3b8>)
 800a65a:	601a      	str	r2, [r3, #0]
 800a65c:	e004      	b.n	800a668 <TIM2_IRQHandler+0x274>
    else { sys_position[X_AXIS]++; }
 800a65e:	4b53      	ldr	r3, [pc, #332]	; (800a7ac <TIM2_IRQHandler+0x3b8>)
 800a660:	681b      	ldr	r3, [r3, #0]
 800a662:	1c5a      	adds	r2, r3, #1
 800a664:	4b51      	ldr	r3, [pc, #324]	; (800a7ac <TIM2_IRQHandler+0x3b8>)
 800a666:	601a      	str	r2, [r3, #0]
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
 800a668:	4b44      	ldr	r3, [pc, #272]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a66a:	685a      	ldr	r2, [r3, #4]
 800a66c:	4b43      	ldr	r3, [pc, #268]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a66e:	69db      	ldr	r3, [r3, #28]
 800a670:	18d2      	adds	r2, r2, r3
 800a672:	4b42      	ldr	r3, [pc, #264]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a674:	605a      	str	r2, [r3, #4]
  #else
    st.counter_y += st.exec_block->steps[Y_AXIS];
  #endif
  if (st.counter_y > st.exec_block->step_event_count) {
 800a676:	4b41      	ldr	r3, [pc, #260]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a678:	685a      	ldr	r2, [r3, #4]
 800a67a:	4b40      	ldr	r3, [pc, #256]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a67c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a67e:	691b      	ldr	r3, [r3, #16]
 800a680:	429a      	cmp	r2, r3
 800a682:	d920      	bls.n	800a6c6 <TIM2_IRQHandler+0x2d2>
    st.step_outbits |= (1<<Y_STEP_BIT);
 800a684:	4b3d      	ldr	r3, [pc, #244]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a686:	8a5b      	ldrh	r3, [r3, #18]
 800a688:	2204      	movs	r2, #4
 800a68a:	4313      	orrs	r3, r2
 800a68c:	b29a      	uxth	r2, r3
 800a68e:	4b3b      	ldr	r3, [pc, #236]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a690:	825a      	strh	r2, [r3, #18]
    st.counter_y -= st.exec_block->step_event_count;
 800a692:	4b3a      	ldr	r3, [pc, #232]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a694:	685a      	ldr	r2, [r3, #4]
 800a696:	4b39      	ldr	r3, [pc, #228]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a698:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a69a:	691b      	ldr	r3, [r3, #16]
 800a69c:	1ad2      	subs	r2, r2, r3
 800a69e:	4b37      	ldr	r3, [pc, #220]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a6a0:	605a      	str	r2, [r3, #4]
    if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys_position[Y_AXIS]--; }
 800a6a2:	4b36      	ldr	r3, [pc, #216]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a6a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a6a6:	7d1b      	ldrb	r3, [r3, #20]
 800a6a8:	001a      	movs	r2, r3
 800a6aa:	2320      	movs	r3, #32
 800a6ac:	4013      	ands	r3, r2
 800a6ae:	d005      	beq.n	800a6bc <TIM2_IRQHandler+0x2c8>
 800a6b0:	4b3e      	ldr	r3, [pc, #248]	; (800a7ac <TIM2_IRQHandler+0x3b8>)
 800a6b2:	685b      	ldr	r3, [r3, #4]
 800a6b4:	1e5a      	subs	r2, r3, #1
 800a6b6:	4b3d      	ldr	r3, [pc, #244]	; (800a7ac <TIM2_IRQHandler+0x3b8>)
 800a6b8:	605a      	str	r2, [r3, #4]
 800a6ba:	e004      	b.n	800a6c6 <TIM2_IRQHandler+0x2d2>
    else { sys_position[Y_AXIS]++; }
 800a6bc:	4b3b      	ldr	r3, [pc, #236]	; (800a7ac <TIM2_IRQHandler+0x3b8>)
 800a6be:	685b      	ldr	r3, [r3, #4]
 800a6c0:	1c5a      	adds	r2, r3, #1
 800a6c2:	4b3a      	ldr	r3, [pc, #232]	; (800a7ac <TIM2_IRQHandler+0x3b8>)
 800a6c4:	605a      	str	r2, [r3, #4]
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
 800a6c6:	4b2d      	ldr	r3, [pc, #180]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a6c8:	689a      	ldr	r2, [r3, #8]
 800a6ca:	4b2c      	ldr	r3, [pc, #176]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a6cc:	6a1b      	ldr	r3, [r3, #32]
 800a6ce:	18d2      	adds	r2, r2, r3
 800a6d0:	4b2a      	ldr	r3, [pc, #168]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a6d2:	609a      	str	r2, [r3, #8]
  #else
    st.counter_z += st.exec_block->steps[Z_AXIS];
  #endif
  if (st.counter_z > st.exec_block->step_event_count) {
 800a6d4:	4b29      	ldr	r3, [pc, #164]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a6d6:	689a      	ldr	r2, [r3, #8]
 800a6d8:	4b28      	ldr	r3, [pc, #160]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a6da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a6dc:	691b      	ldr	r3, [r3, #16]
 800a6de:	429a      	cmp	r2, r3
 800a6e0:	d920      	bls.n	800a724 <TIM2_IRQHandler+0x330>
    st.step_outbits |= (1<<Z_STEP_BIT);
 800a6e2:	4b26      	ldr	r3, [pc, #152]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a6e4:	8a5b      	ldrh	r3, [r3, #18]
 800a6e6:	2208      	movs	r2, #8
 800a6e8:	4313      	orrs	r3, r2
 800a6ea:	b29a      	uxth	r2, r3
 800a6ec:	4b23      	ldr	r3, [pc, #140]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a6ee:	825a      	strh	r2, [r3, #18]
    st.counter_z -= st.exec_block->step_event_count;
 800a6f0:	4b22      	ldr	r3, [pc, #136]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a6f2:	689a      	ldr	r2, [r3, #8]
 800a6f4:	4b21      	ldr	r3, [pc, #132]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a6f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a6f8:	691b      	ldr	r3, [r3, #16]
 800a6fa:	1ad2      	subs	r2, r2, r3
 800a6fc:	4b1f      	ldr	r3, [pc, #124]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a6fe:	609a      	str	r2, [r3, #8]
    if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys_position[Z_AXIS]--; }
 800a700:	4b1e      	ldr	r3, [pc, #120]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a702:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a704:	7d1b      	ldrb	r3, [r3, #20]
 800a706:	001a      	movs	r2, r3
 800a708:	2340      	movs	r3, #64	; 0x40
 800a70a:	4013      	ands	r3, r2
 800a70c:	d005      	beq.n	800a71a <TIM2_IRQHandler+0x326>
 800a70e:	4b27      	ldr	r3, [pc, #156]	; (800a7ac <TIM2_IRQHandler+0x3b8>)
 800a710:	689b      	ldr	r3, [r3, #8]
 800a712:	1e5a      	subs	r2, r3, #1
 800a714:	4b25      	ldr	r3, [pc, #148]	; (800a7ac <TIM2_IRQHandler+0x3b8>)
 800a716:	609a      	str	r2, [r3, #8]
 800a718:	e004      	b.n	800a724 <TIM2_IRQHandler+0x330>
    else { sys_position[Z_AXIS]++; }
 800a71a:	4b24      	ldr	r3, [pc, #144]	; (800a7ac <TIM2_IRQHandler+0x3b8>)
 800a71c:	689b      	ldr	r3, [r3, #8]
 800a71e:	1c5a      	adds	r2, r3, #1
 800a720:	4b22      	ldr	r3, [pc, #136]	; (800a7ac <TIM2_IRQHandler+0x3b8>)
 800a722:	609a      	str	r2, [r3, #8]
  }
#ifdef A_AXIS
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_a += st.steps[A_AXIS];
 800a724:	4b15      	ldr	r3, [pc, #84]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a726:	68da      	ldr	r2, [r3, #12]
 800a728:	4b14      	ldr	r3, [pc, #80]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a72a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a72c:	18d2      	adds	r2, r2, r3
 800a72e:	4b13      	ldr	r3, [pc, #76]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a730:	60da      	str	r2, [r3, #12]
  #else
    st.counter_a += st.exec_block->steps[A_AXIS];
  #endif
  if (st.counter_a > st.exec_block->step_event_count) {
 800a732:	4b12      	ldr	r3, [pc, #72]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a734:	68da      	ldr	r2, [r3, #12]
 800a736:	4b11      	ldr	r3, [pc, #68]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a738:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a73a:	691b      	ldr	r3, [r3, #16]
 800a73c:	429a      	cmp	r2, r3
 800a73e:	d943      	bls.n	800a7c8 <TIM2_IRQHandler+0x3d4>
    st.counter_a -= st.exec_block->step_event_count;
 800a740:	4b0e      	ldr	r3, [pc, #56]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a742:	68da      	ldr	r2, [r3, #12]
 800a744:	4b0d      	ldr	r3, [pc, #52]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a746:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a748:	691b      	ldr	r3, [r3, #16]
 800a74a:	1ad2      	subs	r2, r2, r3
 800a74c:	4b0b      	ldr	r3, [pc, #44]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a74e:	60da      	str	r2, [r3, #12]
    /*if (sys.state == STATE_HOMING) {
    	st.exec_block->direction_bits ^= 0x1;
    }*/
    if (st.exec_block->direction_bits & (0x1)) {
 800a750:	4b0a      	ldr	r3, [pc, #40]	; (800a77c <TIM2_IRQHandler+0x388>)
 800a752:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a754:	7d1b      	ldrb	r3, [r3, #20]
 800a756:	001a      	movs	r2, r3
 800a758:	2301      	movs	r3, #1
 800a75a:	4013      	ands	r3, r2
 800a75c:	d028      	beq.n	800a7b0 <TIM2_IRQHandler+0x3bc>
    	sys_position[A_AXIS]--;
 800a75e:	4b13      	ldr	r3, [pc, #76]	; (800a7ac <TIM2_IRQHandler+0x3b8>)
 800a760:	68db      	ldr	r3, [r3, #12]
 800a762:	1e5a      	subs	r2, r3, #1
 800a764:	4b11      	ldr	r3, [pc, #68]	; (800a7ac <TIM2_IRQHandler+0x3b8>)
 800a766:	60da      	str	r2, [r3, #12]
    	lookUpIndex = (lookUpIndex + 1) & 0x7;
 800a768:	4b08      	ldr	r3, [pc, #32]	; (800a78c <TIM2_IRQHandler+0x398>)
 800a76a:	681b      	ldr	r3, [r3, #0]
 800a76c:	3301      	adds	r3, #1
 800a76e:	2207      	movs	r2, #7
 800a770:	401a      	ands	r2, r3
 800a772:	4b06      	ldr	r3, [pc, #24]	; (800a78c <TIM2_IRQHandler+0x398>)
 800a774:	601a      	str	r2, [r3, #0]
 800a776:	e027      	b.n	800a7c8 <TIM2_IRQHandler+0x3d4>
 800a778:	20000580 	.word	0x20000580
 800a77c:	20000544 	.word	0x20000544
 800a780:	40000400 	.word	0x40000400
 800a784:	48000800 	.word	0x48000800
 800a788:	ffffc3ff 	.word	0xffffc3ff
 800a78c:	20000498 	.word	0x20000498
 800a790:	0800e0c4 	.word	0x0800e0c4
 800a794:	20000579 	.word	0x20000579
 800a798:	20000578 	.word	0x20000578
 800a79c:	20000514 	.word	0x20000514
 800a7a0:	2000049c 	.word	0x2000049c
 800a7a4:	2000057e 	.word	0x2000057e
 800a7a8:	20000bca 	.word	0x20000bca
 800a7ac:	20000bdc 	.word	0x20000bdc
    }
    else {
    	sys_position[A_AXIS]++;
 800a7b0:	4b28      	ldr	r3, [pc, #160]	; (800a854 <TIM2_IRQHandler+0x460>)
 800a7b2:	68db      	ldr	r3, [r3, #12]
 800a7b4:	1c5a      	adds	r2, r3, #1
 800a7b6:	4b27      	ldr	r3, [pc, #156]	; (800a854 <TIM2_IRQHandler+0x460>)
 800a7b8:	60da      	str	r2, [r3, #12]
    	lookUpIndex = (lookUpIndex - 1) & 0x7;
 800a7ba:	4b27      	ldr	r3, [pc, #156]	; (800a858 <TIM2_IRQHandler+0x464>)
 800a7bc:	681b      	ldr	r3, [r3, #0]
 800a7be:	3b01      	subs	r3, #1
 800a7c0:	2207      	movs	r2, #7
 800a7c2:	401a      	ands	r2, r3
 800a7c4:	4b24      	ldr	r3, [pc, #144]	; (800a858 <TIM2_IRQHandler+0x464>)
 800a7c6:	601a      	str	r2, [r3, #0]
    }
  }
#endif

  // During a homing cycle, lock out and prevent desired axes from moving.
  if (sys.state == STATE_HOMING) {
 800a7c8:	4b24      	ldr	r3, [pc, #144]	; (800a85c <TIM2_IRQHandler+0x468>)
 800a7ca:	781b      	ldrb	r3, [r3, #0]
 800a7cc:	2b04      	cmp	r3, #4
 800a7ce:	d111      	bne.n	800a7f4 <TIM2_IRQHandler+0x400>
	  st.step_outbits &= sys.homing_axis_lock;
 800a7d0:	4b23      	ldr	r3, [pc, #140]	; (800a860 <TIM2_IRQHandler+0x46c>)
 800a7d2:	8a5b      	ldrh	r3, [r3, #18]
 800a7d4:	4a21      	ldr	r2, [pc, #132]	; (800a85c <TIM2_IRQHandler+0x468>)
 800a7d6:	7992      	ldrb	r2, [r2, #6]
 800a7d8:	b292      	uxth	r2, r2
 800a7da:	4013      	ands	r3, r2
 800a7dc:	b29a      	uxth	r2, r3
 800a7de:	4b20      	ldr	r3, [pc, #128]	; (800a860 <TIM2_IRQHandler+0x46c>)
 800a7e0:	825a      	strh	r2, [r3, #18]
	  // A axis
	  if(~(sys.homing_axis_lock) & 0x1) {
 800a7e2:	4b1e      	ldr	r3, [pc, #120]	; (800a85c <TIM2_IRQHandler+0x468>)
 800a7e4:	799b      	ldrb	r3, [r3, #6]
 800a7e6:	001a      	movs	r2, r3
 800a7e8:	2301      	movs	r3, #1
 800a7ea:	4013      	ands	r3, r2
 800a7ec:	d102      	bne.n	800a7f4 <TIM2_IRQHandler+0x400>
		  lookUpIndex = 0;
 800a7ee:	4b1a      	ldr	r3, [pc, #104]	; (800a858 <TIM2_IRQHandler+0x464>)
 800a7f0:	2200      	movs	r2, #0
 800a7f2:	601a      	str	r2, [r3, #0]
	  }
  }

  st.step_count--; // Decrement step events count
 800a7f4:	4b1a      	ldr	r3, [pc, #104]	; (800a860 <TIM2_IRQHandler+0x46c>)
 800a7f6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a7f8:	3b01      	subs	r3, #1
 800a7fa:	b29a      	uxth	r2, r3
 800a7fc:	4b18      	ldr	r3, [pc, #96]	; (800a860 <TIM2_IRQHandler+0x46c>)
 800a7fe:	851a      	strh	r2, [r3, #40]	; 0x28
  if (st.step_count == 0) {
 800a800:	4b17      	ldr	r3, [pc, #92]	; (800a860 <TIM2_IRQHandler+0x46c>)
 800a802:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800a804:	2b00      	cmp	r3, #0
 800a806:	d113      	bne.n	800a830 <TIM2_IRQHandler+0x43c>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
 800a808:	4b15      	ldr	r3, [pc, #84]	; (800a860 <TIM2_IRQHandler+0x46c>)
 800a80a:	2200      	movs	r2, #0
 800a80c:	631a      	str	r2, [r3, #48]	; 0x30
#ifndef WIN32
	uint8_t segment_tail_next = segment_buffer_tail + 1;
 800a80e:	4b15      	ldr	r3, [pc, #84]	; (800a864 <TIM2_IRQHandler+0x470>)
 800a810:	781b      	ldrb	r3, [r3, #0]
 800a812:	b2da      	uxtb	r2, r3
 800a814:	1dfb      	adds	r3, r7, #7
 800a816:	3201      	adds	r2, #1
 800a818:	701a      	strb	r2, [r3, #0]
	if (segment_tail_next == SEGMENT_BUFFER_SIZE)
 800a81a:	1dfb      	adds	r3, r7, #7
 800a81c:	781b      	ldrb	r3, [r3, #0]
 800a81e:	2b06      	cmp	r3, #6
 800a820:	d102      	bne.n	800a828 <TIM2_IRQHandler+0x434>
		segment_tail_next = 0;
 800a822:	1dfb      	adds	r3, r7, #7
 800a824:	2200      	movs	r2, #0
 800a826:	701a      	strb	r2, [r3, #0]
	segment_buffer_tail = segment_tail_next;
 800a828:	4b0e      	ldr	r3, [pc, #56]	; (800a864 <TIM2_IRQHandler+0x470>)
 800a82a:	1dfa      	adds	r2, r7, #7
 800a82c:	7812      	ldrb	r2, [r2, #0]
 800a82e:	701a      	strb	r2, [r3, #0]
		segment_buffer_tail = 0; 
	}
#endif
  }

  st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
 800a830:	4b0b      	ldr	r3, [pc, #44]	; (800a860 <TIM2_IRQHandler+0x46c>)
 800a832:	8a5a      	ldrh	r2, [r3, #18]
 800a834:	4b0c      	ldr	r3, [pc, #48]	; (800a868 <TIM2_IRQHandler+0x474>)
 800a836:	881b      	ldrh	r3, [r3, #0]
 800a838:	4053      	eors	r3, r2
 800a83a:	b29a      	uxth	r2, r3
 800a83c:	4b08      	ldr	r3, [pc, #32]	; (800a860 <TIM2_IRQHandler+0x46c>)
 800a83e:	825a      	strh	r2, [r3, #18]
  busy = false;
 800a840:	4b0a      	ldr	r3, [pc, #40]	; (800a86c <TIM2_IRQHandler+0x478>)
 800a842:	2200      	movs	r2, #0
 800a844:	701a      	strb	r2, [r3, #0]
 800a846:	e002      	b.n	800a84e <TIM2_IRQHandler+0x45a>
		return;
 800a848:	46c0      	nop			; (mov r8, r8)
 800a84a:	e000      	b.n	800a84e <TIM2_IRQHandler+0x45a>
  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
 800a84c:	46c0      	nop			; (mov r8, r8)
}
 800a84e:	46bd      	mov	sp, r7
 800a850:	b002      	add	sp, #8
 800a852:	bd80      	pop	{r7, pc}
 800a854:	20000bdc 	.word	0x20000bdc
 800a858:	20000498 	.word	0x20000498
 800a85c:	20000bb4 	.word	0x20000bb4
 800a860:	20000544 	.word	0x20000544
 800a864:	20000578 	.word	0x20000578
 800a868:	2000057c 	.word	0x2000057c
 800a86c:	20000580 	.word	0x20000580

0800a870 <TIM3_IRQHandler>:
ISR(TIMER0_OVF_vect)
#endif
#ifdef WIN32
void Timer0Proc()
#endif
{
 800a870:	b580      	push	{r7, lr}
 800a872:	af00      	add	r7, sp, #0
		NVIC_DisableIRQ(TIM3_IRQn);
		GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
	}
#endif
#ifdef STM32F0DISCOVERY
	if ((TIM3->SR & 0x0001) != 0)                  // check interrupt source
 800a874:	4b18      	ldr	r3, [pc, #96]	; (800a8d8 <TIM3_IRQHandler+0x68>)
 800a876:	8a1b      	ldrh	r3, [r3, #16]
 800a878:	b29b      	uxth	r3, r3
 800a87a:	001a      	movs	r2, r3
 800a87c:	2301      	movs	r3, #1
 800a87e:	4013      	ands	r3, r2
 800a880:	d026      	beq.n	800a8d0 <TIM3_IRQHandler+0x60>
	{
		TIM3->SR &= ~(1<<0);                          // clear UIF flag
 800a882:	4a15      	ldr	r2, [pc, #84]	; (800a8d8 <TIM3_IRQHandler+0x68>)
 800a884:	4b14      	ldr	r3, [pc, #80]	; (800a8d8 <TIM3_IRQHandler+0x68>)
 800a886:	8a1b      	ldrh	r3, [r3, #16]
 800a888:	b29b      	uxth	r3, r3
 800a88a:	2101      	movs	r1, #1
 800a88c:	438b      	bics	r3, r1
 800a88e:	b29b      	uxth	r3, r3
 800a890:	8213      	strh	r3, [r2, #16]
		TIM3->CNT = 0;
 800a892:	4b11      	ldr	r3, [pc, #68]	; (800a8d8 <TIM3_IRQHandler+0x68>)
 800a894:	2200      	movs	r2, #0
 800a896:	625a      	str	r2, [r3, #36]	; 0x24
		NVIC_DisableIRQ(TIM3_IRQn);
 800a898:	2010      	movs	r0, #16
 800a89a:	f7ff fcf1 	bl	800a280 <NVIC_DisableIRQ>
		GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
 800a89e:	2390      	movs	r3, #144	; 0x90
 800a8a0:	05db      	lsls	r3, r3, #23
 800a8a2:	0018      	movs	r0, r3
 800a8a4:	f7f8 f944 	bl	8002b30 <GPIO_ReadOutputData>
 800a8a8:	0003      	movs	r3, r0
 800a8aa:	b21b      	sxth	r3, r3
 800a8ac:	220e      	movs	r2, #14
 800a8ae:	4393      	bics	r3, r2
 800a8b0:	b21a      	sxth	r2, r3
 800a8b2:	4b0a      	ldr	r3, [pc, #40]	; (800a8dc <TIM3_IRQHandler+0x6c>)
 800a8b4:	881b      	ldrh	r3, [r3, #0]
 800a8b6:	b21b      	sxth	r3, r3
 800a8b8:	210e      	movs	r1, #14
 800a8ba:	400b      	ands	r3, r1
 800a8bc:	b21b      	sxth	r3, r3
 800a8be:	4313      	orrs	r3, r2
 800a8c0:	b21b      	sxth	r3, r3
 800a8c2:	b29a      	uxth	r2, r3
 800a8c4:	2390      	movs	r3, #144	; 0x90
 800a8c6:	05db      	lsls	r3, r3, #23
 800a8c8:	0011      	movs	r1, r2
 800a8ca:	0018      	movs	r0, r3
 800a8cc:	f7f8 f976 	bl	8002bbc <GPIO_Write>
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed.
#endif
#ifdef WIN32
  nTimer0Out = 0;
#endif
}
 800a8d0:	46c0      	nop			; (mov r8, r8)
 800a8d2:	46bd      	mov	sp, r7
 800a8d4:	bd80      	pop	{r7, pc}
 800a8d6:	46c0      	nop			; (mov r8, r8)
 800a8d8:	40000400 	.word	0x40000400
 800a8dc:	2000057c 	.word	0x2000057c

0800a8e0 <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{
 800a8e0:	b580      	push	{r7, lr}
 800a8e2:	b082      	sub	sp, #8
 800a8e4:	af00      	add	r7, sp, #0
  uint8_t idx;
  step_port_invert_mask = 0;
 800a8e6:	4b21      	ldr	r3, [pc, #132]	; (800a96c <st_generate_step_dir_invert_masks+0x8c>)
 800a8e8:	2200      	movs	r2, #0
 800a8ea:	801a      	strh	r2, [r3, #0]
  dir_port_invert_mask = 0;
 800a8ec:	4b20      	ldr	r3, [pc, #128]	; (800a970 <st_generate_step_dir_invert_masks+0x90>)
 800a8ee:	2200      	movs	r2, #0
 800a8f0:	801a      	strh	r2, [r3, #0]
  for (idx=0; idx<N_AXIS; idx++) {
 800a8f2:	1dfb      	adds	r3, r7, #7
 800a8f4:	2200      	movs	r2, #0
 800a8f6:	701a      	strb	r2, [r3, #0]
 800a8f8:	e030      	b.n	800a95c <st_generate_step_dir_invert_masks+0x7c>
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= step_pin_mask[idx]; }
 800a8fa:	4b1e      	ldr	r3, [pc, #120]	; (800a974 <st_generate_step_dir_invert_masks+0x94>)
 800a8fc:	2241      	movs	r2, #65	; 0x41
 800a8fe:	5c9b      	ldrb	r3, [r3, r2]
 800a900:	001a      	movs	r2, r3
 800a902:	1dfb      	adds	r3, r7, #7
 800a904:	781b      	ldrb	r3, [r3, #0]
 800a906:	411a      	asrs	r2, r3
 800a908:	0013      	movs	r3, r2
 800a90a:	2201      	movs	r2, #1
 800a90c:	4013      	ands	r3, r2
 800a90e:	d00a      	beq.n	800a926 <st_generate_step_dir_invert_masks+0x46>
 800a910:	1dfb      	adds	r3, r7, #7
 800a912:	781a      	ldrb	r2, [r3, #0]
 800a914:	4b18      	ldr	r3, [pc, #96]	; (800a978 <st_generate_step_dir_invert_masks+0x98>)
 800a916:	0052      	lsls	r2, r2, #1
 800a918:	5ad2      	ldrh	r2, [r2, r3]
 800a91a:	4b14      	ldr	r3, [pc, #80]	; (800a96c <st_generate_step_dir_invert_masks+0x8c>)
 800a91c:	881b      	ldrh	r3, [r3, #0]
 800a91e:	4313      	orrs	r3, r2
 800a920:	b29a      	uxth	r2, r3
 800a922:	4b12      	ldr	r3, [pc, #72]	; (800a96c <st_generate_step_dir_invert_masks+0x8c>)
 800a924:	801a      	strh	r2, [r3, #0]
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= direction_pin_mask[idx]; }
 800a926:	4b13      	ldr	r3, [pc, #76]	; (800a974 <st_generate_step_dir_invert_masks+0x94>)
 800a928:	2242      	movs	r2, #66	; 0x42
 800a92a:	5c9b      	ldrb	r3, [r3, r2]
 800a92c:	001a      	movs	r2, r3
 800a92e:	1dfb      	adds	r3, r7, #7
 800a930:	781b      	ldrb	r3, [r3, #0]
 800a932:	411a      	asrs	r2, r3
 800a934:	0013      	movs	r3, r2
 800a936:	2201      	movs	r2, #1
 800a938:	4013      	ands	r3, r2
 800a93a:	d00a      	beq.n	800a952 <st_generate_step_dir_invert_masks+0x72>
 800a93c:	1dfb      	adds	r3, r7, #7
 800a93e:	781a      	ldrb	r2, [r3, #0]
 800a940:	4b0e      	ldr	r3, [pc, #56]	; (800a97c <st_generate_step_dir_invert_masks+0x9c>)
 800a942:	0052      	lsls	r2, r2, #1
 800a944:	5ad2      	ldrh	r2, [r2, r3]
 800a946:	4b0a      	ldr	r3, [pc, #40]	; (800a970 <st_generate_step_dir_invert_masks+0x90>)
 800a948:	881b      	ldrh	r3, [r3, #0]
 800a94a:	4313      	orrs	r3, r2
 800a94c:	b29a      	uxth	r2, r3
 800a94e:	4b08      	ldr	r3, [pc, #32]	; (800a970 <st_generate_step_dir_invert_masks+0x90>)
 800a950:	801a      	strh	r2, [r3, #0]
  for (idx=0; idx<N_AXIS; idx++) {
 800a952:	1dfb      	adds	r3, r7, #7
 800a954:	781a      	ldrb	r2, [r3, #0]
 800a956:	1dfb      	adds	r3, r7, #7
 800a958:	3201      	adds	r2, #1
 800a95a:	701a      	strb	r2, [r3, #0]
 800a95c:	1dfb      	adds	r3, r7, #7
 800a95e:	781b      	ldrb	r3, [r3, #0]
 800a960:	2b03      	cmp	r3, #3
 800a962:	d9ca      	bls.n	800a8fa <st_generate_step_dir_invert_masks+0x1a>
  }
}
 800a964:	46c0      	nop			; (mov r8, r8)
 800a966:	46bd      	mov	sp, r7
 800a968:	b002      	add	sp, #8
 800a96a:	bd80      	pop	{r7, pc}
 800a96c:	2000057c 	.word	0x2000057c
 800a970:	2000057e 	.word	0x2000057e
 800a974:	20000b44 	.word	0x20000b44
 800a978:	0800e0ac 	.word	0x0800e0ac
 800a97c:	0800e0b4 	.word	0x0800e0b4

0800a980 <st_reset>:


// Reset and clear stepper subsystem variables
void st_reset()
{
 800a980:	b580      	push	{r7, lr}
 800a982:	af00      	add	r7, sp, #0
  // Initialize stepper driver idle state.
  st_go_idle();
 800a984:	f7ff fce8 	bl	800a358 <st_go_idle>

  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(st_prep_t));
 800a988:	4b2c      	ldr	r3, [pc, #176]	; (800aa3c <st_reset+0xbc>)
 800a98a:	2238      	movs	r2, #56	; 0x38
 800a98c:	2100      	movs	r1, #0
 800a98e:	0018      	movs	r0, r3
 800a990:	f001 feb8 	bl	800c704 <memset>
  memset(&st, 0, sizeof(stepper_t));
 800a994:	4b2a      	ldr	r3, [pc, #168]	; (800aa40 <st_reset+0xc0>)
 800a996:	2234      	movs	r2, #52	; 0x34
 800a998:	2100      	movs	r1, #0
 800a99a:	0018      	movs	r0, r3
 800a99c:	f001 feb2 	bl	800c704 <memset>
  st.exec_segment = NULL;
 800a9a0:	4b27      	ldr	r3, [pc, #156]	; (800aa40 <st_reset+0xc0>)
 800a9a2:	2200      	movs	r2, #0
 800a9a4:	631a      	str	r2, [r3, #48]	; 0x30
  pl_block = NULL;  // Planner block pointer used by segment buffer
 800a9a6:	4b27      	ldr	r3, [pc, #156]	; (800aa44 <st_reset+0xc4>)
 800a9a8:	2200      	movs	r2, #0
 800a9aa:	601a      	str	r2, [r3, #0]
  segment_buffer_tail = 0;
 800a9ac:	4b26      	ldr	r3, [pc, #152]	; (800aa48 <st_reset+0xc8>)
 800a9ae:	2200      	movs	r2, #0
 800a9b0:	701a      	strb	r2, [r3, #0]
  segment_buffer_head = 0; // empty = tail
 800a9b2:	4b26      	ldr	r3, [pc, #152]	; (800aa4c <st_reset+0xcc>)
 800a9b4:	2200      	movs	r2, #0
 800a9b6:	701a      	strb	r2, [r3, #0]
  segment_next_head = 1;
 800a9b8:	4b25      	ldr	r3, [pc, #148]	; (800aa50 <st_reset+0xd0>)
 800a9ba:	2201      	movs	r2, #1
 800a9bc:	701a      	strb	r2, [r3, #0]
  busy = false;
 800a9be:	4b25      	ldr	r3, [pc, #148]	; (800aa54 <st_reset+0xd4>)
 800a9c0:	2200      	movs	r2, #0
 800a9c2:	701a      	strb	r2, [r3, #0]

  st_generate_step_dir_invert_masks();
 800a9c4:	f7ff ff8c 	bl	800a8e0 <st_generate_step_dir_invert_masks>
  st.dir_outbits = dir_port_invert_mask; // Initialize direction bits to default.
 800a9c8:	4b23      	ldr	r3, [pc, #140]	; (800aa58 <st_reset+0xd8>)
 800a9ca:	881a      	ldrh	r2, [r3, #0]
 800a9cc:	4b1c      	ldr	r3, [pc, #112]	; (800aa40 <st_reset+0xc0>)
 800a9ce:	829a      	strh	r2, [r3, #20]
#ifdef STM32F103C8
  GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
  GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (dir_port_invert_mask & DIRECTION_MASK));
#endif
#ifdef STM32F0DISCOVERY
  GPIO_Write(STEP_PORT, (GPIO_ReadOutputData(STEP_PORT) & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK));
 800a9d0:	2390      	movs	r3, #144	; 0x90
 800a9d2:	05db      	lsls	r3, r3, #23
 800a9d4:	0018      	movs	r0, r3
 800a9d6:	f7f8 f8ab 	bl	8002b30 <GPIO_ReadOutputData>
 800a9da:	0003      	movs	r3, r0
 800a9dc:	b21b      	sxth	r3, r3
 800a9de:	220e      	movs	r2, #14
 800a9e0:	4393      	bics	r3, r2
 800a9e2:	b21a      	sxth	r2, r3
 800a9e4:	4b1d      	ldr	r3, [pc, #116]	; (800aa5c <st_reset+0xdc>)
 800a9e6:	881b      	ldrh	r3, [r3, #0]
 800a9e8:	b21b      	sxth	r3, r3
 800a9ea:	210e      	movs	r1, #14
 800a9ec:	400b      	ands	r3, r1
 800a9ee:	b21b      	sxth	r3, r3
 800a9f0:	4313      	orrs	r3, r2
 800a9f2:	b21b      	sxth	r3, r3
 800a9f4:	b29a      	uxth	r2, r3
 800a9f6:	2390      	movs	r3, #144	; 0x90
 800a9f8:	05db      	lsls	r3, r3, #23
 800a9fa:	0011      	movs	r1, r2
 800a9fc:	0018      	movs	r0, r3
 800a9fe:	f7f8 f8dd 	bl	8002bbc <GPIO_Write>
  GPIO_Write(DIRECTION_PORT, (GPIO_ReadOutputData(DIRECTION_PORT) & ~DIRECTION_MASK) | (dir_port_invert_mask & DIRECTION_MASK));
 800aa02:	2390      	movs	r3, #144	; 0x90
 800aa04:	05db      	lsls	r3, r3, #23
 800aa06:	0018      	movs	r0, r3
 800aa08:	f7f8 f892 	bl	8002b30 <GPIO_ReadOutputData>
 800aa0c:	0003      	movs	r3, r0
 800aa0e:	b21b      	sxth	r3, r3
 800aa10:	2270      	movs	r2, #112	; 0x70
 800aa12:	4393      	bics	r3, r2
 800aa14:	b21a      	sxth	r2, r3
 800aa16:	4b10      	ldr	r3, [pc, #64]	; (800aa58 <st_reset+0xd8>)
 800aa18:	881b      	ldrh	r3, [r3, #0]
 800aa1a:	b21b      	sxth	r3, r3
 800aa1c:	2170      	movs	r1, #112	; 0x70
 800aa1e:	400b      	ands	r3, r1
 800aa20:	b21b      	sxth	r3, r3
 800aa22:	4313      	orrs	r3, r2
 800aa24:	b21b      	sxth	r3, r3
 800aa26:	b29a      	uxth	r2, r3
 800aa28:	2390      	movs	r3, #144	; 0x90
 800aa2a:	05db      	lsls	r3, r3, #23
 800aa2c:	0011      	movs	r1, r2
 800aa2e:	0018      	movs	r0, r3
 800aa30:	f7f8 f8c4 	bl	8002bbc <GPIO_Write>
#endif
}
 800aa34:	46c0      	nop			; (mov r8, r8)
 800aa36:	46bd      	mov	sp, r7
 800aa38:	bd80      	pop	{r7, pc}
 800aa3a:	46c0      	nop			; (mov r8, r8)
 800aa3c:	2000058c 	.word	0x2000058c
 800aa40:	20000544 	.word	0x20000544
 800aa44:	20000584 	.word	0x20000584
 800aa48:	20000578 	.word	0x20000578
 800aa4c:	20000579 	.word	0x20000579
 800aa50:	2000057a 	.word	0x2000057a
 800aa54:	20000580 	.word	0x20000580
 800aa58:	2000057e 	.word	0x2000057e
 800aa5c:	2000057c 	.word	0x2000057c

0800aa60 <stepper_init>:

#endif

// Initialize and start the stepper motor subsystem
void stepper_init()
{
 800aa60:	b580      	push	{r7, lr}
 800aa62:	b082      	sub	sp, #8
 800aa64:	af00      	add	r7, sp, #0
	NVIC_DisableIRQ(TIM3_IRQn);
	NVIC_DisableIRQ(TIM2_IRQn);
#endif
#ifdef STM32F0DISCOVERY
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_APB2PeriphClockCmd(RCC_STEPPERS_DISABLE_PORT, ENABLE);
 800aa66:	2380      	movs	r3, #128	; 0x80
 800aa68:	029b      	lsls	r3, r3, #10
 800aa6a:	2101      	movs	r1, #1
 800aa6c:	0018      	movs	r0, r3
 800aa6e:	f7f8 fb3b 	bl	80030e8 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800aa72:	003b      	movs	r3, r7
 800aa74:	2203      	movs	r2, #3
 800aa76:	715a      	strb	r2, [r3, #5]
	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800aa78:	003b      	movs	r3, r7
 800aa7a:	2201      	movs	r2, #1
 800aa7c:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800aa7e:	003b      	movs	r3, r7
 800aa80:	2200      	movs	r2, #0
 800aa82:	719a      	strb	r2, [r3, #6]
	GPIO_InitStructure.GPIO_Pin = STEPPERS_DISABLE_MASK;
 800aa84:	003b      	movs	r3, r7
 800aa86:	2280      	movs	r2, #128	; 0x80
 800aa88:	601a      	str	r2, [r3, #0]
	GPIO_Init(STEPPERS_DISABLE_PORT, &GPIO_InitStructure);
 800aa8a:	003a      	movs	r2, r7
 800aa8c:	2390      	movs	r3, #144	; 0x90
 800aa8e:	05db      	lsls	r3, r3, #23
 800aa90:	0011      	movs	r1, r2
 800aa92:	0018      	movs	r0, r3
 800aa94:	f7f7 ffae 	bl	80029f4 <GPIO_Init>

	RCC_APB2PeriphClockCmd(RCC_STEP_PORT, ENABLE);
 800aa98:	2380      	movs	r3, #128	; 0x80
 800aa9a:	029b      	lsls	r3, r3, #10
 800aa9c:	2101      	movs	r1, #1
 800aa9e:	0018      	movs	r0, r3
 800aaa0:	f7f8 fb22 	bl	80030e8 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Pin = STEP_MASK;
 800aaa4:	003b      	movs	r3, r7
 800aaa6:	220e      	movs	r2, #14
 800aaa8:	601a      	str	r2, [r3, #0]
	GPIO_Init(STEP_PORT, &GPIO_InitStructure);
 800aaaa:	003a      	movs	r2, r7
 800aaac:	2390      	movs	r3, #144	; 0x90
 800aaae:	05db      	lsls	r3, r3, #23
 800aab0:	0011      	movs	r1, r2
 800aab2:	0018      	movs	r0, r3
 800aab4:	f7f7 ff9e 	bl	80029f4 <GPIO_Init>

	RCC_APB2PeriphClockCmd(RCC_DIRECTION_PORT, ENABLE);
 800aab8:	2380      	movs	r3, #128	; 0x80
 800aaba:	029b      	lsls	r3, r3, #10
 800aabc:	2101      	movs	r1, #1
 800aabe:	0018      	movs	r0, r3
 800aac0:	f7f8 fb12 	bl	80030e8 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Pin = DIRECTION_MASK;
 800aac4:	003b      	movs	r3, r7
 800aac6:	2270      	movs	r2, #112	; 0x70
 800aac8:	601a      	str	r2, [r3, #0]
	GPIO_Init(DIRECTION_PORT, &GPIO_InitStructure);
 800aaca:	003a      	movs	r2, r7
 800aacc:	2390      	movs	r3, #144	; 0x90
 800aace:	05db      	lsls	r3, r3, #23
 800aad0:	0011      	movs	r1, r2
 800aad2:	0018      	movs	r0, r3
 800aad4:	f7f7 ff8e 	bl	80029f4 <GPIO_Init>

	RCC_APB2PeriphClockCmd(RCC_STEP_PORT2, ENABLE);
 800aad8:	2380      	movs	r3, #128	; 0x80
 800aada:	031b      	lsls	r3, r3, #12
 800aadc:	2101      	movs	r1, #1
 800aade:	0018      	movs	r0, r3
 800aae0:	f7f8 fb02 	bl	80030e8 <RCC_APB2PeriphClockCmd>
	GPIO_InitStructure.GPIO_Pin = STEP_MASK2;
 800aae4:	003b      	movs	r3, r7
 800aae6:	22f0      	movs	r2, #240	; 0xf0
 800aae8:	0192      	lsls	r2, r2, #6
 800aaea:	601a      	str	r2, [r3, #0]
	GPIO_Init(STEP_PORT2, &GPIO_InitStructure);
 800aaec:	003b      	movs	r3, r7
 800aaee:	4a14      	ldr	r2, [pc, #80]	; (800ab40 <stepper_init+0xe0>)
 800aaf0:	0019      	movs	r1, r3
 800aaf2:	0010      	movs	r0, r2
 800aaf4:	f7f7 ff7e 	bl	80029f4 <GPIO_Init>

	RCC->APB1ENR |= RCC_APB1Periph_TIM2;
 800aaf8:	4b12      	ldr	r3, [pc, #72]	; (800ab44 <stepper_init+0xe4>)
 800aafa:	4a12      	ldr	r2, [pc, #72]	; (800ab44 <stepper_init+0xe4>)
 800aafc:	69d2      	ldr	r2, [r2, #28]
 800aafe:	2101      	movs	r1, #1
 800ab00:	430a      	orrs	r2, r1
 800ab02:	61da      	str	r2, [r3, #28]
	TIM_Configuration(TIM2, 1, 1, 1);
 800ab04:	2380      	movs	r3, #128	; 0x80
 800ab06:	05d8      	lsls	r0, r3, #23
 800ab08:	2301      	movs	r3, #1
 800ab0a:	2201      	movs	r2, #1
 800ab0c:	2101      	movs	r1, #1
 800ab0e:	f000 fe23 	bl	800b758 <TIM_Configuration>
	RCC->APB1ENR |= RCC_APB1Periph_TIM3;
 800ab12:	4b0c      	ldr	r3, [pc, #48]	; (800ab44 <stepper_init+0xe4>)
 800ab14:	4a0b      	ldr	r2, [pc, #44]	; (800ab44 <stepper_init+0xe4>)
 800ab16:	69d2      	ldr	r2, [r2, #28]
 800ab18:	2102      	movs	r1, #2
 800ab1a:	430a      	orrs	r2, r1
 800ab1c:	61da      	str	r2, [r3, #28]
	TIM_Configuration(TIM3, 1, 1, 1);
 800ab1e:	480a      	ldr	r0, [pc, #40]	; (800ab48 <stepper_init+0xe8>)
 800ab20:	2301      	movs	r3, #1
 800ab22:	2201      	movs	r2, #1
 800ab24:	2101      	movs	r1, #1
 800ab26:	f000 fe17 	bl	800b758 <TIM_Configuration>
	NVIC_DisableIRQ(TIM3_IRQn);
 800ab2a:	2010      	movs	r0, #16
 800ab2c:	f7ff fba8 	bl	800a280 <NVIC_DisableIRQ>
	NVIC_DisableIRQ(TIM2_IRQn);
 800ab30:	200f      	movs	r0, #15
 800ab32:	f7ff fba5 	bl	800a280 <NVIC_DisableIRQ>
	QueryPerformanceFrequency(&Win32Frequency);

	_beginthread(Timer1Thread, 0, NULL);
	_beginthread(Timer0Thread, 0, NULL);
#endif
}
 800ab36:	46c0      	nop			; (mov r8, r8)
 800ab38:	46bd      	mov	sp, r7
 800ab3a:	b002      	add	sp, #8
 800ab3c:	bd80      	pop	{r7, pc}
 800ab3e:	46c0      	nop			; (mov r8, r8)
 800ab40:	48000800 	.word	0x48000800
 800ab44:	40021000 	.word	0x40021000
 800ab48:	40000400 	.word	0x40000400

0800ab4c <st_update_plan_block_parameters>:


// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{
 800ab4c:	b5b0      	push	{r4, r5, r7, lr}
 800ab4e:	af00      	add	r7, sp, #0
  if (pl_block != NULL) { // Ignore if at start of a new block.
 800ab50:	4b0e      	ldr	r3, [pc, #56]	; (800ab8c <st_update_plan_block_parameters+0x40>)
 800ab52:	681b      	ldr	r3, [r3, #0]
 800ab54:	2b00      	cmp	r3, #0
 800ab56:	d015      	beq.n	800ab84 <st_update_plan_block_parameters+0x38>
    prep.recalculate_flag |= PREP_FLAG_RECALCULATE;
 800ab58:	4b0d      	ldr	r3, [pc, #52]	; (800ab90 <st_update_plan_block_parameters+0x44>)
 800ab5a:	785b      	ldrb	r3, [r3, #1]
 800ab5c:	2201      	movs	r2, #1
 800ab5e:	4313      	orrs	r3, r2
 800ab60:	b2da      	uxtb	r2, r3
 800ab62:	4b0b      	ldr	r3, [pc, #44]	; (800ab90 <st_update_plan_block_parameters+0x44>)
 800ab64:	705a      	strb	r2, [r3, #1]
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
 800ab66:	4b09      	ldr	r3, [pc, #36]	; (800ab8c <st_update_plan_block_parameters+0x40>)
 800ab68:	681c      	ldr	r4, [r3, #0]
 800ab6a:	4b09      	ldr	r3, [pc, #36]	; (800ab90 <st_update_plan_block_parameters+0x44>)
 800ab6c:	69da      	ldr	r2, [r3, #28]
 800ab6e:	4b08      	ldr	r3, [pc, #32]	; (800ab90 <st_update_plan_block_parameters+0x44>)
 800ab70:	69db      	ldr	r3, [r3, #28]
 800ab72:	1c19      	adds	r1, r3, #0
 800ab74:	1c10      	adds	r0, r2, #0
 800ab76:	f7f5 ff8d 	bl	8000a94 <__aeabi_fmul>
 800ab7a:	1c03      	adds	r3, r0, #0
 800ab7c:	61a3      	str	r3, [r4, #24]
    pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
 800ab7e:	4b03      	ldr	r3, [pc, #12]	; (800ab8c <st_update_plan_block_parameters+0x40>)
 800ab80:	2200      	movs	r2, #0
 800ab82:	601a      	str	r2, [r3, #0]
  }
}
 800ab84:	46c0      	nop			; (mov r8, r8)
 800ab86:	46bd      	mov	sp, r7
 800ab88:	bdb0      	pop	{r4, r5, r7, pc}
 800ab8a:	46c0      	nop			; (mov r8, r8)
 800ab8c:	20000584 	.word	0x20000584
 800ab90:	2000058c 	.word	0x2000058c

0800ab94 <st_next_block_index>:


// Increments the step segment buffer block data ring buffer.
static uint8_t st_next_block_index(uint8_t block_index)
{
 800ab94:	b580      	push	{r7, lr}
 800ab96:	b082      	sub	sp, #8
 800ab98:	af00      	add	r7, sp, #0
 800ab9a:	0002      	movs	r2, r0
 800ab9c:	1dfb      	adds	r3, r7, #7
 800ab9e:	701a      	strb	r2, [r3, #0]
  block_index++;
 800aba0:	1dfb      	adds	r3, r7, #7
 800aba2:	781a      	ldrb	r2, [r3, #0]
 800aba4:	1dfb      	adds	r3, r7, #7
 800aba6:	3201      	adds	r2, #1
 800aba8:	701a      	strb	r2, [r3, #0]
  if ( block_index == (SEGMENT_BUFFER_SIZE-1) ) { return(0); }
 800abaa:	1dfb      	adds	r3, r7, #7
 800abac:	781b      	ldrb	r3, [r3, #0]
 800abae:	2b05      	cmp	r3, #5
 800abb0:	d101      	bne.n	800abb6 <st_next_block_index+0x22>
 800abb2:	2300      	movs	r3, #0
 800abb4:	e001      	b.n	800abba <st_next_block_index+0x26>
  return(block_index);
 800abb6:	1dfb      	adds	r3, r7, #7
 800abb8:	781b      	ldrb	r3, [r3, #0]
}
 800abba:	0018      	movs	r0, r3
 800abbc:	46bd      	mov	sp, r7
 800abbe:	b002      	add	sp, #8
 800abc0:	bd80      	pop	{r7, pc}
	...

0800abc4 <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it.
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
 800abc4:	b590      	push	{r4, r7, lr}
 800abc6:	b097      	sub	sp, #92	; 0x5c
 800abc8:	af00      	add	r7, sp, #0
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
 800abca:	4ba5      	ldr	r3, [pc, #660]	; (800ae60 <st_prep_buffer+0x29c>)
 800abcc:	791b      	ldrb	r3, [r3, #4]
 800abce:	001a      	movs	r2, r3
 800abd0:	2301      	movs	r3, #1
 800abd2:	4013      	ands	r3, r2
 800abd4:	d001      	beq.n	800abda <st_prep_buffer+0x16>
 800abd6:	f000 fd90 	bl	800b6fa <st_prep_buffer+0xb36>

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
 800abda:	f000 fd84 	bl	800b6e6 <st_prep_buffer+0xb22>

    // Determine if we need to load a new planner block or if the block needs to be recomputed.
    if (pl_block == NULL) {
 800abde:	4ba1      	ldr	r3, [pc, #644]	; (800ae64 <st_prep_buffer+0x2a0>)
 800abe0:	681b      	ldr	r3, [r3, #0]
 800abe2:	2b00      	cmp	r3, #0
 800abe4:	d000      	beq.n	800abe8 <st_prep_buffer+0x24>
 800abe6:	e261      	b.n	800b0ac <st_prep_buffer+0x4e8>

      // Query planner for a queued block
      if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
 800abe8:	4b9d      	ldr	r3, [pc, #628]	; (800ae60 <st_prep_buffer+0x29c>)
 800abea:	791b      	ldrb	r3, [r3, #4]
 800abec:	001a      	movs	r2, r3
 800abee:	2304      	movs	r3, #4
 800abf0:	4013      	ands	r3, r2
 800abf2:	d005      	beq.n	800ac00 <st_prep_buffer+0x3c>
 800abf4:	f7fc f8f4 	bl	8006de0 <plan_get_system_motion_block>
 800abf8:	0002      	movs	r2, r0
 800abfa:	4b9a      	ldr	r3, [pc, #616]	; (800ae64 <st_prep_buffer+0x2a0>)
 800abfc:	601a      	str	r2, [r3, #0]
 800abfe:	e004      	b.n	800ac0a <st_prep_buffer+0x46>
      else { pl_block = plan_get_current_block(); }
 800ac00:	f7fc f900 	bl	8006e04 <plan_get_current_block>
 800ac04:	0002      	movs	r2, r0
 800ac06:	4b97      	ldr	r3, [pc, #604]	; (800ae64 <st_prep_buffer+0x2a0>)
 800ac08:	601a      	str	r2, [r3, #0]
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
 800ac0a:	4b96      	ldr	r3, [pc, #600]	; (800ae64 <st_prep_buffer+0x2a0>)
 800ac0c:	681b      	ldr	r3, [r3, #0]
 800ac0e:	2b00      	cmp	r3, #0
 800ac10:	d101      	bne.n	800ac16 <st_prep_buffer+0x52>
 800ac12:	f000 fd74 	bl	800b6fe <st_prep_buffer+0xb3a>

      // Check if we need to only recompute the velocity profile or load a new block.
      if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
 800ac16:	4b94      	ldr	r3, [pc, #592]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ac18:	785b      	ldrb	r3, [r3, #1]
 800ac1a:	001a      	movs	r2, r3
 800ac1c:	2301      	movs	r3, #1
 800ac1e:	4013      	ands	r3, r2
 800ac20:	d003      	beq.n	800ac2a <st_prep_buffer+0x66>

        #ifdef PARKING_ENABLE
          if (prep.recalculate_flag & PREP_FLAG_PARKING) { prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE); }
          else { prep.recalculate_flag = false; }
        #else
          prep.recalculate_flag = false;
 800ac22:	4b91      	ldr	r3, [pc, #580]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ac24:	2200      	movs	r2, #0
 800ac26:	705a      	strb	r2, [r3, #1]
 800ac28:	e0b2      	b.n	800ad90 <st_prep_buffer+0x1cc>
        #endif

      } else {

        // Load the Bresenham stepping data for the block.
        prep.st_block_index = st_next_block_index(prep.st_block_index);
 800ac2a:	4b8f      	ldr	r3, [pc, #572]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ac2c:	781b      	ldrb	r3, [r3, #0]
 800ac2e:	0018      	movs	r0, r3
 800ac30:	f7ff ffb0 	bl	800ab94 <st_next_block_index>
 800ac34:	0003      	movs	r3, r0
 800ac36:	001a      	movs	r2, r3
 800ac38:	4b8b      	ldr	r3, [pc, #556]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ac3a:	701a      	strb	r2, [r3, #0]

        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it.
        st_prep_block = &st_block_buffer[prep.st_block_index];
 800ac3c:	4b8a      	ldr	r3, [pc, #552]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ac3e:	781b      	ldrb	r3, [r3, #0]
 800ac40:	001a      	movs	r2, r3
 800ac42:	0013      	movs	r3, r2
 800ac44:	005b      	lsls	r3, r3, #1
 800ac46:	189b      	adds	r3, r3, r2
 800ac48:	00db      	lsls	r3, r3, #3
 800ac4a:	4a88      	ldr	r2, [pc, #544]	; (800ae6c <st_prep_buffer+0x2a8>)
 800ac4c:	189a      	adds	r2, r3, r2
 800ac4e:	4b88      	ldr	r3, [pc, #544]	; (800ae70 <st_prep_buffer+0x2ac>)
 800ac50:	601a      	str	r2, [r3, #0]
        st_prep_block->direction_bits = pl_block->direction_bits;
 800ac52:	4b87      	ldr	r3, [pc, #540]	; (800ae70 <st_prep_buffer+0x2ac>)
 800ac54:	681a      	ldr	r2, [r3, #0]
 800ac56:	4b83      	ldr	r3, [pc, #524]	; (800ae64 <st_prep_buffer+0x2a0>)
 800ac58:	681b      	ldr	r3, [r3, #0]
 800ac5a:	7d1b      	ldrb	r3, [r3, #20]
 800ac5c:	7513      	strb	r3, [r2, #20]
          st_prep_block->step_event_count = (pl_block->step_event_count << 1);
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL; }
 800ac5e:	2357      	movs	r3, #87	; 0x57
 800ac60:	18fb      	adds	r3, r7, r3
 800ac62:	2200      	movs	r2, #0
 800ac64:	701a      	strb	r2, [r3, #0]
 800ac66:	e015      	b.n	800ac94 <st_prep_buffer+0xd0>
 800ac68:	4b81      	ldr	r3, [pc, #516]	; (800ae70 <st_prep_buffer+0x2ac>)
 800ac6a:	681a      	ldr	r2, [r3, #0]
 800ac6c:	2357      	movs	r3, #87	; 0x57
 800ac6e:	18fb      	adds	r3, r7, r3
 800ac70:	7818      	ldrb	r0, [r3, #0]
 800ac72:	4b7c      	ldr	r3, [pc, #496]	; (800ae64 <st_prep_buffer+0x2a0>)
 800ac74:	681b      	ldr	r3, [r3, #0]
 800ac76:	2157      	movs	r1, #87	; 0x57
 800ac78:	1879      	adds	r1, r7, r1
 800ac7a:	7809      	ldrb	r1, [r1, #0]
 800ac7c:	0089      	lsls	r1, r1, #2
 800ac7e:	58cb      	ldr	r3, [r1, r3]
 800ac80:	00d9      	lsls	r1, r3, #3
 800ac82:	0083      	lsls	r3, r0, #2
 800ac84:	5099      	str	r1, [r3, r2]
 800ac86:	2357      	movs	r3, #87	; 0x57
 800ac88:	18fb      	adds	r3, r7, r3
 800ac8a:	781a      	ldrb	r2, [r3, #0]
 800ac8c:	2357      	movs	r3, #87	; 0x57
 800ac8e:	18fb      	adds	r3, r7, r3
 800ac90:	3201      	adds	r2, #1
 800ac92:	701a      	strb	r2, [r3, #0]
 800ac94:	2357      	movs	r3, #87	; 0x57
 800ac96:	18fb      	adds	r3, r7, r3
 800ac98:	781b      	ldrb	r3, [r3, #0]
 800ac9a:	2b03      	cmp	r3, #3
 800ac9c:	d9e4      	bls.n	800ac68 <st_prep_buffer+0xa4>
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
 800ac9e:	4b74      	ldr	r3, [pc, #464]	; (800ae70 <st_prep_buffer+0x2ac>)
 800aca0:	681b      	ldr	r3, [r3, #0]
 800aca2:	4a70      	ldr	r2, [pc, #448]	; (800ae64 <st_prep_buffer+0x2a0>)
 800aca4:	6812      	ldr	r2, [r2, #0]
 800aca6:	6912      	ldr	r2, [r2, #16]
 800aca8:	00d2      	lsls	r2, r2, #3
 800acaa:	611a      	str	r2, [r3, #16]
        #endif

        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = (float)pl_block->step_event_count;
 800acac:	4b6d      	ldr	r3, [pc, #436]	; (800ae64 <st_prep_buffer+0x2a0>)
 800acae:	681b      	ldr	r3, [r3, #0]
 800acb0:	691b      	ldr	r3, [r3, #16]
 800acb2:	0018      	movs	r0, r3
 800acb4:	f7f6 fa32 	bl	800111c <__aeabi_ui2f>
 800acb8:	1c02      	adds	r2, r0, #0
 800acba:	4b6b      	ldr	r3, [pc, #428]	; (800ae68 <st_prep_buffer+0x2a4>)
 800acbc:	609a      	str	r2, [r3, #8]
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
 800acbe:	4b6a      	ldr	r3, [pc, #424]	; (800ae68 <st_prep_buffer+0x2a4>)
 800acc0:	689a      	ldr	r2, [r3, #8]
 800acc2:	4b68      	ldr	r3, [pc, #416]	; (800ae64 <st_prep_buffer+0x2a0>)
 800acc4:	681b      	ldr	r3, [r3, #0]
 800acc6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800acc8:	1c19      	adds	r1, r3, #0
 800acca:	1c10      	adds	r0, r2, #0
 800accc:	f7f5 fcf2 	bl	80006b4 <__aeabi_fdiv>
 800acd0:	1c03      	adds	r3, r0, #0
 800acd2:	1c1a      	adds	r2, r3, #0
 800acd4:	4b64      	ldr	r3, [pc, #400]	; (800ae68 <st_prep_buffer+0x2a4>)
 800acd6:	60da      	str	r2, [r3, #12]
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
 800acd8:	4b63      	ldr	r3, [pc, #396]	; (800ae68 <st_prep_buffer+0x2a4>)
 800acda:	68db      	ldr	r3, [r3, #12]
 800acdc:	1c19      	adds	r1, r3, #0
 800acde:	4865      	ldr	r0, [pc, #404]	; (800ae74 <st_prep_buffer+0x2b0>)
 800ace0:	f7f5 fce8 	bl	80006b4 <__aeabi_fdiv>
 800ace4:	1c03      	adds	r3, r0, #0
 800ace6:	1c1a      	adds	r2, r3, #0
 800ace8:	4b5f      	ldr	r3, [pc, #380]	; (800ae68 <st_prep_buffer+0x2a4>)
 800acea:	611a      	str	r2, [r3, #16]
        prep.dt_remainder = 0.0f; // Reset for new segment block
 800acec:	4b5e      	ldr	r3, [pc, #376]	; (800ae68 <st_prep_buffer+0x2a4>)
 800acee:	2200      	movs	r2, #0
 800acf0:	605a      	str	r2, [r3, #4]

        if ((sys.step_control & STEP_CONTROL_EXECUTE_HOLD) || (prep.recalculate_flag & PREP_FLAG_DECEL_OVERRIDE)) {
 800acf2:	4b5b      	ldr	r3, [pc, #364]	; (800ae60 <st_prep_buffer+0x29c>)
 800acf4:	791b      	ldrb	r3, [r3, #4]
 800acf6:	001a      	movs	r2, r3
 800acf8:	2302      	movs	r3, #2
 800acfa:	4013      	ands	r3, r2
 800acfc:	d105      	bne.n	800ad0a <st_prep_buffer+0x146>
 800acfe:	4b5a      	ldr	r3, [pc, #360]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ad00:	785b      	ldrb	r3, [r3, #1]
 800ad02:	001a      	movs	r2, r3
 800ad04:	2308      	movs	r3, #8
 800ad06:	4013      	ands	r3, r2
 800ad08:	d017      	beq.n	800ad3a <st_prep_buffer+0x176>
          // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
          prep.current_speed = prep.exit_speed;
 800ad0a:	4b57      	ldr	r3, [pc, #348]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ad0c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ad0e:	4b56      	ldr	r3, [pc, #344]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ad10:	61da      	str	r2, [r3, #28]
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed;
 800ad12:	4b54      	ldr	r3, [pc, #336]	; (800ae64 <st_prep_buffer+0x2a0>)
 800ad14:	681c      	ldr	r4, [r3, #0]
 800ad16:	4b54      	ldr	r3, [pc, #336]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ad18:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ad1a:	4b53      	ldr	r3, [pc, #332]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ad1c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ad1e:	1c19      	adds	r1, r3, #0
 800ad20:	1c10      	adds	r0, r2, #0
 800ad22:	f7f5 feb7 	bl	8000a94 <__aeabi_fmul>
 800ad26:	1c03      	adds	r3, r0, #0
 800ad28:	61a3      	str	r3, [r4, #24]
          prep.recalculate_flag &= ~(PREP_FLAG_DECEL_OVERRIDE);
 800ad2a:	4b4f      	ldr	r3, [pc, #316]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ad2c:	785b      	ldrb	r3, [r3, #1]
 800ad2e:	2208      	movs	r2, #8
 800ad30:	4393      	bics	r3, r2
 800ad32:	b2da      	uxtb	r2, r3
 800ad34:	4b4c      	ldr	r3, [pc, #304]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ad36:	705a      	strb	r2, [r3, #1]
 800ad38:	e008      	b.n	800ad4c <st_prep_buffer+0x188>
        } else {
          prep.current_speed = sqrtf(pl_block->entry_speed_sqr);
 800ad3a:	4b4a      	ldr	r3, [pc, #296]	; (800ae64 <st_prep_buffer+0x2a0>)
 800ad3c:	681b      	ldr	r3, [r3, #0]
 800ad3e:	699b      	ldr	r3, [r3, #24]
 800ad40:	1c18      	adds	r0, r3, #0
 800ad42:	f001 fe77 	bl	800ca34 <sqrtf>
 800ad46:	1c02      	adds	r2, r0, #0
 800ad48:	4b47      	ldr	r3, [pc, #284]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ad4a:	61da      	str	r2, [r3, #28]
        }
#ifdef VARIABLE_SPINDLE
        // Setup laser mode variables. PWM rate adjusted motions will always complete a motion with the
        // spindle off. 
        st_prep_block->is_pwm_rate_adjusted = false;
 800ad4c:	4b48      	ldr	r3, [pc, #288]	; (800ae70 <st_prep_buffer+0x2ac>)
 800ad4e:	681b      	ldr	r3, [r3, #0]
 800ad50:	2200      	movs	r2, #0
 800ad52:	755a      	strb	r2, [r3, #21]
        if (settings.flags & BITFLAG_LASER_MODE) {
 800ad54:	4b48      	ldr	r3, [pc, #288]	; (800ae78 <st_prep_buffer+0x2b4>)
 800ad56:	2258      	movs	r2, #88	; 0x58
 800ad58:	5c9b      	ldrb	r3, [r3, r2]
 800ad5a:	001a      	movs	r2, r3
 800ad5c:	2302      	movs	r3, #2
 800ad5e:	4013      	ands	r3, r2
 800ad60:	d016      	beq.n	800ad90 <st_prep_buffer+0x1cc>
          if (pl_block->condition & PL_COND_FLAG_SPINDLE_CCW) {
 800ad62:	4b40      	ldr	r3, [pc, #256]	; (800ae64 <st_prep_buffer+0x2a0>)
 800ad64:	681b      	ldr	r3, [r3, #0]
 800ad66:	7d5b      	ldrb	r3, [r3, #21]
 800ad68:	001a      	movs	r2, r3
 800ad6a:	2320      	movs	r3, #32
 800ad6c:	4013      	ands	r3, r2
 800ad6e:	d00f      	beq.n	800ad90 <st_prep_buffer+0x1cc>
            // Pre-compute inverse programmed rate to speed up PWM updating per step segment.
            prep.inv_rate = 1.0 / pl_block->programmed_rate;
 800ad70:	4b3c      	ldr	r3, [pc, #240]	; (800ae64 <st_prep_buffer+0x2a0>)
 800ad72:	681b      	ldr	r3, [r3, #0]
 800ad74:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ad76:	1c19      	adds	r1, r3, #0
 800ad78:	20fe      	movs	r0, #254	; 0xfe
 800ad7a:	0580      	lsls	r0, r0, #22
 800ad7c:	f7f5 fc9a 	bl	80006b4 <__aeabi_fdiv>
 800ad80:	1c03      	adds	r3, r0, #0
 800ad82:	1c1a      	adds	r2, r3, #0
 800ad84:	4b38      	ldr	r3, [pc, #224]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ad86:	631a      	str	r2, [r3, #48]	; 0x30
            st_prep_block->is_pwm_rate_adjusted = true;
 800ad88:	4b39      	ldr	r3, [pc, #228]	; (800ae70 <st_prep_buffer+0x2ac>)
 800ad8a:	681b      	ldr	r3, [r3, #0]
 800ad8c:	2201      	movs	r2, #1
 800ad8e:	755a      	strb	r2, [r3, #21]
			 Compute the velocity profile of a new planner block based on its entry and exit
			 speeds, or recompute the profile of a partially-completed planner block if the
			 planner has updated it. For a commanded forced-deceleration, such as from a feed
			 hold, override the planner velocities and decelerate to the target exit speed.
			*/
			prep.mm_complete = 0.0f; // Default velocity profile complete at 0.0mm from end of block.
 800ad90:	4b35      	ldr	r3, [pc, #212]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ad92:	2200      	movs	r2, #0
 800ad94:	619a      	str	r2, [r3, #24]
			float inv_2_accel = 0.5f/pl_block->acceleration;
 800ad96:	4b33      	ldr	r3, [pc, #204]	; (800ae64 <st_prep_buffer+0x2a0>)
 800ad98:	681b      	ldr	r3, [r3, #0]
 800ad9a:	6a1b      	ldr	r3, [r3, #32]
 800ad9c:	1c19      	adds	r1, r3, #0
 800ad9e:	20fc      	movs	r0, #252	; 0xfc
 800ada0:	0580      	lsls	r0, r0, #22
 800ada2:	f7f5 fc87 	bl	80006b4 <__aeabi_fdiv>
 800ada6:	1c03      	adds	r3, r0, #0
 800ada8:	617b      	str	r3, [r7, #20]
			if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { // [Forced Deceleration to Zero Velocity]
 800adaa:	4b2d      	ldr	r3, [pc, #180]	; (800ae60 <st_prep_buffer+0x29c>)
 800adac:	791b      	ldrb	r3, [r3, #4]
 800adae:	001a      	movs	r2, r3
 800adb0:	2302      	movs	r3, #2
 800adb2:	4013      	ands	r3, r2
 800adb4:	d040      	beq.n	800ae38 <st_prep_buffer+0x274>
				// Compute velocity profile parameters for a feed hold in-progress. This profile overrides
				// the planner block profile, enforcing a deceleration to zero speed.
				prep.ramp_type = RAMP_DECEL;
 800adb6:	4b2c      	ldr	r3, [pc, #176]	; (800ae68 <st_prep_buffer+0x2a4>)
 800adb8:	2202      	movs	r2, #2
 800adba:	751a      	strb	r2, [r3, #20]
				// Compute decelerate distance relative to end of block.
				float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
 800adbc:	4b29      	ldr	r3, [pc, #164]	; (800ae64 <st_prep_buffer+0x2a0>)
 800adbe:	681b      	ldr	r3, [r3, #0]
 800adc0:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 800adc2:	4b28      	ldr	r3, [pc, #160]	; (800ae64 <st_prep_buffer+0x2a0>)
 800adc4:	681b      	ldr	r3, [r3, #0]
 800adc6:	699b      	ldr	r3, [r3, #24]
 800adc8:	6979      	ldr	r1, [r7, #20]
 800adca:	1c18      	adds	r0, r3, #0
 800adcc:	f7f5 fe62 	bl	8000a94 <__aeabi_fmul>
 800add0:	1c03      	adds	r3, r0, #0
 800add2:	1c19      	adds	r1, r3, #0
 800add4:	1c20      	adds	r0, r4, #0
 800add6:	f7f5 ff7d 	bl	8000cd4 <__aeabi_fsub>
 800adda:	1c03      	adds	r3, r0, #0
 800addc:	613b      	str	r3, [r7, #16]
				if (decel_dist < 0.0f) {
 800adde:	2100      	movs	r1, #0
 800ade0:	6938      	ldr	r0, [r7, #16]
 800ade2:	f7f5 fa77 	bl	80002d4 <__aeabi_fcmplt>
 800ade6:	1e03      	subs	r3, r0, #0
 800ade8:	d01f      	beq.n	800ae2a <st_prep_buffer+0x266>
					// Deceleration through entire planner block. End of feed hold is not in this block.
					prep.exit_speed = sqrtf(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
 800adea:	4b1e      	ldr	r3, [pc, #120]	; (800ae64 <st_prep_buffer+0x2a0>)
 800adec:	681b      	ldr	r3, [r3, #0]
 800adee:	699c      	ldr	r4, [r3, #24]
 800adf0:	4b1c      	ldr	r3, [pc, #112]	; (800ae64 <st_prep_buffer+0x2a0>)
 800adf2:	681b      	ldr	r3, [r3, #0]
 800adf4:	6a1b      	ldr	r3, [r3, #32]
 800adf6:	1c19      	adds	r1, r3, #0
 800adf8:	1c18      	adds	r0, r3, #0
 800adfa:	f7f5 fac9 	bl	8000390 <__aeabi_fadd>
 800adfe:	1c03      	adds	r3, r0, #0
 800ae00:	1c1a      	adds	r2, r3, #0
 800ae02:	4b18      	ldr	r3, [pc, #96]	; (800ae64 <st_prep_buffer+0x2a0>)
 800ae04:	681b      	ldr	r3, [r3, #0]
 800ae06:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ae08:	1c19      	adds	r1, r3, #0
 800ae0a:	1c10      	adds	r0, r2, #0
 800ae0c:	f7f5 fe42 	bl	8000a94 <__aeabi_fmul>
 800ae10:	1c03      	adds	r3, r0, #0
 800ae12:	1c19      	adds	r1, r3, #0
 800ae14:	1c20      	adds	r0, r4, #0
 800ae16:	f7f5 ff5d 	bl	8000cd4 <__aeabi_fsub>
 800ae1a:	1c03      	adds	r3, r0, #0
 800ae1c:	1c18      	adds	r0, r3, #0
 800ae1e:	f001 fe09 	bl	800ca34 <sqrtf>
 800ae22:	1c02      	adds	r2, r0, #0
 800ae24:	4b10      	ldr	r3, [pc, #64]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ae26:	625a      	str	r2, [r3, #36]	; 0x24
 800ae28:	e139      	b.n	800b09e <st_prep_buffer+0x4da>
				} else {
					prep.mm_complete = decel_dist; // End of feed hold.
 800ae2a:	4b0f      	ldr	r3, [pc, #60]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ae2c:	693a      	ldr	r2, [r7, #16]
 800ae2e:	619a      	str	r2, [r3, #24]
					prep.exit_speed = 0.0f;
 800ae30:	4b0d      	ldr	r3, [pc, #52]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ae32:	2200      	movs	r2, #0
 800ae34:	625a      	str	r2, [r3, #36]	; 0x24
 800ae36:	e132      	b.n	800b09e <st_prep_buffer+0x4da>
				}
			} else { // [Normal Operation]
				// Compute or recompute velocity profile parameters of the prepped planner block.
				prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
 800ae38:	4b0b      	ldr	r3, [pc, #44]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ae3a:	2200      	movs	r2, #0
 800ae3c:	751a      	strb	r2, [r3, #20]
				prep.accelerate_until = pl_block->millimeters;
 800ae3e:	4b09      	ldr	r3, [pc, #36]	; (800ae64 <st_prep_buffer+0x2a0>)
 800ae40:	681b      	ldr	r3, [r3, #0]
 800ae42:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ae44:	4b08      	ldr	r3, [pc, #32]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ae46:	629a      	str	r2, [r3, #40]	; 0x28

				float exit_speed_sqr;
				float nominal_speed;
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
 800ae48:	4b05      	ldr	r3, [pc, #20]	; (800ae60 <st_prep_buffer+0x29c>)
 800ae4a:	791b      	ldrb	r3, [r3, #4]
 800ae4c:	001a      	movs	r2, r3
 800ae4e:	2304      	movs	r3, #4
 800ae50:	4013      	ands	r3, r2
 800ae52:	d013      	beq.n	800ae7c <st_prep_buffer+0x2b8>
          prep.exit_speed = exit_speed_sqr = 0.0f; // Enforce stop at end of system motion.
 800ae54:	2300      	movs	r3, #0
 800ae56:	653b      	str	r3, [r7, #80]	; 0x50
 800ae58:	4b03      	ldr	r3, [pc, #12]	; (800ae68 <st_prep_buffer+0x2a4>)
 800ae5a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800ae5c:	625a      	str	r2, [r3, #36]	; 0x24
 800ae5e:	e018      	b.n	800ae92 <st_prep_buffer+0x2ce>
 800ae60:	20000bb4 	.word	0x20000bb4
 800ae64:	20000584 	.word	0x20000584
 800ae68:	2000058c 	.word	0x2000058c
 800ae6c:	2000049c 	.word	0x2000049c
 800ae70:	20000588 	.word	0x20000588
 800ae74:	3fa00000 	.word	0x3fa00000
 800ae78:	20000b44 	.word	0x20000b44
        } else {
          exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
 800ae7c:	f7fb ffde 	bl	8006e3c <plan_get_exec_block_exit_speed_sqr>
 800ae80:	1c03      	adds	r3, r0, #0
 800ae82:	653b      	str	r3, [r7, #80]	; 0x50
          prep.exit_speed = sqrtf(exit_speed_sqr);
 800ae84:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ae86:	1c18      	adds	r0, r3, #0
 800ae88:	f001 fdd4 	bl	800ca34 <sqrtf>
 800ae8c:	1c02      	adds	r2, r0, #0
 800ae8e:	4bd0      	ldr	r3, [pc, #832]	; (800b1d0 <st_prep_buffer+0x60c>)
 800ae90:	625a      	str	r2, [r3, #36]	; 0x24
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
 800ae92:	4bd0      	ldr	r3, [pc, #832]	; (800b1d4 <st_prep_buffer+0x610>)
 800ae94:	681b      	ldr	r3, [r3, #0]
 800ae96:	0018      	movs	r0, r3
 800ae98:	f7fc f80a 	bl	8006eb0 <plan_compute_profile_nominal_speed>
 800ae9c:	1c03      	adds	r3, r0, #0
 800ae9e:	60fb      	str	r3, [r7, #12]
				float nominal_speed_sqr = nominal_speed*nominal_speed;
 800aea0:	68f9      	ldr	r1, [r7, #12]
 800aea2:	68f8      	ldr	r0, [r7, #12]
 800aea4:	f7f5 fdf6 	bl	8000a94 <__aeabi_fmul>
 800aea8:	1c03      	adds	r3, r0, #0
 800aeaa:	60bb      	str	r3, [r7, #8]
				float intersect_distance =
								0.5f*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
 800aeac:	4bc9      	ldr	r3, [pc, #804]	; (800b1d4 <st_prep_buffer+0x610>)
 800aeae:	681b      	ldr	r3, [r3, #0]
 800aeb0:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 800aeb2:	4bc8      	ldr	r3, [pc, #800]	; (800b1d4 <st_prep_buffer+0x610>)
 800aeb4:	681b      	ldr	r3, [r3, #0]
 800aeb6:	699b      	ldr	r3, [r3, #24]
 800aeb8:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800aeba:	1c18      	adds	r0, r3, #0
 800aebc:	f7f5 ff0a 	bl	8000cd4 <__aeabi_fsub>
 800aec0:	1c03      	adds	r3, r0, #0
 800aec2:	6979      	ldr	r1, [r7, #20]
 800aec4:	1c18      	adds	r0, r3, #0
 800aec6:	f7f5 fde5 	bl	8000a94 <__aeabi_fmul>
 800aeca:	1c03      	adds	r3, r0, #0
 800aecc:	1c19      	adds	r1, r3, #0
 800aece:	1c20      	adds	r0, r4, #0
 800aed0:	f7f5 fa5e 	bl	8000390 <__aeabi_fadd>
 800aed4:	1c03      	adds	r3, r0, #0
				float intersect_distance =
 800aed6:	21fc      	movs	r1, #252	; 0xfc
 800aed8:	0589      	lsls	r1, r1, #22
 800aeda:	1c18      	adds	r0, r3, #0
 800aedc:	f7f5 fdda 	bl	8000a94 <__aeabi_fmul>
 800aee0:	1c03      	adds	r3, r0, #0
 800aee2:	607b      	str	r3, [r7, #4]

        if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
 800aee4:	4bbb      	ldr	r3, [pc, #748]	; (800b1d4 <st_prep_buffer+0x610>)
 800aee6:	681b      	ldr	r3, [r3, #0]
 800aee8:	699b      	ldr	r3, [r3, #24]
 800aeea:	68b9      	ldr	r1, [r7, #8]
 800aeec:	1c18      	adds	r0, r3, #0
 800aeee:	f7f5 fa05 	bl	80002fc <__aeabi_fcmpgt>
 800aef2:	1e03      	subs	r3, r0, #0
 800aef4:	d05d      	beq.n	800afb2 <st_prep_buffer+0x3ee>
          prep.accelerate_until = pl_block->millimeters - inv_2_accel*(pl_block->entry_speed_sqr-nominal_speed_sqr);
 800aef6:	4bb7      	ldr	r3, [pc, #732]	; (800b1d4 <st_prep_buffer+0x610>)
 800aef8:	681b      	ldr	r3, [r3, #0]
 800aefa:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 800aefc:	4bb5      	ldr	r3, [pc, #724]	; (800b1d4 <st_prep_buffer+0x610>)
 800aefe:	681b      	ldr	r3, [r3, #0]
 800af00:	699b      	ldr	r3, [r3, #24]
 800af02:	68b9      	ldr	r1, [r7, #8]
 800af04:	1c18      	adds	r0, r3, #0
 800af06:	f7f5 fee5 	bl	8000cd4 <__aeabi_fsub>
 800af0a:	1c03      	adds	r3, r0, #0
 800af0c:	6979      	ldr	r1, [r7, #20]
 800af0e:	1c18      	adds	r0, r3, #0
 800af10:	f7f5 fdc0 	bl	8000a94 <__aeabi_fmul>
 800af14:	1c03      	adds	r3, r0, #0
 800af16:	1c19      	adds	r1, r3, #0
 800af18:	1c20      	adds	r0, r4, #0
 800af1a:	f7f5 fedb 	bl	8000cd4 <__aeabi_fsub>
 800af1e:	1c03      	adds	r3, r0, #0
 800af20:	1c1a      	adds	r2, r3, #0
 800af22:	4bab      	ldr	r3, [pc, #684]	; (800b1d0 <st_prep_buffer+0x60c>)
 800af24:	629a      	str	r2, [r3, #40]	; 0x28
          if (prep.accelerate_until <= 0.0f) { // Deceleration-only.
 800af26:	4baa      	ldr	r3, [pc, #680]	; (800b1d0 <st_prep_buffer+0x60c>)
 800af28:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800af2a:	2100      	movs	r1, #0
 800af2c:	1c18      	adds	r0, r3, #0
 800af2e:	f7f5 f9db 	bl	80002e8 <__aeabi_fcmple>
 800af32:	1e03      	subs	r3, r0, #0
 800af34:	d029      	beq.n	800af8a <st_prep_buffer+0x3c6>
            prep.ramp_type = RAMP_DECEL;
 800af36:	4ba6      	ldr	r3, [pc, #664]	; (800b1d0 <st_prep_buffer+0x60c>)
 800af38:	2202      	movs	r2, #2
 800af3a:	751a      	strb	r2, [r3, #20]
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;

            // Compute override block exit speed since it doesn't match the planner exit speed.
            prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2*pl_block->acceleration*pl_block->millimeters);
 800af3c:	4ba5      	ldr	r3, [pc, #660]	; (800b1d4 <st_prep_buffer+0x610>)
 800af3e:	681b      	ldr	r3, [r3, #0]
 800af40:	699c      	ldr	r4, [r3, #24]
 800af42:	4ba4      	ldr	r3, [pc, #656]	; (800b1d4 <st_prep_buffer+0x610>)
 800af44:	681b      	ldr	r3, [r3, #0]
 800af46:	6a1b      	ldr	r3, [r3, #32]
 800af48:	1c19      	adds	r1, r3, #0
 800af4a:	1c18      	adds	r0, r3, #0
 800af4c:	f7f5 fa20 	bl	8000390 <__aeabi_fadd>
 800af50:	1c03      	adds	r3, r0, #0
 800af52:	1c1a      	adds	r2, r3, #0
 800af54:	4b9f      	ldr	r3, [pc, #636]	; (800b1d4 <st_prep_buffer+0x610>)
 800af56:	681b      	ldr	r3, [r3, #0]
 800af58:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800af5a:	1c19      	adds	r1, r3, #0
 800af5c:	1c10      	adds	r0, r2, #0
 800af5e:	f7f5 fd99 	bl	8000a94 <__aeabi_fmul>
 800af62:	1c03      	adds	r3, r0, #0
 800af64:	1c19      	adds	r1, r3, #0
 800af66:	1c20      	adds	r0, r4, #0
 800af68:	f7f5 feb4 	bl	8000cd4 <__aeabi_fsub>
 800af6c:	1c03      	adds	r3, r0, #0
 800af6e:	1c18      	adds	r0, r3, #0
 800af70:	f001 fd60 	bl	800ca34 <sqrtf>
 800af74:	1c02      	adds	r2, r0, #0
 800af76:	4b96      	ldr	r3, [pc, #600]	; (800b1d0 <st_prep_buffer+0x60c>)
 800af78:	625a      	str	r2, [r3, #36]	; 0x24
            prep.recalculate_flag |= PREP_FLAG_DECEL_OVERRIDE; // Flag to load next block as deceleration override.
 800af7a:	4b95      	ldr	r3, [pc, #596]	; (800b1d0 <st_prep_buffer+0x60c>)
 800af7c:	785b      	ldrb	r3, [r3, #1]
 800af7e:	2208      	movs	r2, #8
 800af80:	4313      	orrs	r3, r2
 800af82:	b2da      	uxtb	r2, r3
 800af84:	4b92      	ldr	r3, [pc, #584]	; (800b1d0 <st_prep_buffer+0x60c>)
 800af86:	705a      	strb	r2, [r3, #1]
 800af88:	e089      	b.n	800b09e <st_prep_buffer+0x4da>
            // Can be tricky since entry speed will be current speed, as in feed holds.
            // Also, look into near-zero speed handling issues with this.

          } else {
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
 800af8a:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800af8c:	68b8      	ldr	r0, [r7, #8]
 800af8e:	f7f5 fea1 	bl	8000cd4 <__aeabi_fsub>
 800af92:	1c03      	adds	r3, r0, #0
 800af94:	6979      	ldr	r1, [r7, #20]
 800af96:	1c18      	adds	r0, r3, #0
 800af98:	f7f5 fd7c 	bl	8000a94 <__aeabi_fmul>
 800af9c:	1c03      	adds	r3, r0, #0
 800af9e:	1c1a      	adds	r2, r3, #0
 800afa0:	4b8b      	ldr	r3, [pc, #556]	; (800b1d0 <st_prep_buffer+0x60c>)
 800afa2:	62da      	str	r2, [r3, #44]	; 0x2c
            prep.maximum_speed = nominal_speed;
 800afa4:	4b8a      	ldr	r3, [pc, #552]	; (800b1d0 <st_prep_buffer+0x60c>)
 800afa6:	68fa      	ldr	r2, [r7, #12]
 800afa8:	621a      	str	r2, [r3, #32]
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
 800afaa:	4b89      	ldr	r3, [pc, #548]	; (800b1d0 <st_prep_buffer+0x60c>)
 800afac:	2203      	movs	r2, #3
 800afae:	751a      	strb	r2, [r3, #20]
 800afb0:	e075      	b.n	800b09e <st_prep_buffer+0x4da>
          }
				} else if (intersect_distance > 0.0f) {
 800afb2:	2100      	movs	r1, #0
 800afb4:	6878      	ldr	r0, [r7, #4]
 800afb6:	f7f5 f9a1 	bl	80002fc <__aeabi_fcmpgt>
 800afba:	1e03      	subs	r3, r0, #0
 800afbc:	d068      	beq.n	800b090 <st_prep_buffer+0x4cc>
					if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
 800afbe:	4b85      	ldr	r3, [pc, #532]	; (800b1d4 <st_prep_buffer+0x610>)
 800afc0:	681b      	ldr	r3, [r3, #0]
 800afc2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800afc4:	6879      	ldr	r1, [r7, #4]
 800afc6:	1c18      	adds	r0, r3, #0
 800afc8:	f7f5 f998 	bl	80002fc <__aeabi_fcmpgt>
 800afcc:	1e03      	subs	r3, r0, #0
 800afce:	d05b      	beq.n	800b088 <st_prep_buffer+0x4c4>
						// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
						prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
 800afd0:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800afd2:	68b8      	ldr	r0, [r7, #8]
 800afd4:	f7f5 fe7e 	bl	8000cd4 <__aeabi_fsub>
 800afd8:	1c03      	adds	r3, r0, #0
 800afda:	6979      	ldr	r1, [r7, #20]
 800afdc:	1c18      	adds	r0, r3, #0
 800afde:	f7f5 fd59 	bl	8000a94 <__aeabi_fmul>
 800afe2:	1c03      	adds	r3, r0, #0
 800afe4:	1c1a      	adds	r2, r3, #0
 800afe6:	4b7a      	ldr	r3, [pc, #488]	; (800b1d0 <st_prep_buffer+0x60c>)
 800afe8:	62da      	str	r2, [r3, #44]	; 0x2c
						if (prep.decelerate_after < intersect_distance) { // Trapezoid type
 800afea:	4b79      	ldr	r3, [pc, #484]	; (800b1d0 <st_prep_buffer+0x60c>)
 800afec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800afee:	6879      	ldr	r1, [r7, #4]
 800aff0:	1c18      	adds	r0, r3, #0
 800aff2:	f7f5 f96f 	bl	80002d4 <__aeabi_fcmplt>
 800aff6:	1e03      	subs	r3, r0, #0
 800aff8:	d027      	beq.n	800b04a <st_prep_buffer+0x486>
							prep.maximum_speed = nominal_speed;
 800affa:	4b75      	ldr	r3, [pc, #468]	; (800b1d0 <st_prep_buffer+0x60c>)
 800affc:	68fa      	ldr	r2, [r7, #12]
 800affe:	621a      	str	r2, [r3, #32]
							if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
 800b000:	4b74      	ldr	r3, [pc, #464]	; (800b1d4 <st_prep_buffer+0x610>)
 800b002:	681b      	ldr	r3, [r3, #0]
 800b004:	699b      	ldr	r3, [r3, #24]
 800b006:	68b9      	ldr	r1, [r7, #8]
 800b008:	1c18      	adds	r0, r3, #0
 800b00a:	f7f5 f95d 	bl	80002c8 <__aeabi_fcmpeq>
 800b00e:	1e03      	subs	r3, r0, #0
 800b010:	d003      	beq.n	800b01a <st_prep_buffer+0x456>
								// Cruise-deceleration or cruise-only type.
								prep.ramp_type = RAMP_CRUISE;
 800b012:	4b6f      	ldr	r3, [pc, #444]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b014:	2201      	movs	r2, #1
 800b016:	751a      	strb	r2, [r3, #20]
 800b018:	e041      	b.n	800b09e <st_prep_buffer+0x4da>
							} else {
								// Full-trapezoid or acceleration-cruise types
								prep.accelerate_until -= inv_2_accel*(nominal_speed_sqr-pl_block->entry_speed_sqr);
 800b01a:	4b6d      	ldr	r3, [pc, #436]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b01c:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 800b01e:	4b6d      	ldr	r3, [pc, #436]	; (800b1d4 <st_prep_buffer+0x610>)
 800b020:	681b      	ldr	r3, [r3, #0]
 800b022:	699b      	ldr	r3, [r3, #24]
 800b024:	1c19      	adds	r1, r3, #0
 800b026:	68b8      	ldr	r0, [r7, #8]
 800b028:	f7f5 fe54 	bl	8000cd4 <__aeabi_fsub>
 800b02c:	1c03      	adds	r3, r0, #0
 800b02e:	6979      	ldr	r1, [r7, #20]
 800b030:	1c18      	adds	r0, r3, #0
 800b032:	f7f5 fd2f 	bl	8000a94 <__aeabi_fmul>
 800b036:	1c03      	adds	r3, r0, #0
 800b038:	1c19      	adds	r1, r3, #0
 800b03a:	1c20      	adds	r0, r4, #0
 800b03c:	f7f5 fe4a 	bl	8000cd4 <__aeabi_fsub>
 800b040:	1c03      	adds	r3, r0, #0
 800b042:	1c1a      	adds	r2, r3, #0
 800b044:	4b62      	ldr	r3, [pc, #392]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b046:	629a      	str	r2, [r3, #40]	; 0x28
 800b048:	e029      	b.n	800b09e <st_prep_buffer+0x4da>
							}
						} else { // Triangle type
							prep.accelerate_until = intersect_distance;
 800b04a:	4b61      	ldr	r3, [pc, #388]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b04c:	687a      	ldr	r2, [r7, #4]
 800b04e:	629a      	str	r2, [r3, #40]	; 0x28
							prep.decelerate_after = intersect_distance;
 800b050:	4b5f      	ldr	r3, [pc, #380]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b052:	687a      	ldr	r2, [r7, #4]
 800b054:	62da      	str	r2, [r3, #44]	; 0x2c
							prep.maximum_speed = sqrtf(2.0f*pl_block->acceleration*intersect_distance+exit_speed_sqr);
 800b056:	4b5f      	ldr	r3, [pc, #380]	; (800b1d4 <st_prep_buffer+0x610>)
 800b058:	681b      	ldr	r3, [r3, #0]
 800b05a:	6a1b      	ldr	r3, [r3, #32]
 800b05c:	1c19      	adds	r1, r3, #0
 800b05e:	1c18      	adds	r0, r3, #0
 800b060:	f7f5 f996 	bl	8000390 <__aeabi_fadd>
 800b064:	1c03      	adds	r3, r0, #0
 800b066:	6879      	ldr	r1, [r7, #4]
 800b068:	1c18      	adds	r0, r3, #0
 800b06a:	f7f5 fd13 	bl	8000a94 <__aeabi_fmul>
 800b06e:	1c03      	adds	r3, r0, #0
 800b070:	6d39      	ldr	r1, [r7, #80]	; 0x50
 800b072:	1c18      	adds	r0, r3, #0
 800b074:	f7f5 f98c 	bl	8000390 <__aeabi_fadd>
 800b078:	1c03      	adds	r3, r0, #0
 800b07a:	1c18      	adds	r0, r3, #0
 800b07c:	f001 fcda 	bl	800ca34 <sqrtf>
 800b080:	1c02      	adds	r2, r0, #0
 800b082:	4b53      	ldr	r3, [pc, #332]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b084:	621a      	str	r2, [r3, #32]
 800b086:	e00a      	b.n	800b09e <st_prep_buffer+0x4da>
						}
					} else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
 800b088:	4b51      	ldr	r3, [pc, #324]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b08a:	2202      	movs	r2, #2
 800b08c:	751a      	strb	r2, [r3, #20]
 800b08e:	e006      	b.n	800b09e <st_prep_buffer+0x4da>
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;
					}
				} else { // Acceleration-only type
					prep.accelerate_until = 0.0f;
 800b090:	4b4f      	ldr	r3, [pc, #316]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b092:	2200      	movs	r2, #0
 800b094:	629a      	str	r2, [r3, #40]	; 0x28
					// prep.decelerate_after = 0.0f;
					prep.maximum_speed = prep.exit_speed;
 800b096:	4b4e      	ldr	r3, [pc, #312]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b098:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b09a:	4b4d      	ldr	r3, [pc, #308]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b09c:	621a      	str	r2, [r3, #32]
				}
			}
      
      #ifdef VARIABLE_SPINDLE
        bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); // Force update whenever updating block.
 800b09e:	4b4e      	ldr	r3, [pc, #312]	; (800b1d8 <st_prep_buffer+0x614>)
 800b0a0:	791b      	ldrb	r3, [r3, #4]
 800b0a2:	2208      	movs	r2, #8
 800b0a4:	4313      	orrs	r3, r2
 800b0a6:	b2da      	uxtb	r2, r3
 800b0a8:	4b4b      	ldr	r3, [pc, #300]	; (800b1d8 <st_prep_buffer+0x614>)
 800b0aa:	711a      	strb	r2, [r3, #4]
      #endif
    }
    
    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
 800b0ac:	4b4b      	ldr	r3, [pc, #300]	; (800b1dc <st_prep_buffer+0x618>)
 800b0ae:	781b      	ldrb	r3, [r3, #0]
 800b0b0:	00da      	lsls	r2, r3, #3
 800b0b2:	4b4b      	ldr	r3, [pc, #300]	; (800b1e0 <st_prep_buffer+0x61c>)
 800b0b4:	18d3      	adds	r3, r2, r3
 800b0b6:	633b      	str	r3, [r7, #48]	; 0x30

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
 800b0b8:	4b45      	ldr	r3, [pc, #276]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b0ba:	781a      	ldrb	r2, [r3, #0]
 800b0bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b0be:	711a      	strb	r2, [r3, #4]
      acceleration ramp, cruising state, and deceleration ramp. Each ramp's travel distance
      may range from zero to the length of the block. Velocity profiles can end either at
      the end of planner block (typical) or mid-block at the end of a forced deceleration,
      such as from a feed hold.
    */
    float dt_max = DT_SEGMENT; // Maximum segment time
 800b0c0:	4b48      	ldr	r3, [pc, #288]	; (800b1e4 <st_prep_buffer+0x620>)
 800b0c2:	64fb      	str	r3, [r7, #76]	; 0x4c
    float dt = 0.0f; // Initialize segment time
 800b0c4:	2300      	movs	r3, #0
 800b0c6:	64bb      	str	r3, [r7, #72]	; 0x48
    float time_var = dt_max; // Time worker variable
 800b0c8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b0ca:	647b      	str	r3, [r7, #68]	; 0x44
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
 800b0cc:	4b41      	ldr	r3, [pc, #260]	; (800b1d4 <st_prep_buffer+0x610>)
 800b0ce:	681b      	ldr	r3, [r3, #0]
 800b0d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b0d2:	643b      	str	r3, [r7, #64]	; 0x40
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
 800b0d4:	4b3e      	ldr	r3, [pc, #248]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b0d6:	691b      	ldr	r3, [r3, #16]
 800b0d8:	1c19      	adds	r1, r3, #0
 800b0da:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800b0dc:	f7f5 fdfa 	bl	8000cd4 <__aeabi_fsub>
 800b0e0:	1c03      	adds	r3, r0, #0
 800b0e2:	63fb      	str	r3, [r7, #60]	; 0x3c
    if (minimum_mm < 0.0f) { minimum_mm = 0.0f; }
 800b0e4:	2100      	movs	r1, #0
 800b0e6:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800b0e8:	f7f5 f8f4 	bl	80002d4 <__aeabi_fcmplt>
 800b0ec:	1e03      	subs	r3, r0, #0
 800b0ee:	d100      	bne.n	800b0f2 <st_prep_buffer+0x52e>
 800b0f0:	e001      	b.n	800b0f6 <st_prep_buffer+0x532>
 800b0f2:	2300      	movs	r3, #0
 800b0f4:	63fb      	str	r3, [r7, #60]	; 0x3c

    do {
      switch (prep.ramp_type) {
 800b0f6:	4b36      	ldr	r3, [pc, #216]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b0f8:	7d1b      	ldrb	r3, [r3, #20]
 800b0fa:	2b01      	cmp	r3, #1
 800b0fc:	d100      	bne.n	800b100 <st_prep_buffer+0x53c>
 800b0fe:	e0db      	b.n	800b2b8 <st_prep_buffer+0x6f4>
 800b100:	2b03      	cmp	r3, #3
 800b102:	d002      	beq.n	800b10a <st_prep_buffer+0x546>
 800b104:	2b00      	cmp	r3, #0
 800b106:	d06f      	beq.n	800b1e8 <st_prep_buffer+0x624>
 800b108:	e105      	b.n	800b316 <st_prep_buffer+0x752>
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
 800b10a:	4b32      	ldr	r3, [pc, #200]	; (800b1d4 <st_prep_buffer+0x610>)
 800b10c:	681b      	ldr	r3, [r3, #0]
 800b10e:	6a1b      	ldr	r3, [r3, #32]
 800b110:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800b112:	1c18      	adds	r0, r3, #0
 800b114:	f7f5 fcbe 	bl	8000a94 <__aeabi_fmul>
 800b118:	1c03      	adds	r3, r0, #0
 800b11a:	62fb      	str	r3, [r7, #44]	; 0x2c
          mm_var = time_var*(prep.current_speed - 0.5f*speed_var);
 800b11c:	4b2c      	ldr	r3, [pc, #176]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b11e:	69dc      	ldr	r4, [r3, #28]
 800b120:	21fc      	movs	r1, #252	; 0xfc
 800b122:	0589      	lsls	r1, r1, #22
 800b124:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b126:	f7f5 fcb5 	bl	8000a94 <__aeabi_fmul>
 800b12a:	1c03      	adds	r3, r0, #0
 800b12c:	1c19      	adds	r1, r3, #0
 800b12e:	1c20      	adds	r0, r4, #0
 800b130:	f7f5 fdd0 	bl	8000cd4 <__aeabi_fsub>
 800b134:	1c03      	adds	r3, r0, #0
 800b136:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800b138:	1c18      	adds	r0, r3, #0
 800b13a:	f7f5 fcab 	bl	8000a94 <__aeabi_fmul>
 800b13e:	1c03      	adds	r3, r0, #0
 800b140:	62bb      	str	r3, [r7, #40]	; 0x28
          mm_remaining -= mm_var;
 800b142:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800b144:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800b146:	f7f5 fdc5 	bl	8000cd4 <__aeabi_fsub>
 800b14a:	1c03      	adds	r3, r0, #0
 800b14c:	643b      	str	r3, [r7, #64]	; 0x40
          if ((mm_remaining < prep.accelerate_until) || (mm_var <= 0)) {
 800b14e:	4b20      	ldr	r3, [pc, #128]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b150:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b152:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800b154:	1c18      	adds	r0, r3, #0
 800b156:	f7f5 f8d1 	bl	80002fc <__aeabi_fcmpgt>
 800b15a:	1e03      	subs	r3, r0, #0
 800b15c:	d105      	bne.n	800b16a <st_prep_buffer+0x5a6>
 800b15e:	2100      	movs	r1, #0
 800b160:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800b162:	f7f5 f8c1 	bl	80002e8 <__aeabi_fcmple>
 800b166:	1e03      	subs	r3, r0, #0
 800b168:	d027      	beq.n	800b1ba <st_prep_buffer+0x5f6>
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
 800b16a:	4b19      	ldr	r3, [pc, #100]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b16c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b16e:	643b      	str	r3, [r7, #64]	; 0x40
            time_var = 2.0f*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
 800b170:	4b18      	ldr	r3, [pc, #96]	; (800b1d4 <st_prep_buffer+0x610>)
 800b172:	681b      	ldr	r3, [r3, #0]
 800b174:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b176:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800b178:	1c18      	adds	r0, r3, #0
 800b17a:	f7f5 fdab 	bl	8000cd4 <__aeabi_fsub>
 800b17e:	1c03      	adds	r3, r0, #0
 800b180:	1c19      	adds	r1, r3, #0
 800b182:	1c18      	adds	r0, r3, #0
 800b184:	f7f5 f904 	bl	8000390 <__aeabi_fadd>
 800b188:	1c03      	adds	r3, r0, #0
 800b18a:	1c1c      	adds	r4, r3, #0
 800b18c:	4b10      	ldr	r3, [pc, #64]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b18e:	69da      	ldr	r2, [r3, #28]
 800b190:	4b0f      	ldr	r3, [pc, #60]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b192:	6a1b      	ldr	r3, [r3, #32]
 800b194:	1c19      	adds	r1, r3, #0
 800b196:	1c10      	adds	r0, r2, #0
 800b198:	f7f5 f8fa 	bl	8000390 <__aeabi_fadd>
 800b19c:	1c03      	adds	r3, r0, #0
 800b19e:	1c19      	adds	r1, r3, #0
 800b1a0:	1c20      	adds	r0, r4, #0
 800b1a2:	f7f5 fa87 	bl	80006b4 <__aeabi_fdiv>
 800b1a6:	1c03      	adds	r3, r0, #0
 800b1a8:	647b      	str	r3, [r7, #68]	; 0x44
            prep.ramp_type = RAMP_CRUISE;
 800b1aa:	4b09      	ldr	r3, [pc, #36]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b1ac:	2201      	movs	r2, #1
 800b1ae:	751a      	strb	r2, [r3, #20]
            prep.current_speed = prep.maximum_speed;
 800b1b0:	4b07      	ldr	r3, [pc, #28]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b1b2:	6a1a      	ldr	r2, [r3, #32]
 800b1b4:	4b06      	ldr	r3, [pc, #24]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b1b6:	61da      	str	r2, [r3, #28]
          } else { // Mid-deceleration override ramp.
            prep.current_speed -= speed_var;
          }
          break;
 800b1b8:	e10e      	b.n	800b3d8 <st_prep_buffer+0x814>
            prep.current_speed -= speed_var;
 800b1ba:	4b05      	ldr	r3, [pc, #20]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b1bc:	69db      	ldr	r3, [r3, #28]
 800b1be:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800b1c0:	1c18      	adds	r0, r3, #0
 800b1c2:	f7f5 fd87 	bl	8000cd4 <__aeabi_fsub>
 800b1c6:	1c03      	adds	r3, r0, #0
 800b1c8:	1c1a      	adds	r2, r3, #0
 800b1ca:	4b01      	ldr	r3, [pc, #4]	; (800b1d0 <st_prep_buffer+0x60c>)
 800b1cc:	61da      	str	r2, [r3, #28]
          break;
 800b1ce:	e103      	b.n	800b3d8 <st_prep_buffer+0x814>
 800b1d0:	2000058c 	.word	0x2000058c
 800b1d4:	20000584 	.word	0x20000584
 800b1d8:	20000bb4 	.word	0x20000bb4
 800b1dc:	20000579 	.word	0x20000579
 800b1e0:	20000514 	.word	0x20000514
 800b1e4:	38aec33e 	.word	0x38aec33e
        case RAMP_ACCEL:
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
 800b1e8:	4bd0      	ldr	r3, [pc, #832]	; (800b52c <st_prep_buffer+0x968>)
 800b1ea:	681b      	ldr	r3, [r3, #0]
 800b1ec:	6a1b      	ldr	r3, [r3, #32]
 800b1ee:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800b1f0:	1c18      	adds	r0, r3, #0
 800b1f2:	f7f5 fc4f 	bl	8000a94 <__aeabi_fmul>
 800b1f6:	1c03      	adds	r3, r0, #0
 800b1f8:	62fb      	str	r3, [r7, #44]	; 0x2c
          mm_remaining -= time_var*(prep.current_speed + 0.5f*speed_var);
 800b1fa:	4bcd      	ldr	r3, [pc, #820]	; (800b530 <st_prep_buffer+0x96c>)
 800b1fc:	69dc      	ldr	r4, [r3, #28]
 800b1fe:	21fc      	movs	r1, #252	; 0xfc
 800b200:	0589      	lsls	r1, r1, #22
 800b202:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b204:	f7f5 fc46 	bl	8000a94 <__aeabi_fmul>
 800b208:	1c03      	adds	r3, r0, #0
 800b20a:	1c19      	adds	r1, r3, #0
 800b20c:	1c20      	adds	r0, r4, #0
 800b20e:	f7f5 f8bf 	bl	8000390 <__aeabi_fadd>
 800b212:	1c03      	adds	r3, r0, #0
 800b214:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800b216:	1c18      	adds	r0, r3, #0
 800b218:	f7f5 fc3c 	bl	8000a94 <__aeabi_fmul>
 800b21c:	1c03      	adds	r3, r0, #0
 800b21e:	1c19      	adds	r1, r3, #0
 800b220:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800b222:	f7f5 fd57 	bl	8000cd4 <__aeabi_fsub>
 800b226:	1c03      	adds	r3, r0, #0
 800b228:	643b      	str	r3, [r7, #64]	; 0x40
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
 800b22a:	4bc1      	ldr	r3, [pc, #772]	; (800b530 <st_prep_buffer+0x96c>)
 800b22c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b22e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800b230:	1c18      	adds	r0, r3, #0
 800b232:	f7f5 f863 	bl	80002fc <__aeabi_fcmpgt>
 800b236:	1e03      	subs	r3, r0, #0
 800b238:	d033      	beq.n	800b2a2 <st_prep_buffer+0x6de>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
 800b23a:	4bbd      	ldr	r3, [pc, #756]	; (800b530 <st_prep_buffer+0x96c>)
 800b23c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b23e:	643b      	str	r3, [r7, #64]	; 0x40
            time_var = 2.0f*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
 800b240:	4bba      	ldr	r3, [pc, #744]	; (800b52c <st_prep_buffer+0x968>)
 800b242:	681b      	ldr	r3, [r3, #0]
 800b244:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b246:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800b248:	1c18      	adds	r0, r3, #0
 800b24a:	f7f5 fd43 	bl	8000cd4 <__aeabi_fsub>
 800b24e:	1c03      	adds	r3, r0, #0
 800b250:	1c19      	adds	r1, r3, #0
 800b252:	1c18      	adds	r0, r3, #0
 800b254:	f7f5 f89c 	bl	8000390 <__aeabi_fadd>
 800b258:	1c03      	adds	r3, r0, #0
 800b25a:	1c1c      	adds	r4, r3, #0
 800b25c:	4bb4      	ldr	r3, [pc, #720]	; (800b530 <st_prep_buffer+0x96c>)
 800b25e:	69da      	ldr	r2, [r3, #28]
 800b260:	4bb3      	ldr	r3, [pc, #716]	; (800b530 <st_prep_buffer+0x96c>)
 800b262:	6a1b      	ldr	r3, [r3, #32]
 800b264:	1c19      	adds	r1, r3, #0
 800b266:	1c10      	adds	r0, r2, #0
 800b268:	f7f5 f892 	bl	8000390 <__aeabi_fadd>
 800b26c:	1c03      	adds	r3, r0, #0
 800b26e:	1c19      	adds	r1, r3, #0
 800b270:	1c20      	adds	r0, r4, #0
 800b272:	f7f5 fa1f 	bl	80006b4 <__aeabi_fdiv>
 800b276:	1c03      	adds	r3, r0, #0
 800b278:	647b      	str	r3, [r7, #68]	; 0x44
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
 800b27a:	4bad      	ldr	r3, [pc, #692]	; (800b530 <st_prep_buffer+0x96c>)
 800b27c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b27e:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800b280:	1c18      	adds	r0, r3, #0
 800b282:	f7f5 f821 	bl	80002c8 <__aeabi_fcmpeq>
 800b286:	1e03      	subs	r3, r0, #0
 800b288:	d003      	beq.n	800b292 <st_prep_buffer+0x6ce>
 800b28a:	4ba9      	ldr	r3, [pc, #676]	; (800b530 <st_prep_buffer+0x96c>)
 800b28c:	2202      	movs	r2, #2
 800b28e:	751a      	strb	r2, [r3, #20]
 800b290:	e002      	b.n	800b298 <st_prep_buffer+0x6d4>
            else { prep.ramp_type = RAMP_CRUISE; }
 800b292:	4ba7      	ldr	r3, [pc, #668]	; (800b530 <st_prep_buffer+0x96c>)
 800b294:	2201      	movs	r2, #1
 800b296:	751a      	strb	r2, [r3, #20]
            prep.current_speed = prep.maximum_speed;
 800b298:	4ba5      	ldr	r3, [pc, #660]	; (800b530 <st_prep_buffer+0x96c>)
 800b29a:	6a1a      	ldr	r2, [r3, #32]
 800b29c:	4ba4      	ldr	r3, [pc, #656]	; (800b530 <st_prep_buffer+0x96c>)
 800b29e:	61da      	str	r2, [r3, #28]
          } else { // Acceleration only.
            prep.current_speed += speed_var;
          }
          break;
 800b2a0:	e09a      	b.n	800b3d8 <st_prep_buffer+0x814>
            prep.current_speed += speed_var;
 800b2a2:	4ba3      	ldr	r3, [pc, #652]	; (800b530 <st_prep_buffer+0x96c>)
 800b2a4:	69db      	ldr	r3, [r3, #28]
 800b2a6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800b2a8:	1c18      	adds	r0, r3, #0
 800b2aa:	f7f5 f871 	bl	8000390 <__aeabi_fadd>
 800b2ae:	1c03      	adds	r3, r0, #0
 800b2b0:	1c1a      	adds	r2, r3, #0
 800b2b2:	4b9f      	ldr	r3, [pc, #636]	; (800b530 <st_prep_buffer+0x96c>)
 800b2b4:	61da      	str	r2, [r3, #28]
          break;
 800b2b6:	e08f      	b.n	800b3d8 <st_prep_buffer+0x814>
        case RAMP_CRUISE:
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
 800b2b8:	4b9d      	ldr	r3, [pc, #628]	; (800b530 <st_prep_buffer+0x96c>)
 800b2ba:	6a1b      	ldr	r3, [r3, #32]
 800b2bc:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800b2be:	1c18      	adds	r0, r3, #0
 800b2c0:	f7f5 fbe8 	bl	8000a94 <__aeabi_fmul>
 800b2c4:	1c03      	adds	r3, r0, #0
 800b2c6:	1c19      	adds	r1, r3, #0
 800b2c8:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800b2ca:	f7f5 fd03 	bl	8000cd4 <__aeabi_fsub>
 800b2ce:	1c03      	adds	r3, r0, #0
 800b2d0:	62bb      	str	r3, [r7, #40]	; 0x28
          if (mm_var < prep.decelerate_after) { // End of cruise.
 800b2d2:	4b97      	ldr	r3, [pc, #604]	; (800b530 <st_prep_buffer+0x96c>)
 800b2d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b2d6:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800b2d8:	1c18      	adds	r0, r3, #0
 800b2da:	f7f5 f80f 	bl	80002fc <__aeabi_fcmpgt>
 800b2de:	1e03      	subs	r3, r0, #0
 800b2e0:	d016      	beq.n	800b310 <st_prep_buffer+0x74c>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
 800b2e2:	4b93      	ldr	r3, [pc, #588]	; (800b530 <st_prep_buffer+0x96c>)
 800b2e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b2e6:	1c19      	adds	r1, r3, #0
 800b2e8:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800b2ea:	f7f5 fcf3 	bl	8000cd4 <__aeabi_fsub>
 800b2ee:	1c03      	adds	r3, r0, #0
 800b2f0:	1c1a      	adds	r2, r3, #0
 800b2f2:	4b8f      	ldr	r3, [pc, #572]	; (800b530 <st_prep_buffer+0x96c>)
 800b2f4:	6a1b      	ldr	r3, [r3, #32]
 800b2f6:	1c19      	adds	r1, r3, #0
 800b2f8:	1c10      	adds	r0, r2, #0
 800b2fa:	f7f5 f9db 	bl	80006b4 <__aeabi_fdiv>
 800b2fe:	1c03      	adds	r3, r0, #0
 800b300:	647b      	str	r3, [r7, #68]	; 0x44
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
 800b302:	4b8b      	ldr	r3, [pc, #556]	; (800b530 <st_prep_buffer+0x96c>)
 800b304:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b306:	643b      	str	r3, [r7, #64]	; 0x40
            prep.ramp_type = RAMP_DECEL;
 800b308:	4b89      	ldr	r3, [pc, #548]	; (800b530 <st_prep_buffer+0x96c>)
 800b30a:	2202      	movs	r2, #2
 800b30c:	751a      	strb	r2, [r3, #20]
          } else { // Cruising only.
            mm_remaining = mm_var;
          }
          break;
 800b30e:	e063      	b.n	800b3d8 <st_prep_buffer+0x814>
            mm_remaining = mm_var;
 800b310:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b312:	643b      	str	r3, [r7, #64]	; 0x40
          break;
 800b314:	e060      	b.n	800b3d8 <st_prep_buffer+0x814>
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
 800b316:	4b85      	ldr	r3, [pc, #532]	; (800b52c <st_prep_buffer+0x968>)
 800b318:	681b      	ldr	r3, [r3, #0]
 800b31a:	6a1b      	ldr	r3, [r3, #32]
 800b31c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800b31e:	1c18      	adds	r0, r3, #0
 800b320:	f7f5 fbb8 	bl	8000a94 <__aeabi_fmul>
 800b324:	1c03      	adds	r3, r0, #0
 800b326:	62fb      	str	r3, [r7, #44]	; 0x2c
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
 800b328:	4b81      	ldr	r3, [pc, #516]	; (800b530 <st_prep_buffer+0x96c>)
 800b32a:	69db      	ldr	r3, [r3, #28]
 800b32c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800b32e:	1c18      	adds	r0, r3, #0
 800b330:	f7f4 ffe4 	bl	80002fc <__aeabi_fcmpgt>
 800b334:	1e03      	subs	r3, r0, #0
 800b336:	d02c      	beq.n	800b392 <st_prep_buffer+0x7ce>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5f*speed_var); // (mm)
 800b338:	4b7d      	ldr	r3, [pc, #500]	; (800b530 <st_prep_buffer+0x96c>)
 800b33a:	69dc      	ldr	r4, [r3, #28]
 800b33c:	21fc      	movs	r1, #252	; 0xfc
 800b33e:	0589      	lsls	r1, r1, #22
 800b340:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b342:	f7f5 fba7 	bl	8000a94 <__aeabi_fmul>
 800b346:	1c03      	adds	r3, r0, #0
 800b348:	1c19      	adds	r1, r3, #0
 800b34a:	1c20      	adds	r0, r4, #0
 800b34c:	f7f5 fcc2 	bl	8000cd4 <__aeabi_fsub>
 800b350:	1c03      	adds	r3, r0, #0
 800b352:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800b354:	1c18      	adds	r0, r3, #0
 800b356:	f7f5 fb9d 	bl	8000a94 <__aeabi_fmul>
 800b35a:	1c03      	adds	r3, r0, #0
 800b35c:	1c19      	adds	r1, r3, #0
 800b35e:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800b360:	f7f5 fcb8 	bl	8000cd4 <__aeabi_fsub>
 800b364:	1c03      	adds	r3, r0, #0
 800b366:	62bb      	str	r3, [r7, #40]	; 0x28
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
 800b368:	4b71      	ldr	r3, [pc, #452]	; (800b530 <st_prep_buffer+0x96c>)
 800b36a:	699b      	ldr	r3, [r3, #24]
 800b36c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800b36e:	1c18      	adds	r0, r3, #0
 800b370:	f7f4 ffb0 	bl	80002d4 <__aeabi_fcmplt>
 800b374:	1e03      	subs	r3, r0, #0
 800b376:	d00c      	beq.n	800b392 <st_prep_buffer+0x7ce>
              mm_remaining = mm_var;
 800b378:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b37a:	643b      	str	r3, [r7, #64]	; 0x40
              prep.current_speed -= speed_var;
 800b37c:	4b6c      	ldr	r3, [pc, #432]	; (800b530 <st_prep_buffer+0x96c>)
 800b37e:	69db      	ldr	r3, [r3, #28]
 800b380:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800b382:	1c18      	adds	r0, r3, #0
 800b384:	f7f5 fca6 	bl	8000cd4 <__aeabi_fsub>
 800b388:	1c03      	adds	r3, r0, #0
 800b38a:	1c1a      	adds	r2, r3, #0
 800b38c:	4b68      	ldr	r3, [pc, #416]	; (800b530 <st_prep_buffer+0x96c>)
 800b38e:	61da      	str	r2, [r3, #28]
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
 800b390:	e022      	b.n	800b3d8 <st_prep_buffer+0x814>
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0f*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
 800b392:	4b67      	ldr	r3, [pc, #412]	; (800b530 <st_prep_buffer+0x96c>)
 800b394:	699b      	ldr	r3, [r3, #24]
 800b396:	1c19      	adds	r1, r3, #0
 800b398:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800b39a:	f7f5 fc9b 	bl	8000cd4 <__aeabi_fsub>
 800b39e:	1c03      	adds	r3, r0, #0
 800b3a0:	1c19      	adds	r1, r3, #0
 800b3a2:	1c18      	adds	r0, r3, #0
 800b3a4:	f7f4 fff4 	bl	8000390 <__aeabi_fadd>
 800b3a8:	1c03      	adds	r3, r0, #0
 800b3aa:	1c1c      	adds	r4, r3, #0
 800b3ac:	4b60      	ldr	r3, [pc, #384]	; (800b530 <st_prep_buffer+0x96c>)
 800b3ae:	69da      	ldr	r2, [r3, #28]
 800b3b0:	4b5f      	ldr	r3, [pc, #380]	; (800b530 <st_prep_buffer+0x96c>)
 800b3b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b3b4:	1c19      	adds	r1, r3, #0
 800b3b6:	1c10      	adds	r0, r2, #0
 800b3b8:	f7f4 ffea 	bl	8000390 <__aeabi_fadd>
 800b3bc:	1c03      	adds	r3, r0, #0
 800b3be:	1c19      	adds	r1, r3, #0
 800b3c0:	1c20      	adds	r0, r4, #0
 800b3c2:	f7f5 f977 	bl	80006b4 <__aeabi_fdiv>
 800b3c6:	1c03      	adds	r3, r0, #0
 800b3c8:	647b      	str	r3, [r7, #68]	; 0x44
          mm_remaining = prep.mm_complete;
 800b3ca:	4b59      	ldr	r3, [pc, #356]	; (800b530 <st_prep_buffer+0x96c>)
 800b3cc:	699b      	ldr	r3, [r3, #24]
 800b3ce:	643b      	str	r3, [r7, #64]	; 0x40
          prep.current_speed = prep.exit_speed;
 800b3d0:	4b57      	ldr	r3, [pc, #348]	; (800b530 <st_prep_buffer+0x96c>)
 800b3d2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b3d4:	4b56      	ldr	r3, [pc, #344]	; (800b530 <st_prep_buffer+0x96c>)
 800b3d6:	61da      	str	r2, [r3, #28]
      }
      dt += time_var; // Add computed ramp time to total segment time.
 800b3d8:	6c79      	ldr	r1, [r7, #68]	; 0x44
 800b3da:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 800b3dc:	f7f4 ffd8 	bl	8000390 <__aeabi_fadd>
 800b3e0:	1c03      	adds	r3, r0, #0
 800b3e2:	64bb      	str	r3, [r7, #72]	; 0x48
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
 800b3e4:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800b3e6:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 800b3e8:	f7f4 ff74 	bl	80002d4 <__aeabi_fcmplt>
 800b3ec:	1e03      	subs	r3, r0, #0
 800b3ee:	d006      	beq.n	800b3fe <st_prep_buffer+0x83a>
 800b3f0:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800b3f2:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800b3f4:	f7f5 fc6e 	bl	8000cd4 <__aeabi_fsub>
 800b3f8:	1c03      	adds	r3, r0, #0
 800b3fa:	647b      	str	r3, [r7, #68]	; 0x44
 800b3fc:	e012      	b.n	800b424 <st_prep_buffer+0x860>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
 800b3fe:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800b400:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800b402:	f7f4 ff7b 	bl	80002fc <__aeabi_fcmpgt>
 800b406:	1e03      	subs	r3, r0, #0
 800b408:	d100      	bne.n	800b40c <st_prep_buffer+0x848>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
          time_var = dt_max - dt;
        } else {
          break; // **Complete** Exit loop. Segment execution time maxed.
 800b40a:	e014      	b.n	800b436 <st_prep_buffer+0x872>
          dt_max += DT_SEGMENT;
 800b40c:	4949      	ldr	r1, [pc, #292]	; (800b534 <st_prep_buffer+0x970>)
 800b40e:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800b410:	f7f4 ffbe 	bl	8000390 <__aeabi_fadd>
 800b414:	1c03      	adds	r3, r0, #0
 800b416:	64fb      	str	r3, [r7, #76]	; 0x4c
          time_var = dt_max - dt;
 800b418:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800b41a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800b41c:	f7f5 fc5a 	bl	8000cd4 <__aeabi_fsub>
 800b420:	1c03      	adds	r3, r0, #0
 800b422:	647b      	str	r3, [r7, #68]	; 0x44
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
 800b424:	4b42      	ldr	r3, [pc, #264]	; (800b530 <st_prep_buffer+0x96c>)
 800b426:	699b      	ldr	r3, [r3, #24]
 800b428:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800b42a:	1c18      	adds	r0, r3, #0
 800b42c:	f7f4 ff52 	bl	80002d4 <__aeabi_fcmplt>
 800b430:	1e03      	subs	r3, r0, #0
 800b432:	d000      	beq.n	800b436 <st_prep_buffer+0x872>
 800b434:	e65f      	b.n	800b0f6 <st_prep_buffer+0x532>
    #ifdef VARIABLE_SPINDLE
      /* -----------------------------------------------------------------------------------
        Compute spindle speed PWM output for step segment
      */

      if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
 800b436:	4b40      	ldr	r3, [pc, #256]	; (800b538 <st_prep_buffer+0x974>)
 800b438:	681b      	ldr	r3, [r3, #0]
 800b43a:	7d5b      	ldrb	r3, [r3, #21]
 800b43c:	2b00      	cmp	r3, #0
 800b43e:	d105      	bne.n	800b44c <st_prep_buffer+0x888>
 800b440:	4b3e      	ldr	r3, [pc, #248]	; (800b53c <st_prep_buffer+0x978>)
 800b442:	791b      	ldrb	r3, [r3, #4]
 800b444:	001a      	movs	r2, r3
 800b446:	2308      	movs	r3, #8
 800b448:	4013      	ands	r3, r2
 800b44a:	d036      	beq.n	800b4ba <st_prep_buffer+0x8f6>
        if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
 800b44c:	4b37      	ldr	r3, [pc, #220]	; (800b52c <st_prep_buffer+0x968>)
 800b44e:	681b      	ldr	r3, [r3, #0]
 800b450:	7d5b      	ldrb	r3, [r3, #21]
 800b452:	001a      	movs	r2, r3
 800b454:	2330      	movs	r3, #48	; 0x30
 800b456:	4013      	ands	r3, r2
 800b458:	d021      	beq.n	800b49e <st_prep_buffer+0x8da>
          float rpm = pl_block->spindle_speed;
 800b45a:	4b34      	ldr	r3, [pc, #208]	; (800b52c <st_prep_buffer+0x968>)
 800b45c:	681b      	ldr	r3, [r3, #0]
 800b45e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800b460:	63bb      	str	r3, [r7, #56]	; 0x38
          // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
          if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
 800b462:	4b35      	ldr	r3, [pc, #212]	; (800b538 <st_prep_buffer+0x974>)
 800b464:	681b      	ldr	r3, [r3, #0]
 800b466:	7d5b      	ldrb	r3, [r3, #21]
 800b468:	2b00      	cmp	r3, #0
 800b46a:	d00e      	beq.n	800b48a <st_prep_buffer+0x8c6>
 800b46c:	4b30      	ldr	r3, [pc, #192]	; (800b530 <st_prep_buffer+0x96c>)
 800b46e:	69da      	ldr	r2, [r3, #28]
 800b470:	4b2f      	ldr	r3, [pc, #188]	; (800b530 <st_prep_buffer+0x96c>)
 800b472:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b474:	1c19      	adds	r1, r3, #0
 800b476:	1c10      	adds	r0, r2, #0
 800b478:	f7f5 fb0c 	bl	8000a94 <__aeabi_fmul>
 800b47c:	1c03      	adds	r3, r0, #0
 800b47e:	1c19      	adds	r1, r3, #0
 800b480:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800b482:	f7f5 fb07 	bl	8000a94 <__aeabi_fmul>
 800b486:	1c03      	adds	r3, r0, #0
 800b488:	63bb      	str	r3, [r7, #56]	; 0x38
          // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE)
          // but this would be instantaneous only and during a motion. May not matter at all.
          prep.current_spindle_pwm = spindle_compute_pwm_value(rpm);
 800b48a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b48c:	1c18      	adds	r0, r3, #0
 800b48e:	f7fe fdfd 	bl	800a08c <spindle_compute_pwm_value>
 800b492:	0003      	movs	r3, r0
 800b494:	b2d9      	uxtb	r1, r3
 800b496:	4b26      	ldr	r3, [pc, #152]	; (800b530 <st_prep_buffer+0x96c>)
 800b498:	2234      	movs	r2, #52	; 0x34
 800b49a:	5499      	strb	r1, [r3, r2]
 800b49c:	e006      	b.n	800b4ac <st_prep_buffer+0x8e8>
        }
        else {
          sys.spindle_speed = 0.0;
 800b49e:	4b27      	ldr	r3, [pc, #156]	; (800b53c <st_prep_buffer+0x978>)
 800b4a0:	2200      	movs	r2, #0
 800b4a2:	611a      	str	r2, [r3, #16]
          prep.current_spindle_pwm = SPINDLE_PWM_OFF_VALUE;
 800b4a4:	4b22      	ldr	r3, [pc, #136]	; (800b530 <st_prep_buffer+0x96c>)
 800b4a6:	2234      	movs	r2, #52	; 0x34
 800b4a8:	2100      	movs	r1, #0
 800b4aa:	5499      	strb	r1, [r3, r2]
        }
        bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 800b4ac:	4b23      	ldr	r3, [pc, #140]	; (800b53c <st_prep_buffer+0x978>)
 800b4ae:	791b      	ldrb	r3, [r3, #4]
 800b4b0:	2208      	movs	r2, #8
 800b4b2:	4393      	bics	r3, r2
 800b4b4:	b2da      	uxtb	r2, r3
 800b4b6:	4b21      	ldr	r3, [pc, #132]	; (800b53c <st_prep_buffer+0x978>)
 800b4b8:	711a      	strb	r2, [r3, #4]
      }
      prep_segment->spindle_pwm = prep.current_spindle_pwm; // Reload segment PWM value
 800b4ba:	4b1d      	ldr	r3, [pc, #116]	; (800b530 <st_prep_buffer+0x96c>)
 800b4bc:	2234      	movs	r2, #52	; 0x34
 800b4be:	5c9a      	ldrb	r2, [r3, r2]
 800b4c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b4c2:	719a      	strb	r2, [r3, #6]
       However, since floats have only 7.2 significant digits, long moves with extremely
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float step_dist_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
 800b4c4:	4b1a      	ldr	r3, [pc, #104]	; (800b530 <st_prep_buffer+0x96c>)
 800b4c6:	68db      	ldr	r3, [r3, #12]
 800b4c8:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800b4ca:	1c18      	adds	r0, r3, #0
 800b4cc:	f7f5 fae2 	bl	8000a94 <__aeabi_fmul>
 800b4d0:	1c03      	adds	r3, r0, #0
 800b4d2:	627b      	str	r3, [r7, #36]	; 0x24
    float n_steps_remaining = ceilf(step_dist_remaining); // Round-up current steps remaining
 800b4d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b4d6:	1c18      	adds	r0, r3, #0
 800b4d8:	f001 f99a 	bl	800c810 <ceilf>
 800b4dc:	1c03      	adds	r3, r0, #0
 800b4de:	623b      	str	r3, [r7, #32]
    float last_n_steps_remaining = ceilf(prep.steps_remaining); // Round-up last steps remaining
 800b4e0:	4b13      	ldr	r3, [pc, #76]	; (800b530 <st_prep_buffer+0x96c>)
 800b4e2:	689b      	ldr	r3, [r3, #8]
 800b4e4:	1c18      	adds	r0, r3, #0
 800b4e6:	f001 f993 	bl	800c810 <ceilf>
 800b4ea:	1c03      	adds	r3, r0, #0
 800b4ec:	61fb      	str	r3, [r7, #28]
	prep_segment->n_step = (uint16_t)(last_n_steps_remaining - n_steps_remaining); // Compute number of steps to execute.
 800b4ee:	6a39      	ldr	r1, [r7, #32]
 800b4f0:	69f8      	ldr	r0, [r7, #28]
 800b4f2:	f7f5 fbef 	bl	8000cd4 <__aeabi_fsub>
 800b4f6:	1c03      	adds	r3, r0, #0
 800b4f8:	1c18      	adds	r0, r3, #0
 800b4fa:	f7f4 ff13 	bl	8000324 <__aeabi_f2uiz>
 800b4fe:	0003      	movs	r3, r0
 800b500:	b29a      	uxth	r2, r3
 800b502:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b504:	801a      	strh	r2, [r3, #0]

    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
 800b506:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b508:	881b      	ldrh	r3, [r3, #0]
 800b50a:	2b00      	cmp	r3, #0
 800b50c:	d118      	bne.n	800b540 <st_prep_buffer+0x97c>
      if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) {
 800b50e:	4b0b      	ldr	r3, [pc, #44]	; (800b53c <st_prep_buffer+0x978>)
 800b510:	791b      	ldrb	r3, [r3, #4]
 800b512:	001a      	movs	r2, r3
 800b514:	2302      	movs	r3, #2
 800b516:	4013      	ands	r3, r2
 800b518:	d012      	beq.n	800b540 <st_prep_buffer+0x97c>
        // Less than one step to decelerate to zero speed, but already very close. AMASS
        // requires full steps to execute. So, just bail.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
 800b51a:	4b08      	ldr	r3, [pc, #32]	; (800b53c <st_prep_buffer+0x978>)
 800b51c:	791b      	ldrb	r3, [r3, #4]
 800b51e:	2201      	movs	r2, #1
 800b520:	4313      	orrs	r3, r2
 800b522:	b2da      	uxtb	r2, r3
 800b524:	4b05      	ldr	r3, [pc, #20]	; (800b53c <st_prep_buffer+0x978>)
 800b526:	711a      	strb	r2, [r3, #4]
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Segment not generated, but current step data still retained.
 800b528:	e0ea      	b.n	800b700 <st_prep_buffer+0xb3c>
 800b52a:	46c0      	nop			; (mov r8, r8)
 800b52c:	20000584 	.word	0x20000584
 800b530:	2000058c 	.word	0x2000058c
 800b534:	38aec33e 	.word	0x38aec33e
 800b538:	20000588 	.word	0x20000588
 800b53c:	20000bb4 	.word	0x20000bb4
    // compensate, we track the time to execute the previous segment's partial step and simply
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
 800b540:	4b71      	ldr	r3, [pc, #452]	; (800b708 <st_prep_buffer+0xb44>)
 800b542:	685b      	ldr	r3, [r3, #4]
 800b544:	1c19      	adds	r1, r3, #0
 800b546:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 800b548:	f7f4 ff22 	bl	8000390 <__aeabi_fadd>
 800b54c:	1c03      	adds	r3, r0, #0
 800b54e:	64bb      	str	r3, [r7, #72]	; 0x48
    float inv_rate = dt/(last_n_steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
 800b550:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800b552:	69f8      	ldr	r0, [r7, #28]
 800b554:	f7f5 fbbe 	bl	8000cd4 <__aeabi_fsub>
 800b558:	1c03      	adds	r3, r0, #0
 800b55a:	1c19      	adds	r1, r3, #0
 800b55c:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 800b55e:	f7f5 f8a9 	bl	80006b4 <__aeabi_fdiv>
 800b562:	1c03      	adds	r3, r0, #0
 800b564:	61bb      	str	r3, [r7, #24]

    // Compute CPU cycles per step for the prepped segment.
	uint32_t cycles = (uint32_t)ceilf((TICKS_PER_MICROSECOND * 1000000) *inv_rate * 60); // (cycles/step)
 800b566:	4b69      	ldr	r3, [pc, #420]	; (800b70c <st_prep_buffer+0xb48>)
 800b568:	681b      	ldr	r3, [r3, #0]
 800b56a:	4969      	ldr	r1, [pc, #420]	; (800b710 <st_prep_buffer+0xb4c>)
 800b56c:	0018      	movs	r0, r3
 800b56e:	f7f4 fdd5 	bl	800011c <__udivsi3>
 800b572:	0003      	movs	r3, r0
 800b574:	001a      	movs	r2, r3
 800b576:	4b66      	ldr	r3, [pc, #408]	; (800b710 <st_prep_buffer+0xb4c>)
 800b578:	4353      	muls	r3, r2
 800b57a:	0018      	movs	r0, r3
 800b57c:	f7f5 fdce 	bl	800111c <__aeabi_ui2f>
 800b580:	1c03      	adds	r3, r0, #0
 800b582:	69b9      	ldr	r1, [r7, #24]
 800b584:	1c18      	adds	r0, r3, #0
 800b586:	f7f5 fa85 	bl	8000a94 <__aeabi_fmul>
 800b58a:	1c03      	adds	r3, r0, #0
 800b58c:	4961      	ldr	r1, [pc, #388]	; (800b714 <st_prep_buffer+0xb50>)
 800b58e:	1c18      	adds	r0, r3, #0
 800b590:	f7f5 fa80 	bl	8000a94 <__aeabi_fmul>
 800b594:	1c03      	adds	r3, r0, #0
 800b596:	1c18      	adds	r0, r3, #0
 800b598:	f001 f93a 	bl	800c810 <ceilf>
 800b59c:	1c03      	adds	r3, r0, #0
 800b59e:	1c18      	adds	r0, r3, #0
 800b5a0:	f7f4 fec0 	bl	8000324 <__aeabi_f2uiz>
 800b5a4:	0003      	movs	r3, r0
 800b5a6:	637b      	str	r3, [r7, #52]	; 0x34

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
 800b5a8:	4b58      	ldr	r3, [pc, #352]	; (800b70c <st_prep_buffer+0xb48>)
 800b5aa:	681a      	ldr	r2, [r3, #0]
 800b5ac:	23fa      	movs	r3, #250	; 0xfa
 800b5ae:	0159      	lsls	r1, r3, #5
 800b5b0:	0010      	movs	r0, r2
 800b5b2:	f7f4 fdb3 	bl	800011c <__udivsi3>
 800b5b6:	0003      	movs	r3, r0
 800b5b8:	001a      	movs	r2, r3
 800b5ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b5bc:	429a      	cmp	r2, r3
 800b5be:	d903      	bls.n	800b5c8 <st_prep_buffer+0xa04>
 800b5c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b5c2:	2200      	movs	r2, #0
 800b5c4:	715a      	strb	r2, [r3, #5]
 800b5c6:	e032      	b.n	800b62e <st_prep_buffer+0xa6a>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
 800b5c8:	4b50      	ldr	r3, [pc, #320]	; (800b70c <st_prep_buffer+0xb48>)
 800b5ca:	681a      	ldr	r2, [r3, #0]
 800b5cc:	23fa      	movs	r3, #250	; 0xfa
 800b5ce:	0119      	lsls	r1, r3, #4
 800b5d0:	0010      	movs	r0, r2
 800b5d2:	f7f4 fda3 	bl	800011c <__udivsi3>
 800b5d6:	0003      	movs	r3, r0
 800b5d8:	001a      	movs	r2, r3
 800b5da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b5dc:	429a      	cmp	r2, r3
 800b5de:	d903      	bls.n	800b5e8 <st_prep_buffer+0xa24>
 800b5e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b5e2:	2201      	movs	r2, #1
 800b5e4:	715a      	strb	r2, [r3, #5]
 800b5e6:	e012      	b.n	800b60e <st_prep_buffer+0xa4a>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
 800b5e8:	4b48      	ldr	r3, [pc, #288]	; (800b70c <st_prep_buffer+0xb48>)
 800b5ea:	681a      	ldr	r2, [r3, #0]
 800b5ec:	23fa      	movs	r3, #250	; 0xfa
 800b5ee:	00d9      	lsls	r1, r3, #3
 800b5f0:	0010      	movs	r0, r2
 800b5f2:	f7f4 fd93 	bl	800011c <__udivsi3>
 800b5f6:	0003      	movs	r3, r0
 800b5f8:	001a      	movs	r2, r3
 800b5fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b5fc:	429a      	cmp	r2, r3
 800b5fe:	d903      	bls.n	800b608 <st_prep_buffer+0xa44>
 800b600:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b602:	2202      	movs	r2, #2
 800b604:	715a      	strb	r2, [r3, #5]
 800b606:	e002      	b.n	800b60e <st_prep_buffer+0xa4a>
        else { prep_segment->amass_level = 3; }
 800b608:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b60a:	2203      	movs	r2, #3
 800b60c:	715a      	strb	r2, [r3, #5]
        cycles >>= prep_segment->amass_level;
 800b60e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b610:	795b      	ldrb	r3, [r3, #5]
 800b612:	001a      	movs	r2, r3
 800b614:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b616:	40d3      	lsrs	r3, r2
 800b618:	637b      	str	r3, [r7, #52]	; 0x34
        prep_segment->n_step <<= prep_segment->amass_level;
 800b61a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b61c:	881b      	ldrh	r3, [r3, #0]
 800b61e:	001a      	movs	r2, r3
 800b620:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b622:	795b      	ldrb	r3, [r3, #5]
 800b624:	409a      	lsls	r2, r3
 800b626:	0013      	movs	r3, r2
 800b628:	b29a      	uxth	r2, r3
 800b62a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b62c:	801a      	strh	r2, [r3, #0]
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
 800b62e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b630:	4a39      	ldr	r2, [pc, #228]	; (800b718 <st_prep_buffer+0xb54>)
 800b632:	4293      	cmp	r3, r2
 800b634:	d804      	bhi.n	800b640 <st_prep_buffer+0xa7c>
 800b636:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b638:	b29a      	uxth	r2, r3
 800b63a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b63c:	805a      	strh	r2, [r3, #2]
 800b63e:	e003      	b.n	800b648 <st_prep_buffer+0xa84>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
 800b640:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b642:	2201      	movs	r2, #1
 800b644:	4252      	negs	r2, r2
 800b646:	805a      	strh	r2, [r3, #2]
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute it.
    segment_buffer_head = segment_next_head;
 800b648:	4b34      	ldr	r3, [pc, #208]	; (800b71c <st_prep_buffer+0xb58>)
 800b64a:	781a      	ldrb	r2, [r3, #0]
 800b64c:	4b34      	ldr	r3, [pc, #208]	; (800b720 <st_prep_buffer+0xb5c>)
 800b64e:	701a      	strb	r2, [r3, #0]
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
 800b650:	4b32      	ldr	r3, [pc, #200]	; (800b71c <st_prep_buffer+0xb58>)
 800b652:	781b      	ldrb	r3, [r3, #0]
 800b654:	3301      	adds	r3, #1
 800b656:	b2da      	uxtb	r2, r3
 800b658:	4b30      	ldr	r3, [pc, #192]	; (800b71c <st_prep_buffer+0xb58>)
 800b65a:	701a      	strb	r2, [r3, #0]
 800b65c:	4b2f      	ldr	r3, [pc, #188]	; (800b71c <st_prep_buffer+0xb58>)
 800b65e:	781b      	ldrb	r3, [r3, #0]
 800b660:	2b06      	cmp	r3, #6
 800b662:	d102      	bne.n	800b66a <st_prep_buffer+0xaa6>
 800b664:	4b2d      	ldr	r3, [pc, #180]	; (800b71c <st_prep_buffer+0xb58>)
 800b666:	2200      	movs	r2, #0
 800b668:	701a      	strb	r2, [r3, #0]

    // Update the appropriate planner and segment data.
    pl_block->millimeters = mm_remaining;
 800b66a:	4b2e      	ldr	r3, [pc, #184]	; (800b724 <st_prep_buffer+0xb60>)
 800b66c:	681b      	ldr	r3, [r3, #0]
 800b66e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800b670:	625a      	str	r2, [r3, #36]	; 0x24
    prep.steps_remaining = n_steps_remaining;
 800b672:	4b25      	ldr	r3, [pc, #148]	; (800b708 <st_prep_buffer+0xb44>)
 800b674:	6a3a      	ldr	r2, [r7, #32]
 800b676:	609a      	str	r2, [r3, #8]
    prep.dt_remainder = (n_steps_remaining - step_dist_remaining)*inv_rate;
 800b678:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800b67a:	6a38      	ldr	r0, [r7, #32]
 800b67c:	f7f5 fb2a 	bl	8000cd4 <__aeabi_fsub>
 800b680:	1c03      	adds	r3, r0, #0
 800b682:	69b9      	ldr	r1, [r7, #24]
 800b684:	1c18      	adds	r0, r3, #0
 800b686:	f7f5 fa05 	bl	8000a94 <__aeabi_fmul>
 800b68a:	1c03      	adds	r3, r0, #0
 800b68c:	1c1a      	adds	r2, r3, #0
 800b68e:	4b1e      	ldr	r3, [pc, #120]	; (800b708 <st_prep_buffer+0xb44>)
 800b690:	605a      	str	r2, [r3, #4]

    // Check for exit conditions and flag to load next planner block.
    if (mm_remaining == prep.mm_complete) {
 800b692:	4b1d      	ldr	r3, [pc, #116]	; (800b708 <st_prep_buffer+0xb44>)
 800b694:	699b      	ldr	r3, [r3, #24]
 800b696:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800b698:	1c18      	adds	r0, r3, #0
 800b69a:	f7f4 fe15 	bl	80002c8 <__aeabi_fcmpeq>
 800b69e:	1e03      	subs	r3, r0, #0
 800b6a0:	d100      	bne.n	800b6a4 <st_prep_buffer+0xae0>
 800b6a2:	e020      	b.n	800b6e6 <st_prep_buffer+0xb22>
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0f) { // At end of forced-termination.
 800b6a4:	2100      	movs	r1, #0
 800b6a6:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800b6a8:	f7f4 fe28 	bl	80002fc <__aeabi_fcmpgt>
 800b6ac:	1e03      	subs	r3, r0, #0
 800b6ae:	d007      	beq.n	800b6c0 <st_prep_buffer+0xafc>
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
 800b6b0:	4b1d      	ldr	r3, [pc, #116]	; (800b728 <st_prep_buffer+0xb64>)
 800b6b2:	791b      	ldrb	r3, [r3, #4]
 800b6b4:	2201      	movs	r2, #1
 800b6b6:	4313      	orrs	r3, r2
 800b6b8:	b2da      	uxtb	r2, r3
 800b6ba:	4b1b      	ldr	r3, [pc, #108]	; (800b728 <st_prep_buffer+0xb64>)
 800b6bc:	711a      	strb	r2, [r3, #4]
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Bail!
 800b6be:	e01f      	b.n	800b700 <st_prep_buffer+0xb3c>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
 800b6c0:	4b19      	ldr	r3, [pc, #100]	; (800b728 <st_prep_buffer+0xb64>)
 800b6c2:	791b      	ldrb	r3, [r3, #4]
 800b6c4:	001a      	movs	r2, r3
 800b6c6:	2304      	movs	r3, #4
 800b6c8:	4013      	ands	r3, r2
 800b6ca:	d007      	beq.n	800b6dc <st_prep_buffer+0xb18>
          bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
 800b6cc:	4b16      	ldr	r3, [pc, #88]	; (800b728 <st_prep_buffer+0xb64>)
 800b6ce:	791b      	ldrb	r3, [r3, #4]
 800b6d0:	2201      	movs	r2, #1
 800b6d2:	4313      	orrs	r3, r2
 800b6d4:	b2da      	uxtb	r2, r3
 800b6d6:	4b14      	ldr	r3, [pc, #80]	; (800b728 <st_prep_buffer+0xb64>)
 800b6d8:	711a      	strb	r2, [r3, #4]
          return;
 800b6da:	e011      	b.n	800b700 <st_prep_buffer+0xb3c>
        }
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
 800b6dc:	4b11      	ldr	r3, [pc, #68]	; (800b724 <st_prep_buffer+0xb60>)
 800b6de:	2200      	movs	r2, #0
 800b6e0:	601a      	str	r2, [r3, #0]
        plan_discard_current_block();
 800b6e2:	f7fb fb53 	bl	8006d8c <plan_discard_current_block>
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
 800b6e6:	4b11      	ldr	r3, [pc, #68]	; (800b72c <st_prep_buffer+0xb68>)
 800b6e8:	781b      	ldrb	r3, [r3, #0]
 800b6ea:	b2da      	uxtb	r2, r3
 800b6ec:	4b0b      	ldr	r3, [pc, #44]	; (800b71c <st_prep_buffer+0xb58>)
 800b6ee:	781b      	ldrb	r3, [r3, #0]
 800b6f0:	429a      	cmp	r2, r3
 800b6f2:	d001      	beq.n	800b6f8 <st_prep_buffer+0xb34>
 800b6f4:	f7ff fa73 	bl	800abde <st_prep_buffer+0x1a>
 800b6f8:	e002      	b.n	800b700 <st_prep_buffer+0xb3c>
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
 800b6fa:	46c0      	nop			; (mov r8, r8)
 800b6fc:	e000      	b.n	800b700 <st_prep_buffer+0xb3c>
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
 800b6fe:	46c0      	nop			; (mov r8, r8)
      }
    }

  }
}
 800b700:	46bd      	mov	sp, r7
 800b702:	b017      	add	sp, #92	; 0x5c
 800b704:	bd90      	pop	{r4, r7, pc}
 800b706:	46c0      	nop			; (mov r8, r8)
 800b708:	2000058c 	.word	0x2000058c
 800b70c:	20000010 	.word	0x20000010
 800b710:	000f4240 	.word	0x000f4240
 800b714:	42700000 	.word	0x42700000
 800b718:	0000ffff 	.word	0x0000ffff
 800b71c:	2000057a 	.word	0x2000057a
 800b720:	20000579 	.word	0x20000579
 800b724:	20000584 	.word	0x20000584
 800b728:	20000bb4 	.word	0x20000bb4
 800b72c:	20000578 	.word	0x20000578

0800b730 <st_get_realtime_rate>:
// Called by realtime status reporting to fetch the current speed being executed. This value
// however is not exactly the current speed, but the speed computed in the last step segment
// in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
// divided by the ACCELERATION TICKS PER SECOND in seconds.
float st_get_realtime_rate()
{
 800b730:	b580      	push	{r7, lr}
 800b732:	af00      	add	r7, sp, #0
  if (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_HOLD | STATE_JOG | STATE_SAFETY_DOOR)){
 800b734:	4b06      	ldr	r3, [pc, #24]	; (800b750 <st_get_realtime_rate+0x20>)
 800b736:	781b      	ldrb	r3, [r3, #0]
 800b738:	001a      	movs	r2, r3
 800b73a:	237c      	movs	r3, #124	; 0x7c
 800b73c:	4013      	ands	r3, r2
 800b73e:	d002      	beq.n	800b746 <st_get_realtime_rate+0x16>
    return prep.current_speed;
 800b740:	4b04      	ldr	r3, [pc, #16]	; (800b754 <st_get_realtime_rate+0x24>)
 800b742:	69db      	ldr	r3, [r3, #28]
 800b744:	e000      	b.n	800b748 <st_get_realtime_rate+0x18>
  }
  return 0.0f;
 800b746:	2300      	movs	r3, #0
}
 800b748:	1c18      	adds	r0, r3, #0
 800b74a:	46bd      	mov	sp, r7
 800b74c:	bd80      	pop	{r7, pc}
 800b74e:	46c0      	nop			; (mov r8, r8)
 800b750:	20000bb4 	.word	0x20000bb4
 800b754:	2000058c 	.word	0x2000058c

0800b758 <TIM_Configuration>:
	NVIC_Init(&NVIC_InitStructure);
}
#endif
#ifdef STM32F0DISCOVERY
void TIM_Configuration(TIM_TypeDef* TIMER, uint16_t Period, uint16_t Prescaler, uint8_t PP)
{
 800b758:	b590      	push	{r4, r7, lr}
 800b75a:	b089      	sub	sp, #36	; 0x24
 800b75c:	af00      	add	r7, sp, #0
 800b75e:	60f8      	str	r0, [r7, #12]
 800b760:	000c      	movs	r4, r1
 800b762:	0010      	movs	r0, r2
 800b764:	0019      	movs	r1, r3
 800b766:	230a      	movs	r3, #10
 800b768:	18fb      	adds	r3, r7, r3
 800b76a:	1c22      	adds	r2, r4, #0
 800b76c:	801a      	strh	r2, [r3, #0]
 800b76e:	2308      	movs	r3, #8
 800b770:	18fb      	adds	r3, r7, r3
 800b772:	1c02      	adds	r2, r0, #0
 800b774:	801a      	strh	r2, [r3, #0]
 800b776:	1dfb      	adds	r3, r7, #7
 800b778:	1c0a      	adds	r2, r1, #0
 800b77a:	701a      	strb	r2, [r3, #0]
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	TIM_TimeBaseStructure.TIM_Period = Period - 1;
 800b77c:	230a      	movs	r3, #10
 800b77e:	18fb      	adds	r3, r7, r3
 800b780:	881b      	ldrh	r3, [r3, #0]
 800b782:	3b01      	subs	r3, #1
 800b784:	001a      	movs	r2, r3
 800b786:	2314      	movs	r3, #20
 800b788:	18fb      	adds	r3, r7, r3
 800b78a:	605a      	str	r2, [r3, #4]
	TIM_TimeBaseStructure.TIM_Prescaler = Prescaler - 1;
 800b78c:	2308      	movs	r3, #8
 800b78e:	18fb      	adds	r3, r7, r3
 800b790:	881b      	ldrh	r3, [r3, #0]
 800b792:	3b01      	subs	r3, #1
 800b794:	b29a      	uxth	r2, r3
 800b796:	2314      	movs	r3, #20
 800b798:	18fb      	adds	r3, r7, r3
 800b79a:	801a      	strh	r2, [r3, #0]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 800b79c:	2314      	movs	r3, #20
 800b79e:	18fb      	adds	r3, r7, r3
 800b7a0:	2200      	movs	r2, #0
 800b7a2:	811a      	strh	r2, [r3, #8]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 800b7a4:	2314      	movs	r3, #20
 800b7a6:	18fb      	adds	r3, r7, r3
 800b7a8:	2200      	movs	r2, #0
 800b7aa:	805a      	strh	r2, [r3, #2]
	TIM_TimeBaseInit(TIMER, &TIM_TimeBaseStructure);
 800b7ac:	2314      	movs	r3, #20
 800b7ae:	18fa      	adds	r2, r7, r3
 800b7b0:	68fb      	ldr	r3, [r7, #12]
 800b7b2:	0011      	movs	r1, r2
 800b7b4:	0018      	movs	r0, r3
 800b7b6:	f7f7 fd01 	bl	80031bc <TIM_TimeBaseInit>

	TIM_ClearITPendingBit(TIMER, TIM_IT_Update);
 800b7ba:	68fb      	ldr	r3, [r7, #12]
 800b7bc:	2101      	movs	r1, #1
 800b7be:	0018      	movs	r0, r3
 800b7c0:	f7f7 fef7 	bl	80035b2 <TIM_ClearITPendingBit>
	TIM_ITConfig(TIMER, TIM_IT_Update, ENABLE);
 800b7c4:	68fb      	ldr	r3, [r7, #12]
 800b7c6:	2201      	movs	r2, #1
 800b7c8:	2101      	movs	r1, #1
 800b7ca:	0018      	movs	r0, r3
 800b7cc:	f7f7 fec8 	bl	8003560 <TIM_ITConfig>
	TIM_Cmd(TIMER, ENABLE);
 800b7d0:	68fb      	ldr	r3, [r7, #12]
 800b7d2:	2101      	movs	r1, #1
 800b7d4:	0018      	movs	r0, r3
 800b7d6:	f7f7 fd81 	bl	80032dc <TIM_Cmd>

	//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
	if (TIMER == TIM2) { NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; }
 800b7da:	68fa      	ldr	r2, [r7, #12]
 800b7dc:	2380      	movs	r3, #128	; 0x80
 800b7de:	05db      	lsls	r3, r3, #23
 800b7e0:	429a      	cmp	r2, r3
 800b7e2:	d104      	bne.n	800b7ee <TIM_Configuration+0x96>
 800b7e4:	2310      	movs	r3, #16
 800b7e6:	18fb      	adds	r3, r7, r3
 800b7e8:	220f      	movs	r2, #15
 800b7ea:	701a      	strb	r2, [r3, #0]
 800b7ec:	e010      	b.n	800b810 <TIM_Configuration+0xb8>
	else if (TIMER == TIM3) { NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn; }
 800b7ee:	68fb      	ldr	r3, [r7, #12]
 800b7f0:	4a10      	ldr	r2, [pc, #64]	; (800b834 <TIM_Configuration+0xdc>)
 800b7f2:	4293      	cmp	r3, r2
 800b7f4:	d104      	bne.n	800b800 <TIM_Configuration+0xa8>
 800b7f6:	2310      	movs	r3, #16
 800b7f8:	18fb      	adds	r3, r7, r3
 800b7fa:	2210      	movs	r2, #16
 800b7fc:	701a      	strb	r2, [r3, #0]
 800b7fe:	e007      	b.n	800b810 <TIM_Configuration+0xb8>
	else if (TIMER == TIM6) { NVIC_InitStructure.NVIC_IRQChannel = TIM6_DAC_IRQn; } // Was TIM4
 800b800:	68fb      	ldr	r3, [r7, #12]
 800b802:	4a0d      	ldr	r2, [pc, #52]	; (800b838 <TIM_Configuration+0xe0>)
 800b804:	4293      	cmp	r3, r2
 800b806:	d103      	bne.n	800b810 <TIM_Configuration+0xb8>
 800b808:	2310      	movs	r3, #16
 800b80a:	18fb      	adds	r3, r7, r3
 800b80c:	2211      	movs	r2, #17
 800b80e:	701a      	strb	r2, [r3, #0]

	//NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = PP;
	//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelPriority = PP;
 800b810:	2310      	movs	r3, #16
 800b812:	18fb      	adds	r3, r7, r3
 800b814:	1dfa      	adds	r2, r7, #7
 800b816:	7812      	ldrb	r2, [r2, #0]
 800b818:	705a      	strb	r2, [r3, #1]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800b81a:	2310      	movs	r3, #16
 800b81c:	18fb      	adds	r3, r7, r3
 800b81e:	2201      	movs	r2, #1
 800b820:	709a      	strb	r2, [r3, #2]
	NVIC_Init(&NVIC_InitStructure);
 800b822:	2310      	movs	r3, #16
 800b824:	18fb      	adds	r3, r7, r3
 800b826:	0018      	movs	r0, r3
 800b828:	f7f7 fa2a 	bl	8002c80 <NVIC_Init>
}
 800b82c:	46c0      	nop			; (mov r8, r8)
 800b82e:	46bd      	mov	sp, r7
 800b830:	b009      	add	sp, #36	; 0x24
 800b832:	bd90      	pop	{r4, r7, pc}
 800b834:	40000400 	.word	0x40000400
 800b838:	40001000 	.word	0x40001000

0800b83c <system_init>:

#include "grbl.h"


void system_init()
{
 800b83c:	b580      	push	{r7, lr}
 800b83e:	b086      	sub	sp, #24
 800b840:	af00      	add	r7, sp, #0
  NVIC_Init(&NVIC_InitStructure);
#endif
#ifdef STM32F0DISCOVERY
  GPIO_InitTypeDef GPIO_InitStructure;
  //RCC_APB2PeriphClockCmd(RCC_CONTROL_PORT | RCC_APB2Periph_AFIO, ENABLE);
  RCC_AHBPeriphClockCmd(RCC_CONTROL_PORT, ENABLE);
 800b842:	2380      	movs	r3, #128	; 0x80
 800b844:	02db      	lsls	r3, r3, #11
 800b846:	2101      	movs	r1, #1
 800b848:	0018      	movs	r0, r3
 800b84a:	f7f7 fc2d 	bl	80030a8 <RCC_AHBPeriphClockCmd>
  /* Enable SYSCFG's APB interface clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 800b84e:	2101      	movs	r1, #1
 800b850:	2001      	movs	r0, #1
 800b852:	f7f7 fc49 	bl	80030e8 <RCC_APB2PeriphClockCmd>
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800b856:	2310      	movs	r3, #16
 800b858:	18fb      	adds	r3, r7, r3
 800b85a:	2203      	movs	r2, #3
 800b85c:	715a      	strb	r2, [r3, #5]
#ifdef DISABLE_CONTROL_PIN_PULL_UP
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
#else
  //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 800b85e:	2310      	movs	r3, #16
 800b860:	18fb      	adds	r3, r7, r3
 800b862:	2200      	movs	r2, #0
 800b864:	711a      	strb	r2, [r3, #4]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 800b866:	2310      	movs	r3, #16
 800b868:	18fb      	adds	r3, r7, r3
 800b86a:	2201      	movs	r2, #1
 800b86c:	71da      	strb	r2, [r3, #7]
#endif
  GPIO_InitStructure.GPIO_Pin = CONTROL_MASK;
 800b86e:	2310      	movs	r3, #16
 800b870:	18fb      	adds	r3, r7, r3
 800b872:	22f0      	movs	r2, #240	; 0xf0
 800b874:	0052      	lsls	r2, r2, #1
 800b876:	601a      	str	r2, [r3, #0]
  GPIO_Init(CONTROL_PORT, &GPIO_InitStructure);
 800b878:	2310      	movs	r3, #16
 800b87a:	18fb      	adds	r3, r7, r3
 800b87c:	4a1d      	ldr	r2, [pc, #116]	; (800b8f4 <system_init+0xb8>)
 800b87e:	0019      	movs	r1, r3
 800b880:	0010      	movs	r0, r2
 800b882:	f7f7 f8b7 	bl	80029f4 <GPIO_Init>

  SYSCFG_EXTILineConfig(GPIO_CONTROL_PORT, CONTROL_RESET_BIT);
 800b886:	2105      	movs	r1, #5
 800b888:	2001      	movs	r0, #1
 800b88a:	f7f7 fc4d 	bl	8003128 <SYSCFG_EXTILineConfig>
  SYSCFG_EXTILineConfig(GPIO_CONTROL_PORT, CONTROL_FEED_HOLD_BIT);
 800b88e:	2106      	movs	r1, #6
 800b890:	2001      	movs	r0, #1
 800b892:	f7f7 fc49 	bl	8003128 <SYSCFG_EXTILineConfig>
  SYSCFG_EXTILineConfig(GPIO_CONTROL_PORT, CONTROL_CYCLE_START_BIT);
 800b896:	2107      	movs	r1, #7
 800b898:	2001      	movs	r0, #1
 800b89a:	f7f7 fc45 	bl	8003128 <SYSCFG_EXTILineConfig>
  SYSCFG_EXTILineConfig(GPIO_CONTROL_PORT, CONTROL_SAFETY_DOOR_BIT);
 800b89e:	2108      	movs	r1, #8
 800b8a0:	2001      	movs	r0, #1
 800b8a2:	f7f7 fc41 	bl	8003128 <SYSCFG_EXTILineConfig>

  EXTI_InitTypeDef EXTI_InitStructure;
  EXTI_InitStructure.EXTI_Line = CONTROL_MASK;    //
 800b8a6:	2308      	movs	r3, #8
 800b8a8:	18fb      	adds	r3, r7, r3
 800b8aa:	22f0      	movs	r2, #240	; 0xf0
 800b8ac:	0052      	lsls	r2, r2, #1
 800b8ae:	601a      	str	r2, [r3, #0]
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt; //Interrupt mode, optional values for the interrupt EXTI_Mode_Interrupt and event EXTI_Mode_Event.
 800b8b0:	2308      	movs	r3, #8
 800b8b2:	18fb      	adds	r3, r7, r3
 800b8b4:	2200      	movs	r2, #0
 800b8b6:	711a      	strb	r2, [r3, #4]
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling; //Trigger mode, can be a falling edge trigger EXTI_Trigger_Falling, the rising edge triggered EXTI_Trigger_Rising, or any level (rising edge and falling edge trigger EXTI_Trigger_Rising_Falling)
 800b8b8:	2308      	movs	r3, #8
 800b8ba:	18fb      	adds	r3, r7, r3
 800b8bc:	220c      	movs	r2, #12
 800b8be:	715a      	strb	r2, [r3, #5]
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 800b8c0:	2308      	movs	r3, #8
 800b8c2:	18fb      	adds	r3, r7, r3
 800b8c4:	2201      	movs	r2, #1
 800b8c6:	719a      	strb	r2, [r3, #6]
  EXTI_Init(&EXTI_InitStructure);
 800b8c8:	2308      	movs	r3, #8
 800b8ca:	18fb      	adds	r3, r7, r3
 800b8cc:	0018      	movs	r0, r3
 800b8ce:	f7f6 fff3 	bl	80028b8 <EXTI_Init>

  NVIC_InitTypeDef NVIC_InitStructure;
  NVIC_InitStructure.NVIC_IRQChannel = EXTI4_15_IRQn; //Enable keypad external interrupt channel
 800b8d2:	1d3b      	adds	r3, r7, #4
 800b8d4:	2207      	movs	r2, #7
 800b8d6:	701a      	strb	r2, [r3, #0]
  //NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //Priority 2,
  //NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02; //Sub priority 2
  NVIC_InitStructure.NVIC_IRQChannelPriority = 0x02; // Priority 2
 800b8d8:	1d3b      	adds	r3, r7, #4
 800b8da:	2202      	movs	r2, #2
 800b8dc:	705a      	strb	r2, [r3, #1]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //Enable external interrupt channel
 800b8de:	1d3b      	adds	r3, r7, #4
 800b8e0:	2201      	movs	r2, #1
 800b8e2:	709a      	strb	r2, [r3, #2]
  NVIC_Init(&NVIC_InitStructure);
 800b8e4:	1d3b      	adds	r3, r7, #4
 800b8e6:	0018      	movs	r0, r3
 800b8e8:	f7f7 f9ca 	bl	8002c80 <NVIC_Init>
#endif
}
 800b8ec:	46c0      	nop			; (mov r8, r8)
 800b8ee:	46bd      	mov	sp, r7
 800b8f0:	b006      	add	sp, #24
 800b8f2:	bd80      	pop	{r7, pc}
 800b8f4:	48000400 	.word	0x48000400

0800b8f8 <system_control_get_state>:

// Returns control pin state as a uint8 bitfield. Each bit indicates the input pin state, where
// triggered is 1 and not triggered is 0. Invert mask is applied. Bitfield organization is
// defined by the CONTROL_PIN_INDEX in the header file.
uint8_t system_control_get_state()
{
 800b8f8:	b590      	push	{r4, r7, lr}
 800b8fa:	b083      	sub	sp, #12
 800b8fc:	af00      	add	r7, sp, #0
  uint8_t control_state = 0;
 800b8fe:	1dfb      	adds	r3, r7, #7
 800b900:	2200      	movs	r2, #0
 800b902:	701a      	strb	r2, [r3, #0]
#endif
#ifdef STM32F103C8
  uint16_t pin= GPIO_ReadInputData(CONTROL_PIN_PORT);
#endif
#ifdef STM32F0DISCOVERY
  uint16_t pin= GPIO_ReadInputData(CONTROL_PIN_PORT);
 800b904:	1d3c      	adds	r4, r7, #4
 800b906:	4b18      	ldr	r3, [pc, #96]	; (800b968 <system_control_get_state+0x70>)
 800b908:	0018      	movs	r0, r3
 800b90a:	f7f7 f906 	bl	8002b1a <GPIO_ReadInputData>
 800b90e:	0003      	movs	r3, r0
 800b910:	8023      	strh	r3, [r4, #0]
#endif
  #ifdef INVERT_CONTROL_PIN_MASK
    pin ^= INVERT_CONTROL_PIN_MASK;
  #endif
  if (pin) {
 800b912:	1d3b      	adds	r3, r7, #4
 800b914:	881b      	ldrh	r3, [r3, #0]
 800b916:	2b00      	cmp	r3, #0
 800b918:	d020      	beq.n	800b95c <system_control_get_state+0x64>
    #ifdef ENABLE_SAFETY_DOOR_INPUT_PIN
      if (bit_isfalse(pin,(1<<CONTROL_SAFETY_DOOR_BIT))) { control_state |= CONTROL_PIN_INDEX_SAFETY_DOOR; }
    #endif
    if (bit_isfalse(pin,(1<<CONTROL_RESET_BIT))) { control_state |= CONTROL_PIN_INDEX_RESET; }
 800b91a:	1d3b      	adds	r3, r7, #4
 800b91c:	881b      	ldrh	r3, [r3, #0]
 800b91e:	2220      	movs	r2, #32
 800b920:	4013      	ands	r3, r2
 800b922:	d105      	bne.n	800b930 <system_control_get_state+0x38>
 800b924:	1dfb      	adds	r3, r7, #7
 800b926:	1dfa      	adds	r2, r7, #7
 800b928:	7812      	ldrb	r2, [r2, #0]
 800b92a:	2101      	movs	r1, #1
 800b92c:	430a      	orrs	r2, r1
 800b92e:	701a      	strb	r2, [r3, #0]
    if (bit_isfalse(pin,(1<<CONTROL_FEED_HOLD_BIT))) { control_state |= CONTROL_PIN_INDEX_FEED_HOLD; }
 800b930:	1d3b      	adds	r3, r7, #4
 800b932:	881b      	ldrh	r3, [r3, #0]
 800b934:	2240      	movs	r2, #64	; 0x40
 800b936:	4013      	ands	r3, r2
 800b938:	d105      	bne.n	800b946 <system_control_get_state+0x4e>
 800b93a:	1dfb      	adds	r3, r7, #7
 800b93c:	1dfa      	adds	r2, r7, #7
 800b93e:	7812      	ldrb	r2, [r2, #0]
 800b940:	2102      	movs	r1, #2
 800b942:	430a      	orrs	r2, r1
 800b944:	701a      	strb	r2, [r3, #0]
    if (bit_isfalse(pin,(1<<CONTROL_CYCLE_START_BIT))) { control_state |= CONTROL_PIN_INDEX_CYCLE_START; }
 800b946:	1d3b      	adds	r3, r7, #4
 800b948:	881b      	ldrh	r3, [r3, #0]
 800b94a:	2280      	movs	r2, #128	; 0x80
 800b94c:	4013      	ands	r3, r2
 800b94e:	d105      	bne.n	800b95c <system_control_get_state+0x64>
 800b950:	1dfb      	adds	r3, r7, #7
 800b952:	1dfa      	adds	r2, r7, #7
 800b954:	7812      	ldrb	r2, [r2, #0]
 800b956:	2104      	movs	r1, #4
 800b958:	430a      	orrs	r2, r1
 800b95a:	701a      	strb	r2, [r3, #0]
  }
  return(control_state);
 800b95c:	1dfb      	adds	r3, r7, #7
 800b95e:	781b      	ldrb	r3, [r3, #0]
}
 800b960:	0018      	movs	r0, r3
 800b962:	46bd      	mov	sp, r7
 800b964:	b003      	add	sp, #12
 800b966:	bd90      	pop	{r4, r7, pc}
 800b968:	48000400 	.word	0x48000400

0800b96c <system_check_safety_door_ajar>:
}
#endif

// Returns if safety door is ajar(T) or closed(F), based on pin state.
uint8_t system_check_safety_door_ajar()
{
 800b96c:	b580      	push	{r7, lr}
 800b96e:	af00      	add	r7, sp, #0
  #ifdef ENABLE_SAFETY_DOOR_INPUT_PIN
    return(system_control_get_state() & CONTROL_PIN_INDEX_SAFETY_DOOR);
  #else
    return(false); // Input pin not enabled, so just return that it's closed.
 800b970:	2300      	movs	r3, #0
  #endif
}
 800b972:	0018      	movs	r0, r3
 800b974:	46bd      	mov	sp, r7
 800b976:	bd80      	pop	{r7, pc}

0800b978 <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line)
{
 800b978:	b590      	push	{r4, r7, lr}
 800b97a:	b085      	sub	sp, #20
 800b97c:	af00      	add	r7, sp, #0
 800b97e:	6078      	str	r0, [r7, #4]
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
 800b980:	230f      	movs	r3, #15
 800b982:	18fb      	adds	r3, r7, r3
 800b984:	2200      	movs	r2, #0
 800b986:	701a      	strb	r2, [r3, #0]
 800b988:	e02d      	b.n	800b9e6 <system_execute_startup+0x6e>
    if (!(settings_read_startup_line(n, line))) {
 800b98a:	687a      	ldr	r2, [r7, #4]
 800b98c:	230f      	movs	r3, #15
 800b98e:	18fb      	adds	r3, r7, r3
 800b990:	781b      	ldrb	r3, [r3, #0]
 800b992:	0011      	movs	r1, r2
 800b994:	0018      	movs	r0, r3
 800b996:	f7fd ffdf 	bl	8009958 <settings_read_startup_line>
 800b99a:	1e03      	subs	r3, r0, #0
 800b99c:	d108      	bne.n	800b9b0 <system_execute_startup+0x38>
      line[0] = 0;
 800b99e:	687b      	ldr	r3, [r7, #4]
 800b9a0:	2200      	movs	r2, #0
 800b9a2:	701a      	strb	r2, [r3, #0]
      report_execute_startup_message(line,STATUS_SETTING_READ_FAIL);
 800b9a4:	687b      	ldr	r3, [r7, #4]
 800b9a6:	2107      	movs	r1, #7
 800b9a8:	0018      	movs	r0, r3
 800b9aa:	f7fd fa6f 	bl	8008e8c <report_execute_startup_message>
 800b9ae:	e013      	b.n	800b9d8 <system_execute_startup+0x60>
    } else {
      if (line[0] != 0) {
 800b9b0:	687b      	ldr	r3, [r7, #4]
 800b9b2:	781b      	ldrb	r3, [r3, #0]
 800b9b4:	2b00      	cmp	r3, #0
 800b9b6:	d00f      	beq.n	800b9d8 <system_execute_startup+0x60>
        uint8_t status_code = gc_execute_line(line);
 800b9b8:	230e      	movs	r3, #14
 800b9ba:	18fc      	adds	r4, r7, r3
 800b9bc:	687b      	ldr	r3, [r7, #4]
 800b9be:	0018      	movs	r0, r3
 800b9c0:	f7f8 f860 	bl	8003a84 <gc_execute_line>
 800b9c4:	0003      	movs	r3, r0
 800b9c6:	7023      	strb	r3, [r4, #0]
        report_execute_startup_message(line,status_code);
 800b9c8:	230e      	movs	r3, #14
 800b9ca:	18fb      	adds	r3, r7, r3
 800b9cc:	781a      	ldrb	r2, [r3, #0]
 800b9ce:	687b      	ldr	r3, [r7, #4]
 800b9d0:	0011      	movs	r1, r2
 800b9d2:	0018      	movs	r0, r3
 800b9d4:	f7fd fa5a 	bl	8008e8c <report_execute_startup_message>
  for (n=0; n < N_STARTUP_LINE; n++) {
 800b9d8:	230f      	movs	r3, #15
 800b9da:	18fb      	adds	r3, r7, r3
 800b9dc:	781a      	ldrb	r2, [r3, #0]
 800b9de:	230f      	movs	r3, #15
 800b9e0:	18fb      	adds	r3, r7, r3
 800b9e2:	3201      	adds	r2, #1
 800b9e4:	701a      	strb	r2, [r3, #0]
 800b9e6:	230f      	movs	r3, #15
 800b9e8:	18fb      	adds	r3, r7, r3
 800b9ea:	781b      	ldrb	r3, [r3, #0]
 800b9ec:	2b01      	cmp	r3, #1
 800b9ee:	d9cc      	bls.n	800b98a <system_execute_startup+0x12>
      }
    }
  }
}
 800b9f0:	46c0      	nop			; (mov r8, r8)
 800b9f2:	46bd      	mov	sp, r7
 800b9f4:	b005      	add	sp, #20
 800b9f6:	bd90      	pop	{r4, r7, pc}

0800b9f8 <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle,
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line)
{
 800b9f8:	b590      	push	{r4, r7, lr}
 800b9fa:	b087      	sub	sp, #28
 800b9fc:	af00      	add	r7, sp, #0
 800b9fe:	6078      	str	r0, [r7, #4]
  uint8_t char_counter = 1;
 800ba00:	2316      	movs	r3, #22
 800ba02:	18fb      	adds	r3, r7, r3
 800ba04:	2201      	movs	r2, #1
 800ba06:	701a      	strb	r2, [r3, #0]
  uint8_t helper_var = 0; // Helper variable
 800ba08:	2317      	movs	r3, #23
 800ba0a:	18fb      	adds	r3, r7, r3
 800ba0c:	2200      	movs	r2, #0
 800ba0e:	701a      	strb	r2, [r3, #0]
  float parameter, value;
  switch( line[char_counter] ) {
 800ba10:	2316      	movs	r3, #22
 800ba12:	18fb      	adds	r3, r7, r3
 800ba14:	781b      	ldrb	r3, [r3, #0]
 800ba16:	001a      	movs	r2, r3
 800ba18:	687b      	ldr	r3, [r7, #4]
 800ba1a:	189b      	adds	r3, r3, r2
 800ba1c:	781b      	ldrb	r3, [r3, #0]
 800ba1e:	2b43      	cmp	r3, #67	; 0x43
 800ba20:	d026      	beq.n	800ba70 <system_execute_line+0x78>
 800ba22:	dc04      	bgt.n	800ba2e <system_execute_line+0x36>
 800ba24:	2b00      	cmp	r3, #0
 800ba26:	d009      	beq.n	800ba3c <system_execute_line+0x44>
 800ba28:	2b24      	cmp	r3, #36	; 0x24
 800ba2a:	d021      	beq.n	800ba70 <system_execute_line+0x78>
 800ba2c:	e06c      	b.n	800bb08 <system_execute_line+0x110>
 800ba2e:	2b4a      	cmp	r3, #74	; 0x4a
 800ba30:	d007      	beq.n	800ba42 <system_execute_line+0x4a>
 800ba32:	2b58      	cmp	r3, #88	; 0x58
 800ba34:	d01c      	beq.n	800ba70 <system_execute_line+0x78>
 800ba36:	2b47      	cmp	r3, #71	; 0x47
 800ba38:	d01a      	beq.n	800ba70 <system_execute_line+0x78>
 800ba3a:	e065      	b.n	800bb08 <system_execute_line+0x110>
    case 0 : report_grbl_help(); break;
 800ba3c:	f7fc ff60 	bl	8008900 <report_grbl_help>
 800ba40:	e23f      	b.n	800bec2 <system_execute_line+0x4ca>
    case 'J' : // Jogging
      // Execute only if in IDLE or JOG states.
      if (sys.state != STATE_IDLE && sys.state != STATE_JOG) { return(STATUS_IDLE_ERROR); }
 800ba42:	4bbc      	ldr	r3, [pc, #752]	; (800bd34 <system_execute_line+0x33c>)
 800ba44:	781b      	ldrb	r3, [r3, #0]
 800ba46:	2b00      	cmp	r3, #0
 800ba48:	d005      	beq.n	800ba56 <system_execute_line+0x5e>
 800ba4a:	4bba      	ldr	r3, [pc, #744]	; (800bd34 <system_execute_line+0x33c>)
 800ba4c:	781b      	ldrb	r3, [r3, #0]
 800ba4e:	2b20      	cmp	r3, #32
 800ba50:	d001      	beq.n	800ba56 <system_execute_line+0x5e>
 800ba52:	2308      	movs	r3, #8
 800ba54:	e236      	b.n	800bec4 <system_execute_line+0x4cc>
      if(line[2] != '=') { return(STATUS_INVALID_STATEMENT); }
 800ba56:	687b      	ldr	r3, [r7, #4]
 800ba58:	3302      	adds	r3, #2
 800ba5a:	781b      	ldrb	r3, [r3, #0]
 800ba5c:	2b3d      	cmp	r3, #61	; 0x3d
 800ba5e:	d001      	beq.n	800ba64 <system_execute_line+0x6c>
 800ba60:	2303      	movs	r3, #3
 800ba62:	e22f      	b.n	800bec4 <system_execute_line+0x4cc>
      return(gc_execute_line(line)); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
 800ba64:	687b      	ldr	r3, [r7, #4]
 800ba66:	0018      	movs	r0, r3
 800ba68:	f7f8 f80c 	bl	8003a84 <gc_execute_line>
 800ba6c:	0003      	movs	r3, r0
 800ba6e:	e229      	b.n	800bec4 <system_execute_line+0x4cc>
      break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
 800ba70:	687b      	ldr	r3, [r7, #4]
 800ba72:	3302      	adds	r3, #2
 800ba74:	781b      	ldrb	r3, [r3, #0]
 800ba76:	2b00      	cmp	r3, #0
 800ba78:	d001      	beq.n	800ba7e <system_execute_line+0x86>
 800ba7a:	2303      	movs	r3, #3
 800ba7c:	e222      	b.n	800bec4 <system_execute_line+0x4cc>
      switch( line[1] ) {
 800ba7e:	687b      	ldr	r3, [r7, #4]
 800ba80:	3301      	adds	r3, #1
 800ba82:	781b      	ldrb	r3, [r3, #0]
 800ba84:	2b43      	cmp	r3, #67	; 0x43
 800ba86:	d016      	beq.n	800bab6 <system_execute_line+0xbe>
 800ba88:	dc02      	bgt.n	800ba90 <system_execute_line+0x98>
 800ba8a:	2b24      	cmp	r3, #36	; 0x24
 800ba8c:	d005      	beq.n	800ba9a <system_execute_line+0xa2>
            sys.state = STATE_IDLE;
            // Don't run startup script. Prevents stored moves in startup from causing accidents.
          } // Otherwise, no effect.
          break;
      }
      break;
 800ba8e:	e218      	b.n	800bec2 <system_execute_line+0x4ca>
      switch( line[1] ) {
 800ba90:	2b47      	cmp	r3, #71	; 0x47
 800ba92:	d00d      	beq.n	800bab0 <system_execute_line+0xb8>
 800ba94:	2b58      	cmp	r3, #88	; 0x58
 800ba96:	d025      	beq.n	800bae4 <system_execute_line+0xec>
      break;
 800ba98:	e213      	b.n	800bec2 <system_execute_line+0x4ca>
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
 800ba9a:	4ba6      	ldr	r3, [pc, #664]	; (800bd34 <system_execute_line+0x33c>)
 800ba9c:	781b      	ldrb	r3, [r3, #0]
 800ba9e:	001a      	movs	r2, r3
 800baa0:	2318      	movs	r3, #24
 800baa2:	4013      	ands	r3, r2
 800baa4:	d001      	beq.n	800baaa <system_execute_line+0xb2>
 800baa6:	2308      	movs	r3, #8
 800baa8:	e20c      	b.n	800bec4 <system_execute_line+0x4cc>
          else { report_grbl_settings(); }
 800baaa:	f7fc ff35 	bl	8008918 <report_grbl_settings>
          break;
 800baae:	e02a      	b.n	800bb06 <system_execute_line+0x10e>
          report_gcode_modes();
 800bab0:	f7fd f918 	bl	8008ce4 <report_gcode_modes>
          break;
 800bab4:	e027      	b.n	800bb06 <system_execute_line+0x10e>
          if ( sys.state == STATE_CHECK_MODE ) {
 800bab6:	4b9f      	ldr	r3, [pc, #636]	; (800bd34 <system_execute_line+0x33c>)
 800bab8:	781b      	ldrb	r3, [r3, #0]
 800baba:	2b02      	cmp	r3, #2
 800babc:	d105      	bne.n	800baca <system_execute_line+0xd2>
            mc_reset();
 800babe:	f7fa fd59 	bl	8006574 <mc_reset>
            report_feedback_message(MESSAGE_DISABLED);
 800bac2:	2005      	movs	r0, #5
 800bac4:	f7fc fea6 	bl	8008814 <report_feedback_message>
          break;
 800bac8:	e01d      	b.n	800bb06 <system_execute_line+0x10e>
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
 800baca:	4b9a      	ldr	r3, [pc, #616]	; (800bd34 <system_execute_line+0x33c>)
 800bacc:	781b      	ldrb	r3, [r3, #0]
 800bace:	2b00      	cmp	r3, #0
 800bad0:	d001      	beq.n	800bad6 <system_execute_line+0xde>
 800bad2:	2308      	movs	r3, #8
 800bad4:	e1f6      	b.n	800bec4 <system_execute_line+0x4cc>
            sys.state = STATE_CHECK_MODE;
 800bad6:	4b97      	ldr	r3, [pc, #604]	; (800bd34 <system_execute_line+0x33c>)
 800bad8:	2202      	movs	r2, #2
 800bada:	701a      	strb	r2, [r3, #0]
            report_feedback_message(MESSAGE_ENABLED);
 800badc:	2004      	movs	r0, #4
 800bade:	f7fc fe99 	bl	8008814 <report_feedback_message>
          break;
 800bae2:	e010      	b.n	800bb06 <system_execute_line+0x10e>
          if (sys.state == STATE_ALARM) {
 800bae4:	4b93      	ldr	r3, [pc, #588]	; (800bd34 <system_execute_line+0x33c>)
 800bae6:	781b      	ldrb	r3, [r3, #0]
 800bae8:	2b01      	cmp	r3, #1
 800baea:	d10b      	bne.n	800bb04 <system_execute_line+0x10c>
            if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); }
 800baec:	f7ff ff3e 	bl	800b96c <system_check_safety_door_ajar>
 800baf0:	1e03      	subs	r3, r0, #0
 800baf2:	d001      	beq.n	800baf8 <system_execute_line+0x100>
 800baf4:	230d      	movs	r3, #13
 800baf6:	e1e5      	b.n	800bec4 <system_execute_line+0x4cc>
            report_feedback_message(MESSAGE_ALARM_UNLOCK);
 800baf8:	2003      	movs	r0, #3
 800bafa:	f7fc fe8b 	bl	8008814 <report_feedback_message>
            sys.state = STATE_IDLE;
 800bafe:	4b8d      	ldr	r3, [pc, #564]	; (800bd34 <system_execute_line+0x33c>)
 800bb00:	2200      	movs	r2, #0
 800bb02:	701a      	strb	r2, [r3, #0]
          break;
 800bb04:	46c0      	nop			; (mov r8, r8)
      break;
 800bb06:	e1dc      	b.n	800bec2 <system_execute_line+0x4ca>
    default :
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
 800bb08:	4b8a      	ldr	r3, [pc, #552]	; (800bd34 <system_execute_line+0x33c>)
 800bb0a:	781b      	ldrb	r3, [r3, #0]
 800bb0c:	2b00      	cmp	r3, #0
 800bb0e:	d005      	beq.n	800bb1c <system_execute_line+0x124>
 800bb10:	4b88      	ldr	r3, [pc, #544]	; (800bd34 <system_execute_line+0x33c>)
 800bb12:	781b      	ldrb	r3, [r3, #0]
 800bb14:	2b01      	cmp	r3, #1
 800bb16:	d001      	beq.n	800bb1c <system_execute_line+0x124>
 800bb18:	2308      	movs	r3, #8
 800bb1a:	e1d3      	b.n	800bec4 <system_execute_line+0x4cc>
      switch( line[1] ) {
 800bb1c:	687b      	ldr	r3, [r7, #4]
 800bb1e:	3301      	adds	r3, #1
 800bb20:	781b      	ldrb	r3, [r3, #0]
 800bb22:	3b23      	subs	r3, #35	; 0x23
 800bb24:	2b30      	cmp	r3, #48	; 0x30
 800bb26:	d900      	bls.n	800bb2a <system_execute_line+0x132>
 800bb28:	e129      	b.n	800bd7e <system_execute_line+0x386>
 800bb2a:	009a      	lsls	r2, r3, #2
 800bb2c:	4b82      	ldr	r3, [pc, #520]	; (800bd38 <system_execute_line+0x340>)
 800bb2e:	18d3      	adds	r3, r2, r3
 800bb30:	681b      	ldr	r3, [r3, #0]
 800bb32:	469f      	mov	pc, r3
        case '#' : // Print Grbl NGC parameters
          if ( line[2] != 0 ) { return(STATUS_INVALID_STATEMENT); }
 800bb34:	687b      	ldr	r3, [r7, #4]
 800bb36:	3302      	adds	r3, #2
 800bb38:	781b      	ldrb	r3, [r3, #0]
 800bb3a:	2b00      	cmp	r3, #0
 800bb3c:	d001      	beq.n	800bb42 <system_execute_line+0x14a>
 800bb3e:	2303      	movs	r3, #3
 800bb40:	e1c0      	b.n	800bec4 <system_execute_line+0x4cc>
          else { report_ngc_parameters(); }
 800bb42:	f7fd f85d 	bl	8008c00 <report_ngc_parameters>
          break;
 800bb46:	e1bc      	b.n	800bec2 <system_execute_line+0x4ca>
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_isfalse(settings.flags,BITFLAG_HOMING_ENABLE)) {return(STATUS_SETTING_DISABLED); }
 800bb48:	4b7c      	ldr	r3, [pc, #496]	; (800bd3c <system_execute_line+0x344>)
 800bb4a:	2258      	movs	r2, #88	; 0x58
 800bb4c:	5c9b      	ldrb	r3, [r3, r2]
 800bb4e:	001a      	movs	r2, r3
 800bb50:	2310      	movs	r3, #16
 800bb52:	4013      	ands	r3, r2
 800bb54:	d101      	bne.n	800bb5a <system_execute_line+0x162>
 800bb56:	2305      	movs	r3, #5
 800bb58:	e1b4      	b.n	800bec4 <system_execute_line+0x4cc>
          if (system_check_safety_door_ajar()) { return(STATUS_CHECK_DOOR); } // Block if safety door is ajar.
 800bb5a:	f7ff ff07 	bl	800b96c <system_check_safety_door_ajar>
 800bb5e:	1e03      	subs	r3, r0, #0
 800bb60:	d001      	beq.n	800bb66 <system_execute_line+0x16e>
 800bb62:	230d      	movs	r3, #13
 800bb64:	e1ae      	b.n	800bec4 <system_execute_line+0x4cc>
          sys.state = STATE_HOMING; // Set system state variable
 800bb66:	4b73      	ldr	r3, [pc, #460]	; (800bd34 <system_execute_line+0x33c>)
 800bb68:	2204      	movs	r2, #4
 800bb6a:	701a      	strb	r2, [r3, #0]
          if (line[2] == 0) {
 800bb6c:	687b      	ldr	r3, [r7, #4]
 800bb6e:	3302      	adds	r3, #2
 800bb70:	781b      	ldrb	r3, [r3, #0]
 800bb72:	2b00      	cmp	r3, #0
 800bb74:	d108      	bne.n	800bb88 <system_execute_line+0x190>
            mc_homing_cycle(HOMING_CYCLE_ALL);
 800bb76:	2000      	movs	r0, #0
 800bb78:	f7fa fc44 	bl	8006404 <mc_homing_cycle>
                case 'Z': mc_homing_cycle(HOMING_CYCLE_Z); break;
                default: return(STATUS_INVALID_STATEMENT);
              }
          #endif
          } else { return(STATUS_INVALID_STATEMENT); }
          if (!sys.abort) {  // Execute startup scripts after successful homing.
 800bb7c:	4b6d      	ldr	r3, [pc, #436]	; (800bd34 <system_execute_line+0x33c>)
 800bb7e:	785b      	ldrb	r3, [r3, #1]
 800bb80:	2b00      	cmp	r3, #0
 800bb82:	d000      	beq.n	800bb86 <system_execute_line+0x18e>
 800bb84:	e19c      	b.n	800bec0 <system_execute_line+0x4c8>
 800bb86:	e001      	b.n	800bb8c <system_execute_line+0x194>
          } else { return(STATUS_INVALID_STATEMENT); }
 800bb88:	2303      	movs	r3, #3
 800bb8a:	e19b      	b.n	800bec4 <system_execute_line+0x4cc>
            sys.state = STATE_IDLE; // Set to IDLE when complete.
 800bb8c:	4b69      	ldr	r3, [pc, #420]	; (800bd34 <system_execute_line+0x33c>)
 800bb8e:	2200      	movs	r2, #0
 800bb90:	701a      	strb	r2, [r3, #0]
            st_go_idle(); // Set steppers to the settings idle state before returning.
 800bb92:	f7fe fbe1 	bl	800a358 <st_go_idle>
            if (line[2] == 0) { system_execute_startup(line); }
 800bb96:	687b      	ldr	r3, [r7, #4]
 800bb98:	3302      	adds	r3, #2
 800bb9a:	781b      	ldrb	r3, [r3, #0]
 800bb9c:	2b00      	cmp	r3, #0
 800bb9e:	d000      	beq.n	800bba2 <system_execute_line+0x1aa>
 800bba0:	e18e      	b.n	800bec0 <system_execute_line+0x4c8>
 800bba2:	687b      	ldr	r3, [r7, #4]
 800bba4:	0018      	movs	r0, r3
 800bba6:	f7ff fee7 	bl	800b978 <system_execute_startup>
          }
          break;
 800bbaa:	e189      	b.n	800bec0 <system_execute_line+0x4c8>
        case 'S' : // Puts Grbl to sleep [IDLE/ALARM]
          if ((line[2] != 'L') || (line[3] != 'P') || (line[4] != 0)) { return(STATUS_INVALID_STATEMENT); }
 800bbac:	687b      	ldr	r3, [r7, #4]
 800bbae:	3302      	adds	r3, #2
 800bbb0:	781b      	ldrb	r3, [r3, #0]
 800bbb2:	2b4c      	cmp	r3, #76	; 0x4c
 800bbb4:	d109      	bne.n	800bbca <system_execute_line+0x1d2>
 800bbb6:	687b      	ldr	r3, [r7, #4]
 800bbb8:	3303      	adds	r3, #3
 800bbba:	781b      	ldrb	r3, [r3, #0]
 800bbbc:	2b50      	cmp	r3, #80	; 0x50
 800bbbe:	d104      	bne.n	800bbca <system_execute_line+0x1d2>
 800bbc0:	687b      	ldr	r3, [r7, #4]
 800bbc2:	3304      	adds	r3, #4
 800bbc4:	781b      	ldrb	r3, [r3, #0]
 800bbc6:	2b00      	cmp	r3, #0
 800bbc8:	d001      	beq.n	800bbce <system_execute_line+0x1d6>
 800bbca:	2303      	movs	r3, #3
 800bbcc:	e17a      	b.n	800bec4 <system_execute_line+0x4cc>
          system_set_exec_state_flag(EXEC_SLEEP); // Set to execute sleep mode immediately
 800bbce:	2080      	movs	r0, #128	; 0x80
 800bbd0:	f000 fa68 	bl	800c0a4 <system_set_exec_state_flag>
          break;
 800bbd4:	e175      	b.n	800bec2 <system_execute_line+0x4ca>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) {
 800bbd6:	2316      	movs	r3, #22
 800bbd8:	18fb      	adds	r3, r7, r3
 800bbda:	781b      	ldrb	r3, [r3, #0]
 800bbdc:	3301      	adds	r3, #1
 800bbde:	b2da      	uxtb	r2, r3
 800bbe0:	2316      	movs	r3, #22
 800bbe2:	18fb      	adds	r3, r7, r3
 800bbe4:	701a      	strb	r2, [r3, #0]
 800bbe6:	2316      	movs	r3, #22
 800bbe8:	18fb      	adds	r3, r7, r3
 800bbea:	781b      	ldrb	r3, [r3, #0]
 800bbec:	001a      	movs	r2, r3
 800bbee:	687b      	ldr	r3, [r7, #4]
 800bbf0:	189b      	adds	r3, r3, r2
 800bbf2:	781b      	ldrb	r3, [r3, #0]
 800bbf4:	2b00      	cmp	r3, #0
 800bbf6:	d108      	bne.n	800bc0a <system_execute_line+0x212>
            settings_read_build_info(line);
 800bbf8:	687b      	ldr	r3, [r7, #4]
 800bbfa:	0018      	movs	r0, r3
 800bbfc:	f7fd fed8 	bl	80099b0 <settings_read_build_info>
            report_build_info(line);
 800bc00:	687b      	ldr	r3, [r7, #4]
 800bc02:	0018      	movs	r0, r3
 800bc04:	f7fd f95c 	bl	8008ec0 <report_build_info>
                line[char_counter-helper_var] = line[char_counter];
              } while (line[char_counter++] != 0);
              settings_store_build_info(line);
          #endif
          }
          break;
 800bc08:	e15b      	b.n	800bec2 <system_execute_line+0x4ca>
              if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
 800bc0a:	2316      	movs	r3, #22
 800bc0c:	18fb      	adds	r3, r7, r3
 800bc0e:	781b      	ldrb	r3, [r3, #0]
 800bc10:	1c5a      	adds	r2, r3, #1
 800bc12:	b2d1      	uxtb	r1, r2
 800bc14:	2216      	movs	r2, #22
 800bc16:	18ba      	adds	r2, r7, r2
 800bc18:	7011      	strb	r1, [r2, #0]
 800bc1a:	001a      	movs	r2, r3
 800bc1c:	687b      	ldr	r3, [r7, #4]
 800bc1e:	189b      	adds	r3, r3, r2
 800bc20:	781b      	ldrb	r3, [r3, #0]
 800bc22:	2b3d      	cmp	r3, #61	; 0x3d
 800bc24:	d001      	beq.n	800bc2a <system_execute_line+0x232>
 800bc26:	2303      	movs	r3, #3
 800bc28:	e14c      	b.n	800bec4 <system_execute_line+0x4cc>
              helper_var = char_counter; // Set helper variable as counter to start of user info line.
 800bc2a:	2317      	movs	r3, #23
 800bc2c:	18fb      	adds	r3, r7, r3
 800bc2e:	2216      	movs	r2, #22
 800bc30:	18ba      	adds	r2, r7, r2
 800bc32:	7812      	ldrb	r2, [r2, #0]
 800bc34:	701a      	strb	r2, [r3, #0]
                line[char_counter-helper_var] = line[char_counter];
 800bc36:	2316      	movs	r3, #22
 800bc38:	18fb      	adds	r3, r7, r3
 800bc3a:	781b      	ldrb	r3, [r3, #0]
 800bc3c:	001a      	movs	r2, r3
 800bc3e:	2317      	movs	r3, #23
 800bc40:	18fb      	adds	r3, r7, r3
 800bc42:	781b      	ldrb	r3, [r3, #0]
 800bc44:	1ad3      	subs	r3, r2, r3
 800bc46:	001a      	movs	r2, r3
 800bc48:	687b      	ldr	r3, [r7, #4]
 800bc4a:	189b      	adds	r3, r3, r2
 800bc4c:	2216      	movs	r2, #22
 800bc4e:	18ba      	adds	r2, r7, r2
 800bc50:	7812      	ldrb	r2, [r2, #0]
 800bc52:	0011      	movs	r1, r2
 800bc54:	687a      	ldr	r2, [r7, #4]
 800bc56:	1852      	adds	r2, r2, r1
 800bc58:	7812      	ldrb	r2, [r2, #0]
 800bc5a:	701a      	strb	r2, [r3, #0]
              } while (line[char_counter++] != 0);
 800bc5c:	2316      	movs	r3, #22
 800bc5e:	18fb      	adds	r3, r7, r3
 800bc60:	781b      	ldrb	r3, [r3, #0]
 800bc62:	1c5a      	adds	r2, r3, #1
 800bc64:	b2d1      	uxtb	r1, r2
 800bc66:	2216      	movs	r2, #22
 800bc68:	18ba      	adds	r2, r7, r2
 800bc6a:	7011      	strb	r1, [r2, #0]
 800bc6c:	001a      	movs	r2, r3
 800bc6e:	687b      	ldr	r3, [r7, #4]
 800bc70:	189b      	adds	r3, r3, r2
 800bc72:	781b      	ldrb	r3, [r3, #0]
 800bc74:	2b00      	cmp	r3, #0
 800bc76:	d1de      	bne.n	800bc36 <system_execute_line+0x23e>
              settings_store_build_info(line);
 800bc78:	687b      	ldr	r3, [r7, #4]
 800bc7a:	0018      	movs	r0, r3
 800bc7c:	f7fd fd2e 	bl	80096dc <settings_store_build_info>
          break;
 800bc80:	e11f      	b.n	800bec2 <system_execute_line+0x4ca>
        case 'R' : // Restore defaults [IDLE/ALARM]
          if ((line[2] != 'S') || (line[3] != 'T') || (line[4] != '=') || (line[6] != 0)) { return(STATUS_INVALID_STATEMENT); }
 800bc82:	687b      	ldr	r3, [r7, #4]
 800bc84:	3302      	adds	r3, #2
 800bc86:	781b      	ldrb	r3, [r3, #0]
 800bc88:	2b53      	cmp	r3, #83	; 0x53
 800bc8a:	d10e      	bne.n	800bcaa <system_execute_line+0x2b2>
 800bc8c:	687b      	ldr	r3, [r7, #4]
 800bc8e:	3303      	adds	r3, #3
 800bc90:	781b      	ldrb	r3, [r3, #0]
 800bc92:	2b54      	cmp	r3, #84	; 0x54
 800bc94:	d109      	bne.n	800bcaa <system_execute_line+0x2b2>
 800bc96:	687b      	ldr	r3, [r7, #4]
 800bc98:	3304      	adds	r3, #4
 800bc9a:	781b      	ldrb	r3, [r3, #0]
 800bc9c:	2b3d      	cmp	r3, #61	; 0x3d
 800bc9e:	d104      	bne.n	800bcaa <system_execute_line+0x2b2>
 800bca0:	687b      	ldr	r3, [r7, #4]
 800bca2:	3306      	adds	r3, #6
 800bca4:	781b      	ldrb	r3, [r3, #0]
 800bca6:	2b00      	cmp	r3, #0
 800bca8:	d001      	beq.n	800bcae <system_execute_line+0x2b6>
 800bcaa:	2303      	movs	r3, #3
 800bcac:	e10a      	b.n	800bec4 <system_execute_line+0x4cc>
          switch (line[5]) {
 800bcae:	687b      	ldr	r3, [r7, #4]
 800bcb0:	3305      	adds	r3, #5
 800bcb2:	781b      	ldrb	r3, [r3, #0]
 800bcb4:	2b24      	cmp	r3, #36	; 0x24
 800bcb6:	d004      	beq.n	800bcc2 <system_execute_line+0x2ca>
 800bcb8:	2b2a      	cmp	r3, #42	; 0x2a
 800bcba:	d00a      	beq.n	800bcd2 <system_execute_line+0x2da>
 800bcbc:	2b23      	cmp	r3, #35	; 0x23
 800bcbe:	d004      	beq.n	800bcca <system_execute_line+0x2d2>
 800bcc0:	e00b      	b.n	800bcda <system_execute_line+0x2e2>
            #ifdef ENABLE_RESTORE_EEPROM_DEFAULT_SETTINGS
              case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
 800bcc2:	2001      	movs	r0, #1
 800bcc4:	f7fd fd4a 	bl	800975c <settings_restore>
 800bcc8:	e009      	b.n	800bcde <system_execute_line+0x2e6>
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_CLEAR_PARAMETERS
              case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
 800bcca:	2002      	movs	r0, #2
 800bccc:	f7fd fd46 	bl	800975c <settings_restore>
 800bcd0:	e005      	b.n	800bcde <system_execute_line+0x2e6>
            #endif
            #ifdef ENABLE_RESTORE_EEPROM_WIPE_ALL
              case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
 800bcd2:	20ff      	movs	r0, #255	; 0xff
 800bcd4:	f7fd fd42 	bl	800975c <settings_restore>
 800bcd8:	e001      	b.n	800bcde <system_execute_line+0x2e6>
            #endif
            default: return(STATUS_INVALID_STATEMENT);
 800bcda:	2303      	movs	r3, #3
 800bcdc:	e0f2      	b.n	800bec4 <system_execute_line+0x4cc>
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
 800bcde:	2009      	movs	r0, #9
 800bce0:	f7fc fd98 	bl	8008814 <report_feedback_message>
          mc_reset(); // Force reset to ensure settings are initialized correctly.
 800bce4:	f7fa fc46 	bl	8006574 <mc_reset>
          break;
 800bce8:	e0eb      	b.n	800bec2 <system_execute_line+0x4ca>
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
 800bcea:	2316      	movs	r3, #22
 800bcec:	18fb      	adds	r3, r7, r3
 800bcee:	781b      	ldrb	r3, [r3, #0]
 800bcf0:	3301      	adds	r3, #1
 800bcf2:	b2da      	uxtb	r2, r3
 800bcf4:	2316      	movs	r3, #22
 800bcf6:	18fb      	adds	r3, r7, r3
 800bcf8:	701a      	strb	r2, [r3, #0]
 800bcfa:	2316      	movs	r3, #22
 800bcfc:	18fb      	adds	r3, r7, r3
 800bcfe:	781b      	ldrb	r3, [r3, #0]
 800bd00:	001a      	movs	r2, r3
 800bd02:	687b      	ldr	r3, [r7, #4]
 800bd04:	189b      	adds	r3, r3, r2
 800bd06:	781b      	ldrb	r3, [r3, #0]
 800bd08:	2b00      	cmp	r3, #0
 800bd0a:	d12e      	bne.n	800bd6a <system_execute_line+0x372>
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
 800bd0c:	2317      	movs	r3, #23
 800bd0e:	18fb      	adds	r3, r7, r3
 800bd10:	2200      	movs	r2, #0
 800bd12:	701a      	strb	r2, [r3, #0]
 800bd14:	e023      	b.n	800bd5e <system_execute_line+0x366>
              if (!(settings_read_startup_line(helper_var, line))) {
 800bd16:	687a      	ldr	r2, [r7, #4]
 800bd18:	2317      	movs	r3, #23
 800bd1a:	18fb      	adds	r3, r7, r3
 800bd1c:	781b      	ldrb	r3, [r3, #0]
 800bd1e:	0011      	movs	r1, r2
 800bd20:	0018      	movs	r0, r3
 800bd22:	f7fd fe19 	bl	8009958 <settings_read_startup_line>
 800bd26:	1e03      	subs	r3, r0, #0
 800bd28:	d10a      	bne.n	800bd40 <system_execute_line+0x348>
                report_status_message(STATUS_SETTING_READ_FAIL);
 800bd2a:	2007      	movs	r0, #7
 800bd2c:	f7fc fd34 	bl	8008798 <report_status_message>
 800bd30:	e00e      	b.n	800bd50 <system_execute_line+0x358>
 800bd32:	46c0      	nop			; (mov r8, r8)
 800bd34:	20000bb4 	.word	0x20000bb4
 800bd38:	0800e0d4 	.word	0x0800e0d4
 800bd3c:	20000b44 	.word	0x20000b44
              } else {
                report_startup_line(helper_var,line);
 800bd40:	687a      	ldr	r2, [r7, #4]
 800bd42:	2317      	movs	r3, #23
 800bd44:	18fb      	adds	r3, r7, r3
 800bd46:	781b      	ldrb	r3, [r3, #0]
 800bd48:	0011      	movs	r1, r2
 800bd4a:	0018      	movs	r0, r3
 800bd4c:	f7fd f87e 	bl	8008e4c <report_startup_line>
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
 800bd50:	2317      	movs	r3, #23
 800bd52:	18fb      	adds	r3, r7, r3
 800bd54:	781a      	ldrb	r2, [r3, #0]
 800bd56:	2317      	movs	r3, #23
 800bd58:	18fb      	adds	r3, r7, r3
 800bd5a:	3201      	adds	r2, #1
 800bd5c:	701a      	strb	r2, [r3, #0]
 800bd5e:	2317      	movs	r3, #23
 800bd60:	18fb      	adds	r3, r7, r3
 800bd62:	781b      	ldrb	r3, [r3, #0]
 800bd64:	2b01      	cmp	r3, #1
 800bd66:	d9d6      	bls.n	800bd16 <system_execute_line+0x31e>
              }
            }
            break;
 800bd68:	e0ab      	b.n	800bec2 <system_execute_line+0x4ca>
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
 800bd6a:	4b58      	ldr	r3, [pc, #352]	; (800becc <system_execute_line+0x4d4>)
 800bd6c:	781b      	ldrb	r3, [r3, #0]
 800bd6e:	2b00      	cmp	r3, #0
 800bd70:	d001      	beq.n	800bd76 <system_execute_line+0x37e>
 800bd72:	2308      	movs	r3, #8
 800bd74:	e0a6      	b.n	800bec4 <system_execute_line+0x4cc>
            helper_var = true;  // Set helper_var to flag storing method.
 800bd76:	2317      	movs	r3, #23
 800bd78:	18fb      	adds	r3, r7, r3
 800bd7a:	2201      	movs	r2, #1
 800bd7c:	701a      	strb	r2, [r3, #0]
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
 800bd7e:	2310      	movs	r3, #16
 800bd80:	18fa      	adds	r2, r7, r3
 800bd82:	2316      	movs	r3, #22
 800bd84:	18f9      	adds	r1, r7, r3
 800bd86:	687b      	ldr	r3, [r7, #4]
 800bd88:	0018      	movs	r0, r3
 800bd8a:	f7fa fc2b 	bl	80065e4 <read_float>
 800bd8e:	1e03      	subs	r3, r0, #0
 800bd90:	d101      	bne.n	800bd96 <system_execute_line+0x39e>
 800bd92:	2302      	movs	r3, #2
 800bd94:	e096      	b.n	800bec4 <system_execute_line+0x4cc>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
 800bd96:	2316      	movs	r3, #22
 800bd98:	18fb      	adds	r3, r7, r3
 800bd9a:	781b      	ldrb	r3, [r3, #0]
 800bd9c:	1c5a      	adds	r2, r3, #1
 800bd9e:	b2d1      	uxtb	r1, r2
 800bda0:	2216      	movs	r2, #22
 800bda2:	18ba      	adds	r2, r7, r2
 800bda4:	7011      	strb	r1, [r2, #0]
 800bda6:	001a      	movs	r2, r3
 800bda8:	687b      	ldr	r3, [r7, #4]
 800bdaa:	189b      	adds	r3, r3, r2
 800bdac:	781b      	ldrb	r3, [r3, #0]
 800bdae:	2b3d      	cmp	r3, #61	; 0x3d
 800bdb0:	d001      	beq.n	800bdb6 <system_execute_line+0x3be>
 800bdb2:	2303      	movs	r3, #3
 800bdb4:	e086      	b.n	800bec4 <system_execute_line+0x4cc>
          if (helper_var) { // Store startup line
 800bdb6:	2317      	movs	r3, #23
 800bdb8:	18fb      	adds	r3, r7, r3
 800bdba:	781b      	ldrb	r3, [r3, #0]
 800bdbc:	2b00      	cmp	r3, #0
 800bdbe:	d054      	beq.n	800be6a <system_execute_line+0x472>
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
 800bdc0:	2317      	movs	r3, #23
 800bdc2:	18fb      	adds	r3, r7, r3
 800bdc4:	2216      	movs	r2, #22
 800bdc6:	18ba      	adds	r2, r7, r2
 800bdc8:	7812      	ldrb	r2, [r2, #0]
 800bdca:	701a      	strb	r2, [r3, #0]
            do {
              line[char_counter-helper_var] = line[char_counter];
 800bdcc:	2316      	movs	r3, #22
 800bdce:	18fb      	adds	r3, r7, r3
 800bdd0:	781b      	ldrb	r3, [r3, #0]
 800bdd2:	001a      	movs	r2, r3
 800bdd4:	2317      	movs	r3, #23
 800bdd6:	18fb      	adds	r3, r7, r3
 800bdd8:	781b      	ldrb	r3, [r3, #0]
 800bdda:	1ad3      	subs	r3, r2, r3
 800bddc:	001a      	movs	r2, r3
 800bdde:	687b      	ldr	r3, [r7, #4]
 800bde0:	189b      	adds	r3, r3, r2
 800bde2:	2216      	movs	r2, #22
 800bde4:	18ba      	adds	r2, r7, r2
 800bde6:	7812      	ldrb	r2, [r2, #0]
 800bde8:	0011      	movs	r1, r2
 800bdea:	687a      	ldr	r2, [r7, #4]
 800bdec:	1852      	adds	r2, r2, r1
 800bdee:	7812      	ldrb	r2, [r2, #0]
 800bdf0:	701a      	strb	r2, [r3, #0]
            } while (line[char_counter++] != 0);
 800bdf2:	2316      	movs	r3, #22
 800bdf4:	18fb      	adds	r3, r7, r3
 800bdf6:	781b      	ldrb	r3, [r3, #0]
 800bdf8:	1c5a      	adds	r2, r3, #1
 800bdfa:	b2d1      	uxtb	r1, r2
 800bdfc:	2216      	movs	r2, #22
 800bdfe:	18ba      	adds	r2, r7, r2
 800be00:	7011      	strb	r1, [r2, #0]
 800be02:	001a      	movs	r2, r3
 800be04:	687b      	ldr	r3, [r7, #4]
 800be06:	189b      	adds	r3, r3, r2
 800be08:	781b      	ldrb	r3, [r3, #0]
 800be0a:	2b00      	cmp	r3, #0
 800be0c:	d1de      	bne.n	800bdcc <system_execute_line+0x3d4>
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
 800be0e:	2317      	movs	r3, #23
 800be10:	18fc      	adds	r4, r7, r3
 800be12:	687b      	ldr	r3, [r7, #4]
 800be14:	0018      	movs	r0, r3
 800be16:	f7f7 fe35 	bl	8003a84 <gc_execute_line>
 800be1a:	0003      	movs	r3, r0
 800be1c:	7023      	strb	r3, [r4, #0]
            if (helper_var) { return(helper_var); }
 800be1e:	2317      	movs	r3, #23
 800be20:	18fb      	adds	r3, r7, r3
 800be22:	781b      	ldrb	r3, [r3, #0]
 800be24:	2b00      	cmp	r3, #0
 800be26:	d003      	beq.n	800be30 <system_execute_line+0x438>
 800be28:	2317      	movs	r3, #23
 800be2a:	18fb      	adds	r3, r7, r3
 800be2c:	781b      	ldrb	r3, [r3, #0]
 800be2e:	e049      	b.n	800bec4 <system_execute_line+0x4cc>
            else {
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
 800be30:	693b      	ldr	r3, [r7, #16]
 800be32:	1c18      	adds	r0, r3, #0
 800be34:	f7f6 fc46 	bl	80026c4 <__aeabi_f2d>
 800be38:	0003      	movs	r3, r0
 800be3a:	000c      	movs	r4, r1
 800be3c:	0018      	movs	r0, r3
 800be3e:	0021      	movs	r1, r4
 800be40:	f000 fcb6 	bl	800c7b0 <trunc>
 800be44:	0002      	movs	r2, r0
 800be46:	000b      	movs	r3, r1
 800be48:	2117      	movs	r1, #23
 800be4a:	187c      	adds	r4, r7, r1
 800be4c:	0010      	movs	r0, r2
 800be4e:	0019      	movs	r1, r3
 800be50:	f7f4 fa80 	bl	8000354 <__aeabi_d2uiz>
 800be54:	0003      	movs	r3, r0
 800be56:	7023      	strb	r3, [r4, #0]
              settings_store_startup_line(helper_var,line);
 800be58:	687a      	ldr	r2, [r7, #4]
 800be5a:	2317      	movs	r3, #23
 800be5c:	18fb      	adds	r3, r7, r3
 800be5e:	781b      	ldrb	r3, [r3, #0]
 800be60:	0011      	movs	r1, r2
 800be62:	0018      	movs	r0, r3
 800be64:	f7fd fc1a 	bl	800969c <settings_store_startup_line>
 800be68:	e02b      	b.n	800bec2 <system_execute_line+0x4ca>
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
 800be6a:	230c      	movs	r3, #12
 800be6c:	18fa      	adds	r2, r7, r3
 800be6e:	2316      	movs	r3, #22
 800be70:	18f9      	adds	r1, r7, r3
 800be72:	687b      	ldr	r3, [r7, #4]
 800be74:	0018      	movs	r0, r3
 800be76:	f7fa fbb5 	bl	80065e4 <read_float>
 800be7a:	1e03      	subs	r3, r0, #0
 800be7c:	d101      	bne.n	800be82 <system_execute_line+0x48a>
 800be7e:	2302      	movs	r3, #2
 800be80:	e020      	b.n	800bec4 <system_execute_line+0x4cc>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
 800be82:	2316      	movs	r3, #22
 800be84:	18fb      	adds	r3, r7, r3
 800be86:	781b      	ldrb	r3, [r3, #0]
 800be88:	001a      	movs	r2, r3
 800be8a:	687b      	ldr	r3, [r7, #4]
 800be8c:	189b      	adds	r3, r3, r2
 800be8e:	781b      	ldrb	r3, [r3, #0]
 800be90:	2b00      	cmp	r3, #0
 800be92:	d106      	bne.n	800bea2 <system_execute_line+0x4aa>
 800be94:	693b      	ldr	r3, [r7, #16]
 800be96:	490e      	ldr	r1, [pc, #56]	; (800bed0 <system_execute_line+0x4d8>)
 800be98:	1c18      	adds	r0, r3, #0
 800be9a:	f7f4 fa2f 	bl	80002fc <__aeabi_fcmpgt>
 800be9e:	1e03      	subs	r3, r0, #0
 800bea0:	d001      	beq.n	800bea6 <system_execute_line+0x4ae>
 800bea2:	2303      	movs	r3, #3
 800bea4:	e00e      	b.n	800bec4 <system_execute_line+0x4cc>
            return(settings_store_global_setting((uint8_t)parameter, value));
 800bea6:	693b      	ldr	r3, [r7, #16]
 800bea8:	1c18      	adds	r0, r3, #0
 800beaa:	f7f4 fa3b 	bl	8000324 <__aeabi_f2uiz>
 800beae:	0003      	movs	r3, r0
 800beb0:	b2db      	uxtb	r3, r3
 800beb2:	68fa      	ldr	r2, [r7, #12]
 800beb4:	1c11      	adds	r1, r2, #0
 800beb6:	0018      	movs	r0, r3
 800beb8:	f7fd fde4 	bl	8009a84 <settings_store_global_setting>
 800bebc:	0003      	movs	r3, r0
 800bebe:	e001      	b.n	800bec4 <system_execute_line+0x4cc>
          break;
 800bec0:	46c0      	nop			; (mov r8, r8)
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
 800bec2:	2300      	movs	r3, #0
}
 800bec4:	0018      	movs	r0, r3
 800bec6:	46bd      	mov	sp, r7
 800bec8:	b007      	add	sp, #28
 800beca:	bd90      	pop	{r4, r7, pc}
 800becc:	20000bb4 	.word	0x20000bb4
 800bed0:	437f0000 	.word	0x437f0000

0800bed4 <system_flag_wco_change>:



void system_flag_wco_change()
{
 800bed4:	b580      	push	{r7, lr}
 800bed6:	af00      	add	r7, sp, #0
  #ifdef FORCE_BUFFER_SYNC_DURING_WCO_CHANGE
    protocol_buffer_synchronize();
 800bed8:	f7fb ff2e 	bl	8007d38 <protocol_buffer_synchronize>
  #endif
  sys.report_wco_counter = 0;
 800bedc:	4b02      	ldr	r3, [pc, #8]	; (800bee8 <system_flag_wco_change+0x14>)
 800bede:	2200      	movs	r2, #0
 800bee0:	731a      	strb	r2, [r3, #12]
}
 800bee2:	46c0      	nop			; (mov r8, r8)
 800bee4:	46bd      	mov	sp, r7
 800bee6:	bd80      	pop	{r7, pc}
 800bee8:	20000bb4 	.word	0x20000bb4

0800beec <system_convert_axis_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//   serves as a central place to compute the transformation.
float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
{
 800beec:	b580      	push	{r7, lr}
 800beee:	b084      	sub	sp, #16
 800bef0:	af00      	add	r7, sp, #0
 800bef2:	6078      	str	r0, [r7, #4]
 800bef4:	000a      	movs	r2, r1
 800bef6:	1cfb      	adds	r3, r7, #3
 800bef8:	701a      	strb	r2, [r3, #0]
  float pos;
  #ifdef COREXY
    if (idx==X_AXIS) {
 800befa:	1cfb      	adds	r3, r7, #3
 800befc:	781b      	ldrb	r3, [r3, #0]
 800befe:	2b00      	cmp	r3, #0
 800bf00:	d112      	bne.n	800bf28 <system_convert_axis_steps_to_mpos+0x3c>
      pos = (float)system_convert_corexy_to_x_axis_steps(steps) / settings.steps_per_mm[idx];
 800bf02:	687b      	ldr	r3, [r7, #4]
 800bf04:	0018      	movs	r0, r3
 800bf06:	f000 f86b 	bl	800bfe0 <system_convert_corexy_to_x_axis_steps>
 800bf0a:	0003      	movs	r3, r0
 800bf0c:	0018      	movs	r0, r3
 800bf0e:	f7f5 f8b5 	bl	800107c <__aeabi_i2f>
 800bf12:	1cfb      	adds	r3, r7, #3
 800bf14:	781a      	ldrb	r2, [r3, #0]
 800bf16:	4b1c      	ldr	r3, [pc, #112]	; (800bf88 <system_convert_axis_steps_to_mpos+0x9c>)
 800bf18:	0092      	lsls	r2, r2, #2
 800bf1a:	58d3      	ldr	r3, [r2, r3]
 800bf1c:	1c19      	adds	r1, r3, #0
 800bf1e:	f7f4 fbc9 	bl	80006b4 <__aeabi_fdiv>
 800bf22:	1c03      	adds	r3, r0, #0
 800bf24:	60fb      	str	r3, [r7, #12]
 800bf26:	e029      	b.n	800bf7c <system_convert_axis_steps_to_mpos+0x90>
    } else if (idx==Y_AXIS) {
 800bf28:	1cfb      	adds	r3, r7, #3
 800bf2a:	781b      	ldrb	r3, [r3, #0]
 800bf2c:	2b01      	cmp	r3, #1
 800bf2e:	d112      	bne.n	800bf56 <system_convert_axis_steps_to_mpos+0x6a>
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[idx];
 800bf30:	687b      	ldr	r3, [r7, #4]
 800bf32:	0018      	movs	r0, r3
 800bf34:	f000 f866 	bl	800c004 <system_convert_corexy_to_y_axis_steps>
 800bf38:	0003      	movs	r3, r0
 800bf3a:	0018      	movs	r0, r3
 800bf3c:	f7f5 f89e 	bl	800107c <__aeabi_i2f>
 800bf40:	1cfb      	adds	r3, r7, #3
 800bf42:	781a      	ldrb	r2, [r3, #0]
 800bf44:	4b10      	ldr	r3, [pc, #64]	; (800bf88 <system_convert_axis_steps_to_mpos+0x9c>)
 800bf46:	0092      	lsls	r2, r2, #2
 800bf48:	58d3      	ldr	r3, [r2, r3]
 800bf4a:	1c19      	adds	r1, r3, #0
 800bf4c:	f7f4 fbb2 	bl	80006b4 <__aeabi_fdiv>
 800bf50:	1c03      	adds	r3, r0, #0
 800bf52:	60fb      	str	r3, [r7, #12]
 800bf54:	e012      	b.n	800bf7c <system_convert_axis_steps_to_mpos+0x90>
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
 800bf56:	1cfb      	adds	r3, r7, #3
 800bf58:	781b      	ldrb	r3, [r3, #0]
 800bf5a:	009b      	lsls	r3, r3, #2
 800bf5c:	687a      	ldr	r2, [r7, #4]
 800bf5e:	18d3      	adds	r3, r2, r3
 800bf60:	681b      	ldr	r3, [r3, #0]
 800bf62:	0018      	movs	r0, r3
 800bf64:	f7f5 f88a 	bl	800107c <__aeabi_i2f>
 800bf68:	1cfb      	adds	r3, r7, #3
 800bf6a:	781a      	ldrb	r2, [r3, #0]
 800bf6c:	4b06      	ldr	r3, [pc, #24]	; (800bf88 <system_convert_axis_steps_to_mpos+0x9c>)
 800bf6e:	0092      	lsls	r2, r2, #2
 800bf70:	58d3      	ldr	r3, [r2, r3]
 800bf72:	1c19      	adds	r1, r3, #0
 800bf74:	f7f4 fb9e 	bl	80006b4 <__aeabi_fdiv>
 800bf78:	1c03      	adds	r3, r0, #0
 800bf7a:	60fb      	str	r3, [r7, #12]
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
  #endif
  return(pos);
 800bf7c:	68fb      	ldr	r3, [r7, #12]
}
 800bf7e:	1c18      	adds	r0, r3, #0
 800bf80:	46bd      	mov	sp, r7
 800bf82:	b004      	add	sp, #16
 800bf84:	bd80      	pop	{r7, pc}
 800bf86:	46c0      	nop			; (mov r8, r8)
 800bf88:	20000b44 	.word	0x20000b44

0800bf8c <system_convert_array_steps_to_mpos>:


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
 800bf8c:	b590      	push	{r4, r7, lr}
 800bf8e:	b085      	sub	sp, #20
 800bf90:	af00      	add	r7, sp, #0
 800bf92:	6078      	str	r0, [r7, #4]
 800bf94:	6039      	str	r1, [r7, #0]
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 800bf96:	230f      	movs	r3, #15
 800bf98:	18fb      	adds	r3, r7, r3
 800bf9a:	2200      	movs	r2, #0
 800bf9c:	701a      	strb	r2, [r3, #0]
 800bf9e:	e016      	b.n	800bfce <system_convert_array_steps_to_mpos+0x42>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
 800bfa0:	230f      	movs	r3, #15
 800bfa2:	18fb      	adds	r3, r7, r3
 800bfa4:	781b      	ldrb	r3, [r3, #0]
 800bfa6:	009b      	lsls	r3, r3, #2
 800bfa8:	687a      	ldr	r2, [r7, #4]
 800bfaa:	18d4      	adds	r4, r2, r3
 800bfac:	230f      	movs	r3, #15
 800bfae:	18fb      	adds	r3, r7, r3
 800bfb0:	781a      	ldrb	r2, [r3, #0]
 800bfb2:	683b      	ldr	r3, [r7, #0]
 800bfb4:	0011      	movs	r1, r2
 800bfb6:	0018      	movs	r0, r3
 800bfb8:	f7ff ff98 	bl	800beec <system_convert_axis_steps_to_mpos>
 800bfbc:	1c03      	adds	r3, r0, #0
 800bfbe:	6023      	str	r3, [r4, #0]
  for (idx=0; idx<N_AXIS; idx++) {
 800bfc0:	230f      	movs	r3, #15
 800bfc2:	18fb      	adds	r3, r7, r3
 800bfc4:	781a      	ldrb	r2, [r3, #0]
 800bfc6:	230f      	movs	r3, #15
 800bfc8:	18fb      	adds	r3, r7, r3
 800bfca:	3201      	adds	r2, #1
 800bfcc:	701a      	strb	r2, [r3, #0]
 800bfce:	230f      	movs	r3, #15
 800bfd0:	18fb      	adds	r3, r7, r3
 800bfd2:	781b      	ldrb	r3, [r3, #0]
 800bfd4:	2b03      	cmp	r3, #3
 800bfd6:	d9e3      	bls.n	800bfa0 <system_convert_array_steps_to_mpos+0x14>
  }
  return;
 800bfd8:	46c0      	nop			; (mov r8, r8)
}
 800bfda:	46bd      	mov	sp, r7
 800bfdc:	b005      	add	sp, #20
 800bfde:	bd90      	pop	{r4, r7, pc}

0800bfe0 <system_convert_corexy_to_x_axis_steps>:


// CoreXY calculation only. Returns x or y-axis "steps" based on CoreXY motor steps.
#ifdef COREXY
  int32_t system_convert_corexy_to_x_axis_steps(int32_t *steps)
  {
 800bfe0:	b580      	push	{r7, lr}
 800bfe2:	b082      	sub	sp, #8
 800bfe4:	af00      	add	r7, sp, #0
 800bfe6:	6078      	str	r0, [r7, #4]
    return( (steps[A_MOTOR] + steps[B_MOTOR])/2 );
 800bfe8:	687b      	ldr	r3, [r7, #4]
 800bfea:	681a      	ldr	r2, [r3, #0]
 800bfec:	687b      	ldr	r3, [r7, #4]
 800bfee:	3304      	adds	r3, #4
 800bff0:	681b      	ldr	r3, [r3, #0]
 800bff2:	18d3      	adds	r3, r2, r3
 800bff4:	2b00      	cmp	r3, #0
 800bff6:	da00      	bge.n	800bffa <system_convert_corexy_to_x_axis_steps+0x1a>
 800bff8:	3301      	adds	r3, #1
 800bffa:	105b      	asrs	r3, r3, #1
  }
 800bffc:	0018      	movs	r0, r3
 800bffe:	46bd      	mov	sp, r7
 800c000:	b002      	add	sp, #8
 800c002:	bd80      	pop	{r7, pc}

0800c004 <system_convert_corexy_to_y_axis_steps>:
  int32_t system_convert_corexy_to_y_axis_steps(int32_t *steps)
  {
 800c004:	b580      	push	{r7, lr}
 800c006:	b082      	sub	sp, #8
 800c008:	af00      	add	r7, sp, #0
 800c00a:	6078      	str	r0, [r7, #4]
    return( (steps[A_MOTOR] - steps[B_MOTOR])/2 );
 800c00c:	687b      	ldr	r3, [r7, #4]
 800c00e:	681a      	ldr	r2, [r3, #0]
 800c010:	687b      	ldr	r3, [r7, #4]
 800c012:	3304      	adds	r3, #4
 800c014:	681b      	ldr	r3, [r3, #0]
 800c016:	1ad3      	subs	r3, r2, r3
 800c018:	d500      	bpl.n	800c01c <system_convert_corexy_to_y_axis_steps+0x18>
 800c01a:	3301      	adds	r3, #1
 800c01c:	105b      	asrs	r3, r3, #1
  }
 800c01e:	0018      	movs	r0, r3
 800c020:	46bd      	mov	sp, r7
 800c022:	b002      	add	sp, #8
 800c024:	bd80      	pop	{r7, pc}
	...

0800c028 <system_check_travel_limits>:
#endif


// Checks and reports if target array exceeds machine travel limits.
uint8_t system_check_travel_limits(float *target)
{
 800c028:	b580      	push	{r7, lr}
 800c02a:	b084      	sub	sp, #16
 800c02c:	af00      	add	r7, sp, #0
 800c02e:	6078      	str	r0, [r7, #4]
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
 800c030:	230f      	movs	r3, #15
 800c032:	18fb      	adds	r3, r7, r3
 800c034:	2200      	movs	r2, #0
 800c036:	701a      	strb	r2, [r3, #0]
 800c038:	e028      	b.n	800c08c <system_check_travel_limits+0x64>
      } else {
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
      }
    #else
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { return(true); }
 800c03a:	230f      	movs	r3, #15
 800c03c:	18fb      	adds	r3, r7, r3
 800c03e:	781b      	ldrb	r3, [r3, #0]
 800c040:	009b      	lsls	r3, r3, #2
 800c042:	687a      	ldr	r2, [r7, #4]
 800c044:	18d3      	adds	r3, r2, r3
 800c046:	681b      	ldr	r3, [r3, #0]
 800c048:	2100      	movs	r1, #0
 800c04a:	1c18      	adds	r0, r3, #0
 800c04c:	f7f4 f956 	bl	80002fc <__aeabi_fcmpgt>
 800c050:	1e03      	subs	r3, r0, #0
 800c052:	d112      	bne.n	800c07a <system_check_travel_limits+0x52>
 800c054:	230f      	movs	r3, #15
 800c056:	18fb      	adds	r3, r7, r3
 800c058:	781b      	ldrb	r3, [r3, #0]
 800c05a:	009b      	lsls	r3, r3, #2
 800c05c:	687a      	ldr	r2, [r7, #4]
 800c05e:	18d3      	adds	r3, r2, r3
 800c060:	6818      	ldr	r0, [r3, #0]
 800c062:	230f      	movs	r3, #15
 800c064:	18fb      	adds	r3, r7, r3
 800c066:	781a      	ldrb	r2, [r3, #0]
 800c068:	4b0d      	ldr	r3, [pc, #52]	; (800c0a0 <system_check_travel_limits+0x78>)
 800c06a:	320c      	adds	r2, #12
 800c06c:	0092      	lsls	r2, r2, #2
 800c06e:	58d3      	ldr	r3, [r2, r3]
 800c070:	1c19      	adds	r1, r3, #0
 800c072:	f7f4 f92f 	bl	80002d4 <__aeabi_fcmplt>
 800c076:	1e03      	subs	r3, r0, #0
 800c078:	d001      	beq.n	800c07e <system_check_travel_limits+0x56>
 800c07a:	2301      	movs	r3, #1
 800c07c:	e00c      	b.n	800c098 <system_check_travel_limits+0x70>
  for (idx=0; idx<N_AXIS; idx++) {
 800c07e:	230f      	movs	r3, #15
 800c080:	18fb      	adds	r3, r7, r3
 800c082:	781a      	ldrb	r2, [r3, #0]
 800c084:	230f      	movs	r3, #15
 800c086:	18fb      	adds	r3, r7, r3
 800c088:	3201      	adds	r2, #1
 800c08a:	701a      	strb	r2, [r3, #0]
 800c08c:	230f      	movs	r3, #15
 800c08e:	18fb      	adds	r3, r7, r3
 800c090:	781b      	ldrb	r3, [r3, #0]
 800c092:	2b03      	cmp	r3, #3
 800c094:	d9d1      	bls.n	800c03a <system_check_travel_limits+0x12>
    #endif
  }
  return(false);
 800c096:	2300      	movs	r3, #0
}
 800c098:	0018      	movs	r0, r3
 800c09a:	46bd      	mov	sp, r7
 800c09c:	b004      	add	sp, #16
 800c09e:	bd80      	pop	{r7, pc}
 800c0a0:	20000b44 	.word	0x20000b44

0800c0a4 <system_set_exec_state_flag>:
#ifdef WIN32
extern CRITICAL_SECTION CriticalSection;
#endif

// Special handlers for setting and clearing Grbl's real-time execution flags.
void system_set_exec_state_flag(uint8_t mask) {
 800c0a4:	b580      	push	{r7, lr}
 800c0a6:	b082      	sub	sp, #8
 800c0a8:	af00      	add	r7, sp, #0
 800c0aa:	0002      	movs	r2, r0
 800c0ac:	1dfb      	adds	r3, r7, #7
 800c0ae:	701a      	strb	r2, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800c0b0:	b672      	cpsid	i
  sys_rt_exec_state |= (mask);
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_state |= (mask);
 800c0b2:	4b07      	ldr	r3, [pc, #28]	; (800c0d0 <system_set_exec_state_flag+0x2c>)
 800c0b4:	781b      	ldrb	r3, [r3, #0]
 800c0b6:	b2da      	uxtb	r2, r3
 800c0b8:	1dfb      	adds	r3, r7, #7
 800c0ba:	781b      	ldrb	r3, [r3, #0]
 800c0bc:	4313      	orrs	r3, r2
 800c0be:	b2da      	uxtb	r2, r3
 800c0c0:	4b03      	ldr	r3, [pc, #12]	; (800c0d0 <system_set_exec_state_flag+0x2c>)
 800c0c2:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 800c0c4:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800c0c6:	46c0      	nop			; (mov r8, r8)
 800c0c8:	46bd      	mov	sp, r7
 800c0ca:	b002      	add	sp, #8
 800c0cc:	bd80      	pop	{r7, pc}
 800c0ce:	46c0      	nop			; (mov r8, r8)
 800c0d0:	20000bc9 	.word	0x20000bc9

0800c0d4 <system_clear_exec_state_flag>:

void system_clear_exec_state_flag(uint8_t mask) {
 800c0d4:	b580      	push	{r7, lr}
 800c0d6:	b082      	sub	sp, #8
 800c0d8:	af00      	add	r7, sp, #0
 800c0da:	0002      	movs	r2, r0
 800c0dc:	1dfb      	adds	r3, r7, #7
 800c0de:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 800c0e0:	b672      	cpsid	i
  sys_rt_exec_state &= ~(mask);
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_state &= ~(mask);
 800c0e2:	1dfb      	adds	r3, r7, #7
 800c0e4:	781b      	ldrb	r3, [r3, #0]
 800c0e6:	b25b      	sxtb	r3, r3
 800c0e8:	43db      	mvns	r3, r3
 800c0ea:	b25b      	sxtb	r3, r3
 800c0ec:	4a06      	ldr	r2, [pc, #24]	; (800c108 <system_clear_exec_state_flag+0x34>)
 800c0ee:	7812      	ldrb	r2, [r2, #0]
 800c0f0:	b2d2      	uxtb	r2, r2
 800c0f2:	b252      	sxtb	r2, r2
 800c0f4:	4013      	ands	r3, r2
 800c0f6:	b25b      	sxtb	r3, r3
 800c0f8:	b2da      	uxtb	r2, r3
 800c0fa:	4b03      	ldr	r3, [pc, #12]	; (800c108 <system_clear_exec_state_flag+0x34>)
 800c0fc:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 800c0fe:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800c100:	46c0      	nop			; (mov r8, r8)
 800c102:	46bd      	mov	sp, r7
 800c104:	b002      	add	sp, #8
 800c106:	bd80      	pop	{r7, pc}
 800c108:	20000bc9 	.word	0x20000bc9

0800c10c <system_set_exec_alarm>:

void system_set_exec_alarm(uint8_t code) {
 800c10c:	b580      	push	{r7, lr}
 800c10e:	b082      	sub	sp, #8
 800c110:	af00      	add	r7, sp, #0
 800c112:	0002      	movs	r2, r0
 800c114:	1dfb      	adds	r3, r7, #7
 800c116:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 800c118:	b672      	cpsid	i
  sys_rt_exec_alarm |= (code);
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_alarm |= (code);
 800c11a:	4b07      	ldr	r3, [pc, #28]	; (800c138 <system_set_exec_alarm+0x2c>)
 800c11c:	781b      	ldrb	r3, [r3, #0]
 800c11e:	b2da      	uxtb	r2, r3
 800c120:	1dfb      	adds	r3, r7, #7
 800c122:	781b      	ldrb	r3, [r3, #0]
 800c124:	4313      	orrs	r3, r2
 800c126:	b2da      	uxtb	r2, r3
 800c128:	4b03      	ldr	r3, [pc, #12]	; (800c138 <system_set_exec_alarm+0x2c>)
 800c12a:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 800c12c:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800c12e:	46c0      	nop			; (mov r8, r8)
 800c130:	46bd      	mov	sp, r7
 800c132:	b002      	add	sp, #8
 800c134:	bd80      	pop	{r7, pc}
 800c136:	46c0      	nop			; (mov r8, r8)
 800c138:	20000bec 	.word	0x20000bec

0800c13c <system_clear_exec_alarm>:

void system_clear_exec_alarm() {
 800c13c:	b580      	push	{r7, lr}
 800c13e:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 800c140:	b672      	cpsid	i
  sys_rt_exec_alarm = 0;
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_alarm = 0;
 800c142:	4b03      	ldr	r3, [pc, #12]	; (800c150 <system_clear_exec_alarm+0x14>)
 800c144:	2200      	movs	r2, #0
 800c146:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 800c148:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800c14a:	46c0      	nop			; (mov r8, r8)
 800c14c:	46bd      	mov	sp, r7
 800c14e:	bd80      	pop	{r7, pc}
 800c150:	20000bec 	.word	0x20000bec

0800c154 <system_set_exec_motion_override_flag>:

void system_set_exec_motion_override_flag(uint8_t mask) {
 800c154:	b580      	push	{r7, lr}
 800c156:	b082      	sub	sp, #8
 800c158:	af00      	add	r7, sp, #0
 800c15a:	0002      	movs	r2, r0
 800c15c:	1dfb      	adds	r3, r7, #7
 800c15e:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 800c160:	b672      	cpsid	i
  sys_rt_exec_motion_override |= (mask);
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_motion_override |= (mask);
 800c162:	4b07      	ldr	r3, [pc, #28]	; (800c180 <system_set_exec_motion_override_flag+0x2c>)
 800c164:	781b      	ldrb	r3, [r3, #0]
 800c166:	b2da      	uxtb	r2, r3
 800c168:	1dfb      	adds	r3, r7, #7
 800c16a:	781b      	ldrb	r3, [r3, #0]
 800c16c:	4313      	orrs	r3, r2
 800c16e:	b2da      	uxtb	r2, r3
 800c170:	4b03      	ldr	r3, [pc, #12]	; (800c180 <system_set_exec_motion_override_flag+0x2c>)
 800c172:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 800c174:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800c176:	46c0      	nop			; (mov r8, r8)
 800c178:	46bd      	mov	sp, r7
 800c17a:	b002      	add	sp, #8
 800c17c:	bd80      	pop	{r7, pc}
 800c17e:	46c0      	nop			; (mov r8, r8)
 800c180:	20000bb0 	.word	0x20000bb0

0800c184 <system_set_exec_accessory_override_flag>:

void system_set_exec_accessory_override_flag(uint8_t mask) {
 800c184:	b580      	push	{r7, lr}
 800c186:	b082      	sub	sp, #8
 800c188:	af00      	add	r7, sp, #0
 800c18a:	0002      	movs	r2, r0
 800c18c:	1dfb      	adds	r3, r7, #7
 800c18e:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 800c190:	b672      	cpsid	i
  sys_rt_exec_accessory_override |= (mask);
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_accessory_override |= (mask);
 800c192:	4b07      	ldr	r3, [pc, #28]	; (800c1b0 <system_set_exec_accessory_override_flag+0x2c>)
 800c194:	781b      	ldrb	r3, [r3, #0]
 800c196:	b2da      	uxtb	r2, r3
 800c198:	1dfb      	adds	r3, r7, #7
 800c19a:	781b      	ldrb	r3, [r3, #0]
 800c19c:	4313      	orrs	r3, r2
 800c19e:	b2da      	uxtb	r2, r3
 800c1a0:	4b03      	ldr	r3, [pc, #12]	; (800c1b0 <system_set_exec_accessory_override_flag+0x2c>)
 800c1a2:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 800c1a4:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800c1a6:	46c0      	nop			; (mov r8, r8)
 800c1a8:	46bd      	mov	sp, r7
 800c1aa:	b002      	add	sp, #8
 800c1ac:	bd80      	pop	{r7, pc}
 800c1ae:	46c0      	nop			; (mov r8, r8)
 800c1b0:	20000bc8 	.word	0x20000bc8

0800c1b4 <system_clear_exec_motion_overrides>:

void system_clear_exec_motion_overrides() {
 800c1b4:	b580      	push	{r7, lr}
 800c1b6:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 800c1b8:	b672      	cpsid	i
  sys_rt_exec_motion_override = 0;
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_motion_override = 0;
 800c1ba:	4b03      	ldr	r3, [pc, #12]	; (800c1c8 <system_clear_exec_motion_overrides+0x14>)
 800c1bc:	2200      	movs	r2, #0
 800c1be:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 800c1c0:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800c1c2:	46c0      	nop			; (mov r8, r8)
 800c1c4:	46bd      	mov	sp, r7
 800c1c6:	bd80      	pop	{r7, pc}
 800c1c8:	20000bb0 	.word	0x20000bb0

0800c1cc <system_clear_exec_accessory_overrides>:

void system_clear_exec_accessory_overrides() {
 800c1cc:	b580      	push	{r7, lr}
 800c1ce:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 800c1d0:	b672      	cpsid	i
  sys_rt_exec_accessory_override = 0;
  __enable_irq();
#endif
#ifdef STM32F0DISCOVERY
  __disable_irq();
  sys_rt_exec_accessory_override = 0;
 800c1d2:	4b03      	ldr	r3, [pc, #12]	; (800c1e0 <system_clear_exec_accessory_overrides+0x14>)
 800c1d4:	2200      	movs	r2, #0
 800c1d6:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 800c1d8:	b662      	cpsie	i
  __enable_irq();
#endif
}
 800c1da:	46c0      	nop			; (mov r8, r8)
 800c1dc:	46bd      	mov	sp, r7
 800c1de:	bd80      	pop	{r7, pc}
 800c1e0:	20000bc8 	.word	0x20000bc8

0800c1e4 <USART1_Configuration>:
#include "stm32eeprom.h"
#ifndef USEUSB
#include "stm32f0xx_usart.h"

void USART1_Configuration(uint32_t BaudRate)
{
 800c1e4:	b580      	push	{r7, lr}
 800c1e6:	b08c      	sub	sp, #48	; 0x30
 800c1e8:	af00      	add	r7, sp, #0
 800c1ea:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef GPIO_InitStructure;
	USART_InitTypeDef USART_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;
	//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); TODO - Check if priority groups avaialbe for stm32f0xx
	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
 800c1ec:	230c      	movs	r3, #12
 800c1ee:	18fb      	adds	r3, r7, r3
 800c1f0:	221b      	movs	r2, #27
 800c1f2:	701a      	strb	r2, [r3, #0]
	//NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelPriority = 0;
 800c1f4:	230c      	movs	r3, #12
 800c1f6:	18fb      	adds	r3, r7, r3
 800c1f8:	2200      	movs	r2, #0
 800c1fa:	705a      	strb	r2, [r3, #1]

	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800c1fc:	230c      	movs	r3, #12
 800c1fe:	18fb      	adds	r3, r7, r3
 800c200:	2201      	movs	r2, #1
 800c202:	709a      	strb	r2, [r3, #2]
	NVIC_Init(&NVIC_InitStructure);
 800c204:	230c      	movs	r3, #12
 800c206:	18fb      	adds	r3, r7, r3
 800c208:	0018      	movs	r0, r3
 800c20a:	f7f6 fd39 	bl	8002c80 <NVIC_Init>
	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);

	RCC_HCLKConfig(RCC_SYSCLK_Div1);
 800c20e:	2000      	movs	r0, #0
 800c210:	f7f6 fd8c 	bl	8002d2c <RCC_HCLKConfig>
	RCC_USARTCLKConfig(RCC_USART1CLK_PCLK);
 800c214:	2380      	movs	r3, #128	; 0x80
 800c216:	055b      	lsls	r3, r3, #21
 800c218:	0018      	movs	r0, r3
 800c21a:	f7f6 fda1 	bl	8002d60 <RCC_USARTCLKConfig>

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 800c21e:	2380      	movs	r3, #128	; 0x80
 800c220:	01db      	lsls	r3, r3, #7
 800c222:	2101      	movs	r1, #1
 800c224:	0018      	movs	r0, r3
 800c226:	f7f6 ff5f 	bl	80030e8 <RCC_APB2PeriphClockCmd>
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 800c22a:	2380      	movs	r3, #128	; 0x80
 800c22c:	029b      	lsls	r3, r3, #10
 800c22e:	2101      	movs	r1, #1
 800c230:	0018      	movs	r0, r3
 800c232:	f7f6 ff39 	bl	80030a8 <RCC_AHBPeriphClockCmd>
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC, ENABLE);
 800c236:	2380      	movs	r3, #128	; 0x80
 800c238:	031b      	lsls	r3, r3, #12
 800c23a:	2101      	movs	r1, #1
 800c23c:	0018      	movs	r0, r3
 800c23e:	f7f6 ff33 	bl	80030a8 <RCC_AHBPeriphClockCmd>

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 800c242:	2328      	movs	r3, #40	; 0x28
 800c244:	18fb      	adds	r3, r7, r3
 800c246:	2280      	movs	r2, #128	; 0x80
 800c248:	0092      	lsls	r2, r2, #2
 800c24a:	601a      	str	r2, [r3, #0]
	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800c24c:	2328      	movs	r3, #40	; 0x28
 800c24e:	18fb      	adds	r3, r7, r3
 800c250:	2202      	movs	r2, #2
 800c252:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800c254:	2328      	movs	r3, #40	; 0x28
 800c256:	18fb      	adds	r3, r7, r3
 800c258:	2200      	movs	r2, #0
 800c25a:	719a      	strb	r2, [r3, #6]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; //CMS
 800c25c:	2328      	movs	r3, #40	; 0x28
 800c25e:	18fb      	adds	r3, r7, r3
 800c260:	2201      	movs	r2, #1
 800c262:	71da      	strb	r2, [r3, #7]

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800c264:	2328      	movs	r3, #40	; 0x28
 800c266:	18fb      	adds	r3, r7, r3
 800c268:	2203      	movs	r2, #3
 800c26a:	715a      	strb	r2, [r3, #5]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800c26c:	2328      	movs	r3, #40	; 0x28
 800c26e:	18fa      	adds	r2, r7, r3
 800c270:	2390      	movs	r3, #144	; 0x90
 800c272:	05db      	lsls	r3, r3, #23
 800c274:	0011      	movs	r1, r2
 800c276:	0018      	movs	r0, r3
 800c278:	f7f6 fbbc 	bl	80029f4 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 800c27c:	2328      	movs	r3, #40	; 0x28
 800c27e:	18fb      	adds	r3, r7, r3
 800c280:	2280      	movs	r2, #128	; 0x80
 800c282:	00d2      	lsls	r2, r2, #3
 800c284:	601a      	str	r2, [r3, #0]
	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;		//CMS
 800c286:	2328      	movs	r3, #40	; 0x28
 800c288:	18fb      	adds	r3, r7, r3
 800c28a:	2202      	movs	r2, #2
 800c28c:	711a      	strb	r2, [r3, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;	//CMS
 800c28e:	2328      	movs	r3, #40	; 0x28
 800c290:	18fb      	adds	r3, r7, r3
 800c292:	2203      	movs	r2, #3
 800c294:	715a      	strb	r2, [r3, #5]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;		//CMS
 800c296:	2328      	movs	r3, #40	; 0x28
 800c298:	18fb      	adds	r3, r7, r3
 800c29a:	2201      	movs	r2, #1
 800c29c:	71da      	strb	r2, [r3, #7]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800c29e:	2328      	movs	r3, #40	; 0x28
 800c2a0:	18fa      	adds	r2, r7, r3
 800c2a2:	2390      	movs	r3, #144	; 0x90
 800c2a4:	05db      	lsls	r3, r3, #23
 800c2a6:	0011      	movs	r1, r2
 800c2a8:	0018      	movs	r0, r3
 800c2aa:	f7f6 fba3 	bl	80029f4 <GPIO_Init>

	GPIOA->AFR[1] |= 0x110;
 800c2ae:	2390      	movs	r3, #144	; 0x90
 800c2b0:	05db      	lsls	r3, r3, #23
 800c2b2:	2290      	movs	r2, #144	; 0x90
 800c2b4:	05d2      	lsls	r2, r2, #23
 800c2b6:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800c2b8:	2188      	movs	r1, #136	; 0x88
 800c2ba:	0049      	lsls	r1, r1, #1
 800c2bc:	430a      	orrs	r2, r1
 800c2be:	625a      	str	r2, [r3, #36]	; 0x24

	USART_InitStructure.USART_BaudRate = BaudRate;
 800c2c0:	2310      	movs	r3, #16
 800c2c2:	18fb      	adds	r3, r7, r3
 800c2c4:	687a      	ldr	r2, [r7, #4]
 800c2c6:	601a      	str	r2, [r3, #0]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 800c2c8:	2310      	movs	r3, #16
 800c2ca:	18fb      	adds	r3, r7, r3
 800c2cc:	2200      	movs	r2, #0
 800c2ce:	605a      	str	r2, [r3, #4]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 800c2d0:	2310      	movs	r3, #16
 800c2d2:	18fb      	adds	r3, r7, r3
 800c2d4:	2200      	movs	r2, #0
 800c2d6:	609a      	str	r2, [r3, #8]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 800c2d8:	2310      	movs	r3, #16
 800c2da:	18fb      	adds	r3, r7, r3
 800c2dc:	2200      	movs	r2, #0
 800c2de:	60da      	str	r2, [r3, #12]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 800c2e0:	2310      	movs	r3, #16
 800c2e2:	18fb      	adds	r3, r7, r3
 800c2e4:	2200      	movs	r2, #0
 800c2e6:	615a      	str	r2, [r3, #20]
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 800c2e8:	2310      	movs	r3, #16
 800c2ea:	18fb      	adds	r3, r7, r3
 800c2ec:	220c      	movs	r2, #12
 800c2ee:	611a      	str	r2, [r3, #16]
	USART1->CR1 |= (USART_CR1_RE | USART_CR1_TE);
 800c2f0:	4b0d      	ldr	r3, [pc, #52]	; (800c328 <USART1_Configuration+0x144>)
 800c2f2:	4a0d      	ldr	r2, [pc, #52]	; (800c328 <USART1_Configuration+0x144>)
 800c2f4:	6812      	ldr	r2, [r2, #0]
 800c2f6:	210c      	movs	r1, #12
 800c2f8:	430a      	orrs	r2, r1
 800c2fa:	601a      	str	r2, [r3, #0]
	USART_Init(USART1, &USART_InitStructure);
 800c2fc:	2310      	movs	r3, #16
 800c2fe:	18fb      	adds	r3, r7, r3
 800c300:	4a09      	ldr	r2, [pc, #36]	; (800c328 <USART1_Configuration+0x144>)
 800c302:	0019      	movs	r1, r3
 800c304:	0010      	movs	r0, r2
 800c306:	f7f7 f965 	bl	80035d4 <USART_Init>
	//USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
 800c30a:	4908      	ldr	r1, [pc, #32]	; (800c32c <USART1_Configuration+0x148>)
 800c30c:	4b06      	ldr	r3, [pc, #24]	; (800c328 <USART1_Configuration+0x144>)
 800c30e:	2201      	movs	r2, #1
 800c310:	0018      	movs	r0, r3
 800c312:	f7f7 fa54 	bl	80037be <USART_ITConfig>
	USART_Cmd(USART1, ENABLE);
 800c316:	4b04      	ldr	r3, [pc, #16]	; (800c328 <USART1_Configuration+0x144>)
 800c318:	2101      	movs	r1, #1
 800c31a:	0018      	movs	r0, r3
 800c31c:	f7f7 fa20 	bl	8003760 <USART_Cmd>


}
 800c320:	46c0      	nop			; (mov r8, r8)
 800c322:	46bd      	mov	sp, r7
 800c324:	b00c      	add	sp, #48	; 0x30
 800c326:	bd80      	pop	{r7, pc}
 800c328:	40013800 	.word	0x40013800
 800c32c:	00050105 	.word	0x00050105

0800c330 <main>:
#ifdef WIN32
int main(int argc, char *argv[])
#else
int main(void)
#endif
{
 800c330:	b580      	push	{r7, lr}
 800c332:	b082      	sub	sp, #8
 800c334:	af00      	add	r7, sp, #0
	GPIO_Init(GPIOC, &GPIO_InitStructure);
#endif
	//Set_System();
#ifndef USEUSB
	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	USART1_Configuration(115200);
 800c336:	23e1      	movs	r3, #225	; 0xe1
 800c338:	025b      	lsls	r3, r3, #9
 800c33a:	0018      	movs	r0, r3
 800c33c:	f7ff ff52 	bl	800c1e4 <USART1_Configuration>
#ifndef NOEEPROMSUPPORT
	FLASH_Unlock();
	eeprom_init();G0 X10

#endif
	 SysTick->CTRL &= 0xfffffffb;
 800c340:	4b31      	ldr	r3, [pc, #196]	; (800c408 <main+0xd8>)
 800c342:	4a31      	ldr	r2, [pc, #196]	; (800c408 <main+0xd8>)
 800c344:	6812      	ldr	r2, [r2, #0]
 800c346:	2104      	movs	r1, #4
 800c348:	438a      	bics	r2, r1
 800c34a:	601a      	str	r2, [r3, #0]
#endif
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
 800c34c:	f7fd f880 	bl	8009450 <serial_init>
#ifdef WIN32
  winserial_init(argv[1]);
  eeprom_init();
#endif
  settings_init(); // Load Grbl settings from EEPROM
 800c350:	f7fd fd80 	bl	8009e54 <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
 800c354:	f7fe fb84 	bl	800aa60 <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
 800c358:	f7ff fa70 	bl	800b83c <system_init>

  memset(sys_position,0,sizeof(sys_position)); // Clear machine position.
 800c35c:	4b2b      	ldr	r3, [pc, #172]	; (800c40c <main+0xdc>)
 800c35e:	2210      	movs	r2, #16
 800c360:	2100      	movs	r1, #0
 800c362:	0018      	movs	r0, r3
 800c364:	f000 f9ce 	bl	800c704 <memset>
  // Initialize system state.
  #ifdef FORCE_INITIALIZATION_ALARM
    // Force Grbl into an ALARM state upon a power-cycle or hard reset.
    sys.state = STATE_ALARM;
  #else
    sys.state = STATE_IDLE;
 800c368:	4b29      	ldr	r3, [pc, #164]	; (800c410 <main+0xe0>)
 800c36a:	2200      	movs	r2, #0
 800c36c:	701a      	strb	r2, [r3, #0]
  // cycle '$H' or kill alarm locks '$X' will disable the alarm.
  // NOTE: The startup script will run after successful completion of the homing cycle, but
  // not after disabling the alarm locks. Prevents motion startup blocks from crashing into
  // things uncontrollably. Very bad.
  #ifdef HOMING_INIT_LOCK
    if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { sys.state = STATE_ALARM; }
 800c36e:	4b29      	ldr	r3, [pc, #164]	; (800c414 <main+0xe4>)
 800c370:	2258      	movs	r2, #88	; 0x58
 800c372:	5c9b      	ldrb	r3, [r3, r2]
 800c374:	001a      	movs	r2, r3
 800c376:	2310      	movs	r3, #16
 800c378:	4013      	ands	r3, r2
 800c37a:	d002      	beq.n	800c382 <main+0x52>
 800c37c:	4b24      	ldr	r3, [pc, #144]	; (800c410 <main+0xe0>)
 800c37e:	2201      	movs	r2, #1
 800c380:	701a      	strb	r2, [r3, #0]
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
 800c382:	1dfb      	adds	r3, r7, #7
 800c384:	4a22      	ldr	r2, [pc, #136]	; (800c410 <main+0xe0>)
 800c386:	7812      	ldrb	r2, [r2, #0]
 800c388:	701a      	strb	r2, [r3, #0]
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
 800c38a:	4b21      	ldr	r3, [pc, #132]	; (800c410 <main+0xe0>)
 800c38c:	2214      	movs	r2, #20
 800c38e:	2100      	movs	r1, #0
 800c390:	0018      	movs	r0, r3
 800c392:	f000 f9b7 	bl	800c704 <memset>
    sys.state = prior_state;
 800c396:	4b1e      	ldr	r3, [pc, #120]	; (800c410 <main+0xe0>)
 800c398:	1dfa      	adds	r2, r7, #7
 800c39a:	7812      	ldrb	r2, [r2, #0]
 800c39c:	701a      	strb	r2, [r3, #0]
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
 800c39e:	4b1c      	ldr	r3, [pc, #112]	; (800c410 <main+0xe0>)
 800c3a0:	2264      	movs	r2, #100	; 0x64
 800c3a2:	71da      	strb	r2, [r3, #7]
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
 800c3a4:	4b1a      	ldr	r3, [pc, #104]	; (800c410 <main+0xe0>)
 800c3a6:	2264      	movs	r2, #100	; 0x64
 800c3a8:	721a      	strb	r2, [r3, #8]
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
 800c3aa:	4b19      	ldr	r3, [pc, #100]	; (800c410 <main+0xe0>)
 800c3ac:	2264      	movs	r2, #100	; 0x64
 800c3ae:	725a      	strb	r2, [r3, #9]
		memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
 800c3b0:	4b19      	ldr	r3, [pc, #100]	; (800c418 <main+0xe8>)
 800c3b2:	2210      	movs	r2, #16
 800c3b4:	2100      	movs	r1, #0
 800c3b6:	0018      	movs	r0, r3
 800c3b8:	f000 f9a4 	bl	800c704 <memset>
    sys_probe_state = 0;
 800c3bc:	4b17      	ldr	r3, [pc, #92]	; (800c41c <main+0xec>)
 800c3be:	2200      	movs	r2, #0
 800c3c0:	701a      	strb	r2, [r3, #0]
    sys_rt_exec_state = 0;
 800c3c2:	4b17      	ldr	r3, [pc, #92]	; (800c420 <main+0xf0>)
 800c3c4:	2200      	movs	r2, #0
 800c3c6:	701a      	strb	r2, [r3, #0]
    sys_rt_exec_alarm = 0;
 800c3c8:	4b16      	ldr	r3, [pc, #88]	; (800c424 <main+0xf4>)
 800c3ca:	2200      	movs	r2, #0
 800c3cc:	701a      	strb	r2, [r3, #0]
    sys_rt_exec_motion_override = 0;
 800c3ce:	4b16      	ldr	r3, [pc, #88]	; (800c428 <main+0xf8>)
 800c3d0:	2200      	movs	r2, #0
 800c3d2:	701a      	strb	r2, [r3, #0]
    sys_rt_exec_accessory_override = 0;
 800c3d4:	4b15      	ldr	r3, [pc, #84]	; (800c42c <main+0xfc>)
 800c3d6:	2200      	movs	r2, #0
 800c3d8:	701a      	strb	r2, [r3, #0]

    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
 800c3da:	f7fd f951 	bl	8009680 <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
 800c3de:	f7f7 fb25 	bl	8003a2c <gc_init>
    spindle_init();
 800c3e2:	f7fd fd49 	bl	8009e78 <spindle_init>
#ifndef STM32F0DISCOVERY
    coolant_init();
#endif
    limits_init();
 800c3e6:	f7f9 f90b 	bl	8005600 <limits_init>
    probe_init();
 800c3ea:	f7fb faf5 	bl	80079d8 <probe_init>
    plan_reset(); // Clear block buffer and planner variables
 800c3ee:	f7fa fca3 	bl	8006d38 <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
 800c3f2:	f7fe fac5 	bl	800a980 <st_reset>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
 800c3f6:	f7fb f911 	bl	800761c <plan_sync_position>
    gc_sync_position();
 800c3fa:	f7f7 fb33 	bl	8003a64 <gc_sync_position>

    // Print welcome message. Indicates an initialization has occured at power-up or with a reset.
    report_init_message();
 800c3fe:	f7fc fa73 	bl	80088e8 <report_init_message>

    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
 800c402:	f7fb fb6b 	bl	8007adc <protocol_main_loop>
  for(;;) {
 800c406:	e7bc      	b.n	800c382 <main+0x52>
 800c408:	e000e010 	.word	0xe000e010
 800c40c:	20000bdc 	.word	0x20000bdc
 800c410:	20000bb4 	.word	0x20000bb4
 800c414:	20000b44 	.word	0x20000b44
 800c418:	20000bcc 	.word	0x20000bcc
 800c41c:	20000bca 	.word	0x20000bca
 800c420:	20000bc9 	.word	0x20000bc9
 800c424:	20000bec 	.word	0x20000bec
 800c428:	20000bb0 	.word	0x20000bb0
 800c42c:	20000bc8 	.word	0x20000bc8

0800c430 <_delay_ms>:
	nOnFlag = (nOnFlag == Bit_SET) ? Bit_RESET : Bit_SET;
}
#endif
#if defined (STM32F0DISCOVERY)
void _delay_ms(uint32_t x)
{
 800c430:	b580      	push	{r7, lr}
 800c432:	b084      	sub	sp, #16
 800c434:	af00      	add	r7, sp, #0
 800c436:	6078      	str	r0, [r7, #4]
	uint32_t temp;
	SysTick->LOAD = (uint32_t)72000000 / 8000;                     // Loading time
 800c438:	4b0f      	ldr	r3, [pc, #60]	; (800c478 <_delay_ms+0x48>)
 800c43a:	4a10      	ldr	r2, [pc, #64]	; (800c47c <_delay_ms+0x4c>)
 800c43c:	605a      	str	r2, [r3, #4]
	SysTick->VAL = 0x00;                                            // Empty the counter
 800c43e:	4b0e      	ldr	r3, [pc, #56]	; (800c478 <_delay_ms+0x48>)
 800c440:	2200      	movs	r2, #0
 800c442:	609a      	str	r2, [r3, #8]
	SysTick->CTRL = 0x01;                                           // Start from bottom
 800c444:	4b0c      	ldr	r3, [pc, #48]	; (800c478 <_delay_ms+0x48>)
 800c446:	2201      	movs	r2, #1
 800c448:	601a      	str	r2, [r3, #0]
	do
	{
		temp = SysTick->CTRL;
 800c44a:	4b0b      	ldr	r3, [pc, #44]	; (800c478 <_delay_ms+0x48>)
 800c44c:	681b      	ldr	r3, [r3, #0]
 800c44e:	60fb      	str	r3, [r7, #12]
	} while (temp & 0x01 && !(temp&(1 << 16)));                             // Wait time arrive
 800c450:	68fb      	ldr	r3, [r7, #12]
 800c452:	2201      	movs	r2, #1
 800c454:	4013      	ands	r3, r2
 800c456:	d004      	beq.n	800c462 <_delay_ms+0x32>
 800c458:	68fa      	ldr	r2, [r7, #12]
 800c45a:	2380      	movs	r3, #128	; 0x80
 800c45c:	025b      	lsls	r3, r3, #9
 800c45e:	4013      	ands	r3, r2
 800c460:	d0f3      	beq.n	800c44a <_delay_ms+0x1a>
	SysTick->CTRL = 0x00;                                            // Close the counter
 800c462:	4b05      	ldr	r3, [pc, #20]	; (800c478 <_delay_ms+0x48>)
 800c464:	2200      	movs	r2, #0
 800c466:	601a      	str	r2, [r3, #0]
	SysTick->VAL = 0X00;                                            // Empty the counter
 800c468:	4b03      	ldr	r3, [pc, #12]	; (800c478 <_delay_ms+0x48>)
 800c46a:	2200      	movs	r2, #0
 800c46c:	609a      	str	r2, [r3, #8]
}
 800c46e:	46c0      	nop			; (mov r8, r8)
 800c470:	46bd      	mov	sp, r7
 800c472:	b004      	add	sp, #16
 800c474:	bd80      	pop	{r7, pc}
 800c476:	46c0      	nop			; (mov r8, r8)
 800c478:	e000e010 	.word	0xe000e010
 800c47c:	00002328 	.word	0x00002328

0800c480 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800c480:	4813      	ldr	r0, [pc, #76]	; (800c4d0 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800c482:	4685      	mov	sp, r0

/*Check if boot space corresponds to test memory*/
 
    LDR R0,=0x00000004
 800c484:	2004      	movs	r0, #4
    LDR R1, [R0]
 800c486:	6801      	ldr	r1, [r0, #0]
    LSRS R1, R1, #24
 800c488:	0e09      	lsrs	r1, r1, #24
    LDR R2,=0x1F
 800c48a:	221f      	movs	r2, #31
    CMP R1, R2
 800c48c:	4291      	cmp	r1, r2
    BNE ApplicationStart
 800c48e:	d105      	bne.n	800c49c <ApplicationStart>

 /*SYSCFG clock enable*/

    LDR R0,=0x40021018
 800c490:	4810      	ldr	r0, [pc, #64]	; (800c4d4 <LoopForever+0x6>)
    LDR R1,=0x00000001
 800c492:	2101      	movs	r1, #1
    STR R1, [R0]
 800c494:	6001      	str	r1, [r0, #0]

/*Set CFGR1 register with flash memory remap at address 0*/
    LDR R0,=0x40010000
 800c496:	4810      	ldr	r0, [pc, #64]	; (800c4d8 <LoopForever+0xa>)
    LDR R1,=0x00000000
 800c498:	2100      	movs	r1, #0
    STR R1, [R0]
 800c49a:	6001      	str	r1, [r0, #0]

0800c49c <ApplicationStart>:

ApplicationStart:
/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 800c49c:	2100      	movs	r1, #0
  b LoopCopyDataInit
 800c49e:	e003      	b.n	800c4a8 <LoopCopyDataInit>

0800c4a0 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 800c4a0:	4b0e      	ldr	r3, [pc, #56]	; (800c4dc <LoopForever+0xe>)
  ldr r3, [r3, r1]
 800c4a2:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 800c4a4:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 800c4a6:	3104      	adds	r1, #4

0800c4a8 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 800c4a8:	480d      	ldr	r0, [pc, #52]	; (800c4e0 <LoopForever+0x12>)
  ldr r3, =_edata
 800c4aa:	4b0e      	ldr	r3, [pc, #56]	; (800c4e4 <LoopForever+0x16>)
  adds r2, r0, r1
 800c4ac:	1842      	adds	r2, r0, r1
  cmp r2, r3
 800c4ae:	429a      	cmp	r2, r3
  bcc CopyDataInit
 800c4b0:	d3f6      	bcc.n	800c4a0 <CopyDataInit>
  ldr r2, =_sbss
 800c4b2:	4a0d      	ldr	r2, [pc, #52]	; (800c4e8 <LoopForever+0x1a>)
  b LoopFillZerobss
 800c4b4:	e002      	b.n	800c4bc <LoopFillZerobss>

0800c4b6 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 800c4b6:	2300      	movs	r3, #0
  str  r3, [r2]
 800c4b8:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800c4ba:	3204      	adds	r2, #4

0800c4bc <LoopFillZerobss>:


LoopFillZerobss:
  ldr r3, = _ebss
 800c4bc:	4b0b      	ldr	r3, [pc, #44]	; (800c4ec <LoopForever+0x1e>)
  cmp r2, r3
 800c4be:	429a      	cmp	r2, r3
  bcc FillZerobss
 800c4c0:	d3f9      	bcc.n	800c4b6 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 800c4c2:	f000 f82d 	bl	800c520 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800c4c6:	f000 f8e1 	bl	800c68c <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800c4ca:	f7ff ff31 	bl	800c330 <main>

0800c4ce <LoopForever>:
  
LoopForever:
    b LoopForever
 800c4ce:	e7fe      	b.n	800c4ce <LoopForever>
  ldr   r0, =_estack
 800c4d0:	20002000 	.word	0x20002000
    LDR R0,=0x40021018
 800c4d4:	40021018 	.word	0x40021018
    LDR R0,=0x40010000
 800c4d8:	40010000 	.word	0x40010000
  ldr r3, =_sidata
 800c4dc:	0800e598 	.word	0x0800e598
  ldr r0, =_sdata
 800c4e0:	20000000 	.word	0x20000000
  ldr r3, =_edata
 800c4e4:	2000007c 	.word	0x2000007c
  ldr r2, =_sbss
 800c4e8:	2000007c 	.word	0x2000007c
  ldr r3, = _ebss
 800c4ec:	20000bf0 	.word	0x20000bf0

0800c4f0 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 800c4f0:	e7fe      	b.n	800c4f0 <ADC1_COMP_IRQHandler>

0800c4f2 <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 800c4f2:	b580      	push	{r7, lr}
 800c4f4:	af00      	add	r7, sp, #0
}
 800c4f6:	46c0      	nop			; (mov r8, r8)
 800c4f8:	46bd      	mov	sp, r7
 800c4fa:	bd80      	pop	{r7, pc}

0800c4fc <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 800c4fc:	b580      	push	{r7, lr}
 800c4fe:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
 800c500:	e7fe      	b.n	800c500 <HardFault_Handler+0x4>

0800c502 <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 800c502:	b580      	push	{r7, lr}
 800c504:	af00      	add	r7, sp, #0
}
 800c506:	46c0      	nop			; (mov r8, r8)
 800c508:	46bd      	mov	sp, r7
 800c50a:	bd80      	pop	{r7, pc}

0800c50c <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 800c50c:	b580      	push	{r7, lr}
 800c50e:	af00      	add	r7, sp, #0
}
 800c510:	46c0      	nop			; (mov r8, r8)
 800c512:	46bd      	mov	sp, r7
 800c514:	bd80      	pop	{r7, pc}

0800c516 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 800c516:	b580      	push	{r7, lr}
 800c518:	af00      	add	r7, sp, #0
}
 800c51a:	46c0      	nop			; (mov r8, r8)
 800c51c:	46bd      	mov	sp, r7
 800c51e:	bd80      	pop	{r7, pc}

0800c520 <SystemInit>:
  *         SystemCoreClock variable.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{    
 800c520:	b580      	push	{r7, lr}
 800c522:	af00      	add	r7, sp, #0
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800c524:	4b1b      	ldr	r3, [pc, #108]	; (800c594 <SystemInit+0x74>)
 800c526:	4a1b      	ldr	r2, [pc, #108]	; (800c594 <SystemInit+0x74>)
 800c528:	6812      	ldr	r2, [r2, #0]
 800c52a:	2101      	movs	r1, #1
 800c52c:	430a      	orrs	r2, r1
 800c52e:	601a      	str	r2, [r3, #0]

#if defined(STM32F051)  
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE and MCOSEL[2:0] bits */
  RCC->CFGR &= (uint32_t)0xF8FFB80C;
 800c530:	4b18      	ldr	r3, [pc, #96]	; (800c594 <SystemInit+0x74>)
 800c532:	4a18      	ldr	r2, [pc, #96]	; (800c594 <SystemInit+0x74>)
 800c534:	6852      	ldr	r2, [r2, #4]
 800c536:	4918      	ldr	r1, [pc, #96]	; (800c598 <SystemInit+0x78>)
 800c538:	400a      	ands	r2, r1
 800c53a:	605a      	str	r2, [r3, #4]
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */
  RCC->CFGR &= (uint32_t)0x08FFB80C;
#endif /* STM32F051 */
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800c53c:	4b15      	ldr	r3, [pc, #84]	; (800c594 <SystemInit+0x74>)
 800c53e:	4a15      	ldr	r2, [pc, #84]	; (800c594 <SystemInit+0x74>)
 800c540:	6812      	ldr	r2, [r2, #0]
 800c542:	4916      	ldr	r1, [pc, #88]	; (800c59c <SystemInit+0x7c>)
 800c544:	400a      	ands	r2, r1
 800c546:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800c548:	4b12      	ldr	r3, [pc, #72]	; (800c594 <SystemInit+0x74>)
 800c54a:	4a12      	ldr	r2, [pc, #72]	; (800c594 <SystemInit+0x74>)
 800c54c:	6812      	ldr	r2, [r2, #0]
 800c54e:	4914      	ldr	r1, [pc, #80]	; (800c5a0 <SystemInit+0x80>)
 800c550:	400a      	ands	r2, r1
 800c552:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  RCC->CFGR &= (uint32_t)0xFFC0FFFF;
 800c554:	4b0f      	ldr	r3, [pc, #60]	; (800c594 <SystemInit+0x74>)
 800c556:	4a0f      	ldr	r2, [pc, #60]	; (800c594 <SystemInit+0x74>)
 800c558:	6852      	ldr	r2, [r2, #4]
 800c55a:	4912      	ldr	r1, [pc, #72]	; (800c5a4 <SystemInit+0x84>)
 800c55c:	400a      	ands	r2, r1
 800c55e:	605a      	str	r2, [r3, #4]

  /* Reset PREDIV1[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
 800c560:	4b0c      	ldr	r3, [pc, #48]	; (800c594 <SystemInit+0x74>)
 800c562:	4a0c      	ldr	r2, [pc, #48]	; (800c594 <SystemInit+0x74>)
 800c564:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800c566:	210f      	movs	r1, #15
 800c568:	438a      	bics	r2, r1
 800c56a:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset USARTSW[1:0], I2CSW, CECSW and ADCSW bits */
  RCC->CFGR3 &= (uint32_t)0xFFFFFEAC;
 800c56c:	4b09      	ldr	r3, [pc, #36]	; (800c594 <SystemInit+0x74>)
 800c56e:	4a09      	ldr	r2, [pc, #36]	; (800c594 <SystemInit+0x74>)
 800c570:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800c572:	490d      	ldr	r1, [pc, #52]	; (800c5a8 <SystemInit+0x88>)
 800c574:	400a      	ands	r2, r1
 800c576:	631a      	str	r2, [r3, #48]	; 0x30

  /* Reset HSI14 bit */
  RCC->CR2 &= (uint32_t)0xFFFFFFFE;
 800c578:	4b06      	ldr	r3, [pc, #24]	; (800c594 <SystemInit+0x74>)
 800c57a:	4a06      	ldr	r2, [pc, #24]	; (800c594 <SystemInit+0x74>)
 800c57c:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800c57e:	2101      	movs	r1, #1
 800c580:	438a      	bics	r2, r1
 800c582:	635a      	str	r2, [r3, #52]	; 0x34

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800c584:	4b03      	ldr	r3, [pc, #12]	; (800c594 <SystemInit+0x74>)
 800c586:	2200      	movs	r2, #0
 800c588:	609a      	str	r2, [r3, #8]

  /* Configure the System clock frequency, AHB/APBx prescalers and Flash settings */
  SetSysClock();
 800c58a:	f000 f80f 	bl	800c5ac <SetSysClock>
}
 800c58e:	46c0      	nop			; (mov r8, r8)
 800c590:	46bd      	mov	sp, r7
 800c592:	bd80      	pop	{r7, pc}
 800c594:	40021000 	.word	0x40021000
 800c598:	f8ffb80c 	.word	0xf8ffb80c
 800c59c:	fef6ffff 	.word	0xfef6ffff
 800c5a0:	fffbffff 	.word	0xfffbffff
 800c5a4:	ffc0ffff 	.word	0xffc0ffff
 800c5a8:	fffffeac 	.word	0xfffffeac

0800c5ac <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 800c5ac:	b580      	push	{r7, lr}
 800c5ae:	b082      	sub	sp, #8
 800c5b0:	af00      	add	r7, sp, #0
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 800c5b2:	2300      	movs	r3, #0
 800c5b4:	607b      	str	r3, [r7, #4]
 800c5b6:	2300      	movs	r3, #0
 800c5b8:	603b      	str	r3, [r7, #0]
  
  /* SYSCLK, HCLK, PCLK configuration ----------------------------------------*/
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 800c5ba:	4b31      	ldr	r3, [pc, #196]	; (800c680 <SetSysClock+0xd4>)
 800c5bc:	4a30      	ldr	r2, [pc, #192]	; (800c680 <SetSysClock+0xd4>)
 800c5be:	6812      	ldr	r2, [r2, #0]
 800c5c0:	2180      	movs	r1, #128	; 0x80
 800c5c2:	0249      	lsls	r1, r1, #9
 800c5c4:	430a      	orrs	r2, r1
 800c5c6:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 800c5c8:	4b2d      	ldr	r3, [pc, #180]	; (800c680 <SetSysClock+0xd4>)
 800c5ca:	681a      	ldr	r2, [r3, #0]
 800c5cc:	2380      	movs	r3, #128	; 0x80
 800c5ce:	029b      	lsls	r3, r3, #10
 800c5d0:	4013      	ands	r3, r2
 800c5d2:	603b      	str	r3, [r7, #0]
    StartUpCounter++;  
 800c5d4:	687b      	ldr	r3, [r7, #4]
 800c5d6:	3301      	adds	r3, #1
 800c5d8:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 800c5da:	683b      	ldr	r3, [r7, #0]
 800c5dc:	2b00      	cmp	r3, #0
 800c5de:	d104      	bne.n	800c5ea <SetSysClock+0x3e>
 800c5e0:	687a      	ldr	r2, [r7, #4]
 800c5e2:	23a0      	movs	r3, #160	; 0xa0
 800c5e4:	01db      	lsls	r3, r3, #7
 800c5e6:	429a      	cmp	r2, r3
 800c5e8:	d1ee      	bne.n	800c5c8 <SetSysClock+0x1c>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 800c5ea:	4b25      	ldr	r3, [pc, #148]	; (800c680 <SetSysClock+0xd4>)
 800c5ec:	681a      	ldr	r2, [r3, #0]
 800c5ee:	2380      	movs	r3, #128	; 0x80
 800c5f0:	029b      	lsls	r3, r3, #10
 800c5f2:	4013      	ands	r3, r2
 800c5f4:	d002      	beq.n	800c5fc <SetSysClock+0x50>
  {
    HSEStatus = (uint32_t)0x01;
 800c5f6:	2301      	movs	r3, #1
 800c5f8:	603b      	str	r3, [r7, #0]
 800c5fa:	e001      	b.n	800c600 <SetSysClock+0x54>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 800c5fc:	2300      	movs	r3, #0
 800c5fe:	603b      	str	r3, [r7, #0]
  }  

  if (HSEStatus == (uint32_t)0x01)
 800c600:	683b      	ldr	r3, [r7, #0]
 800c602:	2b01      	cmp	r3, #1
 800c604:	d138      	bne.n	800c678 <SetSysClock+0xcc>
  {
    /* Enable Prefetch Buffer and set Flash Latency */
    FLASH->ACR = FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY;
 800c606:	4b1f      	ldr	r3, [pc, #124]	; (800c684 <SetSysClock+0xd8>)
 800c608:	2211      	movs	r2, #17
 800c60a:	601a      	str	r2, [r3, #0]
 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 800c60c:	4b1c      	ldr	r3, [pc, #112]	; (800c680 <SetSysClock+0xd4>)
 800c60e:	4a1c      	ldr	r2, [pc, #112]	; (800c680 <SetSysClock+0xd4>)
 800c610:	6852      	ldr	r2, [r2, #4]
 800c612:	605a      	str	r2, [r3, #4]
      
    /* PCLK = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE_DIV1;
 800c614:	4b1a      	ldr	r3, [pc, #104]	; (800c680 <SetSysClock+0xd4>)
 800c616:	4a1a      	ldr	r2, [pc, #104]	; (800c680 <SetSysClock+0xd4>)
 800c618:	6852      	ldr	r2, [r2, #4]
 800c61a:	605a      	str	r2, [r3, #4]

    /* PLL configuration = HSE * 6 = 48 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
 800c61c:	4b18      	ldr	r3, [pc, #96]	; (800c680 <SetSysClock+0xd4>)
 800c61e:	4a18      	ldr	r2, [pc, #96]	; (800c680 <SetSysClock+0xd4>)
 800c620:	6852      	ldr	r2, [r2, #4]
 800c622:	4919      	ldr	r1, [pc, #100]	; (800c688 <SetSysClock+0xdc>)
 800c624:	400a      	ands	r2, r1
 800c626:	605a      	str	r2, [r3, #4]
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLMULL6);
 800c628:	4b15      	ldr	r3, [pc, #84]	; (800c680 <SetSysClock+0xd4>)
 800c62a:	4a15      	ldr	r2, [pc, #84]	; (800c680 <SetSysClock+0xd4>)
 800c62c:	6852      	ldr	r2, [r2, #4]
 800c62e:	2188      	movs	r1, #136	; 0x88
 800c630:	0349      	lsls	r1, r1, #13
 800c632:	430a      	orrs	r2, r1
 800c634:	605a      	str	r2, [r3, #4]
            
    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 800c636:	4b12      	ldr	r3, [pc, #72]	; (800c680 <SetSysClock+0xd4>)
 800c638:	4a11      	ldr	r2, [pc, #68]	; (800c680 <SetSysClock+0xd4>)
 800c63a:	6812      	ldr	r2, [r2, #0]
 800c63c:	2180      	movs	r1, #128	; 0x80
 800c63e:	0449      	lsls	r1, r1, #17
 800c640:	430a      	orrs	r2, r1
 800c642:	601a      	str	r2, [r3, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 800c644:	46c0      	nop			; (mov r8, r8)
 800c646:	4b0e      	ldr	r3, [pc, #56]	; (800c680 <SetSysClock+0xd4>)
 800c648:	681a      	ldr	r2, [r3, #0]
 800c64a:	2380      	movs	r3, #128	; 0x80
 800c64c:	049b      	lsls	r3, r3, #18
 800c64e:	4013      	ands	r3, r2
 800c650:	d0f9      	beq.n	800c646 <SetSysClock+0x9a>
    {
    }

    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 800c652:	4b0b      	ldr	r3, [pc, #44]	; (800c680 <SetSysClock+0xd4>)
 800c654:	4a0a      	ldr	r2, [pc, #40]	; (800c680 <SetSysClock+0xd4>)
 800c656:	6852      	ldr	r2, [r2, #4]
 800c658:	2103      	movs	r1, #3
 800c65a:	438a      	bics	r2, r1
 800c65c:	605a      	str	r2, [r3, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
 800c65e:	4b08      	ldr	r3, [pc, #32]	; (800c680 <SetSysClock+0xd4>)
 800c660:	4a07      	ldr	r2, [pc, #28]	; (800c680 <SetSysClock+0xd4>)
 800c662:	6852      	ldr	r2, [r2, #4]
 800c664:	2102      	movs	r1, #2
 800c666:	430a      	orrs	r2, r1
 800c668:	605a      	str	r2, [r3, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)RCC_CFGR_SWS_PLL)
 800c66a:	46c0      	nop			; (mov r8, r8)
 800c66c:	4b04      	ldr	r3, [pc, #16]	; (800c680 <SetSysClock+0xd4>)
 800c66e:	685b      	ldr	r3, [r3, #4]
 800c670:	220c      	movs	r2, #12
 800c672:	4013      	ands	r3, r2
 800c674:	2b08      	cmp	r3, #8
 800c676:	d1f9      	bne.n	800c66c <SetSysClock+0xc0>
  }
  else
  { /* If HSE fails to start-up, the application will have wrong clock 
         configuration. User can add here some code to deal with this error */
  }  
}
 800c678:	46c0      	nop			; (mov r8, r8)
 800c67a:	46bd      	mov	sp, r7
 800c67c:	b002      	add	sp, #8
 800c67e:	bd80      	pop	{r7, pc}
 800c680:	40021000 	.word	0x40021000
 800c684:	40022000 	.word	0x40022000
 800c688:	ffc07fff 	.word	0xffc07fff

0800c68c <__libc_init_array>:
 800c68c:	b570      	push	{r4, r5, r6, lr}
 800c68e:	2600      	movs	r6, #0
 800c690:	4d0c      	ldr	r5, [pc, #48]	; (800c6c4 <__libc_init_array+0x38>)
 800c692:	4c0d      	ldr	r4, [pc, #52]	; (800c6c8 <__libc_init_array+0x3c>)
 800c694:	1b64      	subs	r4, r4, r5
 800c696:	10a4      	asrs	r4, r4, #2
 800c698:	42a6      	cmp	r6, r4
 800c69a:	d109      	bne.n	800c6b0 <__libc_init_array+0x24>
 800c69c:	2600      	movs	r6, #0
 800c69e:	f001 f9a5 	bl	800d9ec <_init>
 800c6a2:	4d0a      	ldr	r5, [pc, #40]	; (800c6cc <__libc_init_array+0x40>)
 800c6a4:	4c0a      	ldr	r4, [pc, #40]	; (800c6d0 <__libc_init_array+0x44>)
 800c6a6:	1b64      	subs	r4, r4, r5
 800c6a8:	10a4      	asrs	r4, r4, #2
 800c6aa:	42a6      	cmp	r6, r4
 800c6ac:	d105      	bne.n	800c6ba <__libc_init_array+0x2e>
 800c6ae:	bd70      	pop	{r4, r5, r6, pc}
 800c6b0:	00b3      	lsls	r3, r6, #2
 800c6b2:	58eb      	ldr	r3, [r5, r3]
 800c6b4:	4798      	blx	r3
 800c6b6:	3601      	adds	r6, #1
 800c6b8:	e7ee      	b.n	800c698 <__libc_init_array+0xc>
 800c6ba:	00b3      	lsls	r3, r6, #2
 800c6bc:	58eb      	ldr	r3, [r5, r3]
 800c6be:	4798      	blx	r3
 800c6c0:	3601      	adds	r6, #1
 800c6c2:	e7f2      	b.n	800c6aa <__libc_init_array+0x1e>
 800c6c4:	0800e590 	.word	0x0800e590
 800c6c8:	0800e590 	.word	0x0800e590
 800c6cc:	0800e590 	.word	0x0800e590
 800c6d0:	0800e594 	.word	0x0800e594

0800c6d4 <memcmp>:
 800c6d4:	b530      	push	{r4, r5, lr}
 800c6d6:	2400      	movs	r4, #0
 800c6d8:	42a2      	cmp	r2, r4
 800c6da:	d101      	bne.n	800c6e0 <memcmp+0xc>
 800c6dc:	2000      	movs	r0, #0
 800c6de:	e005      	b.n	800c6ec <memcmp+0x18>
 800c6e0:	5d03      	ldrb	r3, [r0, r4]
 800c6e2:	1c65      	adds	r5, r4, #1
 800c6e4:	5d0c      	ldrb	r4, [r1, r4]
 800c6e6:	42a3      	cmp	r3, r4
 800c6e8:	d001      	beq.n	800c6ee <memcmp+0x1a>
 800c6ea:	1b18      	subs	r0, r3, r4
 800c6ec:	bd30      	pop	{r4, r5, pc}
 800c6ee:	002c      	movs	r4, r5
 800c6f0:	e7f2      	b.n	800c6d8 <memcmp+0x4>

0800c6f2 <memcpy>:
 800c6f2:	2300      	movs	r3, #0
 800c6f4:	b510      	push	{r4, lr}
 800c6f6:	429a      	cmp	r2, r3
 800c6f8:	d100      	bne.n	800c6fc <memcpy+0xa>
 800c6fa:	bd10      	pop	{r4, pc}
 800c6fc:	5ccc      	ldrb	r4, [r1, r3]
 800c6fe:	54c4      	strb	r4, [r0, r3]
 800c700:	3301      	adds	r3, #1
 800c702:	e7f8      	b.n	800c6f6 <memcpy+0x4>

0800c704 <memset>:
 800c704:	0003      	movs	r3, r0
 800c706:	1882      	adds	r2, r0, r2
 800c708:	4293      	cmp	r3, r2
 800c70a:	d100      	bne.n	800c70e <memset+0xa>
 800c70c:	4770      	bx	lr
 800c70e:	7019      	strb	r1, [r3, #0]
 800c710:	3301      	adds	r3, #1
 800c712:	e7f9      	b.n	800c708 <memset+0x4>

0800c714 <lround>:
 800c714:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800c716:	000f      	movs	r7, r1
 800c718:	2301      	movs	r3, #1
 800c71a:	0006      	movs	r6, r0
 800c71c:	0001      	movs	r1, r0
 800c71e:	17f8      	asrs	r0, r7, #31
 800c720:	4318      	orrs	r0, r3
 800c722:	007d      	lsls	r5, r7, #1
 800c724:	4b1f      	ldr	r3, [pc, #124]	; (800c7a4 <lround+0x90>)
 800c726:	0d6d      	lsrs	r5, r5, #21
 800c728:	18ec      	adds	r4, r5, r3
 800c72a:	033b      	lsls	r3, r7, #12
 800c72c:	0b1b      	lsrs	r3, r3, #12
 800c72e:	001a      	movs	r2, r3
 800c730:	2380      	movs	r3, #128	; 0x80
 800c732:	035b      	lsls	r3, r3, #13
 800c734:	431a      	orrs	r2, r3
 800c736:	9001      	str	r0, [sp, #4]
 800c738:	0013      	movs	r3, r2
 800c73a:	2c13      	cmp	r4, #19
 800c73c:	dc0f      	bgt.n	800c75e <lround+0x4a>
 800c73e:	2c00      	cmp	r4, #0
 800c740:	da03      	bge.n	800c74a <lround+0x36>
 800c742:	1c63      	adds	r3, r4, #1
 800c744:	d02d      	beq.n	800c7a2 <lround+0x8e>
 800c746:	2000      	movs	r0, #0
 800c748:	e02b      	b.n	800c7a2 <lround+0x8e>
 800c74a:	2080      	movs	r0, #128	; 0x80
 800c74c:	0300      	lsls	r0, r0, #12
 800c74e:	4120      	asrs	r0, r4
 800c750:	2314      	movs	r3, #20
 800c752:	1880      	adds	r0, r0, r2
 800c754:	1b1c      	subs	r4, r3, r4
 800c756:	40e0      	lsrs	r0, r4
 800c758:	9b01      	ldr	r3, [sp, #4]
 800c75a:	4358      	muls	r0, r3
 800c75c:	e021      	b.n	800c7a2 <lround+0x8e>
 800c75e:	2c1e      	cmp	r4, #30
 800c760:	d81b      	bhi.n	800c79a <lround+0x86>
 800c762:	4811      	ldr	r0, [pc, #68]	; (800c7a8 <lround+0x94>)
 800c764:	182f      	adds	r7, r5, r0
 800c766:	2c33      	cmp	r4, #51	; 0x33
 800c768:	dd06      	ble.n	800c778 <lround+0x64>
 800c76a:	0030      	movs	r0, r6
 800c76c:	490f      	ldr	r1, [pc, #60]	; (800c7ac <lround+0x98>)
 800c76e:	40bb      	lsls	r3, r7
 800c770:	186d      	adds	r5, r5, r1
 800c772:	40a8      	lsls	r0, r5
 800c774:	4318      	orrs	r0, r3
 800c776:	e7ef      	b.n	800c758 <lround+0x44>
 800c778:	2080      	movs	r0, #128	; 0x80
 800c77a:	0600      	lsls	r0, r0, #24
 800c77c:	40f8      	lsrs	r0, r7
 800c77e:	1986      	adds	r6, r0, r6
 800c780:	428e      	cmp	r6, r1
 800c782:	4189      	sbcs	r1, r1
 800c784:	4249      	negs	r1, r1
 800c786:	1853      	adds	r3, r2, r1
 800c788:	2134      	movs	r1, #52	; 0x34
 800c78a:	40bb      	lsls	r3, r7
 800c78c:	1b0c      	subs	r4, r1, r4
 800c78e:	2000      	movs	r0, #0
 800c790:	2c20      	cmp	r4, #32
 800c792:	d0ef      	beq.n	800c774 <lround+0x60>
 800c794:	0030      	movs	r0, r6
 800c796:	40e0      	lsrs	r0, r4
 800c798:	e7ec      	b.n	800c774 <lround+0x60>
 800c79a:	0030      	movs	r0, r6
 800c79c:	0039      	movs	r1, r7
 800c79e:	f7f5 ff5d 	bl	800265c <__aeabi_d2iz>
 800c7a2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800c7a4:	fffffc01 	.word	0xfffffc01
 800c7a8:	fffffbed 	.word	0xfffffbed
 800c7ac:	fffffbcd 	.word	0xfffffbcd

0800c7b0 <trunc>:
 800c7b0:	b570      	push	{r4, r5, r6, lr}
 800c7b2:	004b      	lsls	r3, r1, #1
 800c7b4:	4d13      	ldr	r5, [pc, #76]	; (800c804 <trunc+0x54>)
 800c7b6:	0d5b      	lsrs	r3, r3, #21
 800c7b8:	195d      	adds	r5, r3, r5
 800c7ba:	0004      	movs	r4, r0
 800c7bc:	000a      	movs	r2, r1
 800c7be:	2d13      	cmp	r5, #19
 800c7c0:	dc0b      	bgt.n	800c7da <trunc+0x2a>
 800c7c2:	2d00      	cmp	r5, #0
 800c7c4:	da03      	bge.n	800c7ce <trunc+0x1e>
 800c7c6:	2000      	movs	r0, #0
 800c7c8:	0fca      	lsrs	r2, r1, #31
 800c7ca:	07d1      	lsls	r1, r2, #31
 800c7cc:	bd70      	pop	{r4, r5, r6, pc}
 800c7ce:	4b0e      	ldr	r3, [pc, #56]	; (800c808 <trunc+0x58>)
 800c7d0:	2000      	movs	r0, #0
 800c7d2:	412b      	asrs	r3, r5
 800c7d4:	439a      	bics	r2, r3
 800c7d6:	0011      	movs	r1, r2
 800c7d8:	e7f8      	b.n	800c7cc <trunc+0x1c>
 800c7da:	2d33      	cmp	r5, #51	; 0x33
 800c7dc:	dd08      	ble.n	800c7f0 <trunc+0x40>
 800c7de:	2380      	movs	r3, #128	; 0x80
 800c7e0:	00db      	lsls	r3, r3, #3
 800c7e2:	429d      	cmp	r5, r3
 800c7e4:	d1f2      	bne.n	800c7cc <trunc+0x1c>
 800c7e6:	0002      	movs	r2, r0
 800c7e8:	000b      	movs	r3, r1
 800c7ea:	f7f4 fcdd 	bl	80011a8 <__aeabi_dadd>
 800c7ee:	e7ed      	b.n	800c7cc <trunc+0x1c>
 800c7f0:	0011      	movs	r1, r2
 800c7f2:	4a06      	ldr	r2, [pc, #24]	; (800c80c <trunc+0x5c>)
 800c7f4:	189b      	adds	r3, r3, r2
 800c7f6:	2201      	movs	r2, #1
 800c7f8:	4252      	negs	r2, r2
 800c7fa:	40da      	lsrs	r2, r3
 800c7fc:	4394      	bics	r4, r2
 800c7fe:	0020      	movs	r0, r4
 800c800:	e7e4      	b.n	800c7cc <trunc+0x1c>
 800c802:	46c0      	nop			; (mov r8, r8)
 800c804:	fffffc01 	.word	0xfffffc01
 800c808:	000fffff 	.word	0x000fffff
 800c80c:	fffffbed 	.word	0xfffffbed

0800c810 <ceilf>:
 800c810:	b570      	push	{r4, r5, r6, lr}
 800c812:	0045      	lsls	r5, r0, #1
 800c814:	086e      	lsrs	r6, r5, #1
 800c816:	0e2d      	lsrs	r5, r5, #24
 800c818:	3d7f      	subs	r5, #127	; 0x7f
 800c81a:	0004      	movs	r4, r0
 800c81c:	2d16      	cmp	r5, #22
 800c81e:	dc25      	bgt.n	800c86c <ceilf+0x5c>
 800c820:	2d00      	cmp	r5, #0
 800c822:	da0f      	bge.n	800c844 <ceilf+0x34>
 800c824:	4916      	ldr	r1, [pc, #88]	; (800c880 <ceilf+0x70>)
 800c826:	f7f3 fdb3 	bl	8000390 <__aeabi_fadd>
 800c82a:	2100      	movs	r1, #0
 800c82c:	f7f3 fd66 	bl	80002fc <__aeabi_fcmpgt>
 800c830:	2800      	cmp	r0, #0
 800c832:	d005      	beq.n	800c840 <ceilf+0x30>
 800c834:	2c00      	cmp	r4, #0
 800c836:	db20      	blt.n	800c87a <ceilf+0x6a>
 800c838:	2e00      	cmp	r6, #0
 800c83a:	d001      	beq.n	800c840 <ceilf+0x30>
 800c83c:	24fe      	movs	r4, #254	; 0xfe
 800c83e:	05a4      	lsls	r4, r4, #22
 800c840:	1c20      	adds	r0, r4, #0
 800c842:	e019      	b.n	800c878 <ceilf+0x68>
 800c844:	4e0f      	ldr	r6, [pc, #60]	; (800c884 <ceilf+0x74>)
 800c846:	412e      	asrs	r6, r5
 800c848:	4206      	tst	r6, r0
 800c84a:	d015      	beq.n	800c878 <ceilf+0x68>
 800c84c:	490c      	ldr	r1, [pc, #48]	; (800c880 <ceilf+0x70>)
 800c84e:	f7f3 fd9f 	bl	8000390 <__aeabi_fadd>
 800c852:	2100      	movs	r1, #0
 800c854:	f7f3 fd52 	bl	80002fc <__aeabi_fcmpgt>
 800c858:	2800      	cmp	r0, #0
 800c85a:	d0f1      	beq.n	800c840 <ceilf+0x30>
 800c85c:	2c00      	cmp	r4, #0
 800c85e:	dd03      	ble.n	800c868 <ceilf+0x58>
 800c860:	2380      	movs	r3, #128	; 0x80
 800c862:	041b      	lsls	r3, r3, #16
 800c864:	412b      	asrs	r3, r5
 800c866:	18e4      	adds	r4, r4, r3
 800c868:	43b4      	bics	r4, r6
 800c86a:	e7e9      	b.n	800c840 <ceilf+0x30>
 800c86c:	4b06      	ldr	r3, [pc, #24]	; (800c888 <ceilf+0x78>)
 800c86e:	429e      	cmp	r6, r3
 800c870:	d902      	bls.n	800c878 <ceilf+0x68>
 800c872:	1c01      	adds	r1, r0, #0
 800c874:	f7f3 fd8c 	bl	8000390 <__aeabi_fadd>
 800c878:	bd70      	pop	{r4, r5, r6, pc}
 800c87a:	2480      	movs	r4, #128	; 0x80
 800c87c:	0624      	lsls	r4, r4, #24
 800c87e:	e7df      	b.n	800c840 <ceilf+0x30>
 800c880:	7149f2ca 	.word	0x7149f2ca
 800c884:	007fffff 	.word	0x007fffff
 800c888:	7f7fffff 	.word	0x7f7fffff

0800c88c <cosf>:
 800c88c:	b507      	push	{r0, r1, r2, lr}
 800c88e:	4a18      	ldr	r2, [pc, #96]	; (800c8f0 <cosf+0x64>)
 800c890:	0043      	lsls	r3, r0, #1
 800c892:	085b      	lsrs	r3, r3, #1
 800c894:	2100      	movs	r1, #0
 800c896:	4293      	cmp	r3, r2
 800c898:	dd13      	ble.n	800c8c2 <cosf+0x36>
 800c89a:	4a16      	ldr	r2, [pc, #88]	; (800c8f4 <cosf+0x68>)
 800c89c:	4293      	cmp	r3, r2
 800c89e:	dd03      	ble.n	800c8a8 <cosf+0x1c>
 800c8a0:	1c01      	adds	r1, r0, #0
 800c8a2:	f7f4 fa17 	bl	8000cd4 <__aeabi_fsub>
 800c8a6:	bd0e      	pop	{r1, r2, r3, pc}
 800c8a8:	4669      	mov	r1, sp
 800c8aa:	f000 f99b 	bl	800cbe4 <__ieee754_rem_pio2f>
 800c8ae:	2203      	movs	r2, #3
 800c8b0:	4002      	ands	r2, r0
 800c8b2:	2a01      	cmp	r2, #1
 800c8b4:	d008      	beq.n	800c8c8 <cosf+0x3c>
 800c8b6:	2a02      	cmp	r2, #2
 800c8b8:	d00e      	beq.n	800c8d8 <cosf+0x4c>
 800c8ba:	2a00      	cmp	r2, #0
 800c8bc:	d111      	bne.n	800c8e2 <cosf+0x56>
 800c8be:	9901      	ldr	r1, [sp, #4]
 800c8c0:	9800      	ldr	r0, [sp, #0]
 800c8c2:	f000 fb45 	bl	800cf50 <__kernel_cosf>
 800c8c6:	e7ee      	b.n	800c8a6 <cosf+0x1a>
 800c8c8:	9901      	ldr	r1, [sp, #4]
 800c8ca:	9800      	ldr	r0, [sp, #0]
 800c8cc:	f000 fe9c 	bl	800d608 <__kernel_sinf>
 800c8d0:	2380      	movs	r3, #128	; 0x80
 800c8d2:	061b      	lsls	r3, r3, #24
 800c8d4:	18c0      	adds	r0, r0, r3
 800c8d6:	e7e6      	b.n	800c8a6 <cosf+0x1a>
 800c8d8:	9901      	ldr	r1, [sp, #4]
 800c8da:	9800      	ldr	r0, [sp, #0]
 800c8dc:	f000 fb38 	bl	800cf50 <__kernel_cosf>
 800c8e0:	e7f6      	b.n	800c8d0 <cosf+0x44>
 800c8e2:	2201      	movs	r2, #1
 800c8e4:	9901      	ldr	r1, [sp, #4]
 800c8e6:	9800      	ldr	r0, [sp, #0]
 800c8e8:	f000 fe8e 	bl	800d608 <__kernel_sinf>
 800c8ec:	e7db      	b.n	800c8a6 <cosf+0x1a>
 800c8ee:	46c0      	nop			; (mov r8, r8)
 800c8f0:	3f490fd8 	.word	0x3f490fd8
 800c8f4:	7f7fffff 	.word	0x7f7fffff

0800c8f8 <floorf>:
 800c8f8:	b570      	push	{r4, r5, r6, lr}
 800c8fa:	0045      	lsls	r5, r0, #1
 800c8fc:	086e      	lsrs	r6, r5, #1
 800c8fe:	0e2d      	lsrs	r5, r5, #24
 800c900:	3d7f      	subs	r5, #127	; 0x7f
 800c902:	0004      	movs	r4, r0
 800c904:	2d16      	cmp	r5, #22
 800c906:	dc24      	bgt.n	800c952 <floorf+0x5a>
 800c908:	2d00      	cmp	r5, #0
 800c90a:	da0e      	bge.n	800c92a <floorf+0x32>
 800c90c:	4915      	ldr	r1, [pc, #84]	; (800c964 <floorf+0x6c>)
 800c90e:	f7f3 fd3f 	bl	8000390 <__aeabi_fadd>
 800c912:	2100      	movs	r1, #0
 800c914:	f7f3 fcf2 	bl	80002fc <__aeabi_fcmpgt>
 800c918:	2800      	cmp	r0, #0
 800c91a:	d004      	beq.n	800c926 <floorf+0x2e>
 800c91c:	2c00      	cmp	r4, #0
 800c91e:	da1f      	bge.n	800c960 <floorf+0x68>
 800c920:	2e00      	cmp	r6, #0
 800c922:	d000      	beq.n	800c926 <floorf+0x2e>
 800c924:	4c10      	ldr	r4, [pc, #64]	; (800c968 <floorf+0x70>)
 800c926:	1c20      	adds	r0, r4, #0
 800c928:	e019      	b.n	800c95e <floorf+0x66>
 800c92a:	4e10      	ldr	r6, [pc, #64]	; (800c96c <floorf+0x74>)
 800c92c:	412e      	asrs	r6, r5
 800c92e:	4206      	tst	r6, r0
 800c930:	d015      	beq.n	800c95e <floorf+0x66>
 800c932:	490c      	ldr	r1, [pc, #48]	; (800c964 <floorf+0x6c>)
 800c934:	f7f3 fd2c 	bl	8000390 <__aeabi_fadd>
 800c938:	2100      	movs	r1, #0
 800c93a:	f7f3 fcdf 	bl	80002fc <__aeabi_fcmpgt>
 800c93e:	2800      	cmp	r0, #0
 800c940:	d0f1      	beq.n	800c926 <floorf+0x2e>
 800c942:	2c00      	cmp	r4, #0
 800c944:	da03      	bge.n	800c94e <floorf+0x56>
 800c946:	2380      	movs	r3, #128	; 0x80
 800c948:	041b      	lsls	r3, r3, #16
 800c94a:	412b      	asrs	r3, r5
 800c94c:	18e4      	adds	r4, r4, r3
 800c94e:	43b4      	bics	r4, r6
 800c950:	e7e9      	b.n	800c926 <floorf+0x2e>
 800c952:	4b07      	ldr	r3, [pc, #28]	; (800c970 <floorf+0x78>)
 800c954:	429e      	cmp	r6, r3
 800c956:	d902      	bls.n	800c95e <floorf+0x66>
 800c958:	1c01      	adds	r1, r0, #0
 800c95a:	f7f3 fd19 	bl	8000390 <__aeabi_fadd>
 800c95e:	bd70      	pop	{r4, r5, r6, pc}
 800c960:	2400      	movs	r4, #0
 800c962:	e7e0      	b.n	800c926 <floorf+0x2e>
 800c964:	7149f2ca 	.word	0x7149f2ca
 800c968:	bf800000 	.word	0xbf800000
 800c96c:	007fffff 	.word	0x007fffff
 800c970:	7f7fffff 	.word	0x7f7fffff

0800c974 <roundf>:
 800c974:	0dc3      	lsrs	r3, r0, #23
 800c976:	b2db      	uxtb	r3, r3
 800c978:	3b7f      	subs	r3, #127	; 0x7f
 800c97a:	b510      	push	{r4, lr}
 800c97c:	0002      	movs	r2, r0
 800c97e:	2b16      	cmp	r3, #22
 800c980:	dc13      	bgt.n	800c9aa <roundf+0x36>
 800c982:	2b00      	cmp	r3, #0
 800c984:	da07      	bge.n	800c996 <roundf+0x22>
 800c986:	0fc0      	lsrs	r0, r0, #31
 800c988:	07c0      	lsls	r0, r0, #31
 800c98a:	3301      	adds	r3, #1
 800c98c:	d102      	bne.n	800c994 <roundf+0x20>
 800c98e:	23fe      	movs	r3, #254	; 0xfe
 800c990:	059b      	lsls	r3, r3, #22
 800c992:	4318      	orrs	r0, r3
 800c994:	bd10      	pop	{r4, pc}
 800c996:	4908      	ldr	r1, [pc, #32]	; (800c9b8 <roundf+0x44>)
 800c998:	4119      	asrs	r1, r3
 800c99a:	4201      	tst	r1, r0
 800c99c:	d0fa      	beq.n	800c994 <roundf+0x20>
 800c99e:	2080      	movs	r0, #128	; 0x80
 800c9a0:	03c0      	lsls	r0, r0, #15
 800c9a2:	4118      	asrs	r0, r3
 800c9a4:	1880      	adds	r0, r0, r2
 800c9a6:	4388      	bics	r0, r1
 800c9a8:	e7f4      	b.n	800c994 <roundf+0x20>
 800c9aa:	2b80      	cmp	r3, #128	; 0x80
 800c9ac:	d1f2      	bne.n	800c994 <roundf+0x20>
 800c9ae:	1c01      	adds	r1, r0, #0
 800c9b0:	f7f3 fcee 	bl	8000390 <__aeabi_fadd>
 800c9b4:	e7ee      	b.n	800c994 <roundf+0x20>
 800c9b6:	46c0      	nop			; (mov r8, r8)
 800c9b8:	007fffff 	.word	0x007fffff

0800c9bc <sinf>:
 800c9bc:	b507      	push	{r0, r1, r2, lr}
 800c9be:	4a19      	ldr	r2, [pc, #100]	; (800ca24 <sinf+0x68>)
 800c9c0:	0043      	lsls	r3, r0, #1
 800c9c2:	085b      	lsrs	r3, r3, #1
 800c9c4:	4293      	cmp	r3, r2
 800c9c6:	dc04      	bgt.n	800c9d2 <sinf+0x16>
 800c9c8:	2200      	movs	r2, #0
 800c9ca:	2100      	movs	r1, #0
 800c9cc:	f000 fe1c 	bl	800d608 <__kernel_sinf>
 800c9d0:	e005      	b.n	800c9de <sinf+0x22>
 800c9d2:	4a15      	ldr	r2, [pc, #84]	; (800ca28 <sinf+0x6c>)
 800c9d4:	4293      	cmp	r3, r2
 800c9d6:	dd03      	ble.n	800c9e0 <sinf+0x24>
 800c9d8:	1c01      	adds	r1, r0, #0
 800c9da:	f7f4 f97b 	bl	8000cd4 <__aeabi_fsub>
 800c9de:	bd0e      	pop	{r1, r2, r3, pc}
 800c9e0:	4669      	mov	r1, sp
 800c9e2:	f000 f8ff 	bl	800cbe4 <__ieee754_rem_pio2f>
 800c9e6:	2303      	movs	r3, #3
 800c9e8:	4018      	ands	r0, r3
 800c9ea:	2801      	cmp	r0, #1
 800c9ec:	d007      	beq.n	800c9fe <sinf+0x42>
 800c9ee:	2802      	cmp	r0, #2
 800c9f0:	d00a      	beq.n	800ca08 <sinf+0x4c>
 800c9f2:	2800      	cmp	r0, #0
 800c9f4:	d111      	bne.n	800ca1a <sinf+0x5e>
 800c9f6:	2201      	movs	r2, #1
 800c9f8:	9901      	ldr	r1, [sp, #4]
 800c9fa:	9800      	ldr	r0, [sp, #0]
 800c9fc:	e7e6      	b.n	800c9cc <sinf+0x10>
 800c9fe:	9901      	ldr	r1, [sp, #4]
 800ca00:	9800      	ldr	r0, [sp, #0]
 800ca02:	f000 faa5 	bl	800cf50 <__kernel_cosf>
 800ca06:	e7ea      	b.n	800c9de <sinf+0x22>
 800ca08:	2201      	movs	r2, #1
 800ca0a:	9901      	ldr	r1, [sp, #4]
 800ca0c:	9800      	ldr	r0, [sp, #0]
 800ca0e:	f000 fdfb 	bl	800d608 <__kernel_sinf>
 800ca12:	2380      	movs	r3, #128	; 0x80
 800ca14:	061b      	lsls	r3, r3, #24
 800ca16:	18c0      	adds	r0, r0, r3
 800ca18:	e7e1      	b.n	800c9de <sinf+0x22>
 800ca1a:	9901      	ldr	r1, [sp, #4]
 800ca1c:	9800      	ldr	r0, [sp, #0]
 800ca1e:	f000 fa97 	bl	800cf50 <__kernel_cosf>
 800ca22:	e7f6      	b.n	800ca12 <sinf+0x56>
 800ca24:	3f490fd8 	.word	0x3f490fd8
 800ca28:	7f7fffff 	.word	0x7f7fffff

0800ca2c <atan2f>:
 800ca2c:	b510      	push	{r4, lr}
 800ca2e:	f000 f851 	bl	800cad4 <__ieee754_atan2f>
 800ca32:	bd10      	pop	{r4, pc}

0800ca34 <sqrtf>:
 800ca34:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ca36:	2500      	movs	r5, #0
 800ca38:	b08d      	sub	sp, #52	; 0x34
 800ca3a:	1c04      	adds	r4, r0, #0
 800ca3c:	f000 fa32 	bl	800cea4 <__ieee754_sqrtf>
 800ca40:	4b22      	ldr	r3, [pc, #136]	; (800cacc <sqrtf+0x98>)
 800ca42:	1c06      	adds	r6, r0, #0
 800ca44:	575d      	ldrsb	r5, [r3, r5]
 800ca46:	1c6b      	adds	r3, r5, #1
 800ca48:	d030      	beq.n	800caac <sqrtf+0x78>
 800ca4a:	1c21      	adds	r1, r4, #0
 800ca4c:	1c20      	adds	r0, r4, #0
 800ca4e:	f7f4 fadd 	bl	800100c <__aeabi_fcmpun>
 800ca52:	1e07      	subs	r7, r0, #0
 800ca54:	d12a      	bne.n	800caac <sqrtf+0x78>
 800ca56:	2100      	movs	r1, #0
 800ca58:	1c20      	adds	r0, r4, #0
 800ca5a:	f7f3 fc3b 	bl	80002d4 <__aeabi_fcmplt>
 800ca5e:	2800      	cmp	r0, #0
 800ca60:	d024      	beq.n	800caac <sqrtf+0x78>
 800ca62:	2301      	movs	r3, #1
 800ca64:	9302      	str	r3, [sp, #8]
 800ca66:	4b1a      	ldr	r3, [pc, #104]	; (800cad0 <sqrtf+0x9c>)
 800ca68:	1c20      	adds	r0, r4, #0
 800ca6a:	9303      	str	r3, [sp, #12]
 800ca6c:	970a      	str	r7, [sp, #40]	; 0x28
 800ca6e:	f7f5 fe29 	bl	80026c4 <__aeabi_f2d>
 800ca72:	2200      	movs	r2, #0
 800ca74:	9006      	str	r0, [sp, #24]
 800ca76:	9107      	str	r1, [sp, #28]
 800ca78:	9004      	str	r0, [sp, #16]
 800ca7a:	9105      	str	r1, [sp, #20]
 800ca7c:	2300      	movs	r3, #0
 800ca7e:	2d00      	cmp	r5, #0
 800ca80:	d117      	bne.n	800cab2 <sqrtf+0x7e>
 800ca82:	9208      	str	r2, [sp, #32]
 800ca84:	9309      	str	r3, [sp, #36]	; 0x24
 800ca86:	a802      	add	r0, sp, #8
 800ca88:	f000 fe34 	bl	800d6f4 <matherr>
 800ca8c:	2800      	cmp	r0, #0
 800ca8e:	d018      	beq.n	800cac2 <sqrtf+0x8e>
 800ca90:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ca92:	9301      	str	r3, [sp, #4]
 800ca94:	2b00      	cmp	r3, #0
 800ca96:	d004      	beq.n	800caa2 <sqrtf+0x6e>
 800ca98:	f000 ffa2 	bl	800d9e0 <__errno>
 800ca9c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ca9e:	9301      	str	r3, [sp, #4]
 800caa0:	6003      	str	r3, [r0, #0]
 800caa2:	9808      	ldr	r0, [sp, #32]
 800caa4:	9909      	ldr	r1, [sp, #36]	; 0x24
 800caa6:	f7f5 fe5f 	bl	8002768 <__aeabi_d2f>
 800caaa:	1c06      	adds	r6, r0, #0
 800caac:	1c30      	adds	r0, r6, #0
 800caae:	b00d      	add	sp, #52	; 0x34
 800cab0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800cab2:	0010      	movs	r0, r2
 800cab4:	0019      	movs	r1, r3
 800cab6:	f7f4 fe87 	bl	80017c8 <__aeabi_ddiv>
 800caba:	9008      	str	r0, [sp, #32]
 800cabc:	9109      	str	r1, [sp, #36]	; 0x24
 800cabe:	2d02      	cmp	r5, #2
 800cac0:	d1e1      	bne.n	800ca86 <sqrtf+0x52>
 800cac2:	f000 ff8d 	bl	800d9e0 <__errno>
 800cac6:	2321      	movs	r3, #33	; 0x21
 800cac8:	6003      	str	r3, [r0, #0]
 800caca:	e7e1      	b.n	800ca90 <sqrtf+0x5c>
 800cacc:	20000078 	.word	0x20000078
 800cad0:	0800e198 	.word	0x0800e198

0800cad4 <__ieee754_atan2f>:
 800cad4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800cad6:	25ff      	movs	r5, #255	; 0xff
 800cad8:	004a      	lsls	r2, r1, #1
 800cada:	9101      	str	r1, [sp, #4]
 800cadc:	0852      	lsrs	r2, r2, #1
 800cade:	05ed      	lsls	r5, r5, #23
 800cae0:	42aa      	cmp	r2, r5
 800cae2:	dc04      	bgt.n	800caee <__ieee754_atan2f+0x1a>
 800cae4:	0043      	lsls	r3, r0, #1
 800cae6:	0007      	movs	r7, r0
 800cae8:	085b      	lsrs	r3, r3, #1
 800caea:	42ab      	cmp	r3, r5
 800caec:	dd02      	ble.n	800caf4 <__ieee754_atan2f+0x20>
 800caee:	f7f3 fc4f 	bl	8000390 <__aeabi_fadd>
 800caf2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800caf4:	24fe      	movs	r4, #254	; 0xfe
 800caf6:	05a4      	lsls	r4, r4, #22
 800caf8:	42a1      	cmp	r1, r4
 800cafa:	d102      	bne.n	800cb02 <__ieee754_atan2f+0x2e>
 800cafc:	f000 fdfc 	bl	800d6f8 <atanf>
 800cb00:	e7f7      	b.n	800caf2 <__ieee754_atan2f+0x1e>
 800cb02:	2602      	movs	r6, #2
 800cb04:	178c      	asrs	r4, r1, #30
 800cb06:	4034      	ands	r4, r6
 800cb08:	0fc6      	lsrs	r6, r0, #31
 800cb0a:	4334      	orrs	r4, r6
 800cb0c:	2b00      	cmp	r3, #0
 800cb0e:	d105      	bne.n	800cb1c <__ieee754_atan2f+0x48>
 800cb10:	2c02      	cmp	r4, #2
 800cb12:	d023      	beq.n	800cb5c <__ieee754_atan2f+0x88>
 800cb14:	2c03      	cmp	r4, #3
 800cb16:	d1ec      	bne.n	800caf2 <__ieee754_atan2f+0x1e>
 800cb18:	4829      	ldr	r0, [pc, #164]	; (800cbc0 <__ieee754_atan2f+0xec>)
 800cb1a:	e7ea      	b.n	800caf2 <__ieee754_atan2f+0x1e>
 800cb1c:	2a00      	cmp	r2, #0
 800cb1e:	d103      	bne.n	800cb28 <__ieee754_atan2f+0x54>
 800cb20:	2f00      	cmp	r7, #0
 800cb22:	da4a      	bge.n	800cbba <__ieee754_atan2f+0xe6>
 800cb24:	4827      	ldr	r0, [pc, #156]	; (800cbc4 <__ieee754_atan2f+0xf0>)
 800cb26:	e7e4      	b.n	800caf2 <__ieee754_atan2f+0x1e>
 800cb28:	42aa      	cmp	r2, r5
 800cb2a:	d119      	bne.n	800cb60 <__ieee754_atan2f+0x8c>
 800cb2c:	4293      	cmp	r3, r2
 800cb2e:	d10b      	bne.n	800cb48 <__ieee754_atan2f+0x74>
 800cb30:	2c02      	cmp	r4, #2
 800cb32:	d005      	beq.n	800cb40 <__ieee754_atan2f+0x6c>
 800cb34:	2c03      	cmp	r4, #3
 800cb36:	d005      	beq.n	800cb44 <__ieee754_atan2f+0x70>
 800cb38:	2c01      	cmp	r4, #1
 800cb3a:	d13c      	bne.n	800cbb6 <__ieee754_atan2f+0xe2>
 800cb3c:	4822      	ldr	r0, [pc, #136]	; (800cbc8 <__ieee754_atan2f+0xf4>)
 800cb3e:	e7d8      	b.n	800caf2 <__ieee754_atan2f+0x1e>
 800cb40:	4822      	ldr	r0, [pc, #136]	; (800cbcc <__ieee754_atan2f+0xf8>)
 800cb42:	e7d6      	b.n	800caf2 <__ieee754_atan2f+0x1e>
 800cb44:	4822      	ldr	r0, [pc, #136]	; (800cbd0 <__ieee754_atan2f+0xfc>)
 800cb46:	e7d4      	b.n	800caf2 <__ieee754_atan2f+0x1e>
 800cb48:	2c02      	cmp	r4, #2
 800cb4a:	d007      	beq.n	800cb5c <__ieee754_atan2f+0x88>
 800cb4c:	2c03      	cmp	r4, #3
 800cb4e:	d0e3      	beq.n	800cb18 <__ieee754_atan2f+0x44>
 800cb50:	2000      	movs	r0, #0
 800cb52:	2c01      	cmp	r4, #1
 800cb54:	d1cd      	bne.n	800caf2 <__ieee754_atan2f+0x1e>
 800cb56:	2080      	movs	r0, #128	; 0x80
 800cb58:	0600      	lsls	r0, r0, #24
 800cb5a:	e7ca      	b.n	800caf2 <__ieee754_atan2f+0x1e>
 800cb5c:	481d      	ldr	r0, [pc, #116]	; (800cbd4 <__ieee754_atan2f+0x100>)
 800cb5e:	e7c8      	b.n	800caf2 <__ieee754_atan2f+0x1e>
 800cb60:	42ab      	cmp	r3, r5
 800cb62:	d0dd      	beq.n	800cb20 <__ieee754_atan2f+0x4c>
 800cb64:	1a9b      	subs	r3, r3, r2
 800cb66:	15db      	asrs	r3, r3, #23
 800cb68:	2b3c      	cmp	r3, #60	; 0x3c
 800cb6a:	dc14      	bgt.n	800cb96 <__ieee754_atan2f+0xc2>
 800cb6c:	2900      	cmp	r1, #0
 800cb6e:	da01      	bge.n	800cb74 <__ieee754_atan2f+0xa0>
 800cb70:	333c      	adds	r3, #60	; 0x3c
 800cb72:	db12      	blt.n	800cb9a <__ieee754_atan2f+0xc6>
 800cb74:	f7f3 fd9e 	bl	80006b4 <__aeabi_fdiv>
 800cb78:	f000 fed6 	bl	800d928 <fabsf>
 800cb7c:	f000 fdbc 	bl	800d6f8 <atanf>
 800cb80:	2c01      	cmp	r4, #1
 800cb82:	d00c      	beq.n	800cb9e <__ieee754_atan2f+0xca>
 800cb84:	2c02      	cmp	r4, #2
 800cb86:	d00e      	beq.n	800cba6 <__ieee754_atan2f+0xd2>
 800cb88:	2c00      	cmp	r4, #0
 800cb8a:	d0b2      	beq.n	800caf2 <__ieee754_atan2f+0x1e>
 800cb8c:	4912      	ldr	r1, [pc, #72]	; (800cbd8 <__ieee754_atan2f+0x104>)
 800cb8e:	f7f3 fbff 	bl	8000390 <__aeabi_fadd>
 800cb92:	4910      	ldr	r1, [pc, #64]	; (800cbd4 <__ieee754_atan2f+0x100>)
 800cb94:	e00c      	b.n	800cbb0 <__ieee754_atan2f+0xdc>
 800cb96:	4811      	ldr	r0, [pc, #68]	; (800cbdc <__ieee754_atan2f+0x108>)
 800cb98:	e7f2      	b.n	800cb80 <__ieee754_atan2f+0xac>
 800cb9a:	2000      	movs	r0, #0
 800cb9c:	e7f0      	b.n	800cb80 <__ieee754_atan2f+0xac>
 800cb9e:	2380      	movs	r3, #128	; 0x80
 800cba0:	061b      	lsls	r3, r3, #24
 800cba2:	18c0      	adds	r0, r0, r3
 800cba4:	e7a5      	b.n	800caf2 <__ieee754_atan2f+0x1e>
 800cba6:	490c      	ldr	r1, [pc, #48]	; (800cbd8 <__ieee754_atan2f+0x104>)
 800cba8:	f7f3 fbf2 	bl	8000390 <__aeabi_fadd>
 800cbac:	1c01      	adds	r1, r0, #0
 800cbae:	4809      	ldr	r0, [pc, #36]	; (800cbd4 <__ieee754_atan2f+0x100>)
 800cbb0:	f7f4 f890 	bl	8000cd4 <__aeabi_fsub>
 800cbb4:	e79d      	b.n	800caf2 <__ieee754_atan2f+0x1e>
 800cbb6:	480a      	ldr	r0, [pc, #40]	; (800cbe0 <__ieee754_atan2f+0x10c>)
 800cbb8:	e79b      	b.n	800caf2 <__ieee754_atan2f+0x1e>
 800cbba:	4808      	ldr	r0, [pc, #32]	; (800cbdc <__ieee754_atan2f+0x108>)
 800cbbc:	e799      	b.n	800caf2 <__ieee754_atan2f+0x1e>
 800cbbe:	46c0      	nop			; (mov r8, r8)
 800cbc0:	c0490fdb 	.word	0xc0490fdb
 800cbc4:	bfc90fdb 	.word	0xbfc90fdb
 800cbc8:	bf490fdb 	.word	0xbf490fdb
 800cbcc:	4016cbe4 	.word	0x4016cbe4
 800cbd0:	c016cbe4 	.word	0xc016cbe4
 800cbd4:	40490fdb 	.word	0x40490fdb
 800cbd8:	33bbbd2e 	.word	0x33bbbd2e
 800cbdc:	3fc90fdb 	.word	0x3fc90fdb
 800cbe0:	3f490fdb 	.word	0x3f490fdb

0800cbe4 <__ieee754_rem_pio2f>:
 800cbe4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800cbe6:	4ba1      	ldr	r3, [pc, #644]	; (800ce6c <__ieee754_rem_pio2f+0x288>)
 800cbe8:	b08d      	sub	sp, #52	; 0x34
 800cbea:	0045      	lsls	r5, r0, #1
 800cbec:	000c      	movs	r4, r1
 800cbee:	9006      	str	r0, [sp, #24]
 800cbf0:	086d      	lsrs	r5, r5, #1
 800cbf2:	429d      	cmp	r5, r3
 800cbf4:	dc04      	bgt.n	800cc00 <__ieee754_rem_pio2f+0x1c>
 800cbf6:	2300      	movs	r3, #0
 800cbf8:	6008      	str	r0, [r1, #0]
 800cbfa:	604b      	str	r3, [r1, #4]
 800cbfc:	2700      	movs	r7, #0
 800cbfe:	e01a      	b.n	800cc36 <__ieee754_rem_pio2f+0x52>
 800cc00:	4b9b      	ldr	r3, [pc, #620]	; (800ce70 <__ieee754_rem_pio2f+0x28c>)
 800cc02:	429d      	cmp	r5, r3
 800cc04:	dc4c      	bgt.n	800cca0 <__ieee754_rem_pio2f+0xbc>
 800cc06:	4e9b      	ldr	r6, [pc, #620]	; (800ce74 <__ieee754_rem_pio2f+0x290>)
 800cc08:	499b      	ldr	r1, [pc, #620]	; (800ce78 <__ieee754_rem_pio2f+0x294>)
 800cc0a:	2800      	cmp	r0, #0
 800cc0c:	dd24      	ble.n	800cc58 <__ieee754_rem_pio2f+0x74>
 800cc0e:	f7f4 f861 	bl	8000cd4 <__aeabi_fsub>
 800cc12:	230f      	movs	r3, #15
 800cc14:	1c07      	adds	r7, r0, #0
 800cc16:	439d      	bics	r5, r3
 800cc18:	42b5      	cmp	r5, r6
 800cc1a:	d00f      	beq.n	800cc3c <__ieee754_rem_pio2f+0x58>
 800cc1c:	4997      	ldr	r1, [pc, #604]	; (800ce7c <__ieee754_rem_pio2f+0x298>)
 800cc1e:	f7f4 f859 	bl	8000cd4 <__aeabi_fsub>
 800cc22:	1c01      	adds	r1, r0, #0
 800cc24:	6020      	str	r0, [r4, #0]
 800cc26:	1c38      	adds	r0, r7, #0
 800cc28:	f7f4 f854 	bl	8000cd4 <__aeabi_fsub>
 800cc2c:	4993      	ldr	r1, [pc, #588]	; (800ce7c <__ieee754_rem_pio2f+0x298>)
 800cc2e:	f7f4 f851 	bl	8000cd4 <__aeabi_fsub>
 800cc32:	2701      	movs	r7, #1
 800cc34:	6060      	str	r0, [r4, #4]
 800cc36:	0038      	movs	r0, r7
 800cc38:	b00d      	add	sp, #52	; 0x34
 800cc3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800cc3c:	4990      	ldr	r1, [pc, #576]	; (800ce80 <__ieee754_rem_pio2f+0x29c>)
 800cc3e:	f7f4 f849 	bl	8000cd4 <__aeabi_fsub>
 800cc42:	4990      	ldr	r1, [pc, #576]	; (800ce84 <__ieee754_rem_pio2f+0x2a0>)
 800cc44:	1c05      	adds	r5, r0, #0
 800cc46:	f7f4 f845 	bl	8000cd4 <__aeabi_fsub>
 800cc4a:	1c01      	adds	r1, r0, #0
 800cc4c:	6020      	str	r0, [r4, #0]
 800cc4e:	1c28      	adds	r0, r5, #0
 800cc50:	f7f4 f840 	bl	8000cd4 <__aeabi_fsub>
 800cc54:	498b      	ldr	r1, [pc, #556]	; (800ce84 <__ieee754_rem_pio2f+0x2a0>)
 800cc56:	e7ea      	b.n	800cc2e <__ieee754_rem_pio2f+0x4a>
 800cc58:	f7f3 fb9a 	bl	8000390 <__aeabi_fadd>
 800cc5c:	230f      	movs	r3, #15
 800cc5e:	1c07      	adds	r7, r0, #0
 800cc60:	439d      	bics	r5, r3
 800cc62:	42b5      	cmp	r5, r6
 800cc64:	d00e      	beq.n	800cc84 <__ieee754_rem_pio2f+0xa0>
 800cc66:	4985      	ldr	r1, [pc, #532]	; (800ce7c <__ieee754_rem_pio2f+0x298>)
 800cc68:	f7f3 fb92 	bl	8000390 <__aeabi_fadd>
 800cc6c:	1c01      	adds	r1, r0, #0
 800cc6e:	6020      	str	r0, [r4, #0]
 800cc70:	1c38      	adds	r0, r7, #0
 800cc72:	f7f4 f82f 	bl	8000cd4 <__aeabi_fsub>
 800cc76:	4981      	ldr	r1, [pc, #516]	; (800ce7c <__ieee754_rem_pio2f+0x298>)
 800cc78:	f7f3 fb8a 	bl	8000390 <__aeabi_fadd>
 800cc7c:	2701      	movs	r7, #1
 800cc7e:	6060      	str	r0, [r4, #4]
 800cc80:	427f      	negs	r7, r7
 800cc82:	e7d8      	b.n	800cc36 <__ieee754_rem_pio2f+0x52>
 800cc84:	497e      	ldr	r1, [pc, #504]	; (800ce80 <__ieee754_rem_pio2f+0x29c>)
 800cc86:	f7f3 fb83 	bl	8000390 <__aeabi_fadd>
 800cc8a:	497e      	ldr	r1, [pc, #504]	; (800ce84 <__ieee754_rem_pio2f+0x2a0>)
 800cc8c:	1c05      	adds	r5, r0, #0
 800cc8e:	f7f3 fb7f 	bl	8000390 <__aeabi_fadd>
 800cc92:	1c01      	adds	r1, r0, #0
 800cc94:	6020      	str	r0, [r4, #0]
 800cc96:	1c28      	adds	r0, r5, #0
 800cc98:	f7f4 f81c 	bl	8000cd4 <__aeabi_fsub>
 800cc9c:	4979      	ldr	r1, [pc, #484]	; (800ce84 <__ieee754_rem_pio2f+0x2a0>)
 800cc9e:	e7eb      	b.n	800cc78 <__ieee754_rem_pio2f+0x94>
 800cca0:	4b79      	ldr	r3, [pc, #484]	; (800ce88 <__ieee754_rem_pio2f+0x2a4>)
 800cca2:	429d      	cmp	r5, r3
 800cca4:	dd00      	ble.n	800cca8 <__ieee754_rem_pio2f+0xc4>
 800cca6:	e091      	b.n	800cdcc <__ieee754_rem_pio2f+0x1e8>
 800cca8:	f000 fe3e 	bl	800d928 <fabsf>
 800ccac:	4977      	ldr	r1, [pc, #476]	; (800ce8c <__ieee754_rem_pio2f+0x2a8>)
 800ccae:	1c06      	adds	r6, r0, #0
 800ccb0:	f7f3 fef0 	bl	8000a94 <__aeabi_fmul>
 800ccb4:	21fc      	movs	r1, #252	; 0xfc
 800ccb6:	0589      	lsls	r1, r1, #22
 800ccb8:	f7f3 fb6a 	bl	8000390 <__aeabi_fadd>
 800ccbc:	f7f4 f9be 	bl	800103c <__aeabi_f2iz>
 800ccc0:	0007      	movs	r7, r0
 800ccc2:	f7f4 f9db 	bl	800107c <__aeabi_i2f>
 800ccc6:	496c      	ldr	r1, [pc, #432]	; (800ce78 <__ieee754_rem_pio2f+0x294>)
 800ccc8:	9004      	str	r0, [sp, #16]
 800ccca:	f7f3 fee3 	bl	8000a94 <__aeabi_fmul>
 800ccce:	1c01      	adds	r1, r0, #0
 800ccd0:	1c30      	adds	r0, r6, #0
 800ccd2:	f7f3 ffff 	bl	8000cd4 <__aeabi_fsub>
 800ccd6:	4969      	ldr	r1, [pc, #420]	; (800ce7c <__ieee754_rem_pio2f+0x298>)
 800ccd8:	1c06      	adds	r6, r0, #0
 800ccda:	9804      	ldr	r0, [sp, #16]
 800ccdc:	f7f3 feda 	bl	8000a94 <__aeabi_fmul>
 800cce0:	9003      	str	r0, [sp, #12]
 800cce2:	2f1f      	cmp	r7, #31
 800cce4:	dc0d      	bgt.n	800cd02 <__ieee754_rem_pio2f+0x11e>
 800cce6:	23ff      	movs	r3, #255	; 0xff
 800cce8:	002a      	movs	r2, r5
 800ccea:	4969      	ldr	r1, [pc, #420]	; (800ce90 <__ieee754_rem_pio2f+0x2ac>)
 800ccec:	439a      	bics	r2, r3
 800ccee:	1e7b      	subs	r3, r7, #1
 800ccf0:	009b      	lsls	r3, r3, #2
 800ccf2:	585b      	ldr	r3, [r3, r1]
 800ccf4:	429a      	cmp	r2, r3
 800ccf6:	d004      	beq.n	800cd02 <__ieee754_rem_pio2f+0x11e>
 800ccf8:	1c01      	adds	r1, r0, #0
 800ccfa:	1c30      	adds	r0, r6, #0
 800ccfc:	f7f3 ffea 	bl	8000cd4 <__aeabi_fsub>
 800cd00:	e00c      	b.n	800cd1c <__ieee754_rem_pio2f+0x138>
 800cd02:	9903      	ldr	r1, [sp, #12]
 800cd04:	1c30      	adds	r0, r6, #0
 800cd06:	f7f3 ffe5 	bl	8000cd4 <__aeabi_fsub>
 800cd0a:	22ff      	movs	r2, #255	; 0xff
 800cd0c:	15eb      	asrs	r3, r5, #23
 800cd0e:	9307      	str	r3, [sp, #28]
 800cd10:	0dc3      	lsrs	r3, r0, #23
 800cd12:	4013      	ands	r3, r2
 800cd14:	9a07      	ldr	r2, [sp, #28]
 800cd16:	1ad3      	subs	r3, r2, r3
 800cd18:	2b08      	cmp	r3, #8
 800cd1a:	dc01      	bgt.n	800cd20 <__ieee754_rem_pio2f+0x13c>
 800cd1c:	6020      	str	r0, [r4, #0]
 800cd1e:	e026      	b.n	800cd6e <__ieee754_rem_pio2f+0x18a>
 800cd20:	4957      	ldr	r1, [pc, #348]	; (800ce80 <__ieee754_rem_pio2f+0x29c>)
 800cd22:	9804      	ldr	r0, [sp, #16]
 800cd24:	f7f3 feb6 	bl	8000a94 <__aeabi_fmul>
 800cd28:	1c05      	adds	r5, r0, #0
 800cd2a:	1c01      	adds	r1, r0, #0
 800cd2c:	1c30      	adds	r0, r6, #0
 800cd2e:	f7f3 ffd1 	bl	8000cd4 <__aeabi_fsub>
 800cd32:	1c01      	adds	r1, r0, #0
 800cd34:	9005      	str	r0, [sp, #20]
 800cd36:	1c30      	adds	r0, r6, #0
 800cd38:	f7f3 ffcc 	bl	8000cd4 <__aeabi_fsub>
 800cd3c:	1c29      	adds	r1, r5, #0
 800cd3e:	f7f3 ffc9 	bl	8000cd4 <__aeabi_fsub>
 800cd42:	4950      	ldr	r1, [pc, #320]	; (800ce84 <__ieee754_rem_pio2f+0x2a0>)
 800cd44:	1c05      	adds	r5, r0, #0
 800cd46:	9804      	ldr	r0, [sp, #16]
 800cd48:	f7f3 fea4 	bl	8000a94 <__aeabi_fmul>
 800cd4c:	1c29      	adds	r1, r5, #0
 800cd4e:	f7f3 ffc1 	bl	8000cd4 <__aeabi_fsub>
 800cd52:	9003      	str	r0, [sp, #12]
 800cd54:	1c01      	adds	r1, r0, #0
 800cd56:	9805      	ldr	r0, [sp, #20]
 800cd58:	f7f3 ffbc 	bl	8000cd4 <__aeabi_fsub>
 800cd5c:	23ff      	movs	r3, #255	; 0xff
 800cd5e:	0dc5      	lsrs	r5, r0, #23
 800cd60:	401d      	ands	r5, r3
 800cd62:	9b07      	ldr	r3, [sp, #28]
 800cd64:	1b5d      	subs	r5, r3, r5
 800cd66:	2d19      	cmp	r5, #25
 800cd68:	dc15      	bgt.n	800cd96 <__ieee754_rem_pio2f+0x1b2>
 800cd6a:	9e05      	ldr	r6, [sp, #20]
 800cd6c:	6020      	str	r0, [r4, #0]
 800cd6e:	6825      	ldr	r5, [r4, #0]
 800cd70:	1c30      	adds	r0, r6, #0
 800cd72:	1c29      	adds	r1, r5, #0
 800cd74:	f7f3 ffae 	bl	8000cd4 <__aeabi_fsub>
 800cd78:	9903      	ldr	r1, [sp, #12]
 800cd7a:	f7f3 ffab 	bl	8000cd4 <__aeabi_fsub>
 800cd7e:	9b06      	ldr	r3, [sp, #24]
 800cd80:	6060      	str	r0, [r4, #4]
 800cd82:	2b00      	cmp	r3, #0
 800cd84:	db00      	blt.n	800cd88 <__ieee754_rem_pio2f+0x1a4>
 800cd86:	e756      	b.n	800cc36 <__ieee754_rem_pio2f+0x52>
 800cd88:	2380      	movs	r3, #128	; 0x80
 800cd8a:	061b      	lsls	r3, r3, #24
 800cd8c:	18ed      	adds	r5, r5, r3
 800cd8e:	18c0      	adds	r0, r0, r3
 800cd90:	6025      	str	r5, [r4, #0]
 800cd92:	6060      	str	r0, [r4, #4]
 800cd94:	e774      	b.n	800cc80 <__ieee754_rem_pio2f+0x9c>
 800cd96:	493f      	ldr	r1, [pc, #252]	; (800ce94 <__ieee754_rem_pio2f+0x2b0>)
 800cd98:	9804      	ldr	r0, [sp, #16]
 800cd9a:	f7f3 fe7b 	bl	8000a94 <__aeabi_fmul>
 800cd9e:	1c05      	adds	r5, r0, #0
 800cda0:	1c01      	adds	r1, r0, #0
 800cda2:	9805      	ldr	r0, [sp, #20]
 800cda4:	f7f3 ff96 	bl	8000cd4 <__aeabi_fsub>
 800cda8:	1c01      	adds	r1, r0, #0
 800cdaa:	1c06      	adds	r6, r0, #0
 800cdac:	9805      	ldr	r0, [sp, #20]
 800cdae:	f7f3 ff91 	bl	8000cd4 <__aeabi_fsub>
 800cdb2:	1c29      	adds	r1, r5, #0
 800cdb4:	f7f3 ff8e 	bl	8000cd4 <__aeabi_fsub>
 800cdb8:	4937      	ldr	r1, [pc, #220]	; (800ce98 <__ieee754_rem_pio2f+0x2b4>)
 800cdba:	1c05      	adds	r5, r0, #0
 800cdbc:	9804      	ldr	r0, [sp, #16]
 800cdbe:	f7f3 fe69 	bl	8000a94 <__aeabi_fmul>
 800cdc2:	1c29      	adds	r1, r5, #0
 800cdc4:	f7f3 ff86 	bl	8000cd4 <__aeabi_fsub>
 800cdc8:	9003      	str	r0, [sp, #12]
 800cdca:	e795      	b.n	800ccf8 <__ieee754_rem_pio2f+0x114>
 800cdcc:	4b33      	ldr	r3, [pc, #204]	; (800ce9c <__ieee754_rem_pio2f+0x2b8>)
 800cdce:	429d      	cmp	r5, r3
 800cdd0:	dd05      	ble.n	800cdde <__ieee754_rem_pio2f+0x1fa>
 800cdd2:	1c01      	adds	r1, r0, #0
 800cdd4:	f7f3 ff7e 	bl	8000cd4 <__aeabi_fsub>
 800cdd8:	6060      	str	r0, [r4, #4]
 800cdda:	6020      	str	r0, [r4, #0]
 800cddc:	e70e      	b.n	800cbfc <__ieee754_rem_pio2f+0x18>
 800cdde:	15ee      	asrs	r6, r5, #23
 800cde0:	3e86      	subs	r6, #134	; 0x86
 800cde2:	05f3      	lsls	r3, r6, #23
 800cde4:	1aed      	subs	r5, r5, r3
 800cde6:	1c28      	adds	r0, r5, #0
 800cde8:	f7f4 f928 	bl	800103c <__aeabi_f2iz>
 800cdec:	f7f4 f946 	bl	800107c <__aeabi_i2f>
 800cdf0:	1c01      	adds	r1, r0, #0
 800cdf2:	9009      	str	r0, [sp, #36]	; 0x24
 800cdf4:	1c28      	adds	r0, r5, #0
 800cdf6:	f7f3 ff6d 	bl	8000cd4 <__aeabi_fsub>
 800cdfa:	2187      	movs	r1, #135	; 0x87
 800cdfc:	05c9      	lsls	r1, r1, #23
 800cdfe:	f7f3 fe49 	bl	8000a94 <__aeabi_fmul>
 800ce02:	1c07      	adds	r7, r0, #0
 800ce04:	f7f4 f91a 	bl	800103c <__aeabi_f2iz>
 800ce08:	f7f4 f938 	bl	800107c <__aeabi_i2f>
 800ce0c:	1c01      	adds	r1, r0, #0
 800ce0e:	900a      	str	r0, [sp, #40]	; 0x28
 800ce10:	1c05      	adds	r5, r0, #0
 800ce12:	1c38      	adds	r0, r7, #0
 800ce14:	f7f3 ff5e 	bl	8000cd4 <__aeabi_fsub>
 800ce18:	2187      	movs	r1, #135	; 0x87
 800ce1a:	05c9      	lsls	r1, r1, #23
 800ce1c:	f7f3 fe3a 	bl	8000a94 <__aeabi_fmul>
 800ce20:	2100      	movs	r1, #0
 800ce22:	900b      	str	r0, [sp, #44]	; 0x2c
 800ce24:	f7f3 fa50 	bl	80002c8 <__aeabi_fcmpeq>
 800ce28:	2303      	movs	r3, #3
 800ce2a:	2800      	cmp	r0, #0
 800ce2c:	d006      	beq.n	800ce3c <__ieee754_rem_pio2f+0x258>
 800ce2e:	2100      	movs	r1, #0
 800ce30:	1c28      	adds	r0, r5, #0
 800ce32:	f7f3 fa49 	bl	80002c8 <__aeabi_fcmpeq>
 800ce36:	4243      	negs	r3, r0
 800ce38:	4143      	adcs	r3, r0
 800ce3a:	3301      	adds	r3, #1
 800ce3c:	4a18      	ldr	r2, [pc, #96]	; (800cea0 <__ieee754_rem_pio2f+0x2bc>)
 800ce3e:	0021      	movs	r1, r4
 800ce40:	9201      	str	r2, [sp, #4]
 800ce42:	2202      	movs	r2, #2
 800ce44:	a809      	add	r0, sp, #36	; 0x24
 800ce46:	9200      	str	r2, [sp, #0]
 800ce48:	0032      	movs	r2, r6
 800ce4a:	f000 f917 	bl	800d07c <__kernel_rem_pio2f>
 800ce4e:	9b06      	ldr	r3, [sp, #24]
 800ce50:	0007      	movs	r7, r0
 800ce52:	2b00      	cmp	r3, #0
 800ce54:	db00      	blt.n	800ce58 <__ieee754_rem_pio2f+0x274>
 800ce56:	e6ee      	b.n	800cc36 <__ieee754_rem_pio2f+0x52>
 800ce58:	2280      	movs	r2, #128	; 0x80
 800ce5a:	6823      	ldr	r3, [r4, #0]
 800ce5c:	0612      	lsls	r2, r2, #24
 800ce5e:	189b      	adds	r3, r3, r2
 800ce60:	6023      	str	r3, [r4, #0]
 800ce62:	6863      	ldr	r3, [r4, #4]
 800ce64:	189b      	adds	r3, r3, r2
 800ce66:	6063      	str	r3, [r4, #4]
 800ce68:	e70a      	b.n	800cc80 <__ieee754_rem_pio2f+0x9c>
 800ce6a:	46c0      	nop			; (mov r8, r8)
 800ce6c:	3f490fd8 	.word	0x3f490fd8
 800ce70:	4016cbe3 	.word	0x4016cbe3
 800ce74:	3fc90fd0 	.word	0x3fc90fd0
 800ce78:	3fc90f80 	.word	0x3fc90f80
 800ce7c:	37354443 	.word	0x37354443
 800ce80:	37354400 	.word	0x37354400
 800ce84:	2e85a308 	.word	0x2e85a308
 800ce88:	43490f80 	.word	0x43490f80
 800ce8c:	3f22f984 	.word	0x3f22f984
 800ce90:	0800e1a0 	.word	0x0800e1a0
 800ce94:	2e85a300 	.word	0x2e85a300
 800ce98:	248d3132 	.word	0x248d3132
 800ce9c:	7f7fffff 	.word	0x7f7fffff
 800cea0:	0800e220 	.word	0x0800e220

0800cea4 <__ieee754_sqrtf>:
 800cea4:	4928      	ldr	r1, [pc, #160]	; (800cf48 <__ieee754_sqrtf+0xa4>)
 800cea6:	0043      	lsls	r3, r0, #1
 800cea8:	b570      	push	{r4, r5, r6, lr}
 800ceaa:	0002      	movs	r2, r0
 800ceac:	1c04      	adds	r4, r0, #0
 800ceae:	085b      	lsrs	r3, r3, #1
 800ceb0:	428b      	cmp	r3, r1
 800ceb2:	d909      	bls.n	800cec8 <__ieee754_sqrtf+0x24>
 800ceb4:	1c01      	adds	r1, r0, #0
 800ceb6:	f7f3 fded 	bl	8000a94 <__aeabi_fmul>
 800ceba:	1c01      	adds	r1, r0, #0
 800cebc:	1c20      	adds	r0, r4, #0
 800cebe:	f7f3 fa67 	bl	8000390 <__aeabi_fadd>
 800cec2:	1c04      	adds	r4, r0, #0
 800cec4:	1c20      	adds	r0, r4, #0
 800cec6:	bd70      	pop	{r4, r5, r6, pc}
 800cec8:	2b00      	cmp	r3, #0
 800ceca:	d0fb      	beq.n	800cec4 <__ieee754_sqrtf+0x20>
 800cecc:	2800      	cmp	r0, #0
 800cece:	da06      	bge.n	800cede <__ieee754_sqrtf+0x3a>
 800ced0:	1c01      	adds	r1, r0, #0
 800ced2:	f7f3 feff 	bl	8000cd4 <__aeabi_fsub>
 800ced6:	1c01      	adds	r1, r0, #0
 800ced8:	f7f3 fbec 	bl	80006b4 <__aeabi_fdiv>
 800cedc:	e7f1      	b.n	800cec2 <__ieee754_sqrtf+0x1e>
 800cede:	491b      	ldr	r1, [pc, #108]	; (800cf4c <__ieee754_sqrtf+0xa8>)
 800cee0:	15c4      	asrs	r4, r0, #23
 800cee2:	428b      	cmp	r3, r1
 800cee4:	d805      	bhi.n	800cef2 <__ieee754_sqrtf+0x4e>
 800cee6:	2300      	movs	r3, #0
 800cee8:	3101      	adds	r1, #1
 800ceea:	420a      	tst	r2, r1
 800ceec:	d028      	beq.n	800cf40 <__ieee754_sqrtf+0x9c>
 800ceee:	3b01      	subs	r3, #1
 800cef0:	1ae4      	subs	r4, r4, r3
 800cef2:	0252      	lsls	r2, r2, #9
 800cef4:	0a53      	lsrs	r3, r2, #9
 800cef6:	2280      	movs	r2, #128	; 0x80
 800cef8:	3c7f      	subs	r4, #127	; 0x7f
 800cefa:	0412      	lsls	r2, r2, #16
 800cefc:	431a      	orrs	r2, r3
 800cefe:	07e3      	lsls	r3, r4, #31
 800cf00:	d500      	bpl.n	800cf04 <__ieee754_sqrtf+0x60>
 800cf02:	0052      	lsls	r2, r2, #1
 800cf04:	2300      	movs	r3, #0
 800cf06:	2180      	movs	r1, #128	; 0x80
 800cf08:	2019      	movs	r0, #25
 800cf0a:	001e      	movs	r6, r3
 800cf0c:	1064      	asrs	r4, r4, #1
 800cf0e:	0052      	lsls	r2, r2, #1
 800cf10:	0449      	lsls	r1, r1, #17
 800cf12:	1875      	adds	r5, r6, r1
 800cf14:	4295      	cmp	r5, r2
 800cf16:	dc02      	bgt.n	800cf1e <__ieee754_sqrtf+0x7a>
 800cf18:	186e      	adds	r6, r5, r1
 800cf1a:	1b52      	subs	r2, r2, r5
 800cf1c:	185b      	adds	r3, r3, r1
 800cf1e:	3801      	subs	r0, #1
 800cf20:	0052      	lsls	r2, r2, #1
 800cf22:	0849      	lsrs	r1, r1, #1
 800cf24:	2800      	cmp	r0, #0
 800cf26:	d1f4      	bne.n	800cf12 <__ieee754_sqrtf+0x6e>
 800cf28:	2a00      	cmp	r2, #0
 800cf2a:	d002      	beq.n	800cf32 <__ieee754_sqrtf+0x8e>
 800cf2c:	2201      	movs	r2, #1
 800cf2e:	3301      	adds	r3, #1
 800cf30:	4393      	bics	r3, r2
 800cf32:	22fc      	movs	r2, #252	; 0xfc
 800cf34:	105b      	asrs	r3, r3, #1
 800cf36:	0592      	lsls	r2, r2, #22
 800cf38:	189b      	adds	r3, r3, r2
 800cf3a:	05e4      	lsls	r4, r4, #23
 800cf3c:	18e4      	adds	r4, r4, r3
 800cf3e:	e7c1      	b.n	800cec4 <__ieee754_sqrtf+0x20>
 800cf40:	0052      	lsls	r2, r2, #1
 800cf42:	3301      	adds	r3, #1
 800cf44:	e7d1      	b.n	800ceea <__ieee754_sqrtf+0x46>
 800cf46:	46c0      	nop			; (mov r8, r8)
 800cf48:	7f7fffff 	.word	0x7f7fffff
 800cf4c:	007fffff 	.word	0x007fffff

0800cf50 <__kernel_cosf>:
 800cf50:	4b40      	ldr	r3, [pc, #256]	; (800d054 <__kernel_cosf+0x104>)
 800cf52:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800cf54:	0045      	lsls	r5, r0, #1
 800cf56:	1c06      	adds	r6, r0, #0
 800cf58:	1c0f      	adds	r7, r1, #0
 800cf5a:	086d      	lsrs	r5, r5, #1
 800cf5c:	429d      	cmp	r5, r3
 800cf5e:	dc04      	bgt.n	800cf6a <__kernel_cosf+0x1a>
 800cf60:	f7f4 f86c 	bl	800103c <__aeabi_f2iz>
 800cf64:	2800      	cmp	r0, #0
 800cf66:	d100      	bne.n	800cf6a <__kernel_cosf+0x1a>
 800cf68:	e071      	b.n	800d04e <__kernel_cosf+0xfe>
 800cf6a:	1c31      	adds	r1, r6, #0
 800cf6c:	1c30      	adds	r0, r6, #0
 800cf6e:	f7f3 fd91 	bl	8000a94 <__aeabi_fmul>
 800cf72:	4939      	ldr	r1, [pc, #228]	; (800d058 <__kernel_cosf+0x108>)
 800cf74:	1c04      	adds	r4, r0, #0
 800cf76:	f7f3 fd8d 	bl	8000a94 <__aeabi_fmul>
 800cf7a:	4938      	ldr	r1, [pc, #224]	; (800d05c <__kernel_cosf+0x10c>)
 800cf7c:	f7f3 fa08 	bl	8000390 <__aeabi_fadd>
 800cf80:	1c21      	adds	r1, r4, #0
 800cf82:	f7f3 fd87 	bl	8000a94 <__aeabi_fmul>
 800cf86:	4936      	ldr	r1, [pc, #216]	; (800d060 <__kernel_cosf+0x110>)
 800cf88:	f7f3 fea4 	bl	8000cd4 <__aeabi_fsub>
 800cf8c:	1c21      	adds	r1, r4, #0
 800cf8e:	f7f3 fd81 	bl	8000a94 <__aeabi_fmul>
 800cf92:	4934      	ldr	r1, [pc, #208]	; (800d064 <__kernel_cosf+0x114>)
 800cf94:	f7f3 f9fc 	bl	8000390 <__aeabi_fadd>
 800cf98:	1c21      	adds	r1, r4, #0
 800cf9a:	f7f3 fd7b 	bl	8000a94 <__aeabi_fmul>
 800cf9e:	4932      	ldr	r1, [pc, #200]	; (800d068 <__kernel_cosf+0x118>)
 800cfa0:	f7f3 fe98 	bl	8000cd4 <__aeabi_fsub>
 800cfa4:	1c21      	adds	r1, r4, #0
 800cfa6:	f7f3 fd75 	bl	8000a94 <__aeabi_fmul>
 800cfaa:	4930      	ldr	r1, [pc, #192]	; (800d06c <__kernel_cosf+0x11c>)
 800cfac:	f7f3 f9f0 	bl	8000390 <__aeabi_fadd>
 800cfb0:	1c21      	adds	r1, r4, #0
 800cfb2:	f7f3 fd6f 	bl	8000a94 <__aeabi_fmul>
 800cfb6:	4b2e      	ldr	r3, [pc, #184]	; (800d070 <__kernel_cosf+0x120>)
 800cfb8:	9000      	str	r0, [sp, #0]
 800cfba:	429d      	cmp	r5, r3
 800cfbc:	dc1c      	bgt.n	800cff8 <__kernel_cosf+0xa8>
 800cfbe:	21fc      	movs	r1, #252	; 0xfc
 800cfc0:	1c20      	adds	r0, r4, #0
 800cfc2:	0589      	lsls	r1, r1, #22
 800cfc4:	f7f3 fd66 	bl	8000a94 <__aeabi_fmul>
 800cfc8:	9900      	ldr	r1, [sp, #0]
 800cfca:	1c05      	adds	r5, r0, #0
 800cfcc:	1c20      	adds	r0, r4, #0
 800cfce:	f7f3 fd61 	bl	8000a94 <__aeabi_fmul>
 800cfd2:	1c39      	adds	r1, r7, #0
 800cfd4:	1c04      	adds	r4, r0, #0
 800cfd6:	1c30      	adds	r0, r6, #0
 800cfd8:	f7f3 fd5c 	bl	8000a94 <__aeabi_fmul>
 800cfdc:	1c01      	adds	r1, r0, #0
 800cfde:	1c20      	adds	r0, r4, #0
 800cfe0:	f7f3 fe78 	bl	8000cd4 <__aeabi_fsub>
 800cfe4:	1c01      	adds	r1, r0, #0
 800cfe6:	1c28      	adds	r0, r5, #0
 800cfe8:	f7f3 fe74 	bl	8000cd4 <__aeabi_fsub>
 800cfec:	1c01      	adds	r1, r0, #0
 800cfee:	20fe      	movs	r0, #254	; 0xfe
 800cff0:	0580      	lsls	r0, r0, #22
 800cff2:	f7f3 fe6f 	bl	8000cd4 <__aeabi_fsub>
 800cff6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800cff8:	4b1e      	ldr	r3, [pc, #120]	; (800d074 <__kernel_cosf+0x124>)
 800cffa:	429d      	cmp	r5, r3
 800cffc:	dc25      	bgt.n	800d04a <__kernel_cosf+0xfa>
 800cffe:	23ff      	movs	r3, #255	; 0xff
 800d000:	061b      	lsls	r3, r3, #24
 800d002:	18ed      	adds	r5, r5, r3
 800d004:	20fe      	movs	r0, #254	; 0xfe
 800d006:	1c29      	adds	r1, r5, #0
 800d008:	0580      	lsls	r0, r0, #22
 800d00a:	f7f3 fe63 	bl	8000cd4 <__aeabi_fsub>
 800d00e:	21fc      	movs	r1, #252	; 0xfc
 800d010:	9001      	str	r0, [sp, #4]
 800d012:	0589      	lsls	r1, r1, #22
 800d014:	1c20      	adds	r0, r4, #0
 800d016:	f7f3 fd3d 	bl	8000a94 <__aeabi_fmul>
 800d01a:	1c29      	adds	r1, r5, #0
 800d01c:	f7f3 fe5a 	bl	8000cd4 <__aeabi_fsub>
 800d020:	9900      	ldr	r1, [sp, #0]
 800d022:	1c05      	adds	r5, r0, #0
 800d024:	1c20      	adds	r0, r4, #0
 800d026:	f7f3 fd35 	bl	8000a94 <__aeabi_fmul>
 800d02a:	1c39      	adds	r1, r7, #0
 800d02c:	1c04      	adds	r4, r0, #0
 800d02e:	1c30      	adds	r0, r6, #0
 800d030:	f7f3 fd30 	bl	8000a94 <__aeabi_fmul>
 800d034:	1c01      	adds	r1, r0, #0
 800d036:	1c20      	adds	r0, r4, #0
 800d038:	f7f3 fe4c 	bl	8000cd4 <__aeabi_fsub>
 800d03c:	1c01      	adds	r1, r0, #0
 800d03e:	1c28      	adds	r0, r5, #0
 800d040:	f7f3 fe48 	bl	8000cd4 <__aeabi_fsub>
 800d044:	1c01      	adds	r1, r0, #0
 800d046:	9801      	ldr	r0, [sp, #4]
 800d048:	e7d3      	b.n	800cff2 <__kernel_cosf+0xa2>
 800d04a:	4d0b      	ldr	r5, [pc, #44]	; (800d078 <__kernel_cosf+0x128>)
 800d04c:	e7da      	b.n	800d004 <__kernel_cosf+0xb4>
 800d04e:	20fe      	movs	r0, #254	; 0xfe
 800d050:	0580      	lsls	r0, r0, #22
 800d052:	e7d0      	b.n	800cff6 <__kernel_cosf+0xa6>
 800d054:	31ffffff 	.word	0x31ffffff
 800d058:	ad47d74e 	.word	0xad47d74e
 800d05c:	310f74f6 	.word	0x310f74f6
 800d060:	3493f27c 	.word	0x3493f27c
 800d064:	37d00d01 	.word	0x37d00d01
 800d068:	3ab60b61 	.word	0x3ab60b61
 800d06c:	3d2aaaab 	.word	0x3d2aaaab
 800d070:	3e999999 	.word	0x3e999999
 800d074:	3f480000 	.word	0x3f480000
 800d078:	3e900000 	.word	0x3e900000

0800d07c <__kernel_rem_pio2f>:
 800d07c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d07e:	b0dd      	sub	sp, #372	; 0x174
 800d080:	9305      	str	r3, [sp, #20]
 800d082:	9b62      	ldr	r3, [sp, #392]	; 0x188
 800d084:	9102      	str	r1, [sp, #8]
 800d086:	0099      	lsls	r1, r3, #2
 800d088:	4bd3      	ldr	r3, [pc, #844]	; (800d3d8 <__kernel_rem_pio2f+0x35c>)
 800d08a:	2500      	movs	r5, #0
 800d08c:	58cb      	ldr	r3, [r1, r3]
 800d08e:	2107      	movs	r1, #7
 800d090:	9304      	str	r3, [sp, #16]
 800d092:	9b05      	ldr	r3, [sp, #20]
 800d094:	9007      	str	r0, [sp, #28]
 800d096:	3b01      	subs	r3, #1
 800d098:	9306      	str	r3, [sp, #24]
 800d09a:	1ed3      	subs	r3, r2, #3
 800d09c:	17dc      	asrs	r4, r3, #31
 800d09e:	400c      	ands	r4, r1
 800d0a0:	18e4      	adds	r4, r4, r3
 800d0a2:	10e4      	asrs	r4, r4, #3
 800d0a4:	43e3      	mvns	r3, r4
 800d0a6:	17db      	asrs	r3, r3, #31
 800d0a8:	401c      	ands	r4, r3
 800d0aa:	1c63      	adds	r3, r4, #1
 800d0ac:	00db      	lsls	r3, r3, #3
 800d0ae:	1ad3      	subs	r3, r2, r3
 800d0b0:	9a06      	ldr	r2, [sp, #24]
 800d0b2:	9300      	str	r3, [sp, #0]
 800d0b4:	4694      	mov	ip, r2
 800d0b6:	9b04      	ldr	r3, [sp, #16]
 800d0b8:	1aa6      	subs	r6, r4, r2
 800d0ba:	4463      	add	r3, ip
 800d0bc:	9a63      	ldr	r2, [sp, #396]	; 0x18c
 800d0be:	9301      	str	r3, [sp, #4]
 800d0c0:	00b3      	lsls	r3, r6, #2
 800d0c2:	18d3      	adds	r3, r2, r3
 800d0c4:	9303      	str	r3, [sp, #12]
 800d0c6:	af20      	add	r7, sp, #128	; 0x80
 800d0c8:	9b01      	ldr	r3, [sp, #4]
 800d0ca:	429d      	cmp	r5, r3
 800d0cc:	dd0a      	ble.n	800d0e4 <__kernel_rem_pio2f+0x68>
 800d0ce:	2500      	movs	r5, #0
 800d0d0:	9b04      	ldr	r3, [sp, #16]
 800d0d2:	429d      	cmp	r5, r3
 800d0d4:	dc2e      	bgt.n	800d134 <__kernel_rem_pio2f+0xb8>
 800d0d6:	9b05      	ldr	r3, [sp, #20]
 800d0d8:	2700      	movs	r7, #0
 800d0da:	195b      	adds	r3, r3, r5
 800d0dc:	009b      	lsls	r3, r3, #2
 800d0de:	9301      	str	r3, [sp, #4]
 800d0e0:	2600      	movs	r6, #0
 800d0e2:	e01d      	b.n	800d120 <__kernel_rem_pio2f+0xa4>
 800d0e4:	2000      	movs	r0, #0
 800d0e6:	42ee      	cmn	r6, r5
 800d0e8:	d404      	bmi.n	800d0f4 <__kernel_rem_pio2f+0x78>
 800d0ea:	9a03      	ldr	r2, [sp, #12]
 800d0ec:	00ab      	lsls	r3, r5, #2
 800d0ee:	58d0      	ldr	r0, [r2, r3]
 800d0f0:	f7f3 ffc4 	bl	800107c <__aeabi_i2f>
 800d0f4:	00ab      	lsls	r3, r5, #2
 800d0f6:	51d8      	str	r0, [r3, r7]
 800d0f8:	3501      	adds	r5, #1
 800d0fa:	e7e5      	b.n	800d0c8 <__kernel_rem_pio2f+0x4c>
 800d0fc:	2050      	movs	r0, #80	; 0x50
 800d0fe:	9b01      	ldr	r3, [sp, #4]
 800d100:	9907      	ldr	r1, [sp, #28]
 800d102:	00b2      	lsls	r2, r6, #2
 800d104:	5889      	ldr	r1, [r1, r2]
 800d106:	1a9b      	subs	r3, r3, r2
 800d108:	aa0c      	add	r2, sp, #48	; 0x30
 800d10a:	3b04      	subs	r3, #4
 800d10c:	1812      	adds	r2, r2, r0
 800d10e:	58d0      	ldr	r0, [r2, r3]
 800d110:	f7f3 fcc0 	bl	8000a94 <__aeabi_fmul>
 800d114:	1c01      	adds	r1, r0, #0
 800d116:	1c38      	adds	r0, r7, #0
 800d118:	f7f3 f93a 	bl	8000390 <__aeabi_fadd>
 800d11c:	3601      	adds	r6, #1
 800d11e:	1c07      	adds	r7, r0, #0
 800d120:	9b06      	ldr	r3, [sp, #24]
 800d122:	429e      	cmp	r6, r3
 800d124:	ddea      	ble.n	800d0fc <__kernel_rem_pio2f+0x80>
 800d126:	21f0      	movs	r1, #240	; 0xf0
 800d128:	aa0c      	add	r2, sp, #48	; 0x30
 800d12a:	00ab      	lsls	r3, r5, #2
 800d12c:	1852      	adds	r2, r2, r1
 800d12e:	50d7      	str	r7, [r2, r3]
 800d130:	3501      	adds	r5, #1
 800d132:	e7cd      	b.n	800d0d0 <__kernel_rem_pio2f+0x54>
 800d134:	9b04      	ldr	r3, [sp, #16]
 800d136:	aa0c      	add	r2, sp, #48	; 0x30
 800d138:	009b      	lsls	r3, r3, #2
 800d13a:	189b      	adds	r3, r3, r2
 800d13c:	930a      	str	r3, [sp, #40]	; 0x28
 800d13e:	9b05      	ldr	r3, [sp, #20]
 800d140:	9f04      	ldr	r7, [sp, #16]
 800d142:	1ae4      	subs	r4, r4, r3
 800d144:	00a3      	lsls	r3, r4, #2
 800d146:	9309      	str	r3, [sp, #36]	; 0x24
 800d148:	9b05      	ldr	r3, [sp, #20]
 800d14a:	009b      	lsls	r3, r3, #2
 800d14c:	425b      	negs	r3, r3
 800d14e:	9308      	str	r3, [sp, #32]
 800d150:	003e      	movs	r6, r7
 800d152:	ad48      	add	r5, sp, #288	; 0x120
 800d154:	00bb      	lsls	r3, r7, #2
 800d156:	aa0c      	add	r2, sp, #48	; 0x30
 800d158:	595c      	ldr	r4, [r3, r5]
 800d15a:	189b      	adds	r3, r3, r2
 800d15c:	9301      	str	r3, [sp, #4]
 800d15e:	950b      	str	r5, [sp, #44]	; 0x2c
 800d160:	2e00      	cmp	r6, #0
 800d162:	dc63      	bgt.n	800d22c <__kernel_rem_pio2f+0x1b0>
 800d164:	9900      	ldr	r1, [sp, #0]
 800d166:	1c20      	adds	r0, r4, #0
 800d168:	f000 fbe2 	bl	800d930 <scalbnf>
 800d16c:	21f8      	movs	r1, #248	; 0xf8
 800d16e:	0589      	lsls	r1, r1, #22
 800d170:	1c04      	adds	r4, r0, #0
 800d172:	f7f3 fc8f 	bl	8000a94 <__aeabi_fmul>
 800d176:	f7ff fbbf 	bl	800c8f8 <floorf>
 800d17a:	2182      	movs	r1, #130	; 0x82
 800d17c:	05c9      	lsls	r1, r1, #23
 800d17e:	f7f3 fc89 	bl	8000a94 <__aeabi_fmul>
 800d182:	1c01      	adds	r1, r0, #0
 800d184:	1c20      	adds	r0, r4, #0
 800d186:	f7f3 fda5 	bl	8000cd4 <__aeabi_fsub>
 800d18a:	1c04      	adds	r4, r0, #0
 800d18c:	f7f3 ff56 	bl	800103c <__aeabi_f2iz>
 800d190:	9003      	str	r0, [sp, #12]
 800d192:	f7f3 ff73 	bl	800107c <__aeabi_i2f>
 800d196:	1c01      	adds	r1, r0, #0
 800d198:	1c20      	adds	r0, r4, #0
 800d19a:	f7f3 fd9b 	bl	8000cd4 <__aeabi_fsub>
 800d19e:	9b00      	ldr	r3, [sp, #0]
 800d1a0:	1c04      	adds	r4, r0, #0
 800d1a2:	2b00      	cmp	r3, #0
 800d1a4:	dd65      	ble.n	800d272 <__kernel_rem_pio2f+0x1f6>
 800d1a6:	2108      	movs	r1, #8
 800d1a8:	1e7b      	subs	r3, r7, #1
 800d1aa:	009b      	lsls	r3, r3, #2
 800d1ac:	aa0c      	add	r2, sp, #48	; 0x30
 800d1ae:	589a      	ldr	r2, [r3, r2]
 800d1b0:	9800      	ldr	r0, [sp, #0]
 800d1b2:	9d03      	ldr	r5, [sp, #12]
 800d1b4:	1a09      	subs	r1, r1, r0
 800d1b6:	0010      	movs	r0, r2
 800d1b8:	4108      	asrs	r0, r1
 800d1ba:	182d      	adds	r5, r5, r0
 800d1bc:	4088      	lsls	r0, r1
 800d1be:	1a10      	subs	r0, r2, r0
 800d1c0:	aa0c      	add	r2, sp, #48	; 0x30
 800d1c2:	5098      	str	r0, [r3, r2]
 800d1c4:	2307      	movs	r3, #7
 800d1c6:	9a00      	ldr	r2, [sp, #0]
 800d1c8:	9503      	str	r5, [sp, #12]
 800d1ca:	1a9b      	subs	r3, r3, r2
 800d1cc:	4118      	asrs	r0, r3
 800d1ce:	9001      	str	r0, [sp, #4]
 800d1d0:	9b01      	ldr	r3, [sp, #4]
 800d1d2:	2b00      	cmp	r3, #0
 800d1d4:	dd5e      	ble.n	800d294 <__kernel_rem_pio2f+0x218>
 800d1d6:	9b03      	ldr	r3, [sp, #12]
 800d1d8:	2200      	movs	r2, #0
 800d1da:	3301      	adds	r3, #1
 800d1dc:	9303      	str	r3, [sp, #12]
 800d1de:	2301      	movs	r3, #1
 800d1e0:	2680      	movs	r6, #128	; 0x80
 800d1e2:	0015      	movs	r5, r2
 800d1e4:	469c      	mov	ip, r3
 800d1e6:	0076      	lsls	r6, r6, #1
 800d1e8:	4297      	cmp	r7, r2
 800d1ea:	dd00      	ble.n	800d1ee <__kernel_rem_pio2f+0x172>
 800d1ec:	e093      	b.n	800d316 <__kernel_rem_pio2f+0x29a>
 800d1ee:	9b00      	ldr	r3, [sp, #0]
 800d1f0:	2b00      	cmp	r3, #0
 800d1f2:	dd05      	ble.n	800d200 <__kernel_rem_pio2f+0x184>
 800d1f4:	2b01      	cmp	r3, #1
 800d1f6:	d100      	bne.n	800d1fa <__kernel_rem_pio2f+0x17e>
 800d1f8:	e0a1      	b.n	800d33e <__kernel_rem_pio2f+0x2c2>
 800d1fa:	2b02      	cmp	r3, #2
 800d1fc:	d100      	bne.n	800d200 <__kernel_rem_pio2f+0x184>
 800d1fe:	e0a9      	b.n	800d354 <__kernel_rem_pio2f+0x2d8>
 800d200:	9b01      	ldr	r3, [sp, #4]
 800d202:	2b02      	cmp	r3, #2
 800d204:	d146      	bne.n	800d294 <__kernel_rem_pio2f+0x218>
 800d206:	20fe      	movs	r0, #254	; 0xfe
 800d208:	1c21      	adds	r1, r4, #0
 800d20a:	0580      	lsls	r0, r0, #22
 800d20c:	f7f3 fd62 	bl	8000cd4 <__aeabi_fsub>
 800d210:	1c04      	adds	r4, r0, #0
 800d212:	2d00      	cmp	r5, #0
 800d214:	d03e      	beq.n	800d294 <__kernel_rem_pio2f+0x218>
 800d216:	20fe      	movs	r0, #254	; 0xfe
 800d218:	9900      	ldr	r1, [sp, #0]
 800d21a:	0580      	lsls	r0, r0, #22
 800d21c:	f000 fb88 	bl	800d930 <scalbnf>
 800d220:	1c01      	adds	r1, r0, #0
 800d222:	1c20      	adds	r0, r4, #0
 800d224:	f7f3 fd56 	bl	8000cd4 <__aeabi_fsub>
 800d228:	1c04      	adds	r4, r0, #0
 800d22a:	e033      	b.n	800d294 <__kernel_rem_pio2f+0x218>
 800d22c:	21ee      	movs	r1, #238	; 0xee
 800d22e:	1c20      	adds	r0, r4, #0
 800d230:	0589      	lsls	r1, r1, #22
 800d232:	f7f3 fc2f 	bl	8000a94 <__aeabi_fmul>
 800d236:	f7f3 ff01 	bl	800103c <__aeabi_f2iz>
 800d23a:	f7f3 ff1f 	bl	800107c <__aeabi_i2f>
 800d23e:	2187      	movs	r1, #135	; 0x87
 800d240:	00b3      	lsls	r3, r6, #2
 800d242:	425b      	negs	r3, r3
 800d244:	05c9      	lsls	r1, r1, #23
 800d246:	9303      	str	r3, [sp, #12]
 800d248:	1c05      	adds	r5, r0, #0
 800d24a:	f7f3 fc23 	bl	8000a94 <__aeabi_fmul>
 800d24e:	1c01      	adds	r1, r0, #0
 800d250:	1c20      	adds	r0, r4, #0
 800d252:	f7f3 fd3f 	bl	8000cd4 <__aeabi_fsub>
 800d256:	f7f3 fef1 	bl	800103c <__aeabi_f2iz>
 800d25a:	9b01      	ldr	r3, [sp, #4]
 800d25c:	9a03      	ldr	r2, [sp, #12]
 800d25e:	3e01      	subs	r6, #1
 800d260:	5098      	str	r0, [r3, r2]
 800d262:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800d264:	00b3      	lsls	r3, r6, #2
 800d266:	5899      	ldr	r1, [r3, r2]
 800d268:	1c28      	adds	r0, r5, #0
 800d26a:	f7f3 f891 	bl	8000390 <__aeabi_fadd>
 800d26e:	1c04      	adds	r4, r0, #0
 800d270:	e776      	b.n	800d160 <__kernel_rem_pio2f+0xe4>
 800d272:	9b00      	ldr	r3, [sp, #0]
 800d274:	2b00      	cmp	r3, #0
 800d276:	d106      	bne.n	800d286 <__kernel_rem_pio2f+0x20a>
 800d278:	1e7b      	subs	r3, r7, #1
 800d27a:	009b      	lsls	r3, r3, #2
 800d27c:	aa0c      	add	r2, sp, #48	; 0x30
 800d27e:	5898      	ldr	r0, [r3, r2]
 800d280:	1203      	asrs	r3, r0, #8
 800d282:	9301      	str	r3, [sp, #4]
 800d284:	e7a4      	b.n	800d1d0 <__kernel_rem_pio2f+0x154>
 800d286:	21fc      	movs	r1, #252	; 0xfc
 800d288:	0589      	lsls	r1, r1, #22
 800d28a:	f7f3 f841 	bl	8000310 <__aeabi_fcmpge>
 800d28e:	2800      	cmp	r0, #0
 800d290:	d13e      	bne.n	800d310 <__kernel_rem_pio2f+0x294>
 800d292:	9001      	str	r0, [sp, #4]
 800d294:	2100      	movs	r1, #0
 800d296:	1c20      	adds	r0, r4, #0
 800d298:	f7f3 f816 	bl	80002c8 <__aeabi_fcmpeq>
 800d29c:	2800      	cmp	r0, #0
 800d29e:	d100      	bne.n	800d2a2 <__kernel_rem_pio2f+0x226>
 800d2a0:	e09c      	b.n	800d3dc <__kernel_rem_pio2f+0x360>
 800d2a2:	003b      	movs	r3, r7
 800d2a4:	2200      	movs	r2, #0
 800d2a6:	1e79      	subs	r1, r7, #1
 800d2a8:	9804      	ldr	r0, [sp, #16]
 800d2aa:	3b01      	subs	r3, #1
 800d2ac:	4298      	cmp	r0, r3
 800d2ae:	dd58      	ble.n	800d362 <__kernel_rem_pio2f+0x2e6>
 800d2b0:	2a00      	cmp	r2, #0
 800d2b2:	d16c      	bne.n	800d38e <__kernel_rem_pio2f+0x312>
 800d2b4:	2301      	movs	r3, #1
 800d2b6:	009a      	lsls	r2, r3, #2
 800d2b8:	990a      	ldr	r1, [sp, #40]	; 0x28
 800d2ba:	4252      	negs	r2, r2
 800d2bc:	588a      	ldr	r2, [r1, r2]
 800d2be:	2a00      	cmp	r2, #0
 800d2c0:	d054      	beq.n	800d36c <__kernel_rem_pio2f+0x2f0>
 800d2c2:	1c7a      	adds	r2, r7, #1
 800d2c4:	9201      	str	r2, [sp, #4]
 800d2c6:	9a05      	ldr	r2, [sp, #20]
 800d2c8:	19d4      	adds	r4, r2, r7
 800d2ca:	00a4      	lsls	r4, r4, #2
 800d2cc:	18ff      	adds	r7, r7, r3
 800d2ce:	9b01      	ldr	r3, [sp, #4]
 800d2d0:	42bb      	cmp	r3, r7
 800d2d2:	dd00      	ble.n	800d2d6 <__kernel_rem_pio2f+0x25a>
 800d2d4:	e73c      	b.n	800d150 <__kernel_rem_pio2f+0xd4>
 800d2d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d2d8:	9a63      	ldr	r2, [sp, #396]	; 0x18c
 800d2da:	18e3      	adds	r3, r4, r3
 800d2dc:	18d3      	adds	r3, r2, r3
 800d2de:	6858      	ldr	r0, [r3, #4]
 800d2e0:	f7f3 fecc 	bl	800107c <__aeabi_i2f>
 800d2e4:	2250      	movs	r2, #80	; 0x50
 800d2e6:	2500      	movs	r5, #0
 800d2e8:	2600      	movs	r6, #0
 800d2ea:	ab0c      	add	r3, sp, #48	; 0x30
 800d2ec:	189b      	adds	r3, r3, r2
 800d2ee:	5118      	str	r0, [r3, r4]
 800d2f0:	ab20      	add	r3, sp, #128	; 0x80
 800d2f2:	191b      	adds	r3, r3, r4
 800d2f4:	9303      	str	r3, [sp, #12]
 800d2f6:	9b06      	ldr	r3, [sp, #24]
 800d2f8:	429d      	cmp	r5, r3
 800d2fa:	dd39      	ble.n	800d370 <__kernel_rem_pio2f+0x2f4>
 800d2fc:	9b08      	ldr	r3, [sp, #32]
 800d2fe:	aa48      	add	r2, sp, #288	; 0x120
 800d300:	18e3      	adds	r3, r4, r3
 800d302:	18d3      	adds	r3, r2, r3
 800d304:	605e      	str	r6, [r3, #4]
 800d306:	9b01      	ldr	r3, [sp, #4]
 800d308:	3404      	adds	r4, #4
 800d30a:	3301      	adds	r3, #1
 800d30c:	9301      	str	r3, [sp, #4]
 800d30e:	e7de      	b.n	800d2ce <__kernel_rem_pio2f+0x252>
 800d310:	2302      	movs	r3, #2
 800d312:	9301      	str	r3, [sp, #4]
 800d314:	e75f      	b.n	800d1d6 <__kernel_rem_pio2f+0x15a>
 800d316:	0091      	lsls	r1, r2, #2
 800d318:	ab0c      	add	r3, sp, #48	; 0x30
 800d31a:	58cb      	ldr	r3, [r1, r3]
 800d31c:	2d00      	cmp	r5, #0
 800d31e:	d108      	bne.n	800d332 <__kernel_rem_pio2f+0x2b6>
 800d320:	2b00      	cmp	r3, #0
 800d322:	d003      	beq.n	800d32c <__kernel_rem_pio2f+0x2b0>
 800d324:	1af3      	subs	r3, r6, r3
 800d326:	ad0c      	add	r5, sp, #48	; 0x30
 800d328:	514b      	str	r3, [r1, r5]
 800d32a:	4663      	mov	r3, ip
 800d32c:	3201      	adds	r2, #1
 800d32e:	001d      	movs	r5, r3
 800d330:	e75a      	b.n	800d1e8 <__kernel_rem_pio2f+0x16c>
 800d332:	20ff      	movs	r0, #255	; 0xff
 800d334:	1ac3      	subs	r3, r0, r3
 800d336:	a80c      	add	r0, sp, #48	; 0x30
 800d338:	500b      	str	r3, [r1, r0]
 800d33a:	002b      	movs	r3, r5
 800d33c:	e7f6      	b.n	800d32c <__kernel_rem_pio2f+0x2b0>
 800d33e:	1e7b      	subs	r3, r7, #1
 800d340:	009b      	lsls	r3, r3, #2
 800d342:	aa0c      	add	r2, sp, #48	; 0x30
 800d344:	589a      	ldr	r2, [r3, r2]
 800d346:	920b      	str	r2, [sp, #44]	; 0x2c
 800d348:	227f      	movs	r2, #127	; 0x7f
 800d34a:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800d34c:	400a      	ands	r2, r1
 800d34e:	a90c      	add	r1, sp, #48	; 0x30
 800d350:	505a      	str	r2, [r3, r1]
 800d352:	e755      	b.n	800d200 <__kernel_rem_pio2f+0x184>
 800d354:	1e7b      	subs	r3, r7, #1
 800d356:	009b      	lsls	r3, r3, #2
 800d358:	aa0c      	add	r2, sp, #48	; 0x30
 800d35a:	589a      	ldr	r2, [r3, r2]
 800d35c:	920b      	str	r2, [sp, #44]	; 0x2c
 800d35e:	223f      	movs	r2, #63	; 0x3f
 800d360:	e7f3      	b.n	800d34a <__kernel_rem_pio2f+0x2ce>
 800d362:	0098      	lsls	r0, r3, #2
 800d364:	ac0c      	add	r4, sp, #48	; 0x30
 800d366:	5900      	ldr	r0, [r0, r4]
 800d368:	4302      	orrs	r2, r0
 800d36a:	e79d      	b.n	800d2a8 <__kernel_rem_pio2f+0x22c>
 800d36c:	3301      	adds	r3, #1
 800d36e:	e7a2      	b.n	800d2b6 <__kernel_rem_pio2f+0x23a>
 800d370:	9907      	ldr	r1, [sp, #28]
 800d372:	00ab      	lsls	r3, r5, #2
 800d374:	425a      	negs	r2, r3
 800d376:	58c9      	ldr	r1, [r1, r3]
 800d378:	9b03      	ldr	r3, [sp, #12]
 800d37a:	3501      	adds	r5, #1
 800d37c:	5898      	ldr	r0, [r3, r2]
 800d37e:	f7f3 fb89 	bl	8000a94 <__aeabi_fmul>
 800d382:	1c01      	adds	r1, r0, #0
 800d384:	1c30      	adds	r0, r6, #0
 800d386:	f7f3 f803 	bl	8000390 <__aeabi_fadd>
 800d38a:	1c06      	adds	r6, r0, #0
 800d38c:	e7b3      	b.n	800d2f6 <__kernel_rem_pio2f+0x27a>
 800d38e:	000f      	movs	r7, r1
 800d390:	9b00      	ldr	r3, [sp, #0]
 800d392:	3b08      	subs	r3, #8
 800d394:	9300      	str	r3, [sp, #0]
 800d396:	00bb      	lsls	r3, r7, #2
 800d398:	aa0c      	add	r2, sp, #48	; 0x30
 800d39a:	589b      	ldr	r3, [r3, r2]
 800d39c:	2b00      	cmp	r3, #0
 800d39e:	d015      	beq.n	800d3cc <__kernel_rem_pio2f+0x350>
 800d3a0:	20fe      	movs	r0, #254	; 0xfe
 800d3a2:	9900      	ldr	r1, [sp, #0]
 800d3a4:	0580      	lsls	r0, r0, #22
 800d3a6:	f000 fac3 	bl	800d930 <scalbnf>
 800d3aa:	00bb      	lsls	r3, r7, #2
 800d3ac:	001c      	movs	r4, r3
 800d3ae:	003d      	movs	r5, r7
 800d3b0:	1c06      	adds	r6, r0, #0
 800d3b2:	9300      	str	r3, [sp, #0]
 800d3b4:	2d00      	cmp	r5, #0
 800d3b6:	da46      	bge.n	800d446 <__kernel_rem_pio2f+0x3ca>
 800d3b8:	2500      	movs	r5, #0
 800d3ba:	1b7b      	subs	r3, r7, r5
 800d3bc:	d46e      	bmi.n	800d49c <__kernel_rem_pio2f+0x420>
 800d3be:	009b      	lsls	r3, r3, #2
 800d3c0:	aa48      	add	r2, sp, #288	; 0x120
 800d3c2:	18d3      	adds	r3, r2, r3
 800d3c4:	9305      	str	r3, [sp, #20]
 800d3c6:	2600      	movs	r6, #0
 800d3c8:	2400      	movs	r4, #0
 800d3ca:	e05d      	b.n	800d488 <__kernel_rem_pio2f+0x40c>
 800d3cc:	9b00      	ldr	r3, [sp, #0]
 800d3ce:	3f01      	subs	r7, #1
 800d3d0:	3b08      	subs	r3, #8
 800d3d2:	9300      	str	r3, [sp, #0]
 800d3d4:	e7df      	b.n	800d396 <__kernel_rem_pio2f+0x31a>
 800d3d6:	46c0      	nop			; (mov r8, r8)
 800d3d8:	0800e564 	.word	0x0800e564
 800d3dc:	9b00      	ldr	r3, [sp, #0]
 800d3de:	1c20      	adds	r0, r4, #0
 800d3e0:	4259      	negs	r1, r3
 800d3e2:	f000 faa5 	bl	800d930 <scalbnf>
 800d3e6:	2187      	movs	r1, #135	; 0x87
 800d3e8:	05c9      	lsls	r1, r1, #23
 800d3ea:	1c04      	adds	r4, r0, #0
 800d3ec:	f7f2 ff90 	bl	8000310 <__aeabi_fcmpge>
 800d3f0:	2800      	cmp	r0, #0
 800d3f2:	d021      	beq.n	800d438 <__kernel_rem_pio2f+0x3bc>
 800d3f4:	21ee      	movs	r1, #238	; 0xee
 800d3f6:	1c20      	adds	r0, r4, #0
 800d3f8:	0589      	lsls	r1, r1, #22
 800d3fa:	f7f3 fb4b 	bl	8000a94 <__aeabi_fmul>
 800d3fe:	f7f3 fe1d 	bl	800103c <__aeabi_f2iz>
 800d402:	f7f3 fe3b 	bl	800107c <__aeabi_i2f>
 800d406:	2187      	movs	r1, #135	; 0x87
 800d408:	05c9      	lsls	r1, r1, #23
 800d40a:	1c05      	adds	r5, r0, #0
 800d40c:	f7f3 fb42 	bl	8000a94 <__aeabi_fmul>
 800d410:	1c01      	adds	r1, r0, #0
 800d412:	1c20      	adds	r0, r4, #0
 800d414:	f7f3 fc5e 	bl	8000cd4 <__aeabi_fsub>
 800d418:	f7f3 fe10 	bl	800103c <__aeabi_f2iz>
 800d41c:	00be      	lsls	r6, r7, #2
 800d41e:	ab0c      	add	r3, sp, #48	; 0x30
 800d420:	50f0      	str	r0, [r6, r3]
 800d422:	9b00      	ldr	r3, [sp, #0]
 800d424:	1c28      	adds	r0, r5, #0
 800d426:	3308      	adds	r3, #8
 800d428:	9300      	str	r3, [sp, #0]
 800d42a:	f7f3 fe07 	bl	800103c <__aeabi_f2iz>
 800d42e:	3701      	adds	r7, #1
 800d430:	00bc      	lsls	r4, r7, #2
 800d432:	ab0c      	add	r3, sp, #48	; 0x30
 800d434:	50e0      	str	r0, [r4, r3]
 800d436:	e7b3      	b.n	800d3a0 <__kernel_rem_pio2f+0x324>
 800d438:	1c20      	adds	r0, r4, #0
 800d43a:	f7f3 fdff 	bl	800103c <__aeabi_f2iz>
 800d43e:	00bd      	lsls	r5, r7, #2
 800d440:	ab0c      	add	r3, sp, #48	; 0x30
 800d442:	50e8      	str	r0, [r5, r3]
 800d444:	e7ac      	b.n	800d3a0 <__kernel_rem_pio2f+0x324>
 800d446:	ab0c      	add	r3, sp, #48	; 0x30
 800d448:	58e0      	ldr	r0, [r4, r3]
 800d44a:	f7f3 fe17 	bl	800107c <__aeabi_i2f>
 800d44e:	1c31      	adds	r1, r6, #0
 800d450:	f7f3 fb20 	bl	8000a94 <__aeabi_fmul>
 800d454:	22f0      	movs	r2, #240	; 0xf0
 800d456:	21ee      	movs	r1, #238	; 0xee
 800d458:	ab0c      	add	r3, sp, #48	; 0x30
 800d45a:	189b      	adds	r3, r3, r2
 800d45c:	5118      	str	r0, [r3, r4]
 800d45e:	0589      	lsls	r1, r1, #22
 800d460:	1c30      	adds	r0, r6, #0
 800d462:	f7f3 fb17 	bl	8000a94 <__aeabi_fmul>
 800d466:	3d01      	subs	r5, #1
 800d468:	1c06      	adds	r6, r0, #0
 800d46a:	3c04      	subs	r4, #4
 800d46c:	e7a2      	b.n	800d3b4 <__kernel_rem_pio2f+0x338>
 800d46e:	9a05      	ldr	r2, [sp, #20]
 800d470:	00a3      	lsls	r3, r4, #2
 800d472:	58d1      	ldr	r1, [r2, r3]
 800d474:	4a63      	ldr	r2, [pc, #396]	; (800d604 <__kernel_rem_pio2f+0x588>)
 800d476:	3401      	adds	r4, #1
 800d478:	5898      	ldr	r0, [r3, r2]
 800d47a:	f7f3 fb0b 	bl	8000a94 <__aeabi_fmul>
 800d47e:	1c01      	adds	r1, r0, #0
 800d480:	1c30      	adds	r0, r6, #0
 800d482:	f7f2 ff85 	bl	8000390 <__aeabi_fadd>
 800d486:	1c06      	adds	r6, r0, #0
 800d488:	9b04      	ldr	r3, [sp, #16]
 800d48a:	429c      	cmp	r4, r3
 800d48c:	dc01      	bgt.n	800d492 <__kernel_rem_pio2f+0x416>
 800d48e:	42ac      	cmp	r4, r5
 800d490:	dded      	ble.n	800d46e <__kernel_rem_pio2f+0x3f2>
 800d492:	00aa      	lsls	r2, r5, #2
 800d494:	ab34      	add	r3, sp, #208	; 0xd0
 800d496:	50d6      	str	r6, [r2, r3]
 800d498:	3501      	adds	r5, #1
 800d49a:	e78e      	b.n	800d3ba <__kernel_rem_pio2f+0x33e>
 800d49c:	9b62      	ldr	r3, [sp, #392]	; 0x188
 800d49e:	2b03      	cmp	r3, #3
 800d4a0:	d82f      	bhi.n	800d502 <__kernel_rem_pio2f+0x486>
 800d4a2:	0018      	movs	r0, r3
 800d4a4:	f7f2 fe30 	bl	8000108 <__gnu_thumb1_case_uqi>
 800d4a8:	7b020221 	.word	0x7b020221
 800d4ac:	003c      	movs	r4, r7
 800d4ae:	2000      	movs	r0, #0
 800d4b0:	ad34      	add	r5, sp, #208	; 0xd0
 800d4b2:	2c00      	cmp	r4, #0
 800d4b4:	da31      	bge.n	800d51a <__kernel_rem_pio2f+0x49e>
 800d4b6:	9a01      	ldr	r2, [sp, #4]
 800d4b8:	1c03      	adds	r3, r0, #0
 800d4ba:	2a00      	cmp	r2, #0
 800d4bc:	d002      	beq.n	800d4c4 <__kernel_rem_pio2f+0x448>
 800d4be:	2380      	movs	r3, #128	; 0x80
 800d4c0:	061b      	lsls	r3, r3, #24
 800d4c2:	18c3      	adds	r3, r0, r3
 800d4c4:	9a02      	ldr	r2, [sp, #8]
 800d4c6:	1c01      	adds	r1, r0, #0
 800d4c8:	6013      	str	r3, [r2, #0]
 800d4ca:	9834      	ldr	r0, [sp, #208]	; 0xd0
 800d4cc:	f7f3 fc02 	bl	8000cd4 <__aeabi_fsub>
 800d4d0:	2401      	movs	r4, #1
 800d4d2:	ad34      	add	r5, sp, #208	; 0xd0
 800d4d4:	42a7      	cmp	r7, r4
 800d4d6:	da26      	bge.n	800d526 <__kernel_rem_pio2f+0x4aa>
 800d4d8:	9b01      	ldr	r3, [sp, #4]
 800d4da:	2b00      	cmp	r3, #0
 800d4dc:	d002      	beq.n	800d4e4 <__kernel_rem_pio2f+0x468>
 800d4de:	2380      	movs	r3, #128	; 0x80
 800d4e0:	061b      	lsls	r3, r3, #24
 800d4e2:	18c0      	adds	r0, r0, r3
 800d4e4:	9b02      	ldr	r3, [sp, #8]
 800d4e6:	6058      	str	r0, [r3, #4]
 800d4e8:	e00b      	b.n	800d502 <__kernel_rem_pio2f+0x486>
 800d4ea:	2000      	movs	r0, #0
 800d4ec:	ac34      	add	r4, sp, #208	; 0xd0
 800d4ee:	2f00      	cmp	r7, #0
 800d4f0:	da0d      	bge.n	800d50e <__kernel_rem_pio2f+0x492>
 800d4f2:	9b01      	ldr	r3, [sp, #4]
 800d4f4:	2b00      	cmp	r3, #0
 800d4f6:	d002      	beq.n	800d4fe <__kernel_rem_pio2f+0x482>
 800d4f8:	2380      	movs	r3, #128	; 0x80
 800d4fa:	061b      	lsls	r3, r3, #24
 800d4fc:	18c0      	adds	r0, r0, r3
 800d4fe:	9b02      	ldr	r3, [sp, #8]
 800d500:	6018      	str	r0, [r3, #0]
 800d502:	2007      	movs	r0, #7
 800d504:	9b03      	ldr	r3, [sp, #12]
 800d506:	4003      	ands	r3, r0
 800d508:	0018      	movs	r0, r3
 800d50a:	b05d      	add	sp, #372	; 0x174
 800d50c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d50e:	00bb      	lsls	r3, r7, #2
 800d510:	5919      	ldr	r1, [r3, r4]
 800d512:	f7f2 ff3d 	bl	8000390 <__aeabi_fadd>
 800d516:	3f01      	subs	r7, #1
 800d518:	e7e9      	b.n	800d4ee <__kernel_rem_pio2f+0x472>
 800d51a:	00a3      	lsls	r3, r4, #2
 800d51c:	5959      	ldr	r1, [r3, r5]
 800d51e:	f7f2 ff37 	bl	8000390 <__aeabi_fadd>
 800d522:	3c01      	subs	r4, #1
 800d524:	e7c5      	b.n	800d4b2 <__kernel_rem_pio2f+0x436>
 800d526:	00a3      	lsls	r3, r4, #2
 800d528:	5959      	ldr	r1, [r3, r5]
 800d52a:	f7f2 ff31 	bl	8000390 <__aeabi_fadd>
 800d52e:	3401      	adds	r4, #1
 800d530:	e7d0      	b.n	800d4d4 <__kernel_rem_pio2f+0x458>
 800d532:	22a0      	movs	r2, #160	; 0xa0
 800d534:	ab0c      	add	r3, sp, #48	; 0x30
 800d536:	189b      	adds	r3, r3, r2
 800d538:	599b      	ldr	r3, [r3, r6]
 800d53a:	3d01      	subs	r5, #1
 800d53c:	9304      	str	r3, [sp, #16]
 800d53e:	ab34      	add	r3, sp, #208	; 0xd0
 800d540:	199c      	adds	r4, r3, r6
 800d542:	6863      	ldr	r3, [r4, #4]
 800d544:	9804      	ldr	r0, [sp, #16]
 800d546:	1c19      	adds	r1, r3, #0
 800d548:	9305      	str	r3, [sp, #20]
 800d54a:	f7f2 ff21 	bl	8000390 <__aeabi_fadd>
 800d54e:	1c01      	adds	r1, r0, #0
 800d550:	9006      	str	r0, [sp, #24]
 800d552:	9804      	ldr	r0, [sp, #16]
 800d554:	f7f3 fbbe 	bl	8000cd4 <__aeabi_fsub>
 800d558:	9905      	ldr	r1, [sp, #20]
 800d55a:	f7f2 ff19 	bl	8000390 <__aeabi_fadd>
 800d55e:	22a0      	movs	r2, #160	; 0xa0
 800d560:	ab0c      	add	r3, sp, #48	; 0x30
 800d562:	189b      	adds	r3, r3, r2
 800d564:	9a06      	ldr	r2, [sp, #24]
 800d566:	6060      	str	r0, [r4, #4]
 800d568:	519a      	str	r2, [r3, r6]
 800d56a:	3e04      	subs	r6, #4
 800d56c:	2d00      	cmp	r5, #0
 800d56e:	dce0      	bgt.n	800d532 <__kernel_rem_pio2f+0x4b6>
 800d570:	003d      	movs	r5, r7
 800d572:	ac34      	add	r4, sp, #208	; 0xd0
 800d574:	9b00      	ldr	r3, [sp, #0]
 800d576:	3b04      	subs	r3, #4
 800d578:	9300      	str	r3, [sp, #0]
 800d57a:	2d01      	cmp	r5, #1
 800d57c:	dc12      	bgt.n	800d5a4 <__kernel_rem_pio2f+0x528>
 800d57e:	2000      	movs	r0, #0
 800d580:	2f01      	cmp	r7, #1
 800d582:	dc28      	bgt.n	800d5d6 <__kernel_rem_pio2f+0x55a>
 800d584:	9b01      	ldr	r3, [sp, #4]
 800d586:	2b00      	cmp	r3, #0
 800d588:	d12b      	bne.n	800d5e2 <__kernel_rem_pio2f+0x566>
 800d58a:	9b02      	ldr	r3, [sp, #8]
 800d58c:	9a34      	ldr	r2, [sp, #208]	; 0xd0
 800d58e:	601a      	str	r2, [r3, #0]
 800d590:	6863      	ldr	r3, [r4, #4]
 800d592:	9300      	str	r3, [sp, #0]
 800d594:	9a00      	ldr	r2, [sp, #0]
 800d596:	9b02      	ldr	r3, [sp, #8]
 800d598:	605a      	str	r2, [r3, #4]
 800d59a:	6098      	str	r0, [r3, #8]
 800d59c:	e7b1      	b.n	800d502 <__kernel_rem_pio2f+0x486>
 800d59e:	9e00      	ldr	r6, [sp, #0]
 800d5a0:	003d      	movs	r5, r7
 800d5a2:	e7e2      	b.n	800d56a <__kernel_rem_pio2f+0x4ee>
 800d5a4:	9b00      	ldr	r3, [sp, #0]
 800d5a6:	3d01      	subs	r5, #1
 800d5a8:	58e3      	ldr	r3, [r4, r3]
 800d5aa:	9304      	str	r3, [sp, #16]
 800d5ac:	9b00      	ldr	r3, [sp, #0]
 800d5ae:	9804      	ldr	r0, [sp, #16]
 800d5b0:	18e6      	adds	r6, r4, r3
 800d5b2:	6873      	ldr	r3, [r6, #4]
 800d5b4:	1c19      	adds	r1, r3, #0
 800d5b6:	9305      	str	r3, [sp, #20]
 800d5b8:	f7f2 feea 	bl	8000390 <__aeabi_fadd>
 800d5bc:	1c01      	adds	r1, r0, #0
 800d5be:	9006      	str	r0, [sp, #24]
 800d5c0:	9804      	ldr	r0, [sp, #16]
 800d5c2:	f7f3 fb87 	bl	8000cd4 <__aeabi_fsub>
 800d5c6:	9905      	ldr	r1, [sp, #20]
 800d5c8:	f7f2 fee2 	bl	8000390 <__aeabi_fadd>
 800d5cc:	9b00      	ldr	r3, [sp, #0]
 800d5ce:	9a06      	ldr	r2, [sp, #24]
 800d5d0:	6070      	str	r0, [r6, #4]
 800d5d2:	50e2      	str	r2, [r4, r3]
 800d5d4:	e7ce      	b.n	800d574 <__kernel_rem_pio2f+0x4f8>
 800d5d6:	00bb      	lsls	r3, r7, #2
 800d5d8:	58e1      	ldr	r1, [r4, r3]
 800d5da:	f7f2 fed9 	bl	8000390 <__aeabi_fadd>
 800d5de:	3f01      	subs	r7, #1
 800d5e0:	e7ce      	b.n	800d580 <__kernel_rem_pio2f+0x504>
 800d5e2:	2280      	movs	r2, #128	; 0x80
 800d5e4:	9b34      	ldr	r3, [sp, #208]	; 0xd0
 800d5e6:	0612      	lsls	r2, r2, #24
 800d5e8:	189b      	adds	r3, r3, r2
 800d5ea:	9a02      	ldr	r2, [sp, #8]
 800d5ec:	6013      	str	r3, [r2, #0]
 800d5ee:	2280      	movs	r2, #128	; 0x80
 800d5f0:	6863      	ldr	r3, [r4, #4]
 800d5f2:	0612      	lsls	r2, r2, #24
 800d5f4:	189b      	adds	r3, r3, r2
 800d5f6:	9a02      	ldr	r2, [sp, #8]
 800d5f8:	6053      	str	r3, [r2, #4]
 800d5fa:	2380      	movs	r3, #128	; 0x80
 800d5fc:	061b      	lsls	r3, r3, #24
 800d5fe:	18c0      	adds	r0, r0, r3
 800d600:	0013      	movs	r3, r2
 800d602:	e7ca      	b.n	800d59a <__kernel_rem_pio2f+0x51e>
 800d604:	0800e538 	.word	0x0800e538

0800d608 <__kernel_sinf>:
 800d608:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800d60a:	9201      	str	r2, [sp, #4]
 800d60c:	4a32      	ldr	r2, [pc, #200]	; (800d6d8 <__kernel_sinf+0xd0>)
 800d60e:	0043      	lsls	r3, r0, #1
 800d610:	1c04      	adds	r4, r0, #0
 800d612:	9100      	str	r1, [sp, #0]
 800d614:	085b      	lsrs	r3, r3, #1
 800d616:	4293      	cmp	r3, r2
 800d618:	dc03      	bgt.n	800d622 <__kernel_sinf+0x1a>
 800d61a:	f7f3 fd0f 	bl	800103c <__aeabi_f2iz>
 800d61e:	2800      	cmp	r0, #0
 800d620:	d035      	beq.n	800d68e <__kernel_sinf+0x86>
 800d622:	1c21      	adds	r1, r4, #0
 800d624:	1c20      	adds	r0, r4, #0
 800d626:	f7f3 fa35 	bl	8000a94 <__aeabi_fmul>
 800d62a:	1c05      	adds	r5, r0, #0
 800d62c:	1c01      	adds	r1, r0, #0
 800d62e:	1c20      	adds	r0, r4, #0
 800d630:	f7f3 fa30 	bl	8000a94 <__aeabi_fmul>
 800d634:	4929      	ldr	r1, [pc, #164]	; (800d6dc <__kernel_sinf+0xd4>)
 800d636:	1c06      	adds	r6, r0, #0
 800d638:	1c28      	adds	r0, r5, #0
 800d63a:	f7f3 fa2b 	bl	8000a94 <__aeabi_fmul>
 800d63e:	4928      	ldr	r1, [pc, #160]	; (800d6e0 <__kernel_sinf+0xd8>)
 800d640:	f7f3 fb48 	bl	8000cd4 <__aeabi_fsub>
 800d644:	1c29      	adds	r1, r5, #0
 800d646:	f7f3 fa25 	bl	8000a94 <__aeabi_fmul>
 800d64a:	4926      	ldr	r1, [pc, #152]	; (800d6e4 <__kernel_sinf+0xdc>)
 800d64c:	f7f2 fea0 	bl	8000390 <__aeabi_fadd>
 800d650:	1c29      	adds	r1, r5, #0
 800d652:	f7f3 fa1f 	bl	8000a94 <__aeabi_fmul>
 800d656:	4924      	ldr	r1, [pc, #144]	; (800d6e8 <__kernel_sinf+0xe0>)
 800d658:	f7f3 fb3c 	bl	8000cd4 <__aeabi_fsub>
 800d65c:	1c29      	adds	r1, r5, #0
 800d65e:	f7f3 fa19 	bl	8000a94 <__aeabi_fmul>
 800d662:	4922      	ldr	r1, [pc, #136]	; (800d6ec <__kernel_sinf+0xe4>)
 800d664:	f7f2 fe94 	bl	8000390 <__aeabi_fadd>
 800d668:	9b01      	ldr	r3, [sp, #4]
 800d66a:	1c07      	adds	r7, r0, #0
 800d66c:	2b00      	cmp	r3, #0
 800d66e:	d110      	bne.n	800d692 <__kernel_sinf+0x8a>
 800d670:	1c01      	adds	r1, r0, #0
 800d672:	1c28      	adds	r0, r5, #0
 800d674:	f7f3 fa0e 	bl	8000a94 <__aeabi_fmul>
 800d678:	491d      	ldr	r1, [pc, #116]	; (800d6f0 <__kernel_sinf+0xe8>)
 800d67a:	f7f3 fb2b 	bl	8000cd4 <__aeabi_fsub>
 800d67e:	1c31      	adds	r1, r6, #0
 800d680:	f7f3 fa08 	bl	8000a94 <__aeabi_fmul>
 800d684:	1c01      	adds	r1, r0, #0
 800d686:	1c20      	adds	r0, r4, #0
 800d688:	f7f2 fe82 	bl	8000390 <__aeabi_fadd>
 800d68c:	1c04      	adds	r4, r0, #0
 800d68e:	1c20      	adds	r0, r4, #0
 800d690:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800d692:	21fc      	movs	r1, #252	; 0xfc
 800d694:	9800      	ldr	r0, [sp, #0]
 800d696:	0589      	lsls	r1, r1, #22
 800d698:	f7f3 f9fc 	bl	8000a94 <__aeabi_fmul>
 800d69c:	1c39      	adds	r1, r7, #0
 800d69e:	9001      	str	r0, [sp, #4]
 800d6a0:	1c30      	adds	r0, r6, #0
 800d6a2:	f7f3 f9f7 	bl	8000a94 <__aeabi_fmul>
 800d6a6:	1c01      	adds	r1, r0, #0
 800d6a8:	9801      	ldr	r0, [sp, #4]
 800d6aa:	f7f3 fb13 	bl	8000cd4 <__aeabi_fsub>
 800d6ae:	1c29      	adds	r1, r5, #0
 800d6b0:	f7f3 f9f0 	bl	8000a94 <__aeabi_fmul>
 800d6b4:	9900      	ldr	r1, [sp, #0]
 800d6b6:	f7f3 fb0d 	bl	8000cd4 <__aeabi_fsub>
 800d6ba:	490d      	ldr	r1, [pc, #52]	; (800d6f0 <__kernel_sinf+0xe8>)
 800d6bc:	1c05      	adds	r5, r0, #0
 800d6be:	1c30      	adds	r0, r6, #0
 800d6c0:	f7f3 f9e8 	bl	8000a94 <__aeabi_fmul>
 800d6c4:	1c01      	adds	r1, r0, #0
 800d6c6:	1c28      	adds	r0, r5, #0
 800d6c8:	f7f2 fe62 	bl	8000390 <__aeabi_fadd>
 800d6cc:	1c01      	adds	r1, r0, #0
 800d6ce:	1c20      	adds	r0, r4, #0
 800d6d0:	f7f3 fb00 	bl	8000cd4 <__aeabi_fsub>
 800d6d4:	e7da      	b.n	800d68c <__kernel_sinf+0x84>
 800d6d6:	46c0      	nop			; (mov r8, r8)
 800d6d8:	31ffffff 	.word	0x31ffffff
 800d6dc:	2f2ec9d3 	.word	0x2f2ec9d3
 800d6e0:	32d72f34 	.word	0x32d72f34
 800d6e4:	3638ef1b 	.word	0x3638ef1b
 800d6e8:	39500d01 	.word	0x39500d01
 800d6ec:	3c088889 	.word	0x3c088889
 800d6f0:	3e2aaaab 	.word	0x3e2aaaab

0800d6f4 <matherr>:
 800d6f4:	2000      	movs	r0, #0
 800d6f6:	4770      	bx	lr

0800d6f8 <atanf>:
 800d6f8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800d6fa:	4b74      	ldr	r3, [pc, #464]	; (800d8cc <atanf+0x1d4>)
 800d6fc:	0045      	lsls	r5, r0, #1
 800d6fe:	1c04      	adds	r4, r0, #0
 800d700:	9001      	str	r0, [sp, #4]
 800d702:	086d      	lsrs	r5, r5, #1
 800d704:	429d      	cmp	r5, r3
 800d706:	dd0f      	ble.n	800d728 <atanf+0x30>
 800d708:	23ff      	movs	r3, #255	; 0xff
 800d70a:	05db      	lsls	r3, r3, #23
 800d70c:	429d      	cmp	r5, r3
 800d70e:	dd04      	ble.n	800d71a <atanf+0x22>
 800d710:	1c01      	adds	r1, r0, #0
 800d712:	f7f2 fe3d 	bl	8000390 <__aeabi_fadd>
 800d716:	1c04      	adds	r4, r0, #0
 800d718:	e004      	b.n	800d724 <atanf+0x2c>
 800d71a:	9b01      	ldr	r3, [sp, #4]
 800d71c:	2b00      	cmp	r3, #0
 800d71e:	dd00      	ble.n	800d722 <atanf+0x2a>
 800d720:	e0d1      	b.n	800d8c6 <atanf+0x1ce>
 800d722:	4c6b      	ldr	r4, [pc, #428]	; (800d8d0 <atanf+0x1d8>)
 800d724:	1c20      	adds	r0, r4, #0
 800d726:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800d728:	4b6a      	ldr	r3, [pc, #424]	; (800d8d4 <atanf+0x1dc>)
 800d72a:	429d      	cmp	r5, r3
 800d72c:	dc0e      	bgt.n	800d74c <atanf+0x54>
 800d72e:	4b6a      	ldr	r3, [pc, #424]	; (800d8d8 <atanf+0x1e0>)
 800d730:	429d      	cmp	r5, r3
 800d732:	dc08      	bgt.n	800d746 <atanf+0x4e>
 800d734:	4969      	ldr	r1, [pc, #420]	; (800d8dc <atanf+0x1e4>)
 800d736:	f7f2 fe2b 	bl	8000390 <__aeabi_fadd>
 800d73a:	21fe      	movs	r1, #254	; 0xfe
 800d73c:	0589      	lsls	r1, r1, #22
 800d73e:	f7f2 fddd 	bl	80002fc <__aeabi_fcmpgt>
 800d742:	2800      	cmp	r0, #0
 800d744:	d1ee      	bne.n	800d724 <atanf+0x2c>
 800d746:	2501      	movs	r5, #1
 800d748:	426d      	negs	r5, r5
 800d74a:	e01b      	b.n	800d784 <atanf+0x8c>
 800d74c:	f000 f8ec 	bl	800d928 <fabsf>
 800d750:	4b63      	ldr	r3, [pc, #396]	; (800d8e0 <atanf+0x1e8>)
 800d752:	1c04      	adds	r4, r0, #0
 800d754:	429d      	cmp	r5, r3
 800d756:	dc7b      	bgt.n	800d850 <atanf+0x158>
 800d758:	4b62      	ldr	r3, [pc, #392]	; (800d8e4 <atanf+0x1ec>)
 800d75a:	429d      	cmp	r5, r3
 800d75c:	dc67      	bgt.n	800d82e <atanf+0x136>
 800d75e:	1c01      	adds	r1, r0, #0
 800d760:	f7f2 fe16 	bl	8000390 <__aeabi_fadd>
 800d764:	21fe      	movs	r1, #254	; 0xfe
 800d766:	0589      	lsls	r1, r1, #22
 800d768:	f7f3 fab4 	bl	8000cd4 <__aeabi_fsub>
 800d76c:	2180      	movs	r1, #128	; 0x80
 800d76e:	1c05      	adds	r5, r0, #0
 800d770:	05c9      	lsls	r1, r1, #23
 800d772:	1c20      	adds	r0, r4, #0
 800d774:	f7f2 fe0c 	bl	8000390 <__aeabi_fadd>
 800d778:	1c01      	adds	r1, r0, #0
 800d77a:	1c28      	adds	r0, r5, #0
 800d77c:	f7f2 ff9a 	bl	80006b4 <__aeabi_fdiv>
 800d780:	2500      	movs	r5, #0
 800d782:	1c04      	adds	r4, r0, #0
 800d784:	1c21      	adds	r1, r4, #0
 800d786:	1c20      	adds	r0, r4, #0
 800d788:	f7f3 f984 	bl	8000a94 <__aeabi_fmul>
 800d78c:	1c01      	adds	r1, r0, #0
 800d78e:	1c07      	adds	r7, r0, #0
 800d790:	f7f3 f980 	bl	8000a94 <__aeabi_fmul>
 800d794:	4954      	ldr	r1, [pc, #336]	; (800d8e8 <atanf+0x1f0>)
 800d796:	1c06      	adds	r6, r0, #0
 800d798:	f7f3 f97c 	bl	8000a94 <__aeabi_fmul>
 800d79c:	4953      	ldr	r1, [pc, #332]	; (800d8ec <atanf+0x1f4>)
 800d79e:	f7f2 fdf7 	bl	8000390 <__aeabi_fadd>
 800d7a2:	1c31      	adds	r1, r6, #0
 800d7a4:	f7f3 f976 	bl	8000a94 <__aeabi_fmul>
 800d7a8:	4951      	ldr	r1, [pc, #324]	; (800d8f0 <atanf+0x1f8>)
 800d7aa:	f7f2 fdf1 	bl	8000390 <__aeabi_fadd>
 800d7ae:	1c31      	adds	r1, r6, #0
 800d7b0:	f7f3 f970 	bl	8000a94 <__aeabi_fmul>
 800d7b4:	494f      	ldr	r1, [pc, #316]	; (800d8f4 <atanf+0x1fc>)
 800d7b6:	f7f2 fdeb 	bl	8000390 <__aeabi_fadd>
 800d7ba:	1c31      	adds	r1, r6, #0
 800d7bc:	f7f3 f96a 	bl	8000a94 <__aeabi_fmul>
 800d7c0:	494d      	ldr	r1, [pc, #308]	; (800d8f8 <atanf+0x200>)
 800d7c2:	f7f2 fde5 	bl	8000390 <__aeabi_fadd>
 800d7c6:	1c31      	adds	r1, r6, #0
 800d7c8:	f7f3 f964 	bl	8000a94 <__aeabi_fmul>
 800d7cc:	494b      	ldr	r1, [pc, #300]	; (800d8fc <atanf+0x204>)
 800d7ce:	f7f2 fddf 	bl	8000390 <__aeabi_fadd>
 800d7d2:	1c39      	adds	r1, r7, #0
 800d7d4:	f7f3 f95e 	bl	8000a94 <__aeabi_fmul>
 800d7d8:	4949      	ldr	r1, [pc, #292]	; (800d900 <atanf+0x208>)
 800d7da:	1c07      	adds	r7, r0, #0
 800d7dc:	1c30      	adds	r0, r6, #0
 800d7de:	f7f3 f959 	bl	8000a94 <__aeabi_fmul>
 800d7e2:	4948      	ldr	r1, [pc, #288]	; (800d904 <atanf+0x20c>)
 800d7e4:	f7f3 fa76 	bl	8000cd4 <__aeabi_fsub>
 800d7e8:	1c31      	adds	r1, r6, #0
 800d7ea:	f7f3 f953 	bl	8000a94 <__aeabi_fmul>
 800d7ee:	4946      	ldr	r1, [pc, #280]	; (800d908 <atanf+0x210>)
 800d7f0:	f7f3 fa70 	bl	8000cd4 <__aeabi_fsub>
 800d7f4:	1c31      	adds	r1, r6, #0
 800d7f6:	f7f3 f94d 	bl	8000a94 <__aeabi_fmul>
 800d7fa:	4944      	ldr	r1, [pc, #272]	; (800d90c <atanf+0x214>)
 800d7fc:	f7f3 fa6a 	bl	8000cd4 <__aeabi_fsub>
 800d800:	1c31      	adds	r1, r6, #0
 800d802:	f7f3 f947 	bl	8000a94 <__aeabi_fmul>
 800d806:	4942      	ldr	r1, [pc, #264]	; (800d910 <atanf+0x218>)
 800d808:	f7f3 fa64 	bl	8000cd4 <__aeabi_fsub>
 800d80c:	1c31      	adds	r1, r6, #0
 800d80e:	f7f3 f941 	bl	8000a94 <__aeabi_fmul>
 800d812:	1c01      	adds	r1, r0, #0
 800d814:	1c6b      	adds	r3, r5, #1
 800d816:	d13a      	bne.n	800d88e <atanf+0x196>
 800d818:	1c38      	adds	r0, r7, #0
 800d81a:	f7f2 fdb9 	bl	8000390 <__aeabi_fadd>
 800d81e:	1c21      	adds	r1, r4, #0
 800d820:	f7f3 f938 	bl	8000a94 <__aeabi_fmul>
 800d824:	1c01      	adds	r1, r0, #0
 800d826:	1c20      	adds	r0, r4, #0
 800d828:	f7f3 fa54 	bl	8000cd4 <__aeabi_fsub>
 800d82c:	e773      	b.n	800d716 <atanf+0x1e>
 800d82e:	21fe      	movs	r1, #254	; 0xfe
 800d830:	0589      	lsls	r1, r1, #22
 800d832:	f7f3 fa4f 	bl	8000cd4 <__aeabi_fsub>
 800d836:	21fe      	movs	r1, #254	; 0xfe
 800d838:	1c05      	adds	r5, r0, #0
 800d83a:	0589      	lsls	r1, r1, #22
 800d83c:	1c20      	adds	r0, r4, #0
 800d83e:	f7f2 fda7 	bl	8000390 <__aeabi_fadd>
 800d842:	1c01      	adds	r1, r0, #0
 800d844:	1c28      	adds	r0, r5, #0
 800d846:	f7f2 ff35 	bl	80006b4 <__aeabi_fdiv>
 800d84a:	2501      	movs	r5, #1
 800d84c:	1c04      	adds	r4, r0, #0
 800d84e:	e799      	b.n	800d784 <atanf+0x8c>
 800d850:	4b30      	ldr	r3, [pc, #192]	; (800d914 <atanf+0x21c>)
 800d852:	429d      	cmp	r5, r3
 800d854:	dc14      	bgt.n	800d880 <atanf+0x188>
 800d856:	21ff      	movs	r1, #255	; 0xff
 800d858:	0589      	lsls	r1, r1, #22
 800d85a:	f7f3 fa3b 	bl	8000cd4 <__aeabi_fsub>
 800d85e:	21ff      	movs	r1, #255	; 0xff
 800d860:	1c05      	adds	r5, r0, #0
 800d862:	0589      	lsls	r1, r1, #22
 800d864:	1c20      	adds	r0, r4, #0
 800d866:	f7f3 f915 	bl	8000a94 <__aeabi_fmul>
 800d86a:	21fe      	movs	r1, #254	; 0xfe
 800d86c:	0589      	lsls	r1, r1, #22
 800d86e:	f7f2 fd8f 	bl	8000390 <__aeabi_fadd>
 800d872:	1c01      	adds	r1, r0, #0
 800d874:	1c28      	adds	r0, r5, #0
 800d876:	f7f2 ff1d 	bl	80006b4 <__aeabi_fdiv>
 800d87a:	2502      	movs	r5, #2
 800d87c:	1c04      	adds	r4, r0, #0
 800d87e:	e781      	b.n	800d784 <atanf+0x8c>
 800d880:	1c01      	adds	r1, r0, #0
 800d882:	4825      	ldr	r0, [pc, #148]	; (800d918 <atanf+0x220>)
 800d884:	f7f2 ff16 	bl	80006b4 <__aeabi_fdiv>
 800d888:	2503      	movs	r5, #3
 800d88a:	1c04      	adds	r4, r0, #0
 800d88c:	e77a      	b.n	800d784 <atanf+0x8c>
 800d88e:	1c38      	adds	r0, r7, #0
 800d890:	f7f2 fd7e 	bl	8000390 <__aeabi_fadd>
 800d894:	1c21      	adds	r1, r4, #0
 800d896:	f7f3 f8fd 	bl	8000a94 <__aeabi_fmul>
 800d89a:	4b20      	ldr	r3, [pc, #128]	; (800d91c <atanf+0x224>)
 800d89c:	00ad      	lsls	r5, r5, #2
 800d89e:	58e9      	ldr	r1, [r5, r3]
 800d8a0:	f7f3 fa18 	bl	8000cd4 <__aeabi_fsub>
 800d8a4:	1c21      	adds	r1, r4, #0
 800d8a6:	f7f3 fa15 	bl	8000cd4 <__aeabi_fsub>
 800d8aa:	4b1d      	ldr	r3, [pc, #116]	; (800d920 <atanf+0x228>)
 800d8ac:	1c01      	adds	r1, r0, #0
 800d8ae:	58e8      	ldr	r0, [r5, r3]
 800d8b0:	f7f3 fa10 	bl	8000cd4 <__aeabi_fsub>
 800d8b4:	9b01      	ldr	r3, [sp, #4]
 800d8b6:	1c04      	adds	r4, r0, #0
 800d8b8:	2b00      	cmp	r3, #0
 800d8ba:	db00      	blt.n	800d8be <atanf+0x1c6>
 800d8bc:	e732      	b.n	800d724 <atanf+0x2c>
 800d8be:	2380      	movs	r3, #128	; 0x80
 800d8c0:	061b      	lsls	r3, r3, #24
 800d8c2:	18c4      	adds	r4, r0, r3
 800d8c4:	e72e      	b.n	800d724 <atanf+0x2c>
 800d8c6:	4c17      	ldr	r4, [pc, #92]	; (800d924 <atanf+0x22c>)
 800d8c8:	e72c      	b.n	800d724 <atanf+0x2c>
 800d8ca:	46c0      	nop			; (mov r8, r8)
 800d8cc:	507fffff 	.word	0x507fffff
 800d8d0:	bfc90fdb 	.word	0xbfc90fdb
 800d8d4:	3edfffff 	.word	0x3edfffff
 800d8d8:	30ffffff 	.word	0x30ffffff
 800d8dc:	7149f2ca 	.word	0x7149f2ca
 800d8e0:	3f97ffff 	.word	0x3f97ffff
 800d8e4:	3f2fffff 	.word	0x3f2fffff
 800d8e8:	3c8569d7 	.word	0x3c8569d7
 800d8ec:	3d4bda59 	.word	0x3d4bda59
 800d8f0:	3d886b35 	.word	0x3d886b35
 800d8f4:	3dba2e6e 	.word	0x3dba2e6e
 800d8f8:	3e124925 	.word	0x3e124925
 800d8fc:	3eaaaaab 	.word	0x3eaaaaab
 800d900:	bd15a221 	.word	0xbd15a221
 800d904:	3d6ef16b 	.word	0x3d6ef16b
 800d908:	3d9d8795 	.word	0x3d9d8795
 800d90c:	3de38e38 	.word	0x3de38e38
 800d910:	3e4ccccd 	.word	0x3e4ccccd
 800d914:	401bffff 	.word	0x401bffff
 800d918:	bf800000 	.word	0xbf800000
 800d91c:	0800e580 	.word	0x0800e580
 800d920:	0800e570 	.word	0x0800e570
 800d924:	3fc90fdb 	.word	0x3fc90fdb

0800d928 <fabsf>:
 800d928:	0040      	lsls	r0, r0, #1
 800d92a:	0840      	lsrs	r0, r0, #1
 800d92c:	4770      	bx	lr
	...

0800d930 <scalbnf>:
 800d930:	0043      	lsls	r3, r0, #1
 800d932:	b570      	push	{r4, r5, r6, lr}
 800d934:	0002      	movs	r2, r0
 800d936:	000c      	movs	r4, r1
 800d938:	0859      	lsrs	r1, r3, #1
 800d93a:	d005      	beq.n	800d948 <scalbnf+0x18>
 800d93c:	4d1e      	ldr	r5, [pc, #120]	; (800d9b8 <scalbnf+0x88>)
 800d93e:	42a9      	cmp	r1, r5
 800d940:	d903      	bls.n	800d94a <scalbnf+0x1a>
 800d942:	1c01      	adds	r1, r0, #0
 800d944:	f7f2 fd24 	bl	8000390 <__aeabi_fadd>
 800d948:	bd70      	pop	{r4, r5, r6, pc}
 800d94a:	4d1c      	ldr	r5, [pc, #112]	; (800d9bc <scalbnf+0x8c>)
 800d94c:	42a9      	cmp	r1, r5
 800d94e:	d815      	bhi.n	800d97c <scalbnf+0x4c>
 800d950:	2198      	movs	r1, #152	; 0x98
 800d952:	05c9      	lsls	r1, r1, #23
 800d954:	f7f3 f89e 	bl	8000a94 <__aeabi_fmul>
 800d958:	4b19      	ldr	r3, [pc, #100]	; (800d9c0 <scalbnf+0x90>)
 800d95a:	429c      	cmp	r4, r3
 800d95c:	db21      	blt.n	800d9a2 <scalbnf+0x72>
 800d95e:	0002      	movs	r2, r0
 800d960:	15c3      	asrs	r3, r0, #23
 800d962:	b2db      	uxtb	r3, r3
 800d964:	3b19      	subs	r3, #25
 800d966:	191b      	adds	r3, r3, r4
 800d968:	1c01      	adds	r1, r0, #0
 800d96a:	2bfe      	cmp	r3, #254	; 0xfe
 800d96c:	dc0f      	bgt.n	800d98e <scalbnf+0x5e>
 800d96e:	2b00      	cmp	r3, #0
 800d970:	dd06      	ble.n	800d980 <scalbnf+0x50>
 800d972:	4814      	ldr	r0, [pc, #80]	; (800d9c4 <scalbnf+0x94>)
 800d974:	05db      	lsls	r3, r3, #23
 800d976:	4010      	ands	r0, r2
 800d978:	4318      	orrs	r0, r3
 800d97a:	e7e5      	b.n	800d948 <scalbnf+0x18>
 800d97c:	0e1b      	lsrs	r3, r3, #24
 800d97e:	e7f2      	b.n	800d966 <scalbnf+0x36>
 800d980:	0019      	movs	r1, r3
 800d982:	3116      	adds	r1, #22
 800d984:	da0f      	bge.n	800d9a6 <scalbnf+0x76>
 800d986:	4b10      	ldr	r3, [pc, #64]	; (800d9c8 <scalbnf+0x98>)
 800d988:	1c01      	adds	r1, r0, #0
 800d98a:	429c      	cmp	r4, r3
 800d98c:	dd06      	ble.n	800d99c <scalbnf+0x6c>
 800d98e:	480f      	ldr	r0, [pc, #60]	; (800d9cc <scalbnf+0x9c>)
 800d990:	f000 f820 	bl	800d9d4 <copysignf>
 800d994:	490d      	ldr	r1, [pc, #52]	; (800d9cc <scalbnf+0x9c>)
 800d996:	f7f3 f87d 	bl	8000a94 <__aeabi_fmul>
 800d99a:	e7d5      	b.n	800d948 <scalbnf+0x18>
 800d99c:	480c      	ldr	r0, [pc, #48]	; (800d9d0 <scalbnf+0xa0>)
 800d99e:	f000 f819 	bl	800d9d4 <copysignf>
 800d9a2:	490b      	ldr	r1, [pc, #44]	; (800d9d0 <scalbnf+0xa0>)
 800d9a4:	e7f7      	b.n	800d996 <scalbnf+0x66>
 800d9a6:	21cc      	movs	r1, #204	; 0xcc
 800d9a8:	4806      	ldr	r0, [pc, #24]	; (800d9c4 <scalbnf+0x94>)
 800d9aa:	3319      	adds	r3, #25
 800d9ac:	05db      	lsls	r3, r3, #23
 800d9ae:	4010      	ands	r0, r2
 800d9b0:	4318      	orrs	r0, r3
 800d9b2:	0589      	lsls	r1, r1, #22
 800d9b4:	e7ef      	b.n	800d996 <scalbnf+0x66>
 800d9b6:	46c0      	nop			; (mov r8, r8)
 800d9b8:	7f7fffff 	.word	0x7f7fffff
 800d9bc:	007fffff 	.word	0x007fffff
 800d9c0:	ffff3cb0 	.word	0xffff3cb0
 800d9c4:	807fffff 	.word	0x807fffff
 800d9c8:	0000c350 	.word	0x0000c350
 800d9cc:	7149f2ca 	.word	0x7149f2ca
 800d9d0:	0da24260 	.word	0x0da24260

0800d9d4 <copysignf>:
 800d9d4:	0040      	lsls	r0, r0, #1
 800d9d6:	0fc9      	lsrs	r1, r1, #31
 800d9d8:	07c9      	lsls	r1, r1, #31
 800d9da:	0840      	lsrs	r0, r0, #1
 800d9dc:	4308      	orrs	r0, r1
 800d9de:	4770      	bx	lr

0800d9e0 <__errno>:
 800d9e0:	4b01      	ldr	r3, [pc, #4]	; (800d9e8 <__errno+0x8>)
 800d9e2:	6818      	ldr	r0, [r3, #0]
 800d9e4:	4770      	bx	lr
 800d9e6:	46c0      	nop			; (mov r8, r8)
 800d9e8:	20000014 	.word	0x20000014

0800d9ec <_init>:
 800d9ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d9ee:	46c0      	nop			; (mov r8, r8)
 800d9f0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800d9f2:	bc08      	pop	{r3}
 800d9f4:	469e      	mov	lr, r3
 800d9f6:	4770      	bx	lr

0800d9f8 <_fini>:
 800d9f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d9fa:	46c0      	nop			; (mov r8, r8)
 800d9fc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800d9fe:	bc08      	pop	{r3}
 800da00:	469e      	mov	lr, r3
 800da02:	4770      	bx	lr
